// Copyright 2020 - developers of the `grammers` project.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

/// The schema layer from which the definitions were generated.
pub const LAYER: i32 = 135;

/// Return the name from the `.tl` definition corresponding to the provided definition identifier.
pub fn name_for_id(id: u32) -> &'static str {
    match id {
        0xbc799737 => "boolFalse",
        0x997275b5 => "boolTrue",
        0x3fedd339 => "true",
        0xc4b9f9bb => "error",
        0x56730bcc => "null",
        0x7f3b18ea => "inputPeerEmpty",
        0x7da07ec9 => "inputPeerSelf",
        0x35a95cb9 => "inputPeerChat",
        0xdde8a54c => "inputPeerUser",
        0x27bcbbfc => "inputPeerChannel",
        0xa87b0a1c => "inputPeerUserFromMessage",
        0xbd2a0840 => "inputPeerChannelFromMessage",
        0xb98886cf => "inputUserEmpty",
        0xf7c1b13f => "inputUserSelf",
        0xf21158c6 => "inputUser",
        0x1da448e2 => "inputUserFromMessage",
        0xf392b7f4 => "inputPhoneContact",
        0xf52ff27f => "inputFile",
        0xfa4f0bb5 => "inputFileBig",
        0x9664f57f => "inputMediaEmpty",
        0x1e287d04 => "inputMediaUploadedPhoto",
        0xb3ba0635 => "inputMediaPhoto",
        0xf9c44144 => "inputMediaGeoPoint",
        0xf8ab7dfb => "inputMediaContact",
        0x5b38c6c1 => "inputMediaUploadedDocument",
        0x33473058 => "inputMediaDocument",
        0xc13d1c11 => "inputMediaVenue",
        0xe5bbfe1a => "inputMediaPhotoExternal",
        0xfb52dc99 => "inputMediaDocumentExternal",
        0xd33f43f3 => "inputMediaGame",
        0xd9799874 => "inputMediaInvoice",
        0x971fa843 => "inputMediaGeoLive",
        0xf94e5f1 => "inputMediaPoll",
        0xe66fbf7b => "inputMediaDice",
        0x1ca48f57 => "inputChatPhotoEmpty",
        0xc642724e => "inputChatUploadedPhoto",
        0x8953ad37 => "inputChatPhoto",
        0xe4c123d6 => "inputGeoPointEmpty",
        0x48222faf => "inputGeoPoint",
        0x1cd7bf0d => "inputPhotoEmpty",
        0x3bb3b94a => "inputPhoto",
        0xdfdaabe1 => "inputFileLocation",
        0xf5235d55 => "inputEncryptedFileLocation",
        0xbad07584 => "inputDocumentFileLocation",
        0xcbc7ee28 => "inputSecureFileLocation",
        0x29be5899 => "inputTakeoutFileLocation",
        0x40181ffe => "inputPhotoFileLocation",
        0xd83466f3 => "inputPhotoLegacyFileLocation",
        0x37257e99 => "inputPeerPhotoFileLocation",
        0x9d84f3db => "inputStickerSetThumb",
        0x598a92a => "inputGroupCallStream",
        0x59511722 => "peerUser",
        0x36c6019a => "peerChat",
        0xa2a5371e => "peerChannel",
        0xaa963b05 => "storage.fileUnknown",
        0x40bc6f52 => "storage.filePartial",
        0x7efe0e => "storage.fileJpeg",
        0xcae1aadf => "storage.fileGif",
        0xa4f63c0 => "storage.filePng",
        0xae1e508d => "storage.filePdf",
        0x528a0677 => "storage.fileMp3",
        0x4b09ebbc => "storage.fileMov",
        0xb3cea0e4 => "storage.fileMp4",
        0x1081464c => "storage.fileWebp",
        0xd3bc4b7a => "userEmpty",
        0x3ff6ecb0 => "user",
        0x4f11bae1 => "userProfilePhotoEmpty",
        0x82d1f706 => "userProfilePhoto",
        0x9d05049 => "userStatusEmpty",
        0xedb93949 => "userStatusOnline",
        0x8c703f => "userStatusOffline",
        0xe26f42f1 => "userStatusRecently",
        0x7bf09fc => "userStatusLastWeek",
        0x77ebc742 => "userStatusLastMonth",
        0x29562865 => "chatEmpty",
        0x41cbf256 => "chat",
        0x6592a1a7 => "chatForbidden",
        0x8261ac61 => "channel",
        0x17d493d5 => "channelForbidden",
        0x46a6ffb4 => "chatFull",
        0x56662e2e => "channelFull",
        0xc02d4007 => "chatParticipant",
        0xe46bcee4 => "chatParticipantCreator",
        0xa0933f5b => "chatParticipantAdmin",
        0x8763d3e1 => "chatParticipantsForbidden",
        0x3cbc93f8 => "chatParticipants",
        0x37c1011c => "chatPhotoEmpty",
        0x1c6e1c11 => "chatPhoto",
        0x90a6ca84 => "messageEmpty",
        0x85d6cbe2 => "message",
        0x2b085862 => "messageService",
        0x3ded6320 => "messageMediaEmpty",
        0x695150d7 => "messageMediaPhoto",
        0x56e0d474 => "messageMediaGeo",
        0x70322949 => "messageMediaContact",
        0x9f84f49e => "messageMediaUnsupported",
        0x9cb070d7 => "messageMediaDocument",
        0xa32dd600 => "messageMediaWebPage",
        0x2ec0533f => "messageMediaVenue",
        0xfdb19008 => "messageMediaGame",
        0x84551347 => "messageMediaInvoice",
        0xb940c666 => "messageMediaGeoLive",
        0x4bd6e798 => "messageMediaPoll",
        0x3f7ee58b => "messageMediaDice",
        0xb6aef7b0 => "messageActionEmpty",
        0xbd47cbad => "messageActionChatCreate",
        0xb5a1ce5a => "messageActionChatEditTitle",
        0x7fcb13a8 => "messageActionChatEditPhoto",
        0x95e3fbef => "messageActionChatDeletePhoto",
        0x15cefd00 => "messageActionChatAddUser",
        0xa43f30cc => "messageActionChatDeleteUser",
        0x31224c3 => "messageActionChatJoinedByLink",
        0x95d2ac92 => "messageActionChannelCreate",
        0xe1037f92 => "messageActionChatMigrateTo",
        0xea3948e9 => "messageActionChannelMigrateFrom",
        0x94bd38ed => "messageActionPinMessage",
        0x9fbab604 => "messageActionHistoryClear",
        0x92a72876 => "messageActionGameScore",
        0x8f31b327 => "messageActionPaymentSentMe",
        0x40699cd0 => "messageActionPaymentSent",
        0x80e11a7f => "messageActionPhoneCall",
        0x4792929b => "messageActionScreenshotTaken",
        0xfae69f56 => "messageActionCustomAction",
        0xabe9affe => "messageActionBotAllowed",
        0x1b287353 => "messageActionSecureValuesSentMe",
        0xd95c6154 => "messageActionSecureValuesSent",
        0xf3f25f76 => "messageActionContactSignUp",
        0x98e0d697 => "messageActionGeoProximityReached",
        0x7a0d7f42 => "messageActionGroupCall",
        0x502f92f7 => "messageActionInviteToGroupCall",
        0xaa1afbfd => "messageActionSetMessagesTTL",
        0xb3a07661 => "messageActionGroupCallScheduled",
        0xaa786345 => "messageActionSetChatTheme",
        0xebbca3cb => "messageActionChatJoinedByRequest",
        0x2c171f72 => "dialog",
        0x71bd134c => "dialogFolder",
        0x2331b22d => "photoEmpty",
        0xfb197a65 => "photo",
        0xe17e23c => "photoSizeEmpty",
        0x75c78e60 => "photoSize",
        0x21e1ad6 => "photoCachedSize",
        0xe0b0bc2e => "photoStrippedSize",
        0xfa3efb95 => "photoSizeProgressive",
        0xd8214d41 => "photoPathSize",
        0x1117dd5f => "geoPointEmpty",
        0xb2a2f663 => "geoPoint",
        0x5e002502 => "auth.sentCode",
        0x33fb7bb8 => "auth.authorization",
        0x44747e9a => "auth.authorizationSignUpRequired",
        0xb434e2b8 => "auth.exportedAuthorization",
        0xb8bc5b0c => "inputNotifyPeer",
        0x193b4417 => "inputNotifyUsers",
        0x4a95e84e => "inputNotifyChats",
        0xb1db7c7e => "inputNotifyBroadcasts",
        0x9c3d198e => "inputPeerNotifySettings",
        0xaf509d20 => "peerNotifySettings",
        0xa518110d => "peerSettings",
        0xa437c3ed => "wallPaper",
        0xe0804116 => "wallPaperNoFile",
        0x58dbcab8 => "inputReportReasonSpam",
        0x1e22c78d => "inputReportReasonViolence",
        0x2e59d922 => "inputReportReasonPornography",
        0xadf44ee3 => "inputReportReasonChildAbuse",
        0xc1e4a2b1 => "inputReportReasonOther",
        0x9b89f93a => "inputReportReasonCopyright",
        0xdbd4feed => "inputReportReasonGeoIrrelevant",
        0xf5ddd6e7 => "inputReportReasonFake",
        0xcf366521 => "userFull",
        0x145ade0b => "contact",
        0xc13e3c50 => "importedContact",
        0x16d9703b => "contactStatus",
        0xb74ba9d2 => "contacts.contactsNotModified",
        0xeae87e42 => "contacts.contacts",
        0x77d01c3b => "contacts.importedContacts",
        0xade1591 => "contacts.blocked",
        0xe1664194 => "contacts.blockedSlice",
        0x15ba6c40 => "messages.dialogs",
        0x71e094f3 => "messages.dialogsSlice",
        0xf0e3e596 => "messages.dialogsNotModified",
        0x8c718e87 => "messages.messages",
        0x3a54685e => "messages.messagesSlice",
        0x64479808 => "messages.channelMessages",
        0x74535f21 => "messages.messagesNotModified",
        0x64ff9fd5 => "messages.chats",
        0x9cd81144 => "messages.chatsSlice",
        0xe5d7d19c => "messages.chatFull",
        0xb45c69d1 => "messages.affectedHistory",
        0x57e2f66c => "inputMessagesFilterEmpty",
        0x9609a51c => "inputMessagesFilterPhotos",
        0x9fc00e65 => "inputMessagesFilterVideo",
        0x56e9f0e4 => "inputMessagesFilterPhotoVideo",
        0x9eddf188 => "inputMessagesFilterDocument",
        0x7ef0dd87 => "inputMessagesFilterUrl",
        0xffc86587 => "inputMessagesFilterGif",
        0x50f5c392 => "inputMessagesFilterVoice",
        0x3751b49e => "inputMessagesFilterMusic",
        0x3a20ecb8 => "inputMessagesFilterChatPhotos",
        0x80c99768 => "inputMessagesFilterPhoneCalls",
        0x7a7c17a4 => "inputMessagesFilterRoundVoice",
        0xb549da53 => "inputMessagesFilterRoundVideo",
        0xc1f8e69a => "inputMessagesFilterMyMentions",
        0xe7026d0d => "inputMessagesFilterGeo",
        0xe062db83 => "inputMessagesFilterContacts",
        0x1bb00451 => "inputMessagesFilterPinned",
        0x1f2b0afd => "updateNewMessage",
        0x4e90bfd6 => "updateMessageID",
        0xa20db0e5 => "updateDeleteMessages",
        0xc01e857f => "updateUserTyping",
        0x83487af0 => "updateChatUserTyping",
        0x7761198 => "updateChatParticipants",
        0xe5bdf8de => "updateUserStatus",
        0xc3f202e0 => "updateUserName",
        0xf227868c => "updateUserPhoto",
        0x12bcbd9a => "updateNewEncryptedMessage",
        0x1710f156 => "updateEncryptedChatTyping",
        0xb4a2e88d => "updateEncryption",
        0x38fe25b7 => "updateEncryptedMessagesRead",
        0x3dda5451 => "updateChatParticipantAdd",
        0xe32f3d77 => "updateChatParticipantDelete",
        0x8e5e9873 => "updateDcOptions",
        0xbec268ef => "updateNotifySettings",
        0xebe46819 => "updateServiceNotification",
        0xee3b272a => "updatePrivacy",
        0x5492a13 => "updateUserPhone",
        0x9c974fdf => "updateReadHistoryInbox",
        0x2f2f21bf => "updateReadHistoryOutbox",
        0x7f891213 => "updateWebPage",
        0x68c13933 => "updateReadMessagesContents",
        0x108d941f => "updateChannelTooLong",
        0x635b4c09 => "updateChannel",
        0x62ba04d9 => "updateNewChannelMessage",
        0x922e6e10 => "updateReadChannelInbox",
        0xc32d5b12 => "updateDeleteChannelMessages",
        0xf226ac08 => "updateChannelMessageViews",
        0xd7ca61a2 => "updateChatParticipantAdmin",
        0x688a30aa => "updateNewStickerSet",
        0xbb2d201 => "updateStickerSetsOrder",
        0x43ae3dec => "updateStickerSets",
        0x9375341e => "updateSavedGifs",
        0x496f379c => "updateBotInlineQuery",
        0x12f12a07 => "updateBotInlineSend",
        0x1b3f4df7 => "updateEditChannelMessage",
        0xb9cfc48d => "updateBotCallbackQuery",
        0xe40370a3 => "updateEditMessage",
        0x691e9052 => "updateInlineBotCallbackQuery",
        0xb75f99a9 => "updateReadChannelOutbox",
        0xee2bb969 => "updateDraftMessage",
        0x571d2742 => "updateReadFeaturedStickers",
        0x9a422c20 => "updateRecentStickers",
        0xa229dd06 => "updateConfig",
        0x3354678f => "updatePtsChanged",
        0x2f2ba99f => "updateChannelWebPage",
        0x6e6fe51c => "updateDialogPinned",
        0xfa0f3ca2 => "updatePinnedDialogs",
        0x8317c0c3 => "updateBotWebhookJSON",
        0x9b9240a6 => "updateBotWebhookJSONQuery",
        0xb5aefd7d => "updateBotShippingQuery",
        0x8caa9a96 => "updateBotPrecheckoutQuery",
        0xab0f6b1e => "updatePhoneCall",
        0x46560264 => "updateLangPackTooLong",
        0x56022f4d => "updateLangPack",
        0xe511996d => "updateFavedStickers",
        0x44bdd535 => "updateChannelReadMessagesContents",
        0x7084a7be => "updateContactsReset",
        0xb23fc698 => "updateChannelAvailableMessages",
        0xe16459c3 => "updateDialogUnreadMark",
        0xaca1657b => "updateMessagePoll",
        0x54c01850 => "updateChatDefaultBannedRights",
        0x19360dc0 => "updateFolderPeers",
        0x6a7e7366 => "updatePeerSettings",
        0xb4afcfb0 => "updatePeerLocated",
        0x39a51dfb => "updateNewScheduledMessage",
        0x90866cee => "updateDeleteScheduledMessages",
        0x8216fba3 => "updateTheme",
        0x871fb939 => "updateGeoLiveViewed",
        0x564fe691 => "updateLoginToken",
        0x106395c9 => "updateMessagePollVote",
        0x26ffde7d => "updateDialogFilter",
        0xa5d72105 => "updateDialogFilterOrder",
        0x3504914f => "updateDialogFilters",
        0x2661bf09 => "updatePhoneCallSignalingData",
        0xd29a27f4 => "updateChannelMessageForwards",
        0xd6b19546 => "updateReadChannelDiscussionInbox",
        0x695c9e7c => "updateReadChannelDiscussionOutbox",
        0x246a4b22 => "updatePeerBlocked",
        0x8c88c923 => "updateChannelUserTyping",
        0xed85eab5 => "updatePinnedMessages",
        0x5bb98608 => "updatePinnedChannelMessages",
        0xf89a6a4e => "updateChat",
        0xf2ebdb4e => "updateGroupCallParticipants",
        0x14b24500 => "updateGroupCall",
        0xbb9bb9a5 => "updatePeerHistoryTTL",
        0xd087663a => "updateChatParticipant",
        0x985d3abb => "updateChannelParticipant",
        0xc4870a49 => "updateBotStopped",
        0xb783982 => "updateGroupCallConnection",
        0x4d712f2e => "updateBotCommands",
        0x7063c3db => "updatePendingJoinRequests",
        0x11dfa986 => "updateBotChatInviteRequester",
        0xa56c2a3e => "updates.state",
        0x5d75a138 => "updates.differenceEmpty",
        0xf49ca0 => "updates.difference",
        0xa8fb1981 => "updates.differenceSlice",
        0x4afe8f6d => "updates.differenceTooLong",
        0xe317af7e => "updatesTooLong",
        0x313bc7f8 => "updateShortMessage",
        0x4d6deea5 => "updateShortChatMessage",
        0x78d4dec1 => "updateShort",
        0x725b04c3 => "updatesCombined",
        0x74ae4240 => "updates",
        0x9015e101 => "updateShortSentMessage",
        0x8dca6aa5 => "photos.photos",
        0x15051f54 => "photos.photosSlice",
        0x20212ca8 => "photos.photo",
        0x96a18d5 => "upload.file",
        0xf18cda44 => "upload.fileCdnRedirect",
        0x18b7a10d => "dcOption",
        0x330b4067 => "config",
        0x8e1a1775 => "nearestDc",
        0xccbbce30 => "help.appUpdate",
        0xc45a6536 => "help.noAppUpdate",
        0x18cb9f78 => "help.inviteText",
        0xab7ec0a0 => "encryptedChatEmpty",
        0x66b25953 => "encryptedChatWaiting",
        0x48f1d94c => "encryptedChatRequested",
        0x61f0d4c7 => "encryptedChat",
        0x1e1c7c45 => "encryptedChatDiscarded",
        0xf141b5e1 => "inputEncryptedChat",
        0xc21f497e => "encryptedFileEmpty",
        0x4a70994c => "encryptedFile",
        0x1837c364 => "inputEncryptedFileEmpty",
        0x64bd0306 => "inputEncryptedFileUploaded",
        0x5a17b5e5 => "inputEncryptedFile",
        0x2dc173c8 => "inputEncryptedFileBigUploaded",
        0xed18c118 => "encryptedMessage",
        0x23734b06 => "encryptedMessageService",
        0xc0e24635 => "messages.dhConfigNotModified",
        0x2c221edd => "messages.dhConfig",
        0x560f8935 => "messages.sentEncryptedMessage",
        0x9493ff32 => "messages.sentEncryptedFile",
        0x72f0eaae => "inputDocumentEmpty",
        0x1abfb575 => "inputDocument",
        0x36f8c871 => "documentEmpty",
        0x1e87342b => "document",
        0x17c6b5f6 => "help.support",
        0x9fd40bd8 => "notifyPeer",
        0xb4c83b4c => "notifyUsers",
        0xc007cec3 => "notifyChats",
        0xd612e8ef => "notifyBroadcasts",
        0x16bf744e => "sendMessageTypingAction",
        0xfd5ec8f5 => "sendMessageCancelAction",
        0xa187d66f => "sendMessageRecordVideoAction",
        0xe9763aec => "sendMessageUploadVideoAction",
        0xd52f73f7 => "sendMessageRecordAudioAction",
        0xf351d7ab => "sendMessageUploadAudioAction",
        0xd1d34a26 => "sendMessageUploadPhotoAction",
        0xaa0cd9e4 => "sendMessageUploadDocumentAction",
        0x176f8ba1 => "sendMessageGeoLocationAction",
        0x628cbc6f => "sendMessageChooseContactAction",
        0xdd6a8f48 => "sendMessageGamePlayAction",
        0x88f27fbc => "sendMessageRecordRoundAction",
        0x243e1c66 => "sendMessageUploadRoundAction",
        0xd92c2285 => "speakingInGroupCallAction",
        0xdbda9246 => "sendMessageHistoryImportAction",
        0xb05ac6b1 => "sendMessageChooseStickerAction",
        0x25972bcb => "sendMessageEmojiInteraction",
        0xb665902e => "sendMessageEmojiInteractionSeen",
        0xb3134d9d => "contacts.found",
        0x4f96cb18 => "inputPrivacyKeyStatusTimestamp",
        0xbdfb0426 => "inputPrivacyKeyChatInvite",
        0xfabadc5f => "inputPrivacyKeyPhoneCall",
        0xdb9e70d2 => "inputPrivacyKeyPhoneP2P",
        0xa4dd4c08 => "inputPrivacyKeyForwards",
        0x5719bacc => "inputPrivacyKeyProfilePhoto",
        0x352dafa => "inputPrivacyKeyPhoneNumber",
        0xd1219bdd => "inputPrivacyKeyAddedByPhone",
        0xbc2eab30 => "privacyKeyStatusTimestamp",
        0x500e6dfa => "privacyKeyChatInvite",
        0x3d662b7b => "privacyKeyPhoneCall",
        0x39491cc8 => "privacyKeyPhoneP2P",
        0x69ec56a3 => "privacyKeyForwards",
        0x96151fed => "privacyKeyProfilePhoto",
        0xd19ae46d => "privacyKeyPhoneNumber",
        0x42ffd42b => "privacyKeyAddedByPhone",
        0xd09e07b => "inputPrivacyValueAllowContacts",
        0x184b35ce => "inputPrivacyValueAllowAll",
        0x131cc67f => "inputPrivacyValueAllowUsers",
        0xba52007 => "inputPrivacyValueDisallowContacts",
        0xd66b66c9 => "inputPrivacyValueDisallowAll",
        0x90110467 => "inputPrivacyValueDisallowUsers",
        0x840649cf => "inputPrivacyValueAllowChatParticipants",
        0xe94f0f86 => "inputPrivacyValueDisallowChatParticipants",
        0xfffe1bac => "privacyValueAllowContacts",
        0x65427b82 => "privacyValueAllowAll",
        0xb8905fb2 => "privacyValueAllowUsers",
        0xf888fa1a => "privacyValueDisallowContacts",
        0x8b73e763 => "privacyValueDisallowAll",
        0xe4621141 => "privacyValueDisallowUsers",
        0x6b134e8e => "privacyValueAllowChatParticipants",
        0x41c87565 => "privacyValueDisallowChatParticipants",
        0x50a04e45 => "account.privacyRules",
        0xb8d0afdf => "accountDaysTTL",
        0x6c37c15c => "documentAttributeImageSize",
        0x11b58939 => "documentAttributeAnimated",
        0x6319d612 => "documentAttributeSticker",
        0xef02ce6 => "documentAttributeVideo",
        0x9852f9c6 => "documentAttributeAudio",
        0x15590068 => "documentAttributeFilename",
        0x9801d2f7 => "documentAttributeHasStickers",
        0xf1749a22 => "messages.stickersNotModified",
        0x30a6ec7e => "messages.stickers",
        0x12b299d4 => "stickerPack",
        0xe86602c3 => "messages.allStickersNotModified",
        0xcdbbcebb => "messages.allStickers",
        0x84d19185 => "messages.affectedMessages",
        0xeb1477e8 => "webPageEmpty",
        0xc586da1c => "webPagePending",
        0xe89c45b2 => "webPage",
        0x7311ca11 => "webPageNotModified",
        0xad01d61d => "authorization",
        0x4bff8ea0 => "account.authorizations",
        0x185b184f => "account.password",
        0x9a5c33e5 => "account.passwordSettings",
        0xc23727c9 => "account.passwordInputSettings",
        0x137948a5 => "auth.passwordRecovery",
        0xa384b779 => "receivedNotifyMessage",
        0xab4a819 => "chatInviteExported",
        0x5a686d7c => "chatInviteAlready",
        0x300c44c1 => "chatInvite",
        0x61695cb0 => "chatInvitePeek",
        0xffb62b95 => "inputStickerSetEmpty",
        0x9de7a269 => "inputStickerSetID",
        0x861cc8a0 => "inputStickerSetShortName",
        0x28703c8 => "inputStickerSetAnimatedEmoji",
        0xe67f520e => "inputStickerSetDice",
        0xcde3739 => "inputStickerSetAnimatedEmojiAnimations",
        0xd7df217a => "stickerSet",
        0xb60a24a6 => "messages.stickerSet",
        0xd3f924eb => "messages.stickerSetNotModified",
        0xc27ac8c7 => "botCommand",
        0x1b74b335 => "botInfo",
        0xa2fa4880 => "keyboardButton",
        0x258aff05 => "keyboardButtonUrl",
        0x35bbdb6b => "keyboardButtonCallback",
        0xb16a6c29 => "keyboardButtonRequestPhone",
        0xfc796b3f => "keyboardButtonRequestGeoLocation",
        0x568a748 => "keyboardButtonSwitchInline",
        0x50f41ccf => "keyboardButtonGame",
        0xafd93fbb => "keyboardButtonBuy",
        0x10b78d29 => "keyboardButtonUrlAuth",
        0xd02e7fd4 => "inputKeyboardButtonUrlAuth",
        0xbbc7515d => "keyboardButtonRequestPoll",
        0xe988037b => "inputKeyboardButtonUserProfile",
        0x308660c1 => "keyboardButtonUserProfile",
        0x77608b83 => "keyboardButtonRow",
        0xa03e5b85 => "replyKeyboardHide",
        0x86b40b08 => "replyKeyboardForceReply",
        0x85dd99d1 => "replyKeyboardMarkup",
        0x48a30254 => "replyInlineMarkup",
        0xbb92ba95 => "messageEntityUnknown",
        0xfa04579d => "messageEntityMention",
        0x6f635b0d => "messageEntityHashtag",
        0x6cef8ac7 => "messageEntityBotCommand",
        0x6ed02538 => "messageEntityUrl",
        0x64e475c2 => "messageEntityEmail",
        0xbd610bc9 => "messageEntityBold",
        0x826f8b60 => "messageEntityItalic",
        0x28a20571 => "messageEntityCode",
        0x73924be0 => "messageEntityPre",
        0x76a6d327 => "messageEntityTextUrl",
        0xdc7b1140 => "messageEntityMentionName",
        0x208e68c9 => "inputMessageEntityMentionName",
        0x9b69e34b => "messageEntityPhone",
        0x4c4e743f => "messageEntityCashtag",
        0x9c4e7e8b => "messageEntityUnderline",
        0xbf0693d4 => "messageEntityStrike",
        0x20df5d0 => "messageEntityBlockquote",
        0x761e6af4 => "messageEntityBankCard",
        0xee8c1e86 => "inputChannelEmpty",
        0xf35aec28 => "inputChannel",
        0x5b934f9d => "inputChannelFromMessage",
        0x7f077ad9 => "contacts.resolvedPeer",
        0xae30253 => "messageRange",
        0x3e11affb => "updates.channelDifferenceEmpty",
        0xa4bcc6fe => "updates.channelDifferenceTooLong",
        0x2064674e => "updates.channelDifference",
        0x94d42ee7 => "channelMessagesFilterEmpty",
        0xcd77d957 => "channelMessagesFilter",
        0xc00c07c0 => "channelParticipant",
        0x35a8bfa7 => "channelParticipantSelf",
        0x2fe601d3 => "channelParticipantCreator",
        0x34c3bb53 => "channelParticipantAdmin",
        0x6df8014e => "channelParticipantBanned",
        0x1b03f006 => "channelParticipantLeft",
        0xde3f3c79 => "channelParticipantsRecent",
        0xb4608969 => "channelParticipantsAdmins",
        0xa3b54985 => "channelParticipantsKicked",
        0xb0d1865b => "channelParticipantsBots",
        0x1427a5e1 => "channelParticipantsBanned",
        0x656ac4b => "channelParticipantsSearch",
        0xbb6ae88d => "channelParticipantsContacts",
        0xe04b5ceb => "channelParticipantsMentions",
        0x9ab0feaf => "channels.channelParticipants",
        0xf0173fe9 => "channels.channelParticipantsNotModified",
        0xdfb80317 => "channels.channelParticipant",
        0x780a0310 => "help.termsOfService",
        0xe8025ca2 => "messages.savedGifsNotModified",
        0x84a02a0d => "messages.savedGifs",
        0x3380c786 => "inputBotInlineMessageMediaAuto",
        0x3dcd7a87 => "inputBotInlineMessageText",
        0x96929a85 => "inputBotInlineMessageMediaGeo",
        0x417bbf11 => "inputBotInlineMessageMediaVenue",
        0xa6edbffd => "inputBotInlineMessageMediaContact",
        0x4b425864 => "inputBotInlineMessageGame",
        0xd7e78225 => "inputBotInlineMessageMediaInvoice",
        0x88bf9319 => "inputBotInlineResult",
        0xa8d864a7 => "inputBotInlineResultPhoto",
        0xfff8fdc4 => "inputBotInlineResultDocument",
        0x4fa417f2 => "inputBotInlineResultGame",
        0x764cf810 => "botInlineMessageMediaAuto",
        0x8c7f65e2 => "botInlineMessageText",
        0x51846fd => "botInlineMessageMediaGeo",
        0x8a86659c => "botInlineMessageMediaVenue",
        0x18d1cdc2 => "botInlineMessageMediaContact",
        0x354a9b09 => "botInlineMessageMediaInvoice",
        0x11965f3a => "botInlineResult",
        0x17db940b => "botInlineMediaResult",
        0x947ca848 => "messages.botResults",
        0x5dab1af4 => "exportedMessageLink",
        0x5f777dce => "messageFwdHeader",
        0x72a3158c => "auth.codeTypeSms",
        0x741cd3e3 => "auth.codeTypeCall",
        0x226ccefb => "auth.codeTypeFlashCall",
        0xd61ad6ee => "auth.codeTypeMissedCall",
        0x3dbb5986 => "auth.sentCodeTypeApp",
        0xc000bba2 => "auth.sentCodeTypeSms",
        0x5353e5a7 => "auth.sentCodeTypeCall",
        0xab03c6d9 => "auth.sentCodeTypeFlashCall",
        0x82006484 => "auth.sentCodeTypeMissedCall",
        0x36585ea4 => "messages.botCallbackAnswer",
        0x26b5dde6 => "messages.messageEditData",
        0x890c3d89 => "inputBotInlineMessageID",
        0xb6d915d7 => "inputBotInlineMessageID64",
        0x3c20629f => "inlineBotSwitchPM",
        0x3371c354 => "messages.peerDialogs",
        0xedcdc05b => "topPeer",
        0xab661b5b => "topPeerCategoryBotsPM",
        0x148677e2 => "topPeerCategoryBotsInline",
        0x637b7ed => "topPeerCategoryCorrespondents",
        0xbd17a14a => "topPeerCategoryGroups",
        0x161d9628 => "topPeerCategoryChannels",
        0x1e76a78c => "topPeerCategoryPhoneCalls",
        0xa8406ca9 => "topPeerCategoryForwardUsers",
        0xfbeec0f0 => "topPeerCategoryForwardChats",
        0xfb834291 => "topPeerCategoryPeers",
        0xde266ef5 => "contacts.topPeersNotModified",
        0x70b772a8 => "contacts.topPeers",
        0xb52c939d => "contacts.topPeersDisabled",
        0x1b0c841a => "draftMessageEmpty",
        0xfd8e711f => "draftMessage",
        0xc6dc0c66 => "messages.featuredStickersNotModified",
        0x84c02310 => "messages.featuredStickers",
        0xb17f890 => "messages.recentStickersNotModified",
        0x88d37c56 => "messages.recentStickers",
        0x4fcba9c8 => "messages.archivedStickers",
        0x38641628 => "messages.stickerSetInstallResultSuccess",
        0x35e410a8 => "messages.stickerSetInstallResultArchive",
        0x6410a5d2 => "stickerSetCovered",
        0x3407e51b => "stickerSetMultiCovered",
        0xaed6dbb2 => "maskCoords",
        0x4a992157 => "inputStickeredMediaPhoto",
        0x438865b => "inputStickeredMediaDocument",
        0xbdf9653b => "game",
        0x32c3e77 => "inputGameID",
        0xc331e80a => "inputGameShortName",
        0x73a379eb => "highScore",
        0x9a3bfd99 => "messages.highScores",
        0xdc3d824f => "textEmpty",
        0x744694e0 => "textPlain",
        0x6724abc4 => "textBold",
        0xd912a59c => "textItalic",
        0xc12622c4 => "textUnderline",
        0x9bf8bb95 => "textStrike",
        0x6c3f19b9 => "textFixed",
        0x3c2884c1 => "textUrl",
        0xde5a0dd6 => "textEmail",
        0x7e6260d7 => "textConcat",
        0xed6a8504 => "textSubscript",
        0xc7fb5e01 => "textSuperscript",
        0x34b8621 => "textMarked",
        0x1ccb966a => "textPhone",
        0x81ccf4f => "textImage",
        0x35553762 => "textAnchor",
        0x13567e8a => "pageBlockUnsupported",
        0x70abc3fd => "pageBlockTitle",
        0x8ffa9a1f => "pageBlockSubtitle",
        0xbaafe5e0 => "pageBlockAuthorDate",
        0xbfd064ec => "pageBlockHeader",
        0xf12bb6e1 => "pageBlockSubheader",
        0x467a0766 => "pageBlockParagraph",
        0xc070d93e => "pageBlockPreformatted",
        0x48870999 => "pageBlockFooter",
        0xdb20b188 => "pageBlockDivider",
        0xce0d37b0 => "pageBlockAnchor",
        0xe4e88011 => "pageBlockList",
        0x263d7c26 => "pageBlockBlockquote",
        0x4f4456d3 => "pageBlockPullquote",
        0x1759c560 => "pageBlockPhoto",
        0x7c8fe7b6 => "pageBlockVideo",
        0x39f23300 => "pageBlockCover",
        0xa8718dc5 => "pageBlockEmbed",
        0xf259a80b => "pageBlockEmbedPost",
        0x65a0fa4d => "pageBlockCollage",
        0x31f9590 => "pageBlockSlideshow",
        0xef1751b5 => "pageBlockChannel",
        0x804361ea => "pageBlockAudio",
        0x1e148390 => "pageBlockKicker",
        0xbf4dea82 => "pageBlockTable",
        0x9a8ae1e1 => "pageBlockOrderedList",
        0x76768bed => "pageBlockDetails",
        0x16115a96 => "pageBlockRelatedArticles",
        0xa44f3ef6 => "pageBlockMap",
        0x85e42301 => "phoneCallDiscardReasonMissed",
        0xe095c1a0 => "phoneCallDiscardReasonDisconnect",
        0x57adc690 => "phoneCallDiscardReasonHangup",
        0xfaf7e8c9 => "phoneCallDiscardReasonBusy",
        0x7d748d04 => "dataJSON",
        0xcb296bf8 => "labeledPrice",
        0xcd886e0 => "invoice",
        0xea02c27e => "paymentCharge",
        0x1e8caaeb => "postAddress",
        0x909c3f94 => "paymentRequestedInfo",
        0xcdc27a1f => "paymentSavedCredentialsCard",
        0x1c570ed1 => "webDocument",
        0xf9c8bcc6 => "webDocumentNoProxy",
        0x9bed434d => "inputWebDocument",
        0xc239d686 => "inputWebFileLocation",
        0x9f2221c9 => "inputWebFileGeoPointLocation",
        0x21e753bc => "upload.webFile",
        0x1694761b => "payments.paymentForm",
        0xd1451883 => "payments.validatedRequestedInfo",
        0x4e5f810d => "payments.paymentResult",
        0xd8411139 => "payments.paymentVerificationNeeded",
        0x70c4fe03 => "payments.paymentReceipt",
        0xfb8fe43c => "payments.savedInfo",
        0xc10eb2cf => "inputPaymentCredentialsSaved",
        0x3417d728 => "inputPaymentCredentials",
        0xaa1c39f => "inputPaymentCredentialsApplePay",
        0x8ac32801 => "inputPaymentCredentialsGooglePay",
        0xdb64fd34 => "account.tmpPassword",
        0xb6213cdf => "shippingOption",
        0xffa0a496 => "inputStickerSetItem",
        0x1e36fded => "inputPhoneCall",
        0x5366c915 => "phoneCallEmpty",
        0xc5226f17 => "phoneCallWaiting",
        0x14b0ed0c => "phoneCallRequested",
        0x3660c311 => "phoneCallAccepted",
        0x967f7c67 => "phoneCall",
        0x50ca4de1 => "phoneCallDiscarded",
        0x9d4c17c0 => "phoneConnection",
        0x635fe375 => "phoneConnectionWebrtc",
        0xfc878fc8 => "phoneCallProtocol",
        0xec82e140 => "phone.phoneCall",
        0xeea8e46e => "upload.cdnFileReuploadNeeded",
        0xa99fca4f => "upload.cdnFile",
        0xc982eaba => "cdnPublicKey",
        0x5725e40a => "cdnConfig",
        0xcad181f6 => "langPackString",
        0x6c47ac9f => "langPackStringPluralized",
        0x2979eeb2 => "langPackStringDeleted",
        0xf385c1f6 => "langPackDifference",
        0xeeca5ce3 => "langPackLanguage",
        0xe6dfb825 => "channelAdminLogEventActionChangeTitle",
        0x55188a2e => "channelAdminLogEventActionChangeAbout",
        0x6a4afc38 => "channelAdminLogEventActionChangeUsername",
        0x434bd2af => "channelAdminLogEventActionChangePhoto",
        0x1b7907ae => "channelAdminLogEventActionToggleInvites",
        0x26ae0971 => "channelAdminLogEventActionToggleSignatures",
        0xe9e82c18 => "channelAdminLogEventActionUpdatePinned",
        0x709b2405 => "channelAdminLogEventActionEditMessage",
        0x42e047bb => "channelAdminLogEventActionDeleteMessage",
        0x183040d3 => "channelAdminLogEventActionParticipantJoin",
        0xf89777f2 => "channelAdminLogEventActionParticipantLeave",
        0xe31c34d8 => "channelAdminLogEventActionParticipantInvite",
        0xe6d83d7e => "channelAdminLogEventActionParticipantToggleBan",
        0xd5676710 => "channelAdminLogEventActionParticipantToggleAdmin",
        0xb1c3caa7 => "channelAdminLogEventActionChangeStickerSet",
        0x5f5c95f1 => "channelAdminLogEventActionTogglePreHistoryHidden",
        0x2df5fc0a => "channelAdminLogEventActionDefaultBannedRights",
        0x8f079643 => "channelAdminLogEventActionStopPoll",
        0x50c7ac8 => "channelAdminLogEventActionChangeLinkedChat",
        0xe6b76ae => "channelAdminLogEventActionChangeLocation",
        0x53909779 => "channelAdminLogEventActionToggleSlowMode",
        0x23209745 => "channelAdminLogEventActionStartGroupCall",
        0xdb9f9140 => "channelAdminLogEventActionDiscardGroupCall",
        0xf92424d2 => "channelAdminLogEventActionParticipantMute",
        0xe64429c0 => "channelAdminLogEventActionParticipantUnmute",
        0x56d6a247 => "channelAdminLogEventActionToggleGroupCallSetting",
        0x5cdada77 => "channelAdminLogEventActionParticipantJoinByInvite",
        0x5a50fca4 => "channelAdminLogEventActionExportedInviteDelete",
        0x410a134e => "channelAdminLogEventActionExportedInviteRevoke",
        0xe90ebb59 => "channelAdminLogEventActionExportedInviteEdit",
        0x3e7f6847 => "channelAdminLogEventActionParticipantVolume",
        0x6e941a38 => "channelAdminLogEventActionChangeHistoryTTL",
        0xafb6144a => "channelAdminLogEventActionParticipantJoinByRequest",
        0xcb2ac766 => "channelAdminLogEventActionToggleNoForwards",
        0x278f2868 => "channelAdminLogEventActionSendMessage",
        0x1fad68cd => "channelAdminLogEvent",
        0xed8af74d => "channels.adminLogResults",
        0xea107ae4 => "channelAdminLogEventsFilter",
        0x5ce14175 => "popularContact",
        0x9e8fa6d3 => "messages.favedStickersNotModified",
        0x2cb51097 => "messages.favedStickers",
        0x46e1d13d => "recentMeUrlUnknown",
        0xb92c09e2 => "recentMeUrlUser",
        0xb2da71d2 => "recentMeUrlChat",
        0xeb49081d => "recentMeUrlChatInvite",
        0xbc0a57dc => "recentMeUrlStickerSet",
        0xe0310d7 => "help.recentMeUrls",
        0x1cc6e91f => "inputSingleMedia",
        0xa6f8f452 => "webAuthorization",
        0xed56c9fc => "account.webAuthorizations",
        0xa676a322 => "inputMessageID",
        0xbad88395 => "inputMessageReplyTo",
        0x86872538 => "inputMessagePinned",
        0xacfa1a7e => "inputMessageCallbackQuery",
        0xfcaafeb7 => "inputDialogPeer",
        0x64600527 => "inputDialogPeerFolder",
        0xe56dbf05 => "dialogPeer",
        0x514519e2 => "dialogPeerFolder",
        0xd54b65d => "messages.foundStickerSetsNotModified",
        0x8af09dd2 => "messages.foundStickerSets",
        0x6242c773 => "fileHash",
        0x75588b3f => "inputClientProxy",
        0xe3309f7f => "help.termsOfServiceUpdateEmpty",
        0x28ecf961 => "help.termsOfServiceUpdate",
        0x3334b0f0 => "inputSecureFileUploaded",
        0x5367e5be => "inputSecureFile",
        0x64199744 => "secureFileEmpty",
        0xe0277a62 => "secureFile",
        0x8aeabec3 => "secureData",
        0x7d6099dd => "securePlainPhone",
        0x21ec5a5f => "securePlainEmail",
        0x9d2a81e3 => "secureValueTypePersonalDetails",
        0x3dac6a00 => "secureValueTypePassport",
        0x6e425c4 => "secureValueTypeDriverLicense",
        0xa0d0744b => "secureValueTypeIdentityCard",
        0x99a48f23 => "secureValueTypeInternalPassport",
        0xcbe31e26 => "secureValueTypeAddress",
        0xfc36954e => "secureValueTypeUtilityBill",
        0x89137c0d => "secureValueTypeBankStatement",
        0x8b883488 => "secureValueTypeRentalAgreement",
        0x99e3806a => "secureValueTypePassportRegistration",
        0xea02ec33 => "secureValueTypeTemporaryRegistration",
        0xb320aadb => "secureValueTypePhone",
        0x8e3ca7ee => "secureValueTypeEmail",
        0x187fa0ca => "secureValue",
        0xdb21d0a7 => "inputSecureValue",
        0xed1ecdb0 => "secureValueHash",
        0xe8a40bd9 => "secureValueErrorData",
        0xbe3dfa => "secureValueErrorFrontSide",
        0x868a2aa5 => "secureValueErrorReverseSide",
        0xe537ced6 => "secureValueErrorSelfie",
        0x7a700873 => "secureValueErrorFile",
        0x666220e9 => "secureValueErrorFiles",
        0x869d758f => "secureValueError",
        0xa1144770 => "secureValueErrorTranslationFile",
        0x34636dd8 => "secureValueErrorTranslationFiles",
        0x33f0ea47 => "secureCredentialsEncrypted",
        0xad2e1cd8 => "account.authorizationForm",
        0x811f854f => "account.sentEmailCode",
        0x66afa166 => "help.deepLinkInfoEmpty",
        0x6a4ee832 => "help.deepLinkInfo",
        0x1142bd56 => "savedPhoneContact",
        0x4dba4501 => "account.takeout",
        0xd45ab096 => "passwordKdfAlgoUnknown",
        0x3a912d4a => "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow",
        0x4a8537 => "securePasswordKdfAlgoUnknown",
        0xbbf2dda0 => "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000",
        0x86471d92 => "securePasswordKdfAlgoSHA512",
        0x1527bcac => "secureSecretSettings",
        0x9880f658 => "inputCheckPasswordEmpty",
        0xd27ff082 => "inputCheckPasswordSRP",
        0x829d99da => "secureRequiredType",
        0x27477b4 => "secureRequiredTypeOneOf",
        0xbfb9f457 => "help.passportConfigNotModified",
        0xa098d6af => "help.passportConfig",
        0x1d1b1245 => "inputAppEvent",
        0xc0de1bd9 => "jsonObjectValue",
        0x3f6d7b68 => "jsonNull",
        0xc7345e6a => "jsonBool",
        0x2be0dfa4 => "jsonNumber",
        0xb71e767a => "jsonString",
        0xf7444763 => "jsonArray",
        0x99c1d49d => "jsonObject",
        0x34566b6a => "pageTableCell",
        0xe0c0c5e5 => "pageTableRow",
        0x6f747657 => "pageCaption",
        0xb92fb6cd => "pageListItemText",
        0x25e073fc => "pageListItemBlocks",
        0x5e068047 => "pageListOrderedItemText",
        0x98dd8936 => "pageListOrderedItemBlocks",
        0xb390dc08 => "pageRelatedArticle",
        0x98657f0d => "page",
        0x8c05f1c9 => "help.supportName",
        0xf3ae2eed => "help.userInfoEmpty",
        0x1eb3758 => "help.userInfo",
        0x6ca9c2e9 => "pollAnswer",
        0x86e18161 => "poll",
        0x3b6ddad2 => "pollAnswerVoters",
        0xdcb82ea3 => "pollResults",
        0xf041e250 => "chatOnlines",
        0x47a971e0 => "statsURL",
        0x5fb224d5 => "chatAdminRights",
        0x9f120418 => "chatBannedRights",
        0xe630b979 => "inputWallPaper",
        0x72091c80 => "inputWallPaperSlug",
        0x967a462e => "inputWallPaperNoFile",
        0x1c199183 => "account.wallPapersNotModified",
        0xcdc3858c => "account.wallPapers",
        0x8a6469c2 => "codeSettings",
        0x1dc1bca4 => "wallPaperSettings",
        0xe04232f3 => "autoDownloadSettings",
        0x63cacf26 => "account.autoDownloadSettings",
        0xd5b3b9f9 => "emojiKeyword",
        0x236df622 => "emojiKeywordDeleted",
        0x5cc761bd => "emojiKeywordsDifference",
        0xa575739d => "emojiURL",
        0xb3fb5361 => "emojiLanguage",
        0xff544e65 => "folder",
        0xfbd2c296 => "inputFolderPeer",
        0xe9baa668 => "folderPeer",
        0xe844ebff => "messages.searchCounter",
        0x92d33a0e => "urlAuthResultRequest",
        0x8f8c0e4e => "urlAuthResultAccepted",
        0xa9d6db1f => "urlAuthResultDefault",
        0xbfb5ad8b => "channelLocationEmpty",
        0x209b82db => "channelLocation",
        0xca461b5d => "peerLocated",
        0xf8ec284b => "peerSelfLocated",
        0xd072acb4 => "restrictionReason",
        0x3c5693e9 => "inputTheme",
        0xf5890df1 => "inputThemeSlug",
        0xa00e67d6 => "theme",
        0xf41eb622 => "account.themesNotModified",
        0x9a3d8c6d => "account.themes",
        0x629f1980 => "auth.loginToken",
        0x68e9916 => "auth.loginTokenMigrateTo",
        0x390d5c5e => "auth.loginTokenSuccess",
        0x57e28221 => "account.contentSettings",
        0xa927fec5 => "messages.inactiveChats",
        0xc3a12462 => "baseThemeClassic",
        0xfbd81688 => "baseThemeDay",
        0xb7b31ea8 => "baseThemeNight",
        0x6d5f77ee => "baseThemeTinted",
        0x5b11125a => "baseThemeArctic",
        0x8fde504f => "inputThemeSettings",
        0xfa58b6d4 => "themeSettings",
        0x54b56617 => "webPageAttributeTheme",
        0x34d247b4 => "messageUserVote",
        0x3ca5b0ec => "messageUserVoteInputOption",
        0x8a65e557 => "messageUserVoteMultiple",
        0x823f649 => "messages.votesList",
        0xf568028a => "bankCardOpenUrl",
        0x3e24e573 => "payments.bankCardData",
        0x7438f7e8 => "dialogFilter",
        0x77744d4a => "dialogFilterSuggested",
        0xb637edaf => "statsDateRangeDays",
        0xcb43acde => "statsAbsValueAndPrev",
        0xcbce2fe0 => "statsPercentValue",
        0x4a27eb2d => "statsGraphAsync",
        0xbedc9822 => "statsGraphError",
        0x8ea464b6 => "statsGraph",
        0xad4fc9bd => "messageInteractionCounters",
        0xbdf78394 => "stats.broadcastStats",
        0x98f6ac75 => "help.promoDataEmpty",
        0x8c39793f => "help.promoData",
        0xde33b094 => "videoSize",
        0x9d04af9b => "statsGroupTopPoster",
        0xd7584c87 => "statsGroupTopAdmin",
        0x535f779d => "statsGroupTopInviter",
        0xef7ff916 => "stats.megagroupStats",
        0xbea2f424 => "globalPrivacySettings",
        0x4203c5ef => "help.countryCode",
        0xc3878e23 => "help.country",
        0x93cc1f32 => "help.countriesListNotModified",
        0x87d0759e => "help.countriesList",
        0x455b853d => "messageViews",
        0xb6c4f543 => "messages.messageViews",
        0xa6341782 => "messages.discussionMessage",
        0xa6d57763 => "messageReplyHeader",
        0x83d60fc2 => "messageReplies",
        0xe8fd8014 => "peerBlocked",
        0x8999f295 => "stats.messageStats",
        0x7780bcb4 => "groupCallDiscarded",
        0xd597650c => "groupCall",
        0xd8aa840f => "inputGroupCall",
        0xeba636fe => "groupCallParticipant",
        0x9e727aad => "phone.groupCall",
        0xf47751b6 => "phone.groupParticipants",
        0x3081ed9d => "inlineQueryPeerTypeSameBotPM",
        0x833c0fac => "inlineQueryPeerTypePM",
        0xd766c50a => "inlineQueryPeerTypeChat",
        0x5ec4be43 => "inlineQueryPeerTypeMegagroup",
        0x6334ee9a => "inlineQueryPeerTypeBroadcast",
        0x1662af0b => "messages.historyImport",
        0x5e0fb7b9 => "messages.historyImportParsed",
        0xef8d3e6c => "messages.affectedFoundMessages",
        0x8c5adfd9 => "chatInviteImporter",
        0xbdc62dcc => "messages.exportedChatInvites",
        0x1871be50 => "messages.exportedChatInvite",
        0x222600ef => "messages.exportedChatInviteReplaced",
        0x81b6b00a => "messages.chatInviteImporters",
        0xf2ecef23 => "chatAdminWithInvites",
        0xb69b72d7 => "messages.chatAdminsWithInvites",
        0xa24de717 => "messages.checkedHistoryImportPeer",
        0xafe5623f => "phone.joinAsPeers",
        0x204bd158 => "phone.exportedGroupCallInvite",
        0xdcb118b7 => "groupCallParticipantVideoSourceGroup",
        0x67753ac8 => "groupCallParticipantVideo",
        0x85fea03f => "stickers.suggestedShortName",
        0x2f6cb2ab => "botCommandScopeDefault",
        0x3c4f04d8 => "botCommandScopeUsers",
        0x6fe1a881 => "botCommandScopeChats",
        0xb9aa606a => "botCommandScopeChatAdmins",
        0xdb9d897d => "botCommandScopePeer",
        0x3fd863d1 => "botCommandScopePeerAdmins",
        0xa1321f3 => "botCommandScopePeerUser",
        0xe3779861 => "account.resetPasswordFailedWait",
        0xe9effc7d => "account.resetPasswordRequestedWait",
        0xe926d63e => "account.resetPasswordOk",
        0xd151e19a => "sponsoredMessage",
        0x65a4c7d5 => "messages.sponsoredMessages",
        0xc9b0539f => "searchResultsCalendarPeriod",
        0x147ee23c => "messages.searchResultsCalendar",
        0x7f648b67 => "searchResultPosition",
        0x53b22baf => "messages.searchResultsPositions",
        0x8356cda9 => "channels.sendAsPeers",
        0x3b6d152e => "users.userFull",
        0x6880b94d => "messages.peerSettings",
        0xc3a2835f => "auth.loggedOut",
        0xcb9f372d => "invokeAfterMsg",
        0x3dc4b4f0 => "invokeAfterMsgs",
        0xc1cd5ea9 => "initConnection",
        0xda9b0d0d => "invokeWithLayer",
        0xbf9459b7 => "invokeWithoutUpdates",
        0x365275f2 => "invokeWithMessagesRange",
        0xaca9fd2e => "invokeWithTakeout",
        0xa677244f => "auth.sendCode",
        0x80eee427 => "auth.signUp",
        0xbcd51581 => "auth.signIn",
        0x3e72ba19 => "auth.logOut",
        0x9fab0d1a => "auth.resetAuthorizations",
        0xe5bfffcd => "auth.exportAuthorization",
        0xa57a7dad => "auth.importAuthorization",
        0xcdd42a05 => "auth.bindTempAuthKey",
        0x67a3ff2c => "auth.importBotAuthorization",
        0xd18b4d16 => "auth.checkPassword",
        0xd897bc66 => "auth.requestPasswordRecovery",
        0x37096c70 => "auth.recoverPassword",
        0x3ef1a9bf => "auth.resendCode",
        0x1f040578 => "auth.cancelCode",
        0x8e48a188 => "auth.dropTempAuthKeys",
        0xb7e085fe => "auth.exportLoginToken",
        0x95ac5ce4 => "auth.importLoginToken",
        0xe894ad4d => "auth.acceptLoginToken",
        0xd36bf79 => "auth.checkRecoveryPassword",
        0xec86017a => "account.registerDevice",
        0x6a0d3206 => "account.unregisterDevice",
        0x84be5b93 => "account.updateNotifySettings",
        0x12b3ad31 => "account.getNotifySettings",
        0xdb7e1747 => "account.resetNotifySettings",
        0x78515775 => "account.updateProfile",
        0x6628562c => "account.updateStatus",
        0x7967d36 => "account.getWallPapers",
        0xc5ba3d86 => "account.reportPeer",
        0x2714d86c => "account.checkUsername",
        0x3e0bdd7c => "account.updateUsername",
        0xdadbc950 => "account.getPrivacy",
        0xc9f81ce8 => "account.setPrivacy",
        0x418d4e0b => "account.deleteAccount",
        0x8fc711d => "account.getAccountTTL",
        0x2442485e => "account.setAccountTTL",
        0x82574ae5 => "account.sendChangePhoneCode",
        0x70c32edb => "account.changePhone",
        0x38df3532 => "account.updateDeviceLocked",
        0xe320c158 => "account.getAuthorizations",
        0xdf77f3bc => "account.resetAuthorization",
        0x548a30f5 => "account.getPassword",
        0x9cd4eaf9 => "account.getPasswordSettings",
        0xa59b102f => "account.updatePasswordSettings",
        0x1b3faa88 => "account.sendConfirmPhoneCode",
        0x5f2178c3 => "account.confirmPhone",
        0x449e0b51 => "account.getTmpPassword",
        0x182e6d6f => "account.getWebAuthorizations",
        0x2d01b9ef => "account.resetWebAuthorization",
        0x682d2594 => "account.resetWebAuthorizations",
        0xb288bc7d => "account.getAllSecureValues",
        0x73665bc2 => "account.getSecureValue",
        0x899fe31d => "account.saveSecureValue",
        0xb880bc4b => "account.deleteSecureValue",
        0xa929597a => "account.getAuthorizationForm",
        0xf3ed4c73 => "account.acceptAuthorization",
        0xa5a356f9 => "account.sendVerifyPhoneCode",
        0x4dd3a7f6 => "account.verifyPhone",
        0x7011509f => "account.sendVerifyEmailCode",
        0xecba39db => "account.verifyEmail",
        0xf05b4804 => "account.initTakeoutSession",
        0x1d2652ee => "account.finishTakeoutSession",
        0x8fdf1920 => "account.confirmPasswordEmail",
        0x7a7f2a15 => "account.resendPasswordEmail",
        0xc1cbd5b6 => "account.cancelPasswordEmail",
        0x9f07c728 => "account.getContactSignUpNotification",
        0xcff43f61 => "account.setContactSignUpNotification",
        0x53577479 => "account.getNotifyExceptions",
        0xfc8ddbea => "account.getWallPaper",
        0xdd853661 => "account.uploadWallPaper",
        0x6c5a5b37 => "account.saveWallPaper",
        0xfeed5769 => "account.installWallPaper",
        0xbb3b9804 => "account.resetWallPapers",
        0x56da0b3f => "account.getAutoDownloadSettings",
        0x76f36233 => "account.saveAutoDownloadSettings",
        0x1c3db333 => "account.uploadTheme",
        0x652e4400 => "account.createTheme",
        0x2bf40ccc => "account.updateTheme",
        0xf257106c => "account.saveTheme",
        0xc727bb3b => "account.installTheme",
        0x8d9d742b => "account.getTheme",
        0x7206e458 => "account.getThemes",
        0xb574b16b => "account.setContentSettings",
        0x8b9b4dae => "account.getContentSettings",
        0x65ad71dc => "account.getMultiWallPapers",
        0xeb2b4cf6 => "account.getGlobalPrivacySettings",
        0x1edaaac2 => "account.setGlobalPrivacySettings",
        0xfa8cc6f5 => "account.reportProfilePhoto",
        0x9308ce1b => "account.resetPassword",
        0x4c9409f6 => "account.declinePasswordReset",
        0xd638de89 => "account.getChatThemes",
        0xbf899aa0 => "account.setAuthorizationTTL",
        0x40f48462 => "account.changeAuthorizationSettings",
        0xd91a548 => "users.getUsers",
        0xb60f5918 => "users.getFullUser",
        0x90c894b5 => "users.setSecureValueErrors",
        0x7adc669d => "contacts.getContactIDs",
        0xc4a353ee => "contacts.getStatuses",
        0x5dd69e12 => "contacts.getContacts",
        0x2c800be5 => "contacts.importContacts",
        0x96a0e00 => "contacts.deleteContacts",
        0x1013fd9e => "contacts.deleteByPhones",
        0x68cc1411 => "contacts.block",
        0xbea65d50 => "contacts.unblock",
        0xf57c350f => "contacts.getBlocked",
        0x11f812d8 => "contacts.search",
        0xf93ccba3 => "contacts.resolveUsername",
        0x973478b6 => "contacts.getTopPeers",
        0x1ae373ac => "contacts.resetTopPeerRating",
        0x879537f1 => "contacts.resetSaved",
        0x82f1e39f => "contacts.getSaved",
        0x8514bdda => "contacts.toggleTopPeers",
        0xe8f463d0 => "contacts.addContact",
        0xf831a20f => "contacts.acceptContact",
        0xd348bc44 => "contacts.getLocated",
        0x29a8962c => "contacts.blockFromReplies",
        0x63c66506 => "messages.getMessages",
        0xa0f4cb4f => "messages.getDialogs",
        0x4423e6c5 => "messages.getHistory",
        0xa0fda762 => "messages.search",
        0xe306d3a => "messages.readHistory",
        0xb08f922a => "messages.deleteHistory",
        0xe58e95d2 => "messages.deleteMessages",
        0x5a954c0 => "messages.receivedMessages",
        0x58943ee2 => "messages.setTyping",
        0xd9d75a4 => "messages.sendMessage",
        0xe25ff8e0 => "messages.sendMedia",
        0xcc30290b => "messages.forwardMessages",
        0xcf1592db => "messages.reportSpam",
        0xefd9a6a2 => "messages.getPeerSettings",
        0x8953ab4e => "messages.report",
        0x49e9528f => "messages.getChats",
        0xaeb00b34 => "messages.getFullChat",
        0x73783ffd => "messages.editChatTitle",
        0x35ddd674 => "messages.editChatPhoto",
        0xf24753e3 => "messages.addChatUser",
        0xa2185cab => "messages.deleteChatUser",
        0x9cb126e => "messages.createChat",
        0x26cf8950 => "messages.getDhConfig",
        0xf64daf43 => "messages.requestEncryption",
        0x3dbc0415 => "messages.acceptEncryption",
        0xf393aea0 => "messages.discardEncryption",
        0x791451ed => "messages.setEncryptedTyping",
        0x7f4b690a => "messages.readEncryptedHistory",
        0x44fa7a15 => "messages.sendEncrypted",
        0x5559481d => "messages.sendEncryptedFile",
        0x32d439a4 => "messages.sendEncryptedService",
        0x55a5bb66 => "messages.receivedQueue",
        0x4b0c8c0f => "messages.reportEncryptedSpam",
        0x36a73f77 => "messages.readMessageContents",
        0xd5a5d3a1 => "messages.getStickers",
        0xb8a0a1a8 => "messages.getAllStickers",
        0x8b68b0cc => "messages.getWebPagePreview",
        0xa02ce5d5 => "messages.exportChatInvite",
        0x3eadb1bb => "messages.checkChatInvite",
        0x6c50051c => "messages.importChatInvite",
        0xc8a0ec74 => "messages.getStickerSet",
        0xc78fe460 => "messages.installStickerSet",
        0xf96e55de => "messages.uninstallStickerSet",
        0xe6df7378 => "messages.startBot",
        0x5784d3e1 => "messages.getMessagesViews",
        0xa85bd1c2 => "messages.editChatAdmin",
        0xa2875319 => "messages.migrateChat",
        0x4bc6589a => "messages.searchGlobal",
        0x78337739 => "messages.reorderStickerSets",
        0x338e2464 => "messages.getDocumentByHash",
        0x5cf09635 => "messages.getSavedGifs",
        0x327a30cb => "messages.saveGif",
        0x514e999d => "messages.getInlineBotResults",
        0xeb5ea206 => "messages.setInlineBotResults",
        0x7aa11297 => "messages.sendInlineBotResult",
        0xfda68d36 => "messages.getMessageEditData",
        0x48f71778 => "messages.editMessage",
        0x83557dba => "messages.editInlineBotMessage",
        0x9342ca07 => "messages.getBotCallbackAnswer",
        0xd58f130a => "messages.setBotCallbackAnswer",
        0xe470bcfd => "messages.getPeerDialogs",
        0xbc39e14b => "messages.saveDraft",
        0x6a3f8d65 => "messages.getAllDrafts",
        0x64780b14 => "messages.getFeaturedStickers",
        0x5b118126 => "messages.readFeaturedStickers",
        0x9da9403b => "messages.getRecentStickers",
        0x392718f8 => "messages.saveRecentSticker",
        0x8999602d => "messages.clearRecentStickers",
        0x57f17692 => "messages.getArchivedStickers",
        0x640f82b8 => "messages.getMaskStickers",
        0xcc5b67cc => "messages.getAttachedStickers",
        0x8ef8ecc0 => "messages.setGameScore",
        0x15ad9f64 => "messages.setInlineGameScore",
        0xe822649d => "messages.getGameHighScores",
        0xf635e1b => "messages.getInlineGameHighScores",
        0xe40ca104 => "messages.getCommonChats",
        0x875f74be => "messages.getAllChats",
        0x32ca8f91 => "messages.getWebPage",
        0xa731e257 => "messages.toggleDialogPin",
        0x3b1adf37 => "messages.reorderPinnedDialogs",
        0xd6b94df2 => "messages.getPinnedDialogs",
        0xe5f672fa => "messages.setBotShippingResults",
        0x9c2dd95 => "messages.setBotPrecheckoutResults",
        0x519bc2b1 => "messages.uploadMedia",
        0xc97df020 => "messages.sendScreenshotNotification",
        0x4f1aaa9 => "messages.getFavedStickers",
        0xb9ffc55b => "messages.faveSticker",
        0x46578472 => "messages.getUnreadMentions",
        0xf0189d3 => "messages.readMentions",
        0x702a40e0 => "messages.getRecentLocations",
        0xf803138f => "messages.sendMultiMedia",
        0x5057c497 => "messages.uploadEncryptedFile",
        0x35705b8a => "messages.searchStickerSets",
        0x1cff7e08 => "messages.getSplitRanges",
        0xc286d98f => "messages.markDialogUnread",
        0x22e24e22 => "messages.getDialogUnreadMarks",
        0x7e58ee9c => "messages.clearAllDrafts",
        0xd2aaf7ec => "messages.updatePinnedMessage",
        0x10ea6184 => "messages.sendVote",
        0x73bb643b => "messages.getPollResults",
        0x6e2be050 => "messages.getOnlines",
        0xdef60797 => "messages.editChatAbout",
        0xa5866b41 => "messages.editChatDefaultBannedRights",
        0x35a0e062 => "messages.getEmojiKeywords",
        0x1508b6af => "messages.getEmojiKeywordsDifference",
        0x4e9963b2 => "messages.getEmojiKeywordsLanguages",
        0xd5b10c26 => "messages.getEmojiURL",
        0x732eef00 => "messages.getSearchCounters",
        0x198fb446 => "messages.requestUrlAuth",
        0xb12c7125 => "messages.acceptUrlAuth",
        0x4facb138 => "messages.hidePeerSettingsBar",
        0xf516760b => "messages.getScheduledHistory",
        0xbdbb0464 => "messages.getScheduledMessages",
        0xbd38850a => "messages.sendScheduledMessages",
        0x59ae2b16 => "messages.deleteScheduledMessages",
        0xb86e380e => "messages.getPollVotes",
        0xb5052fea => "messages.toggleStickerSets",
        0xf19ed96d => "messages.getDialogFilters",
        0xa29cd42c => "messages.getSuggestedDialogFilters",
        0x1ad4a04a => "messages.updateDialogFilter",
        0xc563c1e4 => "messages.updateDialogFiltersOrder",
        0x7ed094a1 => "messages.getOldFeaturedStickers",
        0x22ddd30c => "messages.getReplies",
        0x446972fd => "messages.getDiscussionMessage",
        0xf731a9f4 => "messages.readDiscussion",
        0xf025bc8b => "messages.unpinAllMessages",
        0x5bd0ee50 => "messages.deleteChat",
        0xf9cbe409 => "messages.deletePhoneCallHistory",
        0x43fe19f3 => "messages.checkHistoryImport",
        0x34090c3b => "messages.initHistoryImport",
        0x2a862092 => "messages.uploadImportedMedia",
        0xb43df344 => "messages.startHistoryImport",
        0xa2b5a3f6 => "messages.getExportedChatInvites",
        0x73746f5c => "messages.getExportedChatInvite",
        0xbdca2f75 => "messages.editExportedChatInvite",
        0x56987bd5 => "messages.deleteRevokedExportedChatInvites",
        0xd464a42b => "messages.deleteExportedChatInvite",
        0x3920e6ef => "messages.getAdminsWithInvites",
        0xdf04dd4e => "messages.getChatInviteImporters",
        0xb80e5fe4 => "messages.setHistoryTTL",
        0x5dc60f03 => "messages.checkHistoryImportPeer",
        0xe63be13f => "messages.setChatTheme",
        0x2c6f97b7 => "messages.getMessageReadParticipants",
        0x49f0bde9 => "messages.getSearchResultsCalendar",
        0x6e9583a3 => "messages.getSearchResultsPositions",
        0x7fe7e815 => "messages.hideChatJoinRequest",
        0xe085f4ea => "messages.hideAllChatJoinRequests",
        0xb11eafa2 => "messages.toggleNoForwards",
        0xccfddf96 => "messages.saveDefaultSendAs",
        0xedd4882a => "updates.getState",
        0x25939651 => "updates.getDifference",
        0x3173d78 => "updates.getChannelDifference",
        0x72d4742c => "photos.updateProfilePhoto",
        0x89f30f69 => "photos.uploadProfilePhoto",
        0x87cf7f2f => "photos.deletePhotos",
        0x91cd32a8 => "photos.getUserPhotos",
        0xb304a621 => "upload.saveFilePart",
        0xb15a9afc => "upload.getFile",
        0xde7b673d => "upload.saveBigFilePart",
        0x24e6818d => "upload.getWebFile",
        0x2000bcc3 => "upload.getCdnFile",
        0x9b2754a8 => "upload.reuploadCdnFile",
        0x4da54231 => "upload.getCdnFileHashes",
        0xc7025931 => "upload.getFileHashes",
        0xc4f9186b => "help.getConfig",
        0x1fb33026 => "help.getNearestDc",
        0x522d5a7d => "help.getAppUpdate",
        0x4d392343 => "help.getInviteText",
        0x9cdf08cd => "help.getSupport",
        0x9010ef6f => "help.getAppChangelog",
        0xec22cfcd => "help.setBotUpdatesStatus",
        0x52029342 => "help.getCdnConfig",
        0x3dc0f114 => "help.getRecentMeUrls",
        0x2ca51fd1 => "help.getTermsOfServiceUpdate",
        0xee72f79a => "help.acceptTermsOfService",
        0x3fedc75f => "help.getDeepLinkInfo",
        0x98914110 => "help.getAppConfig",
        0x6f02f748 => "help.saveAppLog",
        0xc661ad08 => "help.getPassportConfig",
        0xd360e72c => "help.getSupportName",
        0x38a08d3 => "help.getUserInfo",
        0x66b91b70 => "help.editUserInfo",
        0xc0977421 => "help.getPromoData",
        0x1e251c95 => "help.hidePromoData",
        0xf50dbaa1 => "help.dismissSuggestion",
        0x735787a8 => "help.getCountriesList",
        0xcc104937 => "channels.readHistory",
        0x84c1fd4e => "channels.deleteMessages",
        0xf44a8315 => "channels.reportSpam",
        0xad8c9a23 => "channels.getMessages",
        0x77ced9d0 => "channels.getParticipants",
        0xa0ab6cc6 => "channels.getParticipant",
        0xa7f6bbb => "channels.getChannels",
        0x8736a09 => "channels.getFullChannel",
        0x3d5fb10f => "channels.createChannel",
        0xd33c8902 => "channels.editAdmin",
        0x566decd0 => "channels.editTitle",
        0xf12e57c9 => "channels.editPhoto",
        0x10e6bd2c => "channels.checkUsername",
        0x3514b3de => "channels.updateUsername",
        0x24b524c5 => "channels.joinChannel",
        0xf836aa95 => "channels.leaveChannel",
        0x199f3a6c => "channels.inviteToChannel",
        0xc0111fe3 => "channels.deleteChannel",
        0xe63fadeb => "channels.exportMessageLink",
        0x1f69b606 => "channels.toggleSignatures",
        0xf8b036af => "channels.getAdminedPublicChannels",
        0x96e6cd81 => "channels.editBanned",
        0x33ddf480 => "channels.getAdminLog",
        0xea8ca4f9 => "channels.setStickers",
        0xeab5dc38 => "channels.readMessageContents",
        0xaf369d42 => "channels.deleteHistory",
        0xeabbb94c => "channels.togglePreHistoryHidden",
        0x8341ecc0 => "channels.getLeftChannels",
        0xf5dad378 => "channels.getGroupsForDiscussion",
        0x40582bb2 => "channels.setDiscussionGroup",
        0x8f38cd1f => "channels.editCreator",
        0x58e63f6d => "channels.editLocation",
        0xedd49ef0 => "channels.toggleSlowMode",
        0x11e831ee => "channels.getInactiveChannels",
        0xb290c69 => "channels.convertToGigagroup",
        0xbeaedb94 => "channels.viewSponsoredMessage",
        0xec210fbf => "channels.getSponsoredMessages",
        0xdc770ee => "channels.getSendAs",
        0x367544db => "channels.deleteParticipantHistory",
        0xaa2769ed => "bots.sendCustomRequest",
        0xe6213f4d => "bots.answerWebhookJSONQuery",
        0x517165a => "bots.setBotCommands",
        0x3d8de0f9 => "bots.resetBotCommands",
        0xe34c0dd6 => "bots.getBotCommands",
        0x8a333c8d => "payments.getPaymentForm",
        0x2478d1cc => "payments.getPaymentReceipt",
        0xdb103170 => "payments.validateRequestedInfo",
        0x30c3bc9d => "payments.sendPaymentForm",
        0x227d824b => "payments.getSavedInfo",
        0xd83d70c1 => "payments.clearSavedInfo",
        0x2e79d779 => "payments.getBankCardData",
        0x9021ab67 => "stickers.createStickerSet",
        0xf7760f51 => "stickers.removeStickerFromSet",
        0xffb6d4ca => "stickers.changeStickerPosition",
        0x8653febe => "stickers.addStickerToSet",
        0x9a364e30 => "stickers.setStickerSetThumb",
        0x284b3639 => "stickers.checkShortName",
        0x4dafc503 => "stickers.suggestShortName",
        0x55451fa9 => "phone.getCallConfig",
        0x42ff96ed => "phone.requestCall",
        0x3bd2b4a0 => "phone.acceptCall",
        0x2efe1722 => "phone.confirmCall",
        0x17d54f61 => "phone.receivedCall",
        0xb2cbc1c0 => "phone.discardCall",
        0x59ead627 => "phone.setCallRating",
        0x277add7e => "phone.saveCallDebug",
        0xff7a9383 => "phone.sendSignalingData",
        0x48cdc6d8 => "phone.createGroupCall",
        0xb132ff7b => "phone.joinGroupCall",
        0x500377f9 => "phone.leaveGroupCall",
        0x7b393160 => "phone.inviteToGroupCall",
        0x7a777135 => "phone.discardGroupCall",
        0x74bbb43d => "phone.toggleGroupCallSettings",
        0x41845db => "phone.getGroupCall",
        0xc558d8ab => "phone.getGroupParticipants",
        0xb59cf977 => "phone.checkGroupCall",
        0xf128c708 => "phone.toggleGroupCallRecord",
        0xa5273abf => "phone.editGroupCallParticipant",
        0x1ca6ac0a => "phone.editGroupCallTitle",
        0xef7c213a => "phone.getGroupCallJoinAs",
        0xe6aa647f => "phone.exportGroupCallInvite",
        0x219c34e6 => "phone.toggleGroupCallStartSubscription",
        0x5680e342 => "phone.startScheduledGroupCall",
        0x575e1f8c => "phone.saveDefaultGroupCallJoinAs",
        0xcbea6bc4 => "phone.joinGroupCallPresentation",
        0x1c50d144 => "phone.leaveGroupCallPresentation",
        0xf2f2330a => "langpack.getLangPack",
        0xefea3803 => "langpack.getStrings",
        0xcd984aa5 => "langpack.getDifference",
        0x42c6978f => "langpack.getLanguages",
        0x6a596502 => "langpack.getLanguage",
        0x6847d0ab => "folders.editPeerFolders",
        0x1c295881 => "folders.deleteFolder",
        0xab42441a => "stats.getBroadcastStats",
        0x621d5fa0 => "stats.loadAsyncGraph",
        0xdcdf8607 => "stats.getMegagroupStats",
        0x5630281b => "stats.getMessagePublicForwards",
        0xb6e0a3f5 => "stats.getMessageStats",
        0x5162463 => "resPQ",
        0x83c95aec => "p_q_inner_data",
        0xa9f55f95 => "p_q_inner_data_dc",
        0x3c6a84d4 => "p_q_inner_data_temp",
        0x56fddf88 => "p_q_inner_data_temp_dc",
        0x75a3f765 => "bind_auth_key_inner",
        0x79cb045d => "server_DH_params_fail",
        0xd0e8075c => "server_DH_params_ok",
        0xb5890dba => "server_DH_inner_data",
        0x6643b654 => "client_DH_inner_data",
        0x3bcbf734 => "dh_gen_ok",
        0x46dc1fb9 => "dh_gen_retry",
        0xa69dae02 => "dh_gen_fail",
        0xf660e1d4 => "destroy_auth_key_ok",
        0xa9f2259 => "destroy_auth_key_none",
        0xea109b13 => "destroy_auth_key_fail",
        0x60469778 => "req_pq",
        0xbe7e8ef1 => "req_pq_multi",
        0xd712e4be => "req_DH_params",
        0xf5045f1f => "set_client_DH_params",
        0xd1435160 => "destroy_auth_key",
        0x62d6b459 => "msgs_ack",
        0xa7eff811 => "bad_msg_notification",
        0xedab447b => "bad_server_salt",
        0xda69fb52 => "msgs_state_req",
        0x4deb57d => "msgs_state_info",
        0x8cc0d131 => "msgs_all_info",
        0x276d3ec6 => "msg_detailed_info",
        0x809db6df => "msg_new_detailed_info",
        0x7d861a08 => "msg_resend_req",
        0x8610baeb => "msg_resend_ans_req",
        0x2144ca19 => "rpc_error",
        0x5e2ad36e => "rpc_answer_unknown",
        0xcd78e586 => "rpc_answer_dropped_running",
        0xa43ad8b7 => "rpc_answer_dropped",
        0x949d9dc => "future_salt",
        0xae500895 => "future_salts",
        0x347773c5 => "pong",
        0xe22045fc => "destroy_session_ok",
        0x62d350c9 => "destroy_session_none",
        0x9ec20908 => "new_session_created",
        0x9299359f => "http_wait",
        0xd433ad73 => "ipPort",
        0x37982646 => "ipPortSecret",
        0x4679b65f => "accessPointRule",
        0x5a592a6c => "help.configSimple",
        0x6c52c484 => "tlsClientHello",
        0xb2b51dca => "tlsBlockString",
        0x4d4dc41e => "tlsBlockRandom",
        0x9333afb => "tlsBlockZero",
        0x10e8636f => "tlsBlockDomain",
        0xe675a1c1 => "tlsBlockGrease",
        0x9eb95b5c => "tlsBlockPublicKey",
        0xe725d44f => "tlsBlockScope",
        0x58e4a740 => "rpc_drop_answer",
        0xb921bd04 => "get_future_salts",
        0x7abe77ec => "ping",
        0xf3427b8c => "ping_delay_disconnect",
        0xe7512126 => "destroy_session",

        _ => "(unknown)",
    }
}

/// This module contains all of the bare types, each
/// represented by a `struct`. All of them implement
/// [`Identifiable`], [`Serializable`] and [`Deserializable`].
///
/// [`Identifiable`]: ../trait.Identifiable.html
/// [`Serializable`]: ../trait.Serializable.html
/// [`Deserializable`]: ../trait.Deserializable.html
#[allow(
    clippy::cognitive_complexity,
    clippy::identity_op,
    clippy::unreadable_literal
)]
pub mod types {
    #[allow(unused_imports)]
    use std::convert::TryFrom;
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccessPointRule {
        pub phone_prefix_rules: Vec<u8>,
        pub dc_id: i32,
        pub ips: crate::RawVec<crate::enums::IpPort>,
    }
    impl crate::Identifiable for AccessPointRule {
        const CONSTRUCTOR_ID: u32 = 1182381663;
    }
    impl crate::Serializable for AccessPointRule {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone_prefix_rules.serialize(buf);
            self.dc_id.serialize(buf);
            self.ips.serialize(buf);
        }
    }
    impl crate::Deserializable for AccessPointRule {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone_prefix_rules = Vec::<u8>::deserialize(buf)?;
            let dc_id = i32::deserialize(buf)?;
            let ips = crate::RawVec::<crate::enums::IpPort>::deserialize(buf)?;
            Ok(AccessPointRule {
                phone_prefix_rules,
                dc_id,
                ips,
            })
        }
    }
    impl From<crate::enums::AccessPointRule> for AccessPointRule {
        fn from(x: crate::enums::AccessPointRule) -> Self {
            match x {
                crate::enums::AccessPointRule::Rule(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountDaysTtl {
        pub days: i32,
    }
    impl crate::Identifiable for AccountDaysTtl {
        const CONSTRUCTOR_ID: u32 = 3100684255;
    }
    impl crate::Serializable for AccountDaysTtl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.days.serialize(buf);
        }
    }
    impl crate::Deserializable for AccountDaysTtl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let days = i32::deserialize(buf)?;
            Ok(AccountDaysTtl { days })
        }
    }
    impl From<crate::enums::AccountDaysTtl> for AccountDaysTtl {
        fn from(x: crate::enums::AccountDaysTtl) -> Self {
            match x {
                crate::enums::AccountDaysTtl::Ttl(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Authorization {
        pub current: bool,
        pub official_app: bool,
        pub password_pending: bool,
        pub encrypted_requests_disabled: bool,
        pub call_requests_disabled: bool,
        pub hash: i64,
        pub device_model: String,
        pub platform: String,
        pub system_version: String,
        pub api_id: i32,
        pub app_name: String,
        pub app_version: String,
        pub date_created: i32,
        pub date_active: i32,
        pub ip: String,
        pub country: String,
        pub region: String,
    }
    impl crate::Identifiable for Authorization {
        const CONSTRUCTOR_ID: u32 = 2902578717;
    }
    impl crate::Serializable for Authorization {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.current { 1 } else { 0 }
                | if self.official_app { 2 } else { 0 }
                | if self.password_pending { 4 } else { 0 }
                | if self.encrypted_requests_disabled {
                    8
                } else {
                    0
                }
                | if self.call_requests_disabled { 16 } else { 0 })
            .serialize(buf);
            self.hash.serialize(buf);
            self.device_model.serialize(buf);
            self.platform.serialize(buf);
            self.system_version.serialize(buf);
            self.api_id.serialize(buf);
            self.app_name.serialize(buf);
            self.app_version.serialize(buf);
            self.date_created.serialize(buf);
            self.date_active.serialize(buf);
            self.ip.serialize(buf);
            self.country.serialize(buf);
            self.region.serialize(buf);
        }
    }
    impl crate::Deserializable for Authorization {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let current = (flags & 1) != 0;
            let official_app = (flags & 2) != 0;
            let password_pending = (flags & 4) != 0;
            let encrypted_requests_disabled = (flags & 8) != 0;
            let call_requests_disabled = (flags & 16) != 0;
            let hash = i64::deserialize(buf)?;
            let device_model = String::deserialize(buf)?;
            let platform = String::deserialize(buf)?;
            let system_version = String::deserialize(buf)?;
            let api_id = i32::deserialize(buf)?;
            let app_name = String::deserialize(buf)?;
            let app_version = String::deserialize(buf)?;
            let date_created = i32::deserialize(buf)?;
            let date_active = i32::deserialize(buf)?;
            let ip = String::deserialize(buf)?;
            let country = String::deserialize(buf)?;
            let region = String::deserialize(buf)?;
            Ok(Authorization {
                current,
                official_app,
                password_pending,
                encrypted_requests_disabled,
                call_requests_disabled,
                hash,
                device_model,
                platform,
                system_version,
                api_id,
                app_name,
                app_version,
                date_created,
                date_active,
                ip,
                country,
                region,
            })
        }
    }
    impl From<crate::enums::Authorization> for Authorization {
        fn from(x: crate::enums::Authorization) -> Self {
            match x {
                crate::enums::Authorization::Authorization(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct AutoDownloadSettings {
        pub disabled: bool,
        pub video_preload_large: bool,
        pub audio_preload_next: bool,
        pub phonecalls_less_data: bool,
        pub photo_size_max: i32,
        pub video_size_max: i32,
        pub file_size_max: i32,
        pub video_upload_maxbitrate: i32,
    }
    impl crate::Identifiable for AutoDownloadSettings {
        const CONSTRUCTOR_ID: u32 = 3762434803;
    }
    impl crate::Serializable for AutoDownloadSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.disabled { 1 } else { 0 }
                | if self.video_preload_large { 2 } else { 0 }
                | if self.audio_preload_next { 4 } else { 0 }
                | if self.phonecalls_less_data { 8 } else { 0 })
            .serialize(buf);
            self.photo_size_max.serialize(buf);
            self.video_size_max.serialize(buf);
            self.file_size_max.serialize(buf);
            self.video_upload_maxbitrate.serialize(buf);
        }
    }
    impl crate::Deserializable for AutoDownloadSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let disabled = (flags & 1) != 0;
            let video_preload_large = (flags & 2) != 0;
            let audio_preload_next = (flags & 4) != 0;
            let phonecalls_less_data = (flags & 8) != 0;
            let photo_size_max = i32::deserialize(buf)?;
            let video_size_max = i32::deserialize(buf)?;
            let file_size_max = i32::deserialize(buf)?;
            let video_upload_maxbitrate = i32::deserialize(buf)?;
            Ok(AutoDownloadSettings {
                disabled,
                video_preload_large,
                audio_preload_next,
                phonecalls_less_data,
                photo_size_max,
                video_size_max,
                file_size_max,
                video_upload_maxbitrate,
            })
        }
    }
    impl From<crate::enums::AutoDownloadSettings> for AutoDownloadSettings {
        fn from(x: crate::enums::AutoDownloadSettings) -> Self {
            match x {
                crate::enums::AutoDownloadSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BadMsgNotification {
        pub bad_msg_id: i64,
        pub bad_msg_seqno: i32,
        pub error_code: i32,
    }
    impl crate::Identifiable for BadMsgNotification {
        const CONSTRUCTOR_ID: u32 = 2817521681;
    }
    impl crate::Serializable for BadMsgNotification {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.bad_msg_id.serialize(buf);
            self.bad_msg_seqno.serialize(buf);
            self.error_code.serialize(buf);
        }
    }
    impl crate::Deserializable for BadMsgNotification {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let bad_msg_id = i64::deserialize(buf)?;
            let bad_msg_seqno = i32::deserialize(buf)?;
            let error_code = i32::deserialize(buf)?;
            Ok(BadMsgNotification {
                bad_msg_id,
                bad_msg_seqno,
                error_code,
            })
        }
    }
    impl TryFrom<crate::enums::BadMsgNotification> for BadMsgNotification {
        type Error = ();
        fn try_from(x: crate::enums::BadMsgNotification) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BadMsgNotification::Notification(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BadServerSalt {
        pub bad_msg_id: i64,
        pub bad_msg_seqno: i32,
        pub error_code: i32,
        pub new_server_salt: i64,
    }
    impl crate::Identifiable for BadServerSalt {
        const CONSTRUCTOR_ID: u32 = 3987424379;
    }
    impl crate::Serializable for BadServerSalt {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.bad_msg_id.serialize(buf);
            self.bad_msg_seqno.serialize(buf);
            self.error_code.serialize(buf);
            self.new_server_salt.serialize(buf);
        }
    }
    impl crate::Deserializable for BadServerSalt {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let bad_msg_id = i64::deserialize(buf)?;
            let bad_msg_seqno = i32::deserialize(buf)?;
            let error_code = i32::deserialize(buf)?;
            let new_server_salt = i64::deserialize(buf)?;
            Ok(BadServerSalt {
                bad_msg_id,
                bad_msg_seqno,
                error_code,
                new_server_salt,
            })
        }
    }
    impl TryFrom<crate::enums::BadMsgNotification> for BadServerSalt {
        type Error = ();
        fn try_from(x: crate::enums::BadMsgNotification) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BadMsgNotification::BadServerSalt(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BankCardOpenUrl {
        pub url: String,
        pub name: String,
    }
    impl crate::Identifiable for BankCardOpenUrl {
        const CONSTRUCTOR_ID: u32 = 4117234314;
    }
    impl crate::Serializable for BankCardOpenUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.name.serialize(buf);
        }
    }
    impl crate::Deserializable for BankCardOpenUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let name = String::deserialize(buf)?;
            Ok(BankCardOpenUrl { url, name })
        }
    }
    impl From<crate::enums::BankCardOpenUrl> for BankCardOpenUrl {
        fn from(x: crate::enums::BankCardOpenUrl) -> Self {
            match x {
                crate::enums::BankCardOpenUrl::Url(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BaseThemeArctic {}
    impl crate::Identifiable for BaseThemeArctic {
        const CONSTRUCTOR_ID: u32 = 1527845466;
    }
    impl crate::Serializable for BaseThemeArctic {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BaseThemeArctic {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BaseThemeArctic {})
        }
    }
    impl TryFrom<crate::enums::BaseTheme> for BaseThemeArctic {
        type Error = ();
        fn try_from(x: crate::enums::BaseTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BaseTheme::Arctic => Ok(BaseThemeArctic {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BaseThemeClassic {}
    impl crate::Identifiable for BaseThemeClassic {
        const CONSTRUCTOR_ID: u32 = 3282117730;
    }
    impl crate::Serializable for BaseThemeClassic {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BaseThemeClassic {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BaseThemeClassic {})
        }
    }
    impl TryFrom<crate::enums::BaseTheme> for BaseThemeClassic {
        type Error = ();
        fn try_from(x: crate::enums::BaseTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BaseTheme::Classic => Ok(BaseThemeClassic {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BaseThemeDay {}
    impl crate::Identifiable for BaseThemeDay {
        const CONSTRUCTOR_ID: u32 = 4225242760;
    }
    impl crate::Serializable for BaseThemeDay {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BaseThemeDay {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BaseThemeDay {})
        }
    }
    impl TryFrom<crate::enums::BaseTheme> for BaseThemeDay {
        type Error = ();
        fn try_from(x: crate::enums::BaseTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BaseTheme::Day => Ok(BaseThemeDay {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BaseThemeNight {}
    impl crate::Identifiable for BaseThemeNight {
        const CONSTRUCTOR_ID: u32 = 3081969320;
    }
    impl crate::Serializable for BaseThemeNight {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BaseThemeNight {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BaseThemeNight {})
        }
    }
    impl TryFrom<crate::enums::BaseTheme> for BaseThemeNight {
        type Error = ();
        fn try_from(x: crate::enums::BaseTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BaseTheme::Night => Ok(BaseThemeNight {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BaseThemeTinted {}
    impl crate::Identifiable for BaseThemeTinted {
        const CONSTRUCTOR_ID: u32 = 1834973166;
    }
    impl crate::Serializable for BaseThemeTinted {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BaseThemeTinted {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BaseThemeTinted {})
        }
    }
    impl TryFrom<crate::enums::BaseTheme> for BaseThemeTinted {
        type Error = ();
        fn try_from(x: crate::enums::BaseTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BaseTheme::Tinted => Ok(BaseThemeTinted {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BindAuthKeyInner {
        pub nonce: i64,
        pub temp_auth_key_id: i64,
        pub perm_auth_key_id: i64,
        pub temp_session_id: i64,
        pub expires_at: i32,
    }
    impl crate::Identifiable for BindAuthKeyInner {
        const CONSTRUCTOR_ID: u32 = 1973679973;
    }
    impl crate::Serializable for BindAuthKeyInner {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.temp_auth_key_id.serialize(buf);
            self.perm_auth_key_id.serialize(buf);
            self.temp_session_id.serialize(buf);
            self.expires_at.serialize(buf);
        }
    }
    impl crate::Deserializable for BindAuthKeyInner {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = i64::deserialize(buf)?;
            let temp_auth_key_id = i64::deserialize(buf)?;
            let perm_auth_key_id = i64::deserialize(buf)?;
            let temp_session_id = i64::deserialize(buf)?;
            let expires_at = i32::deserialize(buf)?;
            Ok(BindAuthKeyInner {
                nonce,
                temp_auth_key_id,
                perm_auth_key_id,
                temp_session_id,
                expires_at,
            })
        }
    }
    impl From<crate::enums::BindAuthKeyInner> for BindAuthKeyInner {
        fn from(x: crate::enums::BindAuthKeyInner) -> Self {
            match x {
                crate::enums::BindAuthKeyInner::Inner(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommand {
        pub command: String,
        pub description: String,
    }
    impl crate::Identifiable for BotCommand {
        const CONSTRUCTOR_ID: u32 = 3262826695;
    }
    impl crate::Serializable for BotCommand {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.command.serialize(buf);
            self.description.serialize(buf);
        }
    }
    impl crate::Deserializable for BotCommand {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let command = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            Ok(BotCommand {
                command,
                description,
            })
        }
    }
    impl From<crate::enums::BotCommand> for BotCommand {
        fn from(x: crate::enums::BotCommand) -> Self {
            match x {
                crate::enums::BotCommand::Command(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopeChatAdmins {}
    impl crate::Identifiable for BotCommandScopeChatAdmins {
        const CONSTRUCTOR_ID: u32 = 3114950762;
    }
    impl crate::Serializable for BotCommandScopeChatAdmins {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BotCommandScopeChatAdmins {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BotCommandScopeChatAdmins {})
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopeChatAdmins {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::ChatAdmins => Ok(BotCommandScopeChatAdmins {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopeChats {}
    impl crate::Identifiable for BotCommandScopeChats {
        const CONSTRUCTOR_ID: u32 = 1877059713;
    }
    impl crate::Serializable for BotCommandScopeChats {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BotCommandScopeChats {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BotCommandScopeChats {})
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopeChats {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::Chats => Ok(BotCommandScopeChats {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopeDefault {}
    impl crate::Identifiable for BotCommandScopeDefault {
        const CONSTRUCTOR_ID: u32 = 795652779;
    }
    impl crate::Serializable for BotCommandScopeDefault {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BotCommandScopeDefault {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BotCommandScopeDefault {})
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopeDefault {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::Default => Ok(BotCommandScopeDefault {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopePeer {
        pub peer: crate::enums::InputPeer,
    }
    impl crate::Identifiable for BotCommandScopePeer {
        const CONSTRUCTOR_ID: u32 = 3684534653;
    }
    impl crate::Serializable for BotCommandScopePeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for BotCommandScopePeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            Ok(BotCommandScopePeer { peer })
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopePeer {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::Peer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopePeerAdmins {
        pub peer: crate::enums::InputPeer,
    }
    impl crate::Identifiable for BotCommandScopePeerAdmins {
        const CONSTRUCTOR_ID: u32 = 1071145937;
    }
    impl crate::Serializable for BotCommandScopePeerAdmins {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for BotCommandScopePeerAdmins {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            Ok(BotCommandScopePeerAdmins { peer })
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopePeerAdmins {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::PeerAdmins(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopePeerUser {
        pub peer: crate::enums::InputPeer,
        pub user_id: crate::enums::InputUser,
    }
    impl crate::Identifiable for BotCommandScopePeerUser {
        const CONSTRUCTOR_ID: u32 = 169026035;
    }
    impl crate::Serializable for BotCommandScopePeerUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for BotCommandScopePeerUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let user_id = crate::enums::InputUser::deserialize(buf)?;
            Ok(BotCommandScopePeerUser { peer, user_id })
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopePeerUser {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::PeerUser(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotCommandScopeUsers {}
    impl crate::Identifiable for BotCommandScopeUsers {
        const CONSTRUCTOR_ID: u32 = 1011811544;
    }
    impl crate::Serializable for BotCommandScopeUsers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for BotCommandScopeUsers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(BotCommandScopeUsers {})
        }
    }
    impl TryFrom<crate::enums::BotCommandScope> for BotCommandScopeUsers {
        type Error = ();
        fn try_from(x: crate::enums::BotCommandScope) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotCommandScope::Users => Ok(BotCommandScopeUsers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInfo {
        pub user_id: i64,
        pub description: String,
        pub commands: Vec<crate::enums::BotCommand>,
    }
    impl crate::Identifiable for BotInfo {
        const CONSTRUCTOR_ID: u32 = 460632885;
    }
    impl crate::Serializable for BotInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.description.serialize(buf);
            self.commands.serialize(buf);
        }
    }
    impl crate::Deserializable for BotInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let commands = Vec::<crate::enums::BotCommand>::deserialize(buf)?;
            Ok(BotInfo {
                user_id,
                description,
                commands,
            })
        }
    }
    impl From<crate::enums::BotInfo> for BotInfo {
        fn from(x: crate::enums::BotInfo) -> Self {
            match x {
                crate::enums::BotInfo::Info(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMediaResult {
        pub id: String,
        pub r#type: String,
        pub photo: Option<crate::enums::Photo>,
        pub document: Option<crate::enums::Document>,
        pub title: Option<String>,
        pub description: Option<String>,
        pub send_message: crate::enums::BotInlineMessage,
    }
    impl crate::Identifiable for BotInlineMediaResult {
        const CONSTRUCTOR_ID: u32 = 400266251;
    }
    impl crate::Serializable for BotInlineMediaResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.document.is_some() { 2 } else { 0 }
                | if self.title.is_some() { 4 } else { 0 }
                | if self.description.is_some() { 8 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.document {
                x.serialize(buf);
            }
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for BotInlineMediaResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = String::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::Photo::deserialize(buf)?)
            } else {
                None
            };
            let document = if (flags & 2) != 0 {
                Some(crate::enums::Document::deserialize(buf)?)
            } else {
                None
            };
            let title = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let send_message = crate::enums::BotInlineMessage::deserialize(buf)?;
            Ok(BotInlineMediaResult {
                id,
                r#type,
                photo,
                document,
                title,
                description,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineResult> for BotInlineMediaResult {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineResult::BotInlineMediaResult(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageMediaAuto {
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageMediaAuto {
        const CONSTRUCTOR_ID: u32 = 1984755728;
    }
    impl crate::Serializable for BotInlineMessageMediaAuto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.entities.is_some() { 2 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageMediaAuto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageMediaAuto {
                message,
                entities,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageMediaAuto {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::MediaAuto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageMediaContact {
        pub phone_number: String,
        pub first_name: String,
        pub last_name: String,
        pub vcard: String,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageMediaContact {
        const CONSTRUCTOR_ID: u32 = 416402882;
    }
    impl crate::Serializable for BotInlineMessageMediaContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.reply_markup.is_some() { 4 } else { 0 }).serialize(buf);
            self.phone_number.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.vcard.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageMediaContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let phone_number = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let vcard = String::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageMediaContact {
                phone_number,
                first_name,
                last_name,
                vcard,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageMediaContact {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::MediaContact(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageMediaGeo {
        pub geo: crate::enums::GeoPoint,
        pub heading: Option<i32>,
        pub period: Option<i32>,
        pub proximity_notification_radius: Option<i32>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageMediaGeo {
        const CONSTRUCTOR_ID: u32 = 85477117;
    }
    impl crate::Serializable for BotInlineMessageMediaGeo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.heading.is_some() { 1 } else { 0 }
                | if self.period.is_some() { 2 } else { 0 }
                | if self.proximity_notification_radius.is_some() {
                    8
                } else {
                    0
                }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.geo.serialize(buf);
            if let Some(ref x) = self.heading {
                x.serialize(buf);
            }
            if let Some(ref x) = self.period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.proximity_notification_radius {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageMediaGeo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            let heading = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let period = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let proximity_notification_radius = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageMediaGeo {
                geo,
                heading,
                period,
                proximity_notification_radius,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageMediaGeo {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::MediaGeo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageMediaInvoice {
        pub shipping_address_requested: bool,
        pub test: bool,
        pub title: String,
        pub description: String,
        pub photo: Option<crate::enums::WebDocument>,
        pub currency: String,
        pub total_amount: i64,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageMediaInvoice {
        const CONSTRUCTOR_ID: u32 = 894081801;
    }
    impl crate::Serializable for BotInlineMessageMediaInvoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.shipping_address_requested {
                    2
                } else {
                    0
                }
                | if self.test { 8 } else { 0 }
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.title.serialize(buf);
            self.description.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            self.currency.serialize(buf);
            self.total_amount.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageMediaInvoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let shipping_address_requested = (flags & 2) != 0;
            let test = (flags & 8) != 0;
            let title = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::WebDocument::deserialize(buf)?)
            } else {
                None
            };
            let currency = String::deserialize(buf)?;
            let total_amount = i64::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageMediaInvoice {
                shipping_address_requested,
                test,
                title,
                description,
                photo,
                currency,
                total_amount,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageMediaInvoice {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::MediaInvoice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageMediaVenue {
        pub geo: crate::enums::GeoPoint,
        pub title: String,
        pub address: String,
        pub provider: String,
        pub venue_id: String,
        pub venue_type: String,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageMediaVenue {
        const CONSTRUCTOR_ID: u32 = 2324063644;
    }
    impl crate::Serializable for BotInlineMessageMediaVenue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.reply_markup.is_some() { 4 } else { 0 }).serialize(buf);
            self.geo.serialize(buf);
            self.title.serialize(buf);
            self.address.serialize(buf);
            self.provider.serialize(buf);
            self.venue_id.serialize(buf);
            self.venue_type.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageMediaVenue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let address = String::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let venue_id = String::deserialize(buf)?;
            let venue_type = String::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageMediaVenue {
                geo,
                title,
                address,
                provider,
                venue_id,
                venue_type,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageMediaVenue {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::MediaVenue(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineMessageText {
        pub no_webpage: bool,
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for BotInlineMessageText {
        const CONSTRUCTOR_ID: u32 = 2357159394;
    }
    impl crate::Serializable for BotInlineMessageText {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.no_webpage { 1 } else { 0 }
                | if self.entities.is_some() { 2 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for BotInlineMessageText {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let no_webpage = (flags & 1) != 0;
            let message = String::deserialize(buf)?;
            let entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(BotInlineMessageText {
                no_webpage,
                message,
                entities,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineMessage> for BotInlineMessageText {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineMessage::Text(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct BotInlineResult {
        pub id: String,
        pub r#type: String,
        pub title: Option<String>,
        pub description: Option<String>,
        pub url: Option<String>,
        pub thumb: Option<crate::enums::WebDocument>,
        pub content: Option<crate::enums::WebDocument>,
        pub send_message: crate::enums::BotInlineMessage,
    }
    impl crate::Identifiable for BotInlineResult {
        const CONSTRUCTOR_ID: u32 = 295067450;
    }
    impl crate::Serializable for BotInlineResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.title.is_some() { 2 } else { 0 }
                | if self.description.is_some() { 4 } else { 0 }
                | if self.url.is_some() { 8 } else { 0 }
                | if self.thumb.is_some() { 16 } else { 0 }
                | if self.content.is_some() { 32 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            if let Some(ref x) = self.url {
                x.serialize(buf);
            }
            if let Some(ref x) = self.thumb {
                x.serialize(buf);
            }
            if let Some(ref x) = self.content {
                x.serialize(buf);
            }
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for BotInlineResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = String::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let title = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let url = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let thumb = if (flags & 16) != 0 {
                Some(crate::enums::WebDocument::deserialize(buf)?)
            } else {
                None
            };
            let content = if (flags & 32) != 0 {
                Some(crate::enums::WebDocument::deserialize(buf)?)
            } else {
                None
            };
            let send_message = crate::enums::BotInlineMessage::deserialize(buf)?;
            Ok(BotInlineResult {
                id,
                r#type,
                title,
                description,
                url,
                thumb,
                content,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::BotInlineResult> for BotInlineResult {
        type Error = ();
        fn try_from(x: crate::enums::BotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::BotInlineResult::Result(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct CdnConfig {
        pub public_keys: Vec<crate::enums::CdnPublicKey>,
    }
    impl crate::Identifiable for CdnConfig {
        const CONSTRUCTOR_ID: u32 = 1462101002;
    }
    impl crate::Serializable for CdnConfig {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.public_keys.serialize(buf);
        }
    }
    impl crate::Deserializable for CdnConfig {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let public_keys = Vec::<crate::enums::CdnPublicKey>::deserialize(buf)?;
            Ok(CdnConfig { public_keys })
        }
    }
    impl From<crate::enums::CdnConfig> for CdnConfig {
        fn from(x: crate::enums::CdnConfig) -> Self {
            match x {
                crate::enums::CdnConfig::Config(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct CdnPublicKey {
        pub dc_id: i32,
        pub public_key: String,
    }
    impl crate::Identifiable for CdnPublicKey {
        const CONSTRUCTOR_ID: u32 = 3380800186;
    }
    impl crate::Serializable for CdnPublicKey {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.dc_id.serialize(buf);
            self.public_key.serialize(buf);
        }
    }
    impl crate::Deserializable for CdnPublicKey {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let dc_id = i32::deserialize(buf)?;
            let public_key = String::deserialize(buf)?;
            Ok(CdnPublicKey { dc_id, public_key })
        }
    }
    impl From<crate::enums::CdnPublicKey> for CdnPublicKey {
        fn from(x: crate::enums::CdnPublicKey) -> Self {
            match x {
                crate::enums::CdnPublicKey::Key(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Channel {
        pub creator: bool,
        pub left: bool,
        pub broadcast: bool,
        pub verified: bool,
        pub megagroup: bool,
        pub restricted: bool,
        pub signatures: bool,
        pub min: bool,
        pub scam: bool,
        pub has_link: bool,
        pub has_geo: bool,
        pub slowmode_enabled: bool,
        pub call_active: bool,
        pub call_not_empty: bool,
        pub fake: bool,
        pub gigagroup: bool,
        pub noforwards: bool,
        pub id: i64,
        pub access_hash: Option<i64>,
        pub title: String,
        pub username: Option<String>,
        pub photo: crate::enums::ChatPhoto,
        pub date: i32,
        pub restriction_reason: Option<Vec<crate::enums::RestrictionReason>>,
        pub admin_rights: Option<crate::enums::ChatAdminRights>,
        pub banned_rights: Option<crate::enums::ChatBannedRights>,
        pub default_banned_rights: Option<crate::enums::ChatBannedRights>,
        pub participants_count: Option<i32>,
    }
    impl crate::Identifiable for Channel {
        const CONSTRUCTOR_ID: u32 = 2187439201;
    }
    impl crate::Serializable for Channel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.creator { 1 } else { 0 }
                | if self.left { 4 } else { 0 }
                | if self.broadcast { 32 } else { 0 }
                | if self.verified { 128 } else { 0 }
                | if self.megagroup { 256 } else { 0 }
                | if self.restricted { 512 } else { 0 }
                | if self.signatures { 2048 } else { 0 }
                | if self.min { 4096 } else { 0 }
                | if self.scam { 524288 } else { 0 }
                | if self.has_link { 1048576 } else { 0 }
                | if self.has_geo { 2097152 } else { 0 }
                | if self.slowmode_enabled { 4194304 } else { 0 }
                | if self.call_active { 8388608 } else { 0 }
                | if self.call_not_empty { 16777216 } else { 0 }
                | if self.fake { 33554432 } else { 0 }
                | if self.gigagroup { 67108864 } else { 0 }
                | if self.noforwards { 134217728 } else { 0 }
                | if self.access_hash.is_some() { 8192 } else { 0 }
                | if self.username.is_some() { 64 } else { 0 }
                | if self.restriction_reason.is_some() {
                    512
                } else {
                    0
                }
                | if self.admin_rights.is_some() {
                    16384
                } else {
                    0
                }
                | if self.banned_rights.is_some() {
                    32768
                } else {
                    0
                }
                | if self.default_banned_rights.is_some() {
                    262144
                } else {
                    0
                }
                | if self.participants_count.is_some() {
                    131072
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.access_hash {
                x.serialize(buf);
            }
            self.title.serialize(buf);
            if let Some(ref x) = self.username {
                x.serialize(buf);
            }
            self.photo.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.restriction_reason {
                x.serialize(buf);
            }
            if let Some(ref x) = self.admin_rights {
                x.serialize(buf);
            }
            if let Some(ref x) = self.banned_rights {
                x.serialize(buf);
            }
            if let Some(ref x) = self.default_banned_rights {
                x.serialize(buf);
            }
            if let Some(ref x) = self.participants_count {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Channel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let creator = (flags & 1) != 0;
            let left = (flags & 4) != 0;
            let broadcast = (flags & 32) != 0;
            let verified = (flags & 128) != 0;
            let megagroup = (flags & 256) != 0;
            let restricted = (flags & 512) != 0;
            let signatures = (flags & 2048) != 0;
            let min = (flags & 4096) != 0;
            let scam = (flags & 524288) != 0;
            let has_link = (flags & 1048576) != 0;
            let has_geo = (flags & 2097152) != 0;
            let slowmode_enabled = (flags & 4194304) != 0;
            let call_active = (flags & 8388608) != 0;
            let call_not_empty = (flags & 16777216) != 0;
            let fake = (flags & 33554432) != 0;
            let gigagroup = (flags & 67108864) != 0;
            let noforwards = (flags & 134217728) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = if (flags & 8192) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let title = String::deserialize(buf)?;
            let username = if (flags & 64) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let photo = crate::enums::ChatPhoto::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let restriction_reason = if (flags & 512) != 0 {
                Some(Vec::<crate::enums::RestrictionReason>::deserialize(buf)?)
            } else {
                None
            };
            let admin_rights = if (flags & 16384) != 0 {
                Some(crate::enums::ChatAdminRights::deserialize(buf)?)
            } else {
                None
            };
            let banned_rights = if (flags & 32768) != 0 {
                Some(crate::enums::ChatBannedRights::deserialize(buf)?)
            } else {
                None
            };
            let default_banned_rights = if (flags & 262144) != 0 {
                Some(crate::enums::ChatBannedRights::deserialize(buf)?)
            } else {
                None
            };
            let participants_count = if (flags & 131072) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Channel {
                creator,
                left,
                broadcast,
                verified,
                megagroup,
                restricted,
                signatures,
                min,
                scam,
                has_link,
                has_geo,
                slowmode_enabled,
                call_active,
                call_not_empty,
                fake,
                gigagroup,
                noforwards,
                id,
                access_hash,
                title,
                username,
                photo,
                date,
                restriction_reason,
                admin_rights,
                banned_rights,
                default_banned_rights,
                participants_count,
            })
        }
    }
    impl TryFrom<crate::enums::Chat> for Channel {
        type Error = ();
        fn try_from(x: crate::enums::Chat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Chat::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEvent {
        pub id: i64,
        pub date: i32,
        pub user_id: i64,
        pub action: crate::enums::ChannelAdminLogEventAction,
    }
    impl crate::Identifiable for ChannelAdminLogEvent {
        const CONSTRUCTOR_ID: u32 = 531458253;
    }
    impl crate::Serializable for ChannelAdminLogEvent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.date.serialize(buf);
            self.user_id.serialize(buf);
            self.action.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEvent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let action = crate::enums::ChannelAdminLogEventAction::deserialize(buf)?;
            Ok(ChannelAdminLogEvent {
                id,
                date,
                user_id,
                action,
            })
        }
    }
    impl From<crate::enums::ChannelAdminLogEvent> for ChannelAdminLogEvent {
        fn from(x: crate::enums::ChannelAdminLogEvent) -> Self {
            match x {
                crate::enums::ChannelAdminLogEvent::Event(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeAbout {
        pub prev_value: String,
        pub new_value: String,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeAbout {
        const CONSTRUCTOR_ID: u32 = 1427671598;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeAbout {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeAbout {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = String::deserialize(buf)?;
            let new_value = String::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeAbout {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionChangeAbout {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeAbout(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeHistoryTtl {
        pub prev_value: i32,
        pub new_value: i32,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeHistoryTtl {
        const CONSTRUCTOR_ID: u32 = 1855199800;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeHistoryTtl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeHistoryTtl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = i32::deserialize(buf)?;
            let new_value = i32::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeHistoryTtl {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionChangeHistoryTtl
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeHistoryTtl(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeLinkedChat {
        pub prev_value: i64,
        pub new_value: i64,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeLinkedChat {
        const CONSTRUCTOR_ID: u32 = 84703944;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeLinkedChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeLinkedChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = i64::deserialize(buf)?;
            let new_value = i64::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeLinkedChat {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionChangeLinkedChat
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeLinkedChat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeLocation {
        pub prev_value: crate::enums::ChannelLocation,
        pub new_value: crate::enums::ChannelLocation,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeLocation {
        const CONSTRUCTOR_ID: u32 = 241923758;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = crate::enums::ChannelLocation::deserialize(buf)?;
            let new_value = crate::enums::ChannelLocation::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeLocation {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionChangeLocation
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangePhoto {
        pub prev_photo: crate::enums::Photo,
        pub new_photo: crate::enums::Photo,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangePhoto {
        const CONSTRUCTOR_ID: u32 = 1129042607;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangePhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_photo.serialize(buf);
            self.new_photo.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangePhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_photo = crate::enums::Photo::deserialize(buf)?;
            let new_photo = crate::enums::Photo::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangePhoto {
                prev_photo,
                new_photo,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionChangePhoto {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangePhoto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeStickerSet {
        pub prev_stickerset: crate::enums::InputStickerSet,
        pub new_stickerset: crate::enums::InputStickerSet,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeStickerSet {
        const CONSTRUCTOR_ID: u32 = 2982398631;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeStickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_stickerset.serialize(buf);
            self.new_stickerset.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeStickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_stickerset = crate::enums::InputStickerSet::deserialize(buf)?;
            let new_stickerset = crate::enums::InputStickerSet::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeStickerSet {
                prev_stickerset,
                new_stickerset,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionChangeStickerSet
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeStickerSet(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeTitle {
        pub prev_value: String,
        pub new_value: String,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeTitle {
        const CONSTRUCTOR_ID: u32 = 3873421349;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeTitle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeTitle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = String::deserialize(buf)?;
            let new_value = String::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeTitle {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionChangeTitle {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeTitle(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionChangeUsername {
        pub prev_value: String,
        pub new_value: String,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionChangeUsername {
        const CONSTRUCTOR_ID: u32 = 1783299128;
    }
    impl crate::Serializable for ChannelAdminLogEventActionChangeUsername {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionChangeUsername {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = String::deserialize(buf)?;
            let new_value = String::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionChangeUsername {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionChangeUsername
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ChangeUsername(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionDefaultBannedRights {
        pub prev_banned_rights: crate::enums::ChatBannedRights,
        pub new_banned_rights: crate::enums::ChatBannedRights,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionDefaultBannedRights {
        const CONSTRUCTOR_ID: u32 = 771095562;
    }
    impl crate::Serializable for ChannelAdminLogEventActionDefaultBannedRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_banned_rights.serialize(buf);
            self.new_banned_rights.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionDefaultBannedRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_banned_rights = crate::enums::ChatBannedRights::deserialize(buf)?;
            let new_banned_rights = crate::enums::ChatBannedRights::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionDefaultBannedRights {
                prev_banned_rights,
                new_banned_rights,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionDefaultBannedRights
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::DefaultBannedRights(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionDeleteMessage {
        pub message: crate::enums::Message,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionDeleteMessage {
        const CONSTRUCTOR_ID: u32 = 1121994683;
    }
    impl crate::Serializable for ChannelAdminLogEventActionDeleteMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionDeleteMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionDeleteMessage { message })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionDeleteMessage {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::DeleteMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionDiscardGroupCall {
        pub call: crate::enums::InputGroupCall,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionDiscardGroupCall {
        const CONSTRUCTOR_ID: u32 = 3684667712;
    }
    impl crate::Serializable for ChannelAdminLogEventActionDiscardGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.call.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionDiscardGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionDiscardGroupCall { call })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionDiscardGroupCall
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::DiscardGroupCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionEditMessage {
        pub prev_message: crate::enums::Message,
        pub new_message: crate::enums::Message,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionEditMessage {
        const CONSTRUCTOR_ID: u32 = 1889215493;
    }
    impl crate::Serializable for ChannelAdminLogEventActionEditMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_message.serialize(buf);
            self.new_message.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionEditMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_message = crate::enums::Message::deserialize(buf)?;
            let new_message = crate::enums::Message::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionEditMessage {
                prev_message,
                new_message,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionEditMessage {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::EditMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionExportedInviteDelete {
        pub invite: crate::enums::ExportedChatInvite,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionExportedInviteDelete {
        const CONSTRUCTOR_ID: u32 = 1515256996;
    }
    impl crate::Serializable for ChannelAdminLogEventActionExportedInviteDelete {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.invite.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionExportedInviteDelete {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionExportedInviteDelete { invite })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionExportedInviteDelete
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ExportedInviteDelete(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionExportedInviteEdit {
        pub prev_invite: crate::enums::ExportedChatInvite,
        pub new_invite: crate::enums::ExportedChatInvite,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionExportedInviteEdit {
        const CONSTRUCTOR_ID: u32 = 3910056793;
    }
    impl crate::Serializable for ChannelAdminLogEventActionExportedInviteEdit {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_invite.serialize(buf);
            self.new_invite.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionExportedInviteEdit {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            let new_invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionExportedInviteEdit {
                prev_invite,
                new_invite,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionExportedInviteEdit
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ExportedInviteEdit(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionExportedInviteRevoke {
        pub invite: crate::enums::ExportedChatInvite,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionExportedInviteRevoke {
        const CONSTRUCTOR_ID: u32 = 1091179342;
    }
    impl crate::Serializable for ChannelAdminLogEventActionExportedInviteRevoke {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.invite.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionExportedInviteRevoke {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionExportedInviteRevoke { invite })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionExportedInviteRevoke
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ExportedInviteRevoke(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantInvite {
        pub participant: crate::enums::ChannelParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantInvite {
        const CONSTRUCTOR_ID: u32 = 3810276568;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let participant = crate::enums::ChannelParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantInvite { participant })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantInvite
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantInvite(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantJoin {}
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantJoin {
        const CONSTRUCTOR_ID: u32 = 405815507;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantJoin {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantJoin {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelAdminLogEventActionParticipantJoin {})
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantJoin
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantJoin => {
                    Ok(ChannelAdminLogEventActionParticipantJoin {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantJoinByInvite {
        pub invite: crate::enums::ExportedChatInvite,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantJoinByInvite {
        const CONSTRUCTOR_ID: u32 = 1557846647;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantJoinByInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.invite.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantJoinByInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantJoinByInvite { invite })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantJoinByInvite
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantJoinByInvite(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantJoinByRequest {
        pub invite: crate::enums::ExportedChatInvite,
        pub approved_by: i64,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantJoinByRequest {
        const CONSTRUCTOR_ID: u32 = 2947945546;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantJoinByRequest {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.invite.serialize(buf);
            self.approved_by.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantJoinByRequest {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            let approved_by = i64::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantJoinByRequest {
                invite,
                approved_by,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantJoinByRequest
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantJoinByRequest(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantLeave {}
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantLeave {
        const CONSTRUCTOR_ID: u32 = 4170676210;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantLeave {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantLeave {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelAdminLogEventActionParticipantLeave {})
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantLeave
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantLeave => {
                    Ok(ChannelAdminLogEventActionParticipantLeave {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantMute {
        pub participant: crate::enums::GroupCallParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantMute {
        const CONSTRUCTOR_ID: u32 = 4179895506;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantMute {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantMute {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let participant = crate::enums::GroupCallParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantMute { participant })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantMute
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantMute(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantToggleAdmin {
        pub prev_participant: crate::enums::ChannelParticipant,
        pub new_participant: crate::enums::ChannelParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantToggleAdmin {
        const CONSTRUCTOR_ID: u32 = 3580323600;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantToggleAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_participant.serialize(buf);
            self.new_participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantToggleAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_participant = crate::enums::ChannelParticipant::deserialize(buf)?;
            let new_participant = crate::enums::ChannelParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantToggleAdmin {
                prev_participant,
                new_participant,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantToggleAdmin
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantToggleAdmin(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantToggleBan {
        pub prev_participant: crate::enums::ChannelParticipant,
        pub new_participant: crate::enums::ChannelParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantToggleBan {
        const CONSTRUCTOR_ID: u32 = 3872931198;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantToggleBan {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_participant.serialize(buf);
            self.new_participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantToggleBan {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_participant = crate::enums::ChannelParticipant::deserialize(buf)?;
            let new_participant = crate::enums::ChannelParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantToggleBan {
                prev_participant,
                new_participant,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantToggleBan
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantToggleBan(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantUnmute {
        pub participant: crate::enums::GroupCallParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantUnmute {
        const CONSTRUCTOR_ID: u32 = 3863226816;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantUnmute {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantUnmute {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let participant = crate::enums::GroupCallParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantUnmute { participant })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantUnmute
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantUnmute(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionParticipantVolume {
        pub participant: crate::enums::GroupCallParticipant,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionParticipantVolume {
        const CONSTRUCTOR_ID: u32 = 1048537159;
    }
    impl crate::Serializable for ChannelAdminLogEventActionParticipantVolume {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.participant.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionParticipantVolume {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let participant = crate::enums::GroupCallParticipant::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionParticipantVolume { participant })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionParticipantVolume
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ParticipantVolume(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionSendMessage {
        pub message: crate::enums::Message,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionSendMessage {
        const CONSTRUCTOR_ID: u32 = 663693416;
    }
    impl crate::Serializable for ChannelAdminLogEventActionSendMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionSendMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionSendMessage { message })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionSendMessage {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::SendMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionStartGroupCall {
        pub call: crate::enums::InputGroupCall,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionStartGroupCall {
        const CONSTRUCTOR_ID: u32 = 589338437;
    }
    impl crate::Serializable for ChannelAdminLogEventActionStartGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.call.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionStartGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionStartGroupCall { call })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionStartGroupCall
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::StartGroupCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionStopPoll {
        pub message: crate::enums::Message,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionStopPoll {
        const CONSTRUCTOR_ID: u32 = 2399639107;
    }
    impl crate::Serializable for ChannelAdminLogEventActionStopPoll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionStopPoll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionStopPoll { message })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionStopPoll {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::StopPoll(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionToggleGroupCallSetting {
        pub join_muted: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionToggleGroupCallSetting {
        const CONSTRUCTOR_ID: u32 = 1456906823;
    }
    impl crate::Serializable for ChannelAdminLogEventActionToggleGroupCallSetting {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.join_muted.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionToggleGroupCallSetting {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let join_muted = bool::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionToggleGroupCallSetting { join_muted })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionToggleGroupCallSetting
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ToggleGroupCallSetting(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionToggleInvites {
        pub new_value: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionToggleInvites {
        const CONSTRUCTOR_ID: u32 = 460916654;
    }
    impl crate::Serializable for ChannelAdminLogEventActionToggleInvites {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionToggleInvites {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let new_value = bool::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionToggleInvites { new_value })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionToggleInvites {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ToggleInvites(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionToggleNoForwards {
        pub new_value: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionToggleNoForwards {
        const CONSTRUCTOR_ID: u32 = 3408578406;
    }
    impl crate::Serializable for ChannelAdminLogEventActionToggleNoForwards {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionToggleNoForwards {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let new_value = bool::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionToggleNoForwards { new_value })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionToggleNoForwards
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ToggleNoForwards(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionTogglePreHistoryHidden {
        pub new_value: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionTogglePreHistoryHidden {
        const CONSTRUCTOR_ID: u32 = 1599903217;
    }
    impl crate::Serializable for ChannelAdminLogEventActionTogglePreHistoryHidden {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionTogglePreHistoryHidden {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let new_value = bool::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionTogglePreHistoryHidden { new_value })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionTogglePreHistoryHidden
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::TogglePreHistoryHidden(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionToggleSignatures {
        pub new_value: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionToggleSignatures {
        const CONSTRUCTOR_ID: u32 = 648939889;
    }
    impl crate::Serializable for ChannelAdminLogEventActionToggleSignatures {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionToggleSignatures {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let new_value = bool::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionToggleSignatures { new_value })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionToggleSignatures
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ToggleSignatures(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionToggleSlowMode {
        pub prev_value: i32,
        pub new_value: i32,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionToggleSlowMode {
        const CONSTRUCTOR_ID: u32 = 1401984889;
    }
    impl crate::Serializable for ChannelAdminLogEventActionToggleSlowMode {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.prev_value.serialize(buf);
            self.new_value.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionToggleSlowMode {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let prev_value = i32::deserialize(buf)?;
            let new_value = i32::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionToggleSlowMode {
                prev_value,
                new_value,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction>
        for ChannelAdminLogEventActionToggleSlowMode
    {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::ToggleSlowMode(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventActionUpdatePinned {
        pub message: crate::enums::Message,
    }
    impl crate::Identifiable for ChannelAdminLogEventActionUpdatePinned {
        const CONSTRUCTOR_ID: u32 = 3924306968;
    }
    impl crate::Serializable for ChannelAdminLogEventActionUpdatePinned {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventActionUpdatePinned {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            Ok(ChannelAdminLogEventActionUpdatePinned { message })
        }
    }
    impl TryFrom<crate::enums::ChannelAdminLogEventAction> for ChannelAdminLogEventActionUpdatePinned {
        type Error = ();
        fn try_from(x: crate::enums::ChannelAdminLogEventAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelAdminLogEventAction::UpdatePinned(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelAdminLogEventsFilter {
        pub join: bool,
        pub leave: bool,
        pub invite: bool,
        pub ban: bool,
        pub unban: bool,
        pub kick: bool,
        pub unkick: bool,
        pub promote: bool,
        pub demote: bool,
        pub info: bool,
        pub settings: bool,
        pub pinned: bool,
        pub edit: bool,
        pub delete: bool,
        pub group_call: bool,
        pub invites: bool,
        pub send: bool,
    }
    impl crate::Identifiable for ChannelAdminLogEventsFilter {
        const CONSTRUCTOR_ID: u32 = 3926948580;
    }
    impl crate::Serializable for ChannelAdminLogEventsFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.join { 1 } else { 0 }
                | if self.leave { 2 } else { 0 }
                | if self.invite { 4 } else { 0 }
                | if self.ban { 8 } else { 0 }
                | if self.unban { 16 } else { 0 }
                | if self.kick { 32 } else { 0 }
                | if self.unkick { 64 } else { 0 }
                | if self.promote { 128 } else { 0 }
                | if self.demote { 256 } else { 0 }
                | if self.info { 512 } else { 0 }
                | if self.settings { 1024 } else { 0 }
                | if self.pinned { 2048 } else { 0 }
                | if self.edit { 4096 } else { 0 }
                | if self.delete { 8192 } else { 0 }
                | if self.group_call { 16384 } else { 0 }
                | if self.invites { 32768 } else { 0 }
                | if self.send { 65536 } else { 0 })
            .serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventsFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let join = (flags & 1) != 0;
            let leave = (flags & 2) != 0;
            let invite = (flags & 4) != 0;
            let ban = (flags & 8) != 0;
            let unban = (flags & 16) != 0;
            let kick = (flags & 32) != 0;
            let unkick = (flags & 64) != 0;
            let promote = (flags & 128) != 0;
            let demote = (flags & 256) != 0;
            let info = (flags & 512) != 0;
            let settings = (flags & 1024) != 0;
            let pinned = (flags & 2048) != 0;
            let edit = (flags & 4096) != 0;
            let delete = (flags & 8192) != 0;
            let group_call = (flags & 16384) != 0;
            let invites = (flags & 32768) != 0;
            let send = (flags & 65536) != 0;
            Ok(ChannelAdminLogEventsFilter {
                join,
                leave,
                invite,
                ban,
                unban,
                kick,
                unkick,
                promote,
                demote,
                info,
                settings,
                pinned,
                edit,
                delete,
                group_call,
                invites,
                send,
            })
        }
    }
    impl From<crate::enums::ChannelAdminLogEventsFilter> for ChannelAdminLogEventsFilter {
        fn from(x: crate::enums::ChannelAdminLogEventsFilter) -> Self {
            match x {
                crate::enums::ChannelAdminLogEventsFilter::Filter(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelForbidden {
        pub broadcast: bool,
        pub megagroup: bool,
        pub id: i64,
        pub access_hash: i64,
        pub title: String,
        pub until_date: Option<i32>,
    }
    impl crate::Identifiable for ChannelForbidden {
        const CONSTRUCTOR_ID: u32 = 399807445;
    }
    impl crate::Serializable for ChannelForbidden {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.broadcast { 32 } else { 0 }
                | if self.megagroup { 256 } else { 0 }
                | if self.until_date.is_some() { 65536 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.title.serialize(buf);
            if let Some(ref x) = self.until_date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChannelForbidden {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let broadcast = (flags & 32) != 0;
            let megagroup = (flags & 256) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let until_date = if (flags & 65536) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChannelForbidden {
                broadcast,
                megagroup,
                id,
                access_hash,
                title,
                until_date,
            })
        }
    }
    impl TryFrom<crate::enums::Chat> for ChannelForbidden {
        type Error = ();
        fn try_from(x: crate::enums::Chat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Chat::ChannelForbidden(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelFull {
        pub can_view_participants: bool,
        pub can_set_username: bool,
        pub can_set_stickers: bool,
        pub hidden_prehistory: bool,
        pub can_set_location: bool,
        pub has_scheduled: bool,
        pub can_view_stats: bool,
        pub blocked: bool,
        pub id: i64,
        pub about: String,
        pub participants_count: Option<i32>,
        pub admins_count: Option<i32>,
        pub kicked_count: Option<i32>,
        pub banned_count: Option<i32>,
        pub online_count: Option<i32>,
        pub read_inbox_max_id: i32,
        pub read_outbox_max_id: i32,
        pub unread_count: i32,
        pub chat_photo: crate::enums::Photo,
        pub notify_settings: crate::enums::PeerNotifySettings,
        pub exported_invite: Option<crate::enums::ExportedChatInvite>,
        pub bot_info: Vec<crate::enums::BotInfo>,
        pub migrated_from_chat_id: Option<i64>,
        pub migrated_from_max_id: Option<i32>,
        pub pinned_msg_id: Option<i32>,
        pub stickerset: Option<crate::enums::StickerSet>,
        pub available_min_id: Option<i32>,
        pub folder_id: Option<i32>,
        pub linked_chat_id: Option<i64>,
        pub location: Option<crate::enums::ChannelLocation>,
        pub slowmode_seconds: Option<i32>,
        pub slowmode_next_send_date: Option<i32>,
        pub stats_dc: Option<i32>,
        pub pts: i32,
        pub call: Option<crate::enums::InputGroupCall>,
        pub ttl_period: Option<i32>,
        pub pending_suggestions: Option<Vec<String>>,
        pub groupcall_default_join_as: Option<crate::enums::Peer>,
        pub theme_emoticon: Option<String>,
        pub requests_pending: Option<i32>,
        pub recent_requesters: Option<Vec<i64>>,
        pub default_send_as: Option<crate::enums::Peer>,
    }
    impl crate::Identifiable for ChannelFull {
        const CONSTRUCTOR_ID: u32 = 1449537070;
    }
    impl crate::Serializable for ChannelFull {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.can_view_participants { 8 } else { 0 }
                | if self.can_set_username { 64 } else { 0 }
                | if self.can_set_stickers { 128 } else { 0 }
                | if self.hidden_prehistory { 1024 } else { 0 }
                | if self.can_set_location { 65536 } else { 0 }
                | if self.has_scheduled { 524288 } else { 0 }
                | if self.can_view_stats { 1048576 } else { 0 }
                | if self.blocked { 4194304 } else { 0 }
                | if self.participants_count.is_some() {
                    1
                } else {
                    0
                }
                | if self.admins_count.is_some() { 2 } else { 0 }
                | if self.kicked_count.is_some() { 4 } else { 0 }
                | if self.banned_count.is_some() { 4 } else { 0 }
                | if self.online_count.is_some() { 8192 } else { 0 }
                | if self.exported_invite.is_some() {
                    8388608
                } else {
                    0
                }
                | if self.migrated_from_chat_id.is_some() {
                    16
                } else {
                    0
                }
                | if self.migrated_from_max_id.is_some() {
                    16
                } else {
                    0
                }
                | if self.pinned_msg_id.is_some() { 32 } else { 0 }
                | if self.stickerset.is_some() { 256 } else { 0 }
                | if self.available_min_id.is_some() {
                    512
                } else {
                    0
                }
                | if self.folder_id.is_some() { 2048 } else { 0 }
                | if self.linked_chat_id.is_some() {
                    16384
                } else {
                    0
                }
                | if self.location.is_some() { 32768 } else { 0 }
                | if self.slowmode_seconds.is_some() {
                    131072
                } else {
                    0
                }
                | if self.slowmode_next_send_date.is_some() {
                    262144
                } else {
                    0
                }
                | if self.stats_dc.is_some() { 4096 } else { 0 }
                | if self.call.is_some() { 2097152 } else { 0 }
                | if self.ttl_period.is_some() {
                    16777216
                } else {
                    0
                }
                | if self.pending_suggestions.is_some() {
                    33554432
                } else {
                    0
                }
                | if self.groupcall_default_join_as.is_some() {
                    67108864
                } else {
                    0
                }
                | if self.theme_emoticon.is_some() {
                    134217728
                } else {
                    0
                }
                | if self.requests_pending.is_some() {
                    268435456
                } else {
                    0
                }
                | if self.recent_requesters.is_some() {
                    268435456
                } else {
                    0
                }
                | if self.default_send_as.is_some() {
                    536870912
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.about.serialize(buf);
            if let Some(ref x) = self.participants_count {
                x.serialize(buf);
            }
            if let Some(ref x) = self.admins_count {
                x.serialize(buf);
            }
            if let Some(ref x) = self.kicked_count {
                x.serialize(buf);
            }
            if let Some(ref x) = self.banned_count {
                x.serialize(buf);
            }
            if let Some(ref x) = self.online_count {
                x.serialize(buf);
            }
            self.read_inbox_max_id.serialize(buf);
            self.read_outbox_max_id.serialize(buf);
            self.unread_count.serialize(buf);
            self.chat_photo.serialize(buf);
            self.notify_settings.serialize(buf);
            if let Some(ref x) = self.exported_invite {
                x.serialize(buf);
            }
            self.bot_info.serialize(buf);
            if let Some(ref x) = self.migrated_from_chat_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.migrated_from_max_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.pinned_msg_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.stickerset {
                x.serialize(buf);
            }
            if let Some(ref x) = self.available_min_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.linked_chat_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.location {
                x.serialize(buf);
            }
            if let Some(ref x) = self.slowmode_seconds {
                x.serialize(buf);
            }
            if let Some(ref x) = self.slowmode_next_send_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.stats_dc {
                x.serialize(buf);
            }
            self.pts.serialize(buf);
            if let Some(ref x) = self.call {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.pending_suggestions {
                x.serialize(buf);
            }
            if let Some(ref x) = self.groupcall_default_join_as {
                x.serialize(buf);
            }
            if let Some(ref x) = self.theme_emoticon {
                x.serialize(buf);
            }
            if let Some(ref x) = self.requests_pending {
                x.serialize(buf);
            }
            if let Some(ref x) = self.recent_requesters {
                x.serialize(buf);
            }
            if let Some(ref x) = self.default_send_as {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChannelFull {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let can_view_participants = (flags & 8) != 0;
            let can_set_username = (flags & 64) != 0;
            let can_set_stickers = (flags & 128) != 0;
            let hidden_prehistory = (flags & 1024) != 0;
            let can_set_location = (flags & 65536) != 0;
            let has_scheduled = (flags & 524288) != 0;
            let can_view_stats = (flags & 1048576) != 0;
            let blocked = (flags & 4194304) != 0;
            let id = i64::deserialize(buf)?;
            let about = String::deserialize(buf)?;
            let participants_count = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let admins_count = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let kicked_count = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let banned_count = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let online_count = if (flags & 8192) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let read_inbox_max_id = i32::deserialize(buf)?;
            let read_outbox_max_id = i32::deserialize(buf)?;
            let unread_count = i32::deserialize(buf)?;
            let chat_photo = crate::enums::Photo::deserialize(buf)?;
            let notify_settings = crate::enums::PeerNotifySettings::deserialize(buf)?;
            let exported_invite = if (flags & 8388608) != 0 {
                Some(crate::enums::ExportedChatInvite::deserialize(buf)?)
            } else {
                None
            };
            let bot_info = Vec::<crate::enums::BotInfo>::deserialize(buf)?;
            let migrated_from_chat_id = if (flags & 16) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let migrated_from_max_id = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let pinned_msg_id = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let stickerset = if (flags & 256) != 0 {
                Some(crate::enums::StickerSet::deserialize(buf)?)
            } else {
                None
            };
            let available_min_id = if (flags & 512) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let folder_id = if (flags & 2048) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let linked_chat_id = if (flags & 16384) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let location = if (flags & 32768) != 0 {
                Some(crate::enums::ChannelLocation::deserialize(buf)?)
            } else {
                None
            };
            let slowmode_seconds = if (flags & 131072) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let slowmode_next_send_date = if (flags & 262144) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let stats_dc = if (flags & 4096) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let pts = i32::deserialize(buf)?;
            let call = if (flags & 2097152) != 0 {
                Some(crate::enums::InputGroupCall::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 16777216) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let pending_suggestions = if (flags & 33554432) != 0 {
                Some(Vec::<String>::deserialize(buf)?)
            } else {
                None
            };
            let groupcall_default_join_as = if (flags & 67108864) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let theme_emoticon = if (flags & 134217728) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let requests_pending = if (flags & 268435456) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let recent_requesters = if (flags & 268435456) != 0 {
                Some(Vec::<i64>::deserialize(buf)?)
            } else {
                None
            };
            let default_send_as = if (flags & 536870912) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChannelFull {
                can_view_participants,
                can_set_username,
                can_set_stickers,
                hidden_prehistory,
                can_set_location,
                has_scheduled,
                can_view_stats,
                blocked,
                id,
                about,
                participants_count,
                admins_count,
                kicked_count,
                banned_count,
                online_count,
                read_inbox_max_id,
                read_outbox_max_id,
                unread_count,
                chat_photo,
                notify_settings,
                exported_invite,
                bot_info,
                migrated_from_chat_id,
                migrated_from_max_id,
                pinned_msg_id,
                stickerset,
                available_min_id,
                folder_id,
                linked_chat_id,
                location,
                slowmode_seconds,
                slowmode_next_send_date,
                stats_dc,
                pts,
                call,
                ttl_period,
                pending_suggestions,
                groupcall_default_join_as,
                theme_emoticon,
                requests_pending,
                recent_requesters,
                default_send_as,
            })
        }
    }
    impl TryFrom<crate::enums::ChatFull> for ChannelFull {
        type Error = ();
        fn try_from(x: crate::enums::ChatFull) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatFull::ChannelFull(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelLocation {
        pub geo_point: crate::enums::GeoPoint,
        pub address: String,
    }
    impl crate::Identifiable for ChannelLocation {
        const CONSTRUCTOR_ID: u32 = 547062491;
    }
    impl crate::Serializable for ChannelLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo_point.serialize(buf);
            self.address.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo_point = crate::enums::GeoPoint::deserialize(buf)?;
            let address = String::deserialize(buf)?;
            Ok(ChannelLocation { geo_point, address })
        }
    }
    impl TryFrom<crate::enums::ChannelLocation> for ChannelLocation {
        type Error = ();
        fn try_from(x: crate::enums::ChannelLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelLocation::Location(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelLocationEmpty {}
    impl crate::Identifiable for ChannelLocationEmpty {
        const CONSTRUCTOR_ID: u32 = 3216354699;
    }
    impl crate::Serializable for ChannelLocationEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelLocationEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelLocationEmpty {})
        }
    }
    impl TryFrom<crate::enums::ChannelLocation> for ChannelLocationEmpty {
        type Error = ();
        fn try_from(x: crate::enums::ChannelLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelLocation::Empty => Ok(ChannelLocationEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelMessagesFilter {
        pub exclude_new_messages: bool,
        pub ranges: Vec<crate::enums::MessageRange>,
    }
    impl crate::Identifiable for ChannelMessagesFilter {
        const CONSTRUCTOR_ID: u32 = 3447183703;
    }
    impl crate::Serializable for ChannelMessagesFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.exclude_new_messages { 2 } else { 0 }).serialize(buf);
            self.ranges.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelMessagesFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let exclude_new_messages = (flags & 2) != 0;
            let ranges = Vec::<crate::enums::MessageRange>::deserialize(buf)?;
            Ok(ChannelMessagesFilter {
                exclude_new_messages,
                ranges,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelMessagesFilter> for ChannelMessagesFilter {
        type Error = ();
        fn try_from(x: crate::enums::ChannelMessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelMessagesFilter::Filter(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelMessagesFilterEmpty {}
    impl crate::Identifiable for ChannelMessagesFilterEmpty {
        const CONSTRUCTOR_ID: u32 = 2496933607;
    }
    impl crate::Serializable for ChannelMessagesFilterEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelMessagesFilterEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelMessagesFilterEmpty {})
        }
    }
    impl TryFrom<crate::enums::ChannelMessagesFilter> for ChannelMessagesFilterEmpty {
        type Error = ();
        fn try_from(x: crate::enums::ChannelMessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelMessagesFilter::Empty => Ok(ChannelMessagesFilterEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipant {
        pub user_id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for ChannelParticipant {
        const CONSTRUCTOR_ID: u32 = 3222013888;
    }
    impl crate::Serializable for ChannelParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(ChannelParticipant { user_id, date })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipant {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::Participant(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantAdmin {
        pub can_edit: bool,
        pub is_self: bool,
        pub user_id: i64,
        pub inviter_id: Option<i64>,
        pub promoted_by: i64,
        pub date: i32,
        pub admin_rights: crate::enums::ChatAdminRights,
        pub rank: Option<String>,
    }
    impl crate::Identifiable for ChannelParticipantAdmin {
        const CONSTRUCTOR_ID: u32 = 885242707;
    }
    impl crate::Serializable for ChannelParticipantAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.can_edit { 1 } else { 0 }
                | if self.is_self { 2 } else { 0 }
                | if self.inviter_id.is_some() { 2 } else { 0 }
                | if self.rank.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.user_id.serialize(buf);
            if let Some(ref x) = self.inviter_id {
                x.serialize(buf);
            }
            self.promoted_by.serialize(buf);
            self.date.serialize(buf);
            self.admin_rights.serialize(buf);
            if let Some(ref x) = self.rank {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChannelParticipantAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let can_edit = (flags & 1) != 0;
            let is_self = (flags & 2) != 0;
            let user_id = i64::deserialize(buf)?;
            let inviter_id = if (flags & 2) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let promoted_by = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_rights = crate::enums::ChatAdminRights::deserialize(buf)?;
            let rank = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChannelParticipantAdmin {
                can_edit,
                is_self,
                user_id,
                inviter_id,
                promoted_by,
                date,
                admin_rights,
                rank,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipantAdmin {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::Admin(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantBanned {
        pub left: bool,
        pub peer: crate::enums::Peer,
        pub kicked_by: i64,
        pub date: i32,
        pub banned_rights: crate::enums::ChatBannedRights,
    }
    impl crate::Identifiable for ChannelParticipantBanned {
        const CONSTRUCTOR_ID: u32 = 1844969806;
    }
    impl crate::Serializable for ChannelParticipantBanned {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.left { 1 } else { 0 }).serialize(buf);
            self.peer.serialize(buf);
            self.kicked_by.serialize(buf);
            self.date.serialize(buf);
            self.banned_rights.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantBanned {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let left = (flags & 1) != 0;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let kicked_by = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let banned_rights = crate::enums::ChatBannedRights::deserialize(buf)?;
            Ok(ChannelParticipantBanned {
                left,
                peer,
                kicked_by,
                date,
                banned_rights,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipantBanned {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::Banned(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantCreator {
        pub user_id: i64,
        pub admin_rights: crate::enums::ChatAdminRights,
        pub rank: Option<String>,
    }
    impl crate::Identifiable for ChannelParticipantCreator {
        const CONSTRUCTOR_ID: u32 = 803602899;
    }
    impl crate::Serializable for ChannelParticipantCreator {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.rank.is_some() { 1 } else { 0 }).serialize(buf);
            self.user_id.serialize(buf);
            self.admin_rights.serialize(buf);
            if let Some(ref x) = self.rank {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChannelParticipantCreator {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let admin_rights = crate::enums::ChatAdminRights::deserialize(buf)?;
            let rank = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChannelParticipantCreator {
                user_id,
                admin_rights,
                rank,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipantCreator {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::Creator(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantLeft {
        pub peer: crate::enums::Peer,
    }
    impl crate::Identifiable for ChannelParticipantLeft {
        const CONSTRUCTOR_ID: u32 = 453242886;
    }
    impl crate::Serializable for ChannelParticipantLeft {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantLeft {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            Ok(ChannelParticipantLeft { peer })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipantLeft {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::Left(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantSelf {
        pub via_request: bool,
        pub user_id: i64,
        pub inviter_id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for ChannelParticipantSelf {
        const CONSTRUCTOR_ID: u32 = 900251559;
    }
    impl crate::Serializable for ChannelParticipantSelf {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.via_request { 1 } else { 0 }).serialize(buf);
            self.user_id.serialize(buf);
            self.inviter_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantSelf {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let via_request = (flags & 1) != 0;
            let user_id = i64::deserialize(buf)?;
            let inviter_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(ChannelParticipantSelf {
                via_request,
                user_id,
                inviter_id,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipant> for ChannelParticipantSelf {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipant::ParticipantSelf(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsAdmins {}
    impl crate::Identifiable for ChannelParticipantsAdmins {
        const CONSTRUCTOR_ID: u32 = 3026225513;
    }
    impl crate::Serializable for ChannelParticipantsAdmins {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelParticipantsAdmins {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelParticipantsAdmins {})
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsAdmins {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsAdmins => {
                    Ok(ChannelParticipantsAdmins {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsBanned {
        pub q: String,
    }
    impl crate::Identifiable for ChannelParticipantsBanned {
        const CONSTRUCTOR_ID: u32 = 338142689;
    }
    impl crate::Serializable for ChannelParticipantsBanned {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.q.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantsBanned {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let q = String::deserialize(buf)?;
            Ok(ChannelParticipantsBanned { q })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsBanned {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsBanned(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsBots {}
    impl crate::Identifiable for ChannelParticipantsBots {
        const CONSTRUCTOR_ID: u32 = 2966521435;
    }
    impl crate::Serializable for ChannelParticipantsBots {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelParticipantsBots {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelParticipantsBots {})
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsBots {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsBots => {
                    Ok(ChannelParticipantsBots {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsContacts {
        pub q: String,
    }
    impl crate::Identifiable for ChannelParticipantsContacts {
        const CONSTRUCTOR_ID: u32 = 3144345741;
    }
    impl crate::Serializable for ChannelParticipantsContacts {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.q.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantsContacts {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let q = String::deserialize(buf)?;
            Ok(ChannelParticipantsContacts { q })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsContacts {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsContacts(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsKicked {
        pub q: String,
    }
    impl crate::Identifiable for ChannelParticipantsKicked {
        const CONSTRUCTOR_ID: u32 = 2746567045;
    }
    impl crate::Serializable for ChannelParticipantsKicked {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.q.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantsKicked {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let q = String::deserialize(buf)?;
            Ok(ChannelParticipantsKicked { q })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsKicked {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsKicked(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsMentions {
        pub q: Option<String>,
        pub top_msg_id: Option<i32>,
    }
    impl crate::Identifiable for ChannelParticipantsMentions {
        const CONSTRUCTOR_ID: u32 = 3763035371;
    }
    impl crate::Serializable for ChannelParticipantsMentions {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.q.is_some() { 1 } else { 0 }
                | if self.top_msg_id.is_some() { 2 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.q {
                x.serialize(buf);
            }
            if let Some(ref x) = self.top_msg_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChannelParticipantsMentions {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let q = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let top_msg_id = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChannelParticipantsMentions { q, top_msg_id })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsMentions {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsMentions(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsRecent {}
    impl crate::Identifiable for ChannelParticipantsRecent {
        const CONSTRUCTOR_ID: u32 = 3728686201;
    }
    impl crate::Serializable for ChannelParticipantsRecent {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChannelParticipantsRecent {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChannelParticipantsRecent {})
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsRecent {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsRecent => {
                    Ok(ChannelParticipantsRecent {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChannelParticipantsSearch {
        pub q: String,
    }
    impl crate::Identifiable for ChannelParticipantsSearch {
        const CONSTRUCTOR_ID: u32 = 106343499;
    }
    impl crate::Serializable for ChannelParticipantsSearch {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.q.serialize(buf);
        }
    }
    impl crate::Deserializable for ChannelParticipantsSearch {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let q = String::deserialize(buf)?;
            Ok(ChannelParticipantsSearch { q })
        }
    }
    impl TryFrom<crate::enums::ChannelParticipantsFilter> for ChannelParticipantsSearch {
        type Error = ();
        fn try_from(x: crate::enums::ChannelParticipantsFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChannelParticipantsFilter::ChannelParticipantsSearch(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Chat {
        pub creator: bool,
        pub kicked: bool,
        pub left: bool,
        pub deactivated: bool,
        pub call_active: bool,
        pub call_not_empty: bool,
        pub noforwards: bool,
        pub id: i64,
        pub title: String,
        pub photo: crate::enums::ChatPhoto,
        pub participants_count: i32,
        pub date: i32,
        pub version: i32,
        pub migrated_to: Option<crate::enums::InputChannel>,
        pub admin_rights: Option<crate::enums::ChatAdminRights>,
        pub default_banned_rights: Option<crate::enums::ChatBannedRights>,
    }
    impl crate::Identifiable for Chat {
        const CONSTRUCTOR_ID: u32 = 1103884886;
    }
    impl crate::Serializable for Chat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.creator { 1 } else { 0 }
                | if self.kicked { 2 } else { 0 }
                | if self.left { 4 } else { 0 }
                | if self.deactivated { 32 } else { 0 }
                | if self.call_active { 8388608 } else { 0 }
                | if self.call_not_empty { 16777216 } else { 0 }
                | if self.noforwards { 33554432 } else { 0 }
                | if self.migrated_to.is_some() { 64 } else { 0 }
                | if self.admin_rights.is_some() {
                    16384
                } else {
                    0
                }
                | if self.default_banned_rights.is_some() {
                    262144
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.title.serialize(buf);
            self.photo.serialize(buf);
            self.participants_count.serialize(buf);
            self.date.serialize(buf);
            self.version.serialize(buf);
            if let Some(ref x) = self.migrated_to {
                x.serialize(buf);
            }
            if let Some(ref x) = self.admin_rights {
                x.serialize(buf);
            }
            if let Some(ref x) = self.default_banned_rights {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Chat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let creator = (flags & 1) != 0;
            let kicked = (flags & 2) != 0;
            let left = (flags & 4) != 0;
            let deactivated = (flags & 32) != 0;
            let call_active = (flags & 8388608) != 0;
            let call_not_empty = (flags & 16777216) != 0;
            let noforwards = (flags & 33554432) != 0;
            let id = i64::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let photo = crate::enums::ChatPhoto::deserialize(buf)?;
            let participants_count = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            let migrated_to = if (flags & 64) != 0 {
                Some(crate::enums::InputChannel::deserialize(buf)?)
            } else {
                None
            };
            let admin_rights = if (flags & 16384) != 0 {
                Some(crate::enums::ChatAdminRights::deserialize(buf)?)
            } else {
                None
            };
            let default_banned_rights = if (flags & 262144) != 0 {
                Some(crate::enums::ChatBannedRights::deserialize(buf)?)
            } else {
                None
            };
            Ok(Chat {
                creator,
                kicked,
                left,
                deactivated,
                call_active,
                call_not_empty,
                noforwards,
                id,
                title,
                photo,
                participants_count,
                date,
                version,
                migrated_to,
                admin_rights,
                default_banned_rights,
            })
        }
    }
    impl TryFrom<crate::enums::Chat> for Chat {
        type Error = ();
        fn try_from(x: crate::enums::Chat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Chat::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatAdminRights {
        pub change_info: bool,
        pub post_messages: bool,
        pub edit_messages: bool,
        pub delete_messages: bool,
        pub ban_users: bool,
        pub invite_users: bool,
        pub pin_messages: bool,
        pub add_admins: bool,
        pub anonymous: bool,
        pub manage_call: bool,
        pub other: bool,
    }
    impl crate::Identifiable for ChatAdminRights {
        const CONSTRUCTOR_ID: u32 = 1605510357;
    }
    impl crate::Serializable for ChatAdminRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.change_info { 1 } else { 0 }
                | if self.post_messages { 2 } else { 0 }
                | if self.edit_messages { 4 } else { 0 }
                | if self.delete_messages { 8 } else { 0 }
                | if self.ban_users { 16 } else { 0 }
                | if self.invite_users { 32 } else { 0 }
                | if self.pin_messages { 128 } else { 0 }
                | if self.add_admins { 512 } else { 0 }
                | if self.anonymous { 1024 } else { 0 }
                | if self.manage_call { 2048 } else { 0 }
                | if self.other { 4096 } else { 0 })
            .serialize(buf);
        }
    }
    impl crate::Deserializable for ChatAdminRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let change_info = (flags & 1) != 0;
            let post_messages = (flags & 2) != 0;
            let edit_messages = (flags & 4) != 0;
            let delete_messages = (flags & 8) != 0;
            let ban_users = (flags & 16) != 0;
            let invite_users = (flags & 32) != 0;
            let pin_messages = (flags & 128) != 0;
            let add_admins = (flags & 512) != 0;
            let anonymous = (flags & 1024) != 0;
            let manage_call = (flags & 2048) != 0;
            let other = (flags & 4096) != 0;
            Ok(ChatAdminRights {
                change_info,
                post_messages,
                edit_messages,
                delete_messages,
                ban_users,
                invite_users,
                pin_messages,
                add_admins,
                anonymous,
                manage_call,
                other,
            })
        }
    }
    impl From<crate::enums::ChatAdminRights> for ChatAdminRights {
        fn from(x: crate::enums::ChatAdminRights) -> Self {
            match x {
                crate::enums::ChatAdminRights::Rights(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatAdminWithInvites {
        pub admin_id: i64,
        pub invites_count: i32,
        pub revoked_invites_count: i32,
    }
    impl crate::Identifiable for ChatAdminWithInvites {
        const CONSTRUCTOR_ID: u32 = 4075613987;
    }
    impl crate::Serializable for ChatAdminWithInvites {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.admin_id.serialize(buf);
            self.invites_count.serialize(buf);
            self.revoked_invites_count.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatAdminWithInvites {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let admin_id = i64::deserialize(buf)?;
            let invites_count = i32::deserialize(buf)?;
            let revoked_invites_count = i32::deserialize(buf)?;
            Ok(ChatAdminWithInvites {
                admin_id,
                invites_count,
                revoked_invites_count,
            })
        }
    }
    impl From<crate::enums::ChatAdminWithInvites> for ChatAdminWithInvites {
        fn from(x: crate::enums::ChatAdminWithInvites) -> Self {
            match x {
                crate::enums::ChatAdminWithInvites::Invites(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatBannedRights {
        pub view_messages: bool,
        pub send_messages: bool,
        pub send_media: bool,
        pub send_stickers: bool,
        pub send_gifs: bool,
        pub send_games: bool,
        pub send_inline: bool,
        pub embed_links: bool,
        pub send_polls: bool,
        pub change_info: bool,
        pub invite_users: bool,
        pub pin_messages: bool,
        pub until_date: i32,
    }
    impl crate::Identifiable for ChatBannedRights {
        const CONSTRUCTOR_ID: u32 = 2668758040;
    }
    impl crate::Serializable for ChatBannedRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.view_messages { 1 } else { 0 }
                | if self.send_messages { 2 } else { 0 }
                | if self.send_media { 4 } else { 0 }
                | if self.send_stickers { 8 } else { 0 }
                | if self.send_gifs { 16 } else { 0 }
                | if self.send_games { 32 } else { 0 }
                | if self.send_inline { 64 } else { 0 }
                | if self.embed_links { 128 } else { 0 }
                | if self.send_polls { 256 } else { 0 }
                | if self.change_info { 1024 } else { 0 }
                | if self.invite_users { 32768 } else { 0 }
                | if self.pin_messages { 131072 } else { 0 })
            .serialize(buf);
            self.until_date.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatBannedRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let view_messages = (flags & 1) != 0;
            let send_messages = (flags & 2) != 0;
            let send_media = (flags & 4) != 0;
            let send_stickers = (flags & 8) != 0;
            let send_gifs = (flags & 16) != 0;
            let send_games = (flags & 32) != 0;
            let send_inline = (flags & 64) != 0;
            let embed_links = (flags & 128) != 0;
            let send_polls = (flags & 256) != 0;
            let change_info = (flags & 1024) != 0;
            let invite_users = (flags & 32768) != 0;
            let pin_messages = (flags & 131072) != 0;
            let until_date = i32::deserialize(buf)?;
            Ok(ChatBannedRights {
                view_messages,
                send_messages,
                send_media,
                send_stickers,
                send_gifs,
                send_games,
                send_inline,
                embed_links,
                send_polls,
                change_info,
                invite_users,
                pin_messages,
                until_date,
            })
        }
    }
    impl From<crate::enums::ChatBannedRights> for ChatBannedRights {
        fn from(x: crate::enums::ChatBannedRights) -> Self {
            match x {
                crate::enums::ChatBannedRights::Rights(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for ChatEmpty {
        const CONSTRUCTOR_ID: u32 = 693512293;
    }
    impl crate::Serializable for ChatEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(ChatEmpty { id })
        }
    }
    impl TryFrom<crate::enums::Chat> for ChatEmpty {
        type Error = ();
        fn try_from(x: crate::enums::Chat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Chat::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatForbidden {
        pub id: i64,
        pub title: String,
    }
    impl crate::Identifiable for ChatForbidden {
        const CONSTRUCTOR_ID: u32 = 1704108455;
    }
    impl crate::Serializable for ChatForbidden {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.title.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatForbidden {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            Ok(ChatForbidden { id, title })
        }
    }
    impl TryFrom<crate::enums::Chat> for ChatForbidden {
        type Error = ();
        fn try_from(x: crate::enums::Chat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Chat::Forbidden(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatFull {
        pub can_set_username: bool,
        pub has_scheduled: bool,
        pub id: i64,
        pub about: String,
        pub participants: crate::enums::ChatParticipants,
        pub chat_photo: Option<crate::enums::Photo>,
        pub notify_settings: crate::enums::PeerNotifySettings,
        pub exported_invite: Option<crate::enums::ExportedChatInvite>,
        pub bot_info: Option<Vec<crate::enums::BotInfo>>,
        pub pinned_msg_id: Option<i32>,
        pub folder_id: Option<i32>,
        pub call: Option<crate::enums::InputGroupCall>,
        pub ttl_period: Option<i32>,
        pub groupcall_default_join_as: Option<crate::enums::Peer>,
        pub theme_emoticon: Option<String>,
        pub requests_pending: Option<i32>,
        pub recent_requesters: Option<Vec<i64>>,
    }
    impl crate::Identifiable for ChatFull {
        const CONSTRUCTOR_ID: u32 = 1185349556;
    }
    impl crate::Serializable for ChatFull {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.can_set_username { 128 } else { 0 }
                | if self.has_scheduled { 256 } else { 0 }
                | if self.chat_photo.is_some() { 4 } else { 0 }
                | if self.exported_invite.is_some() {
                    8192
                } else {
                    0
                }
                | if self.bot_info.is_some() { 8 } else { 0 }
                | if self.pinned_msg_id.is_some() { 64 } else { 0 }
                | if self.folder_id.is_some() { 2048 } else { 0 }
                | if self.call.is_some() { 4096 } else { 0 }
                | if self.ttl_period.is_some() { 16384 } else { 0 }
                | if self.groupcall_default_join_as.is_some() {
                    32768
                } else {
                    0
                }
                | if self.theme_emoticon.is_some() {
                    65536
                } else {
                    0
                }
                | if self.requests_pending.is_some() {
                    131072
                } else {
                    0
                }
                | if self.recent_requesters.is_some() {
                    131072
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.about.serialize(buf);
            self.participants.serialize(buf);
            if let Some(ref x) = self.chat_photo {
                x.serialize(buf);
            }
            self.notify_settings.serialize(buf);
            if let Some(ref x) = self.exported_invite {
                x.serialize(buf);
            }
            if let Some(ref x) = self.bot_info {
                x.serialize(buf);
            }
            if let Some(ref x) = self.pinned_msg_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.call {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.groupcall_default_join_as {
                x.serialize(buf);
            }
            if let Some(ref x) = self.theme_emoticon {
                x.serialize(buf);
            }
            if let Some(ref x) = self.requests_pending {
                x.serialize(buf);
            }
            if let Some(ref x) = self.recent_requesters {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChatFull {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let can_set_username = (flags & 128) != 0;
            let has_scheduled = (flags & 256) != 0;
            let id = i64::deserialize(buf)?;
            let about = String::deserialize(buf)?;
            let participants = crate::enums::ChatParticipants::deserialize(buf)?;
            let chat_photo = if (flags & 4) != 0 {
                Some(crate::enums::Photo::deserialize(buf)?)
            } else {
                None
            };
            let notify_settings = crate::enums::PeerNotifySettings::deserialize(buf)?;
            let exported_invite = if (flags & 8192) != 0 {
                Some(crate::enums::ExportedChatInvite::deserialize(buf)?)
            } else {
                None
            };
            let bot_info = if (flags & 8) != 0 {
                Some(Vec::<crate::enums::BotInfo>::deserialize(buf)?)
            } else {
                None
            };
            let pinned_msg_id = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let folder_id = if (flags & 2048) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let call = if (flags & 4096) != 0 {
                Some(crate::enums::InputGroupCall::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 16384) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let groupcall_default_join_as = if (flags & 32768) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let theme_emoticon = if (flags & 65536) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let requests_pending = if (flags & 131072) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let recent_requesters = if (flags & 131072) != 0 {
                Some(Vec::<i64>::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChatFull {
                can_set_username,
                has_scheduled,
                id,
                about,
                participants,
                chat_photo,
                notify_settings,
                exported_invite,
                bot_info,
                pinned_msg_id,
                folder_id,
                call,
                ttl_period,
                groupcall_default_join_as,
                theme_emoticon,
                requests_pending,
                recent_requesters,
            })
        }
    }
    impl TryFrom<crate::enums::ChatFull> for ChatFull {
        type Error = ();
        fn try_from(x: crate::enums::ChatFull) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatFull::Full(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatInvite {
        pub channel: bool,
        pub broadcast: bool,
        pub public: bool,
        pub megagroup: bool,
        pub request_needed: bool,
        pub title: String,
        pub about: Option<String>,
        pub photo: crate::enums::Photo,
        pub participants_count: i32,
        pub participants: Option<Vec<crate::enums::User>>,
    }
    impl crate::Identifiable for ChatInvite {
        const CONSTRUCTOR_ID: u32 = 806110401;
    }
    impl crate::Serializable for ChatInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.channel { 1 } else { 0 }
                | if self.broadcast { 2 } else { 0 }
                | if self.public { 4 } else { 0 }
                | if self.megagroup { 8 } else { 0 }
                | if self.request_needed { 64 } else { 0 }
                | if self.about.is_some() { 32 } else { 0 }
                | if self.participants.is_some() { 16 } else { 0 })
            .serialize(buf);
            self.title.serialize(buf);
            if let Some(ref x) = self.about {
                x.serialize(buf);
            }
            self.photo.serialize(buf);
            self.participants_count.serialize(buf);
            if let Some(ref x) = self.participants {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChatInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let channel = (flags & 1) != 0;
            let broadcast = (flags & 2) != 0;
            let public = (flags & 4) != 0;
            let megagroup = (flags & 8) != 0;
            let request_needed = (flags & 64) != 0;
            let title = String::deserialize(buf)?;
            let about = if (flags & 32) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let photo = crate::enums::Photo::deserialize(buf)?;
            let participants_count = i32::deserialize(buf)?;
            let participants = if (flags & 16) != 0 {
                Some(Vec::<crate::enums::User>::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChatInvite {
                channel,
                broadcast,
                public,
                megagroup,
                request_needed,
                title,
                about,
                photo,
                participants_count,
                participants,
            })
        }
    }
    impl TryFrom<crate::enums::ChatInvite> for ChatInvite {
        type Error = ();
        fn try_from(x: crate::enums::ChatInvite) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatInvite::Invite(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatInviteAlready {
        pub chat: crate::enums::Chat,
    }
    impl crate::Identifiable for ChatInviteAlready {
        const CONSTRUCTOR_ID: u32 = 1516793212;
    }
    impl crate::Serializable for ChatInviteAlready {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatInviteAlready {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat = crate::enums::Chat::deserialize(buf)?;
            Ok(ChatInviteAlready { chat })
        }
    }
    impl TryFrom<crate::enums::ChatInvite> for ChatInviteAlready {
        type Error = ();
        fn try_from(x: crate::enums::ChatInvite) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatInvite::Already(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatInviteExported {
        pub revoked: bool,
        pub permanent: bool,
        pub request_needed: bool,
        pub link: String,
        pub admin_id: i64,
        pub date: i32,
        pub start_date: Option<i32>,
        pub expire_date: Option<i32>,
        pub usage_limit: Option<i32>,
        pub usage: Option<i32>,
        pub requested: Option<i32>,
        pub title: Option<String>,
    }
    impl crate::Identifiable for ChatInviteExported {
        const CONSTRUCTOR_ID: u32 = 179611673;
    }
    impl crate::Serializable for ChatInviteExported {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.revoked { 1 } else { 0 }
                | if self.permanent { 32 } else { 0 }
                | if self.request_needed { 64 } else { 0 }
                | if self.start_date.is_some() { 16 } else { 0 }
                | if self.expire_date.is_some() { 2 } else { 0 }
                | if self.usage_limit.is_some() { 4 } else { 0 }
                | if self.usage.is_some() { 8 } else { 0 }
                | if self.requested.is_some() { 128 } else { 0 }
                | if self.title.is_some() { 256 } else { 0 })
            .serialize(buf);
            self.link.serialize(buf);
            self.admin_id.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.start_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.expire_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.usage_limit {
                x.serialize(buf);
            }
            if let Some(ref x) = self.usage {
                x.serialize(buf);
            }
            if let Some(ref x) = self.requested {
                x.serialize(buf);
            }
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChatInviteExported {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let revoked = (flags & 1) != 0;
            let permanent = (flags & 32) != 0;
            let request_needed = (flags & 64) != 0;
            let link = String::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let start_date = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let expire_date = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let usage_limit = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let usage = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let requested = if (flags & 128) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let title = if (flags & 256) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChatInviteExported {
                revoked,
                permanent,
                request_needed,
                link,
                admin_id,
                date,
                start_date,
                expire_date,
                usage_limit,
                usage,
                requested,
                title,
            })
        }
    }
    impl From<crate::enums::ExportedChatInvite> for ChatInviteExported {
        fn from(x: crate::enums::ExportedChatInvite) -> Self {
            match x {
                crate::enums::ExportedChatInvite::ChatInviteExported(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatInviteImporter {
        pub requested: bool,
        pub user_id: i64,
        pub date: i32,
        pub about: Option<String>,
        pub approved_by: Option<i64>,
    }
    impl crate::Identifiable for ChatInviteImporter {
        const CONSTRUCTOR_ID: u32 = 2354765785;
    }
    impl crate::Serializable for ChatInviteImporter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.requested { 1 } else { 0 }
                | if self.about.is_some() { 4 } else { 0 }
                | if self.approved_by.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.user_id.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.about {
                x.serialize(buf);
            }
            if let Some(ref x) = self.approved_by {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChatInviteImporter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let requested = (flags & 1) != 0;
            let user_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let about = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let approved_by = if (flags & 2) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChatInviteImporter {
                requested,
                user_id,
                date,
                about,
                approved_by,
            })
        }
    }
    impl From<crate::enums::ChatInviteImporter> for ChatInviteImporter {
        fn from(x: crate::enums::ChatInviteImporter) -> Self {
            match x {
                crate::enums::ChatInviteImporter::Importer(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatInvitePeek {
        pub chat: crate::enums::Chat,
        pub expires: i32,
    }
    impl crate::Identifiable for ChatInvitePeek {
        const CONSTRUCTOR_ID: u32 = 1634294960;
    }
    impl crate::Serializable for ChatInvitePeek {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat.serialize(buf);
            self.expires.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatInvitePeek {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat = crate::enums::Chat::deserialize(buf)?;
            let expires = i32::deserialize(buf)?;
            Ok(ChatInvitePeek { chat, expires })
        }
    }
    impl TryFrom<crate::enums::ChatInvite> for ChatInvitePeek {
        type Error = ();
        fn try_from(x: crate::enums::ChatInvite) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatInvite::Peek(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatOnlines {
        pub onlines: i32,
    }
    impl crate::Identifiable for ChatOnlines {
        const CONSTRUCTOR_ID: u32 = 4030849616;
    }
    impl crate::Serializable for ChatOnlines {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.onlines.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatOnlines {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let onlines = i32::deserialize(buf)?;
            Ok(ChatOnlines { onlines })
        }
    }
    impl From<crate::enums::ChatOnlines> for ChatOnlines {
        fn from(x: crate::enums::ChatOnlines) -> Self {
            match x {
                crate::enums::ChatOnlines::Onlines(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatParticipant {
        pub user_id: i64,
        pub inviter_id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for ChatParticipant {
        const CONSTRUCTOR_ID: u32 = 3224190983;
    }
    impl crate::Serializable for ChatParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.inviter_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let inviter_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(ChatParticipant {
                user_id,
                inviter_id,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::ChatParticipant> for ChatParticipant {
        type Error = ();
        fn try_from(x: crate::enums::ChatParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatParticipant::Participant(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatParticipantAdmin {
        pub user_id: i64,
        pub inviter_id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for ChatParticipantAdmin {
        const CONSTRUCTOR_ID: u32 = 2694004571;
    }
    impl crate::Serializable for ChatParticipantAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.inviter_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatParticipantAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let inviter_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(ChatParticipantAdmin {
                user_id,
                inviter_id,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::ChatParticipant> for ChatParticipantAdmin {
        type Error = ();
        fn try_from(x: crate::enums::ChatParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatParticipant::Admin(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatParticipantCreator {
        pub user_id: i64,
    }
    impl crate::Identifiable for ChatParticipantCreator {
        const CONSTRUCTOR_ID: u32 = 3832270564;
    }
    impl crate::Serializable for ChatParticipantCreator {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatParticipantCreator {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            Ok(ChatParticipantCreator { user_id })
        }
    }
    impl TryFrom<crate::enums::ChatParticipant> for ChatParticipantCreator {
        type Error = ();
        fn try_from(x: crate::enums::ChatParticipant) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatParticipant::Creator(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatParticipants {
        pub chat_id: i64,
        pub participants: Vec<crate::enums::ChatParticipant>,
        pub version: i32,
    }
    impl crate::Identifiable for ChatParticipants {
        const CONSTRUCTOR_ID: u32 = 1018991608;
    }
    impl crate::Serializable for ChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.participants.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let participants = Vec::<crate::enums::ChatParticipant>::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(ChatParticipants {
                chat_id,
                participants,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::ChatParticipants> for ChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::ChatParticipants) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatParticipants::Participants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatParticipantsForbidden {
        pub chat_id: i64,
        pub self_participant: Option<crate::enums::ChatParticipant>,
    }
    impl crate::Identifiable for ChatParticipantsForbidden {
        const CONSTRUCTOR_ID: u32 = 2271466465;
    }
    impl crate::Serializable for ChatParticipantsForbidden {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.self_participant.is_some() {
                    1
                } else {
                    0
                })
            .serialize(buf);
            self.chat_id.serialize(buf);
            if let Some(ref x) = self.self_participant {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ChatParticipantsForbidden {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let chat_id = i64::deserialize(buf)?;
            let self_participant = if (flags & 1) != 0 {
                Some(crate::enums::ChatParticipant::deserialize(buf)?)
            } else {
                None
            };
            Ok(ChatParticipantsForbidden {
                chat_id,
                self_participant,
            })
        }
    }
    impl TryFrom<crate::enums::ChatParticipants> for ChatParticipantsForbidden {
        type Error = ();
        fn try_from(x: crate::enums::ChatParticipants) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatParticipants::Forbidden(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatPhoto {
        pub has_video: bool,
        pub photo_id: i64,
        pub stripped_thumb: Option<Vec<u8>>,
        pub dc_id: i32,
    }
    impl crate::Identifiable for ChatPhoto {
        const CONSTRUCTOR_ID: u32 = 476978193;
    }
    impl crate::Serializable for ChatPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.has_video { 1 } else { 0 }
                | if self.stripped_thumb.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.photo_id.serialize(buf);
            if let Some(ref x) = self.stripped_thumb {
                x.serialize(buf);
            }
            self.dc_id.serialize(buf);
        }
    }
    impl crate::Deserializable for ChatPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let has_video = (flags & 1) != 0;
            let photo_id = i64::deserialize(buf)?;
            let stripped_thumb = if (flags & 2) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            let dc_id = i32::deserialize(buf)?;
            Ok(ChatPhoto {
                has_video,
                photo_id,
                stripped_thumb,
                dc_id,
            })
        }
    }
    impl TryFrom<crate::enums::ChatPhoto> for ChatPhoto {
        type Error = ();
        fn try_from(x: crate::enums::ChatPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatPhoto::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ChatPhotoEmpty {}
    impl crate::Identifiable for ChatPhotoEmpty {
        const CONSTRUCTOR_ID: u32 = 935395612;
    }
    impl crate::Serializable for ChatPhotoEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for ChatPhotoEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(ChatPhotoEmpty {})
        }
    }
    impl TryFrom<crate::enums::ChatPhoto> for ChatPhotoEmpty {
        type Error = ();
        fn try_from(x: crate::enums::ChatPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ChatPhoto::Empty => Ok(ChatPhotoEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ClientDhInnerData {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub retry_id: i64,
        pub g_b: Vec<u8>,
    }
    impl crate::Identifiable for ClientDhInnerData {
        const CONSTRUCTOR_ID: u32 = 1715713620;
    }
    impl crate::Serializable for ClientDhInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.retry_id.serialize(buf);
            self.g_b.serialize(buf);
        }
    }
    impl crate::Deserializable for ClientDhInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let retry_id = i64::deserialize(buf)?;
            let g_b = Vec::<u8>::deserialize(buf)?;
            Ok(ClientDhInnerData {
                nonce,
                server_nonce,
                retry_id,
                g_b,
            })
        }
    }
    impl From<crate::enums::ClientDhInnerData> for ClientDhInnerData {
        fn from(x: crate::enums::ClientDhInnerData) -> Self {
            match x {
                crate::enums::ClientDhInnerData::Data(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct CodeSettings {
        pub allow_flashcall: bool,
        pub current_number: bool,
        pub allow_app_hash: bool,
        pub allow_missed_call: bool,
        pub logout_tokens: Option<Vec<Vec<u8>>>,
    }
    impl crate::Identifiable for CodeSettings {
        const CONSTRUCTOR_ID: u32 = 2321836482;
    }
    impl crate::Serializable for CodeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.allow_flashcall { 1 } else { 0 }
                | if self.current_number { 2 } else { 0 }
                | if self.allow_app_hash { 16 } else { 0 }
                | if self.allow_missed_call { 32 } else { 0 }
                | if self.logout_tokens.is_some() { 64 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.logout_tokens {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for CodeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let allow_flashcall = (flags & 1) != 0;
            let current_number = (flags & 2) != 0;
            let allow_app_hash = (flags & 16) != 0;
            let allow_missed_call = (flags & 32) != 0;
            let logout_tokens = if (flags & 64) != 0 {
                Some(Vec::<Vec<u8>>::deserialize(buf)?)
            } else {
                None
            };
            Ok(CodeSettings {
                allow_flashcall,
                current_number,
                allow_app_hash,
                allow_missed_call,
                logout_tokens,
            })
        }
    }
    impl From<crate::enums::CodeSettings> for CodeSettings {
        fn from(x: crate::enums::CodeSettings) -> Self {
            match x {
                crate::enums::CodeSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Config {
        pub phonecalls_enabled: bool,
        pub default_p2p_contacts: bool,
        pub preload_featured_stickers: bool,
        pub ignore_phone_entities: bool,
        pub revoke_pm_inbox: bool,
        pub blocked_mode: bool,
        pub pfs_enabled: bool,
        pub date: i32,
        pub expires: i32,
        pub test_mode: bool,
        pub this_dc: i32,
        pub dc_options: Vec<crate::enums::DcOption>,
        pub dc_txt_domain_name: String,
        pub chat_size_max: i32,
        pub megagroup_size_max: i32,
        pub forwarded_count_max: i32,
        pub online_update_period_ms: i32,
        pub offline_blur_timeout_ms: i32,
        pub offline_idle_timeout_ms: i32,
        pub online_cloud_timeout_ms: i32,
        pub notify_cloud_delay_ms: i32,
        pub notify_default_delay_ms: i32,
        pub push_chat_period_ms: i32,
        pub push_chat_limit: i32,
        pub saved_gifs_limit: i32,
        pub edit_time_limit: i32,
        pub revoke_time_limit: i32,
        pub revoke_pm_time_limit: i32,
        pub rating_e_decay: i32,
        pub stickers_recent_limit: i32,
        pub stickers_faved_limit: i32,
        pub channels_read_media_period: i32,
        pub tmp_sessions: Option<i32>,
        pub pinned_dialogs_count_max: i32,
        pub pinned_infolder_count_max: i32,
        pub call_receive_timeout_ms: i32,
        pub call_ring_timeout_ms: i32,
        pub call_connect_timeout_ms: i32,
        pub call_packet_timeout_ms: i32,
        pub me_url_prefix: String,
        pub autoupdate_url_prefix: Option<String>,
        pub gif_search_username: Option<String>,
        pub venue_search_username: Option<String>,
        pub img_search_username: Option<String>,
        pub static_maps_provider: Option<String>,
        pub caption_length_max: i32,
        pub message_length_max: i32,
        pub webfile_dc_id: i32,
        pub suggested_lang_code: Option<String>,
        pub lang_pack_version: Option<i32>,
        pub base_lang_pack_version: Option<i32>,
    }
    impl crate::Identifiable for Config {
        const CONSTRUCTOR_ID: u32 = 856375399;
    }
    impl crate::Serializable for Config {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.phonecalls_enabled { 2 } else { 0 }
                | if self.default_p2p_contacts { 8 } else { 0 }
                | if self.preload_featured_stickers {
                    16
                } else {
                    0
                }
                | if self.ignore_phone_entities { 32 } else { 0 }
                | if self.revoke_pm_inbox { 64 } else { 0 }
                | if self.blocked_mode { 256 } else { 0 }
                | if self.pfs_enabled { 8192 } else { 0 }
                | if self.tmp_sessions.is_some() { 1 } else { 0 }
                | if self.autoupdate_url_prefix.is_some() {
                    128
                } else {
                    0
                }
                | if self.gif_search_username.is_some() {
                    512
                } else {
                    0
                }
                | if self.venue_search_username.is_some() {
                    1024
                } else {
                    0
                }
                | if self.img_search_username.is_some() {
                    2048
                } else {
                    0
                }
                | if self.static_maps_provider.is_some() {
                    4096
                } else {
                    0
                }
                | if self.suggested_lang_code.is_some() {
                    4
                } else {
                    0
                }
                | if self.lang_pack_version.is_some() {
                    4
                } else {
                    0
                }
                | if self.base_lang_pack_version.is_some() {
                    4
                } else {
                    0
                })
            .serialize(buf);
            self.date.serialize(buf);
            self.expires.serialize(buf);
            self.test_mode.serialize(buf);
            self.this_dc.serialize(buf);
            self.dc_options.serialize(buf);
            self.dc_txt_domain_name.serialize(buf);
            self.chat_size_max.serialize(buf);
            self.megagroup_size_max.serialize(buf);
            self.forwarded_count_max.serialize(buf);
            self.online_update_period_ms.serialize(buf);
            self.offline_blur_timeout_ms.serialize(buf);
            self.offline_idle_timeout_ms.serialize(buf);
            self.online_cloud_timeout_ms.serialize(buf);
            self.notify_cloud_delay_ms.serialize(buf);
            self.notify_default_delay_ms.serialize(buf);
            self.push_chat_period_ms.serialize(buf);
            self.push_chat_limit.serialize(buf);
            self.saved_gifs_limit.serialize(buf);
            self.edit_time_limit.serialize(buf);
            self.revoke_time_limit.serialize(buf);
            self.revoke_pm_time_limit.serialize(buf);
            self.rating_e_decay.serialize(buf);
            self.stickers_recent_limit.serialize(buf);
            self.stickers_faved_limit.serialize(buf);
            self.channels_read_media_period.serialize(buf);
            if let Some(ref x) = self.tmp_sessions {
                x.serialize(buf);
            }
            self.pinned_dialogs_count_max.serialize(buf);
            self.pinned_infolder_count_max.serialize(buf);
            self.call_receive_timeout_ms.serialize(buf);
            self.call_ring_timeout_ms.serialize(buf);
            self.call_connect_timeout_ms.serialize(buf);
            self.call_packet_timeout_ms.serialize(buf);
            self.me_url_prefix.serialize(buf);
            if let Some(ref x) = self.autoupdate_url_prefix {
                x.serialize(buf);
            }
            if let Some(ref x) = self.gif_search_username {
                x.serialize(buf);
            }
            if let Some(ref x) = self.venue_search_username {
                x.serialize(buf);
            }
            if let Some(ref x) = self.img_search_username {
                x.serialize(buf);
            }
            if let Some(ref x) = self.static_maps_provider {
                x.serialize(buf);
            }
            self.caption_length_max.serialize(buf);
            self.message_length_max.serialize(buf);
            self.webfile_dc_id.serialize(buf);
            if let Some(ref x) = self.suggested_lang_code {
                x.serialize(buf);
            }
            if let Some(ref x) = self.lang_pack_version {
                x.serialize(buf);
            }
            if let Some(ref x) = self.base_lang_pack_version {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Config {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let phonecalls_enabled = (flags & 2) != 0;
            let default_p2p_contacts = (flags & 8) != 0;
            let preload_featured_stickers = (flags & 16) != 0;
            let ignore_phone_entities = (flags & 32) != 0;
            let revoke_pm_inbox = (flags & 64) != 0;
            let blocked_mode = (flags & 256) != 0;
            let pfs_enabled = (flags & 8192) != 0;
            let date = i32::deserialize(buf)?;
            let expires = i32::deserialize(buf)?;
            let test_mode = bool::deserialize(buf)?;
            let this_dc = i32::deserialize(buf)?;
            let dc_options = Vec::<crate::enums::DcOption>::deserialize(buf)?;
            let dc_txt_domain_name = String::deserialize(buf)?;
            let chat_size_max = i32::deserialize(buf)?;
            let megagroup_size_max = i32::deserialize(buf)?;
            let forwarded_count_max = i32::deserialize(buf)?;
            let online_update_period_ms = i32::deserialize(buf)?;
            let offline_blur_timeout_ms = i32::deserialize(buf)?;
            let offline_idle_timeout_ms = i32::deserialize(buf)?;
            let online_cloud_timeout_ms = i32::deserialize(buf)?;
            let notify_cloud_delay_ms = i32::deserialize(buf)?;
            let notify_default_delay_ms = i32::deserialize(buf)?;
            let push_chat_period_ms = i32::deserialize(buf)?;
            let push_chat_limit = i32::deserialize(buf)?;
            let saved_gifs_limit = i32::deserialize(buf)?;
            let edit_time_limit = i32::deserialize(buf)?;
            let revoke_time_limit = i32::deserialize(buf)?;
            let revoke_pm_time_limit = i32::deserialize(buf)?;
            let rating_e_decay = i32::deserialize(buf)?;
            let stickers_recent_limit = i32::deserialize(buf)?;
            let stickers_faved_limit = i32::deserialize(buf)?;
            let channels_read_media_period = i32::deserialize(buf)?;
            let tmp_sessions = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let pinned_dialogs_count_max = i32::deserialize(buf)?;
            let pinned_infolder_count_max = i32::deserialize(buf)?;
            let call_receive_timeout_ms = i32::deserialize(buf)?;
            let call_ring_timeout_ms = i32::deserialize(buf)?;
            let call_connect_timeout_ms = i32::deserialize(buf)?;
            let call_packet_timeout_ms = i32::deserialize(buf)?;
            let me_url_prefix = String::deserialize(buf)?;
            let autoupdate_url_prefix = if (flags & 128) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let gif_search_username = if (flags & 512) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let venue_search_username = if (flags & 1024) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let img_search_username = if (flags & 2048) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let static_maps_provider = if (flags & 4096) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let caption_length_max = i32::deserialize(buf)?;
            let message_length_max = i32::deserialize(buf)?;
            let webfile_dc_id = i32::deserialize(buf)?;
            let suggested_lang_code = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let lang_pack_version = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let base_lang_pack_version = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Config {
                phonecalls_enabled,
                default_p2p_contacts,
                preload_featured_stickers,
                ignore_phone_entities,
                revoke_pm_inbox,
                blocked_mode,
                pfs_enabled,
                date,
                expires,
                test_mode,
                this_dc,
                dc_options,
                dc_txt_domain_name,
                chat_size_max,
                megagroup_size_max,
                forwarded_count_max,
                online_update_period_ms,
                offline_blur_timeout_ms,
                offline_idle_timeout_ms,
                online_cloud_timeout_ms,
                notify_cloud_delay_ms,
                notify_default_delay_ms,
                push_chat_period_ms,
                push_chat_limit,
                saved_gifs_limit,
                edit_time_limit,
                revoke_time_limit,
                revoke_pm_time_limit,
                rating_e_decay,
                stickers_recent_limit,
                stickers_faved_limit,
                channels_read_media_period,
                tmp_sessions,
                pinned_dialogs_count_max,
                pinned_infolder_count_max,
                call_receive_timeout_ms,
                call_ring_timeout_ms,
                call_connect_timeout_ms,
                call_packet_timeout_ms,
                me_url_prefix,
                autoupdate_url_prefix,
                gif_search_username,
                venue_search_username,
                img_search_username,
                static_maps_provider,
                caption_length_max,
                message_length_max,
                webfile_dc_id,
                suggested_lang_code,
                lang_pack_version,
                base_lang_pack_version,
            })
        }
    }
    impl From<crate::enums::Config> for Config {
        fn from(x: crate::enums::Config) -> Self {
            match x {
                crate::enums::Config::Config(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Contact {
        pub user_id: i64,
        pub mutual: bool,
    }
    impl crate::Identifiable for Contact {
        const CONSTRUCTOR_ID: u32 = 341499403;
    }
    impl crate::Serializable for Contact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.mutual.serialize(buf);
        }
    }
    impl crate::Deserializable for Contact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let mutual = bool::deserialize(buf)?;
            Ok(Contact { user_id, mutual })
        }
    }
    impl From<crate::enums::Contact> for Contact {
        fn from(x: crate::enums::Contact) -> Self {
            match x {
                crate::enums::Contact::Contact(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ContactStatus {
        pub user_id: i64,
        pub status: crate::enums::UserStatus,
    }
    impl crate::Identifiable for ContactStatus {
        const CONSTRUCTOR_ID: u32 = 383348795;
    }
    impl crate::Serializable for ContactStatus {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.status.serialize(buf);
        }
    }
    impl crate::Deserializable for ContactStatus {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let status = crate::enums::UserStatus::deserialize(buf)?;
            Ok(ContactStatus { user_id, status })
        }
    }
    impl From<crate::enums::ContactStatus> for ContactStatus {
        fn from(x: crate::enums::ContactStatus) -> Self {
            match x {
                crate::enums::ContactStatus::Status(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DataJson {
        pub data: String,
    }
    impl crate::Identifiable for DataJson {
        const CONSTRUCTOR_ID: u32 = 2104790276;
    }
    impl crate::Serializable for DataJson {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for DataJson {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let data = String::deserialize(buf)?;
            Ok(DataJson { data })
        }
    }
    impl From<crate::enums::DataJson> for DataJson {
        fn from(x: crate::enums::DataJson) -> Self {
            match x {
                crate::enums::DataJson::Json(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DcOption {
        pub ipv6: bool,
        pub media_only: bool,
        pub tcpo_only: bool,
        pub cdn: bool,
        pub r#static: bool,
        pub id: i32,
        pub ip_address: String,
        pub port: i32,
        pub secret: Option<Vec<u8>>,
    }
    impl crate::Identifiable for DcOption {
        const CONSTRUCTOR_ID: u32 = 414687501;
    }
    impl crate::Serializable for DcOption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.ipv6 { 1 } else { 0 }
                | if self.media_only { 2 } else { 0 }
                | if self.tcpo_only { 4 } else { 0 }
                | if self.cdn { 8 } else { 0 }
                | if self.r#static { 16 } else { 0 }
                | if self.secret.is_some() { 1024 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.ip_address.serialize(buf);
            self.port.serialize(buf);
            if let Some(ref x) = self.secret {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for DcOption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let ipv6 = (flags & 1) != 0;
            let media_only = (flags & 2) != 0;
            let tcpo_only = (flags & 4) != 0;
            let cdn = (flags & 8) != 0;
            let r#static = (flags & 16) != 0;
            let id = i32::deserialize(buf)?;
            let ip_address = String::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            let secret = if (flags & 1024) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            Ok(DcOption {
                ipv6,
                media_only,
                tcpo_only,
                cdn,
                r#static,
                id,
                ip_address,
                port,
                secret,
            })
        }
    }
    impl From<crate::enums::DcOption> for DcOption {
        fn from(x: crate::enums::DcOption) -> Self {
            match x {
                crate::enums::DcOption::Option(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroyAuthKeyFail {}
    impl crate::Identifiable for DestroyAuthKeyFail {
        const CONSTRUCTOR_ID: u32 = 3926956819;
    }
    impl crate::Serializable for DestroyAuthKeyFail {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for DestroyAuthKeyFail {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(DestroyAuthKeyFail {})
        }
    }
    impl TryFrom<crate::enums::DestroyAuthKeyRes> for DestroyAuthKeyFail {
        type Error = ();
        fn try_from(x: crate::enums::DestroyAuthKeyRes) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DestroyAuthKeyRes::DestroyAuthKeyFail => Ok(DestroyAuthKeyFail {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroyAuthKeyNone {}
    impl crate::Identifiable for DestroyAuthKeyNone {
        const CONSTRUCTOR_ID: u32 = 178201177;
    }
    impl crate::Serializable for DestroyAuthKeyNone {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for DestroyAuthKeyNone {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(DestroyAuthKeyNone {})
        }
    }
    impl TryFrom<crate::enums::DestroyAuthKeyRes> for DestroyAuthKeyNone {
        type Error = ();
        fn try_from(x: crate::enums::DestroyAuthKeyRes) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DestroyAuthKeyRes::DestroyAuthKeyNone => Ok(DestroyAuthKeyNone {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroyAuthKeyOk {}
    impl crate::Identifiable for DestroyAuthKeyOk {
        const CONSTRUCTOR_ID: u32 = 4133544404;
    }
    impl crate::Serializable for DestroyAuthKeyOk {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for DestroyAuthKeyOk {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(DestroyAuthKeyOk {})
        }
    }
    impl TryFrom<crate::enums::DestroyAuthKeyRes> for DestroyAuthKeyOk {
        type Error = ();
        fn try_from(x: crate::enums::DestroyAuthKeyRes) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DestroyAuthKeyRes::DestroyAuthKeyOk => Ok(DestroyAuthKeyOk {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroySessionNone {
        pub session_id: i64,
    }
    impl crate::Identifiable for DestroySessionNone {
        const CONSTRUCTOR_ID: u32 = 1658015945;
    }
    impl crate::Serializable for DestroySessionNone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.session_id.serialize(buf);
        }
    }
    impl crate::Deserializable for DestroySessionNone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let session_id = i64::deserialize(buf)?;
            Ok(DestroySessionNone { session_id })
        }
    }
    impl TryFrom<crate::enums::DestroySessionRes> for DestroySessionNone {
        type Error = ();
        fn try_from(x: crate::enums::DestroySessionRes) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DestroySessionRes::DestroySessionNone(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroySessionOk {
        pub session_id: i64,
    }
    impl crate::Identifiable for DestroySessionOk {
        const CONSTRUCTOR_ID: u32 = 3793765884;
    }
    impl crate::Serializable for DestroySessionOk {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.session_id.serialize(buf);
        }
    }
    impl crate::Deserializable for DestroySessionOk {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let session_id = i64::deserialize(buf)?;
            Ok(DestroySessionOk { session_id })
        }
    }
    impl TryFrom<crate::enums::DestroySessionRes> for DestroySessionOk {
        type Error = ();
        fn try_from(x: crate::enums::DestroySessionRes) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DestroySessionRes::DestroySessionOk(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DhGenFail {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce_hash3: [u8; 16],
    }
    impl crate::Identifiable for DhGenFail {
        const CONSTRUCTOR_ID: u32 = 2795351554;
    }
    impl crate::Serializable for DhGenFail {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce_hash3.serialize(buf);
        }
    }
    impl crate::Deserializable for DhGenFail {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce_hash3 = <[u8; 16]>::deserialize(buf)?;
            Ok(DhGenFail {
                nonce,
                server_nonce,
                new_nonce_hash3,
            })
        }
    }
    impl TryFrom<crate::enums::SetClientDhParamsAnswer> for DhGenFail {
        type Error = ();
        fn try_from(x: crate::enums::SetClientDhParamsAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SetClientDhParamsAnswer::DhGenFail(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DhGenOk {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce_hash1: [u8; 16],
    }
    impl crate::Identifiable for DhGenOk {
        const CONSTRUCTOR_ID: u32 = 1003222836;
    }
    impl crate::Serializable for DhGenOk {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce_hash1.serialize(buf);
        }
    }
    impl crate::Deserializable for DhGenOk {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce_hash1 = <[u8; 16]>::deserialize(buf)?;
            Ok(DhGenOk {
                nonce,
                server_nonce,
                new_nonce_hash1,
            })
        }
    }
    impl TryFrom<crate::enums::SetClientDhParamsAnswer> for DhGenOk {
        type Error = ();
        fn try_from(x: crate::enums::SetClientDhParamsAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SetClientDhParamsAnswer::DhGenOk(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DhGenRetry {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce_hash2: [u8; 16],
    }
    impl crate::Identifiable for DhGenRetry {
        const CONSTRUCTOR_ID: u32 = 1188831161;
    }
    impl crate::Serializable for DhGenRetry {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce_hash2.serialize(buf);
        }
    }
    impl crate::Deserializable for DhGenRetry {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce_hash2 = <[u8; 16]>::deserialize(buf)?;
            Ok(DhGenRetry {
                nonce,
                server_nonce,
                new_nonce_hash2,
            })
        }
    }
    impl TryFrom<crate::enums::SetClientDhParamsAnswer> for DhGenRetry {
        type Error = ();
        fn try_from(x: crate::enums::SetClientDhParamsAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SetClientDhParamsAnswer::DhGenRetry(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Dialog {
        pub pinned: bool,
        pub unread_mark: bool,
        pub peer: crate::enums::Peer,
        pub top_message: i32,
        pub read_inbox_max_id: i32,
        pub read_outbox_max_id: i32,
        pub unread_count: i32,
        pub unread_mentions_count: i32,
        pub notify_settings: crate::enums::PeerNotifySettings,
        pub pts: Option<i32>,
        pub draft: Option<crate::enums::DraftMessage>,
        pub folder_id: Option<i32>,
    }
    impl crate::Identifiable for Dialog {
        const CONSTRUCTOR_ID: u32 = 739712882;
    }
    impl crate::Serializable for Dialog {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.pinned { 4 } else { 0 }
                | if self.unread_mark { 8 } else { 0 }
                | if self.pts.is_some() { 1 } else { 0 }
                | if self.draft.is_some() { 2 } else { 0 }
                | if self.folder_id.is_some() { 16 } else { 0 })
            .serialize(buf);
            self.peer.serialize(buf);
            self.top_message.serialize(buf);
            self.read_inbox_max_id.serialize(buf);
            self.read_outbox_max_id.serialize(buf);
            self.unread_count.serialize(buf);
            self.unread_mentions_count.serialize(buf);
            self.notify_settings.serialize(buf);
            if let Some(ref x) = self.pts {
                x.serialize(buf);
            }
            if let Some(ref x) = self.draft {
                x.serialize(buf);
            }
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Dialog {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let pinned = (flags & 4) != 0;
            let unread_mark = (flags & 8) != 0;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let top_message = i32::deserialize(buf)?;
            let read_inbox_max_id = i32::deserialize(buf)?;
            let read_outbox_max_id = i32::deserialize(buf)?;
            let unread_count = i32::deserialize(buf)?;
            let unread_mentions_count = i32::deserialize(buf)?;
            let notify_settings = crate::enums::PeerNotifySettings::deserialize(buf)?;
            let pts = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let draft = if (flags & 2) != 0 {
                Some(crate::enums::DraftMessage::deserialize(buf)?)
            } else {
                None
            };
            let folder_id = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Dialog {
                pinned,
                unread_mark,
                peer,
                top_message,
                read_inbox_max_id,
                read_outbox_max_id,
                unread_count,
                unread_mentions_count,
                notify_settings,
                pts,
                draft,
                folder_id,
            })
        }
    }
    impl TryFrom<crate::enums::Dialog> for Dialog {
        type Error = ();
        fn try_from(x: crate::enums::Dialog) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Dialog::Dialog(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DialogFilter {
        pub contacts: bool,
        pub non_contacts: bool,
        pub groups: bool,
        pub broadcasts: bool,
        pub bots: bool,
        pub exclude_muted: bool,
        pub exclude_read: bool,
        pub exclude_archived: bool,
        pub id: i32,
        pub title: String,
        pub emoticon: Option<String>,
        pub pinned_peers: Vec<crate::enums::InputPeer>,
        pub include_peers: Vec<crate::enums::InputPeer>,
        pub exclude_peers: Vec<crate::enums::InputPeer>,
    }
    impl crate::Identifiable for DialogFilter {
        const CONSTRUCTOR_ID: u32 = 1949890536;
    }
    impl crate::Serializable for DialogFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.contacts { 1 } else { 0 }
                | if self.non_contacts { 2 } else { 0 }
                | if self.groups { 4 } else { 0 }
                | if self.broadcasts { 8 } else { 0 }
                | if self.bots { 16 } else { 0 }
                | if self.exclude_muted { 2048 } else { 0 }
                | if self.exclude_read { 4096 } else { 0 }
                | if self.exclude_archived { 8192 } else { 0 }
                | if self.emoticon.is_some() { 33554432 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.title.serialize(buf);
            if let Some(ref x) = self.emoticon {
                x.serialize(buf);
            }
            self.pinned_peers.serialize(buf);
            self.include_peers.serialize(buf);
            self.exclude_peers.serialize(buf);
        }
    }
    impl crate::Deserializable for DialogFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let contacts = (flags & 1) != 0;
            let non_contacts = (flags & 2) != 0;
            let groups = (flags & 4) != 0;
            let broadcasts = (flags & 8) != 0;
            let bots = (flags & 16) != 0;
            let exclude_muted = (flags & 2048) != 0;
            let exclude_read = (flags & 4096) != 0;
            let exclude_archived = (flags & 8192) != 0;
            let id = i32::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let emoticon = if (flags & 33554432) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let pinned_peers = Vec::<crate::enums::InputPeer>::deserialize(buf)?;
            let include_peers = Vec::<crate::enums::InputPeer>::deserialize(buf)?;
            let exclude_peers = Vec::<crate::enums::InputPeer>::deserialize(buf)?;
            Ok(DialogFilter {
                contacts,
                non_contacts,
                groups,
                broadcasts,
                bots,
                exclude_muted,
                exclude_read,
                exclude_archived,
                id,
                title,
                emoticon,
                pinned_peers,
                include_peers,
                exclude_peers,
            })
        }
    }
    impl From<crate::enums::DialogFilter> for DialogFilter {
        fn from(x: crate::enums::DialogFilter) -> Self {
            match x {
                crate::enums::DialogFilter::Filter(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DialogFilterSuggested {
        pub filter: crate::enums::DialogFilter,
        pub description: String,
    }
    impl crate::Identifiable for DialogFilterSuggested {
        const CONSTRUCTOR_ID: u32 = 2004110666;
    }
    impl crate::Serializable for DialogFilterSuggested {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.filter.serialize(buf);
            self.description.serialize(buf);
        }
    }
    impl crate::Deserializable for DialogFilterSuggested {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let filter = crate::enums::DialogFilter::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            Ok(DialogFilterSuggested {
                filter,
                description,
            })
        }
    }
    impl From<crate::enums::DialogFilterSuggested> for DialogFilterSuggested {
        fn from(x: crate::enums::DialogFilterSuggested) -> Self {
            match x {
                crate::enums::DialogFilterSuggested::Suggested(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DialogFolder {
        pub pinned: bool,
        pub folder: crate::enums::Folder,
        pub peer: crate::enums::Peer,
        pub top_message: i32,
        pub unread_muted_peers_count: i32,
        pub unread_unmuted_peers_count: i32,
        pub unread_muted_messages_count: i32,
        pub unread_unmuted_messages_count: i32,
    }
    impl crate::Identifiable for DialogFolder {
        const CONSTRUCTOR_ID: u32 = 1908216652;
    }
    impl crate::Serializable for DialogFolder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.pinned { 4 } else { 0 }).serialize(buf);
            self.folder.serialize(buf);
            self.peer.serialize(buf);
            self.top_message.serialize(buf);
            self.unread_muted_peers_count.serialize(buf);
            self.unread_unmuted_peers_count.serialize(buf);
            self.unread_muted_messages_count.serialize(buf);
            self.unread_unmuted_messages_count.serialize(buf);
        }
    }
    impl crate::Deserializable for DialogFolder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let pinned = (flags & 4) != 0;
            let folder = crate::enums::Folder::deserialize(buf)?;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let top_message = i32::deserialize(buf)?;
            let unread_muted_peers_count = i32::deserialize(buf)?;
            let unread_unmuted_peers_count = i32::deserialize(buf)?;
            let unread_muted_messages_count = i32::deserialize(buf)?;
            let unread_unmuted_messages_count = i32::deserialize(buf)?;
            Ok(DialogFolder {
                pinned,
                folder,
                peer,
                top_message,
                unread_muted_peers_count,
                unread_unmuted_peers_count,
                unread_muted_messages_count,
                unread_unmuted_messages_count,
            })
        }
    }
    impl TryFrom<crate::enums::Dialog> for DialogFolder {
        type Error = ();
        fn try_from(x: crate::enums::Dialog) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Dialog::Folder(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DialogPeer {
        pub peer: crate::enums::Peer,
    }
    impl crate::Identifiable for DialogPeer {
        const CONSTRUCTOR_ID: u32 = 3849174789;
    }
    impl crate::Serializable for DialogPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for DialogPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            Ok(DialogPeer { peer })
        }
    }
    impl TryFrom<crate::enums::DialogPeer> for DialogPeer {
        type Error = ();
        fn try_from(x: crate::enums::DialogPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DialogPeer::Peer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DialogPeerFolder {
        pub folder_id: i32,
    }
    impl crate::Identifiable for DialogPeerFolder {
        const CONSTRUCTOR_ID: u32 = 1363483106;
    }
    impl crate::Serializable for DialogPeerFolder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.folder_id.serialize(buf);
        }
    }
    impl crate::Deserializable for DialogPeerFolder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let folder_id = i32::deserialize(buf)?;
            Ok(DialogPeerFolder { folder_id })
        }
    }
    impl TryFrom<crate::enums::DialogPeer> for DialogPeerFolder {
        type Error = ();
        fn try_from(x: crate::enums::DialogPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DialogPeer::Folder(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Document {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
        pub date: i32,
        pub mime_type: String,
        pub size: i32,
        pub thumbs: Option<Vec<crate::enums::PhotoSize>>,
        pub video_thumbs: Option<Vec<crate::enums::VideoSize>>,
        pub dc_id: i32,
        pub attributes: Vec<crate::enums::DocumentAttribute>,
    }
    impl crate::Identifiable for Document {
        const CONSTRUCTOR_ID: u32 = 512177195;
    }
    impl crate::Serializable for Document {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.thumbs.is_some() { 1 } else { 0 }
                | if self.video_thumbs.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
            self.date.serialize(buf);
            self.mime_type.serialize(buf);
            self.size.serialize(buf);
            if let Some(ref x) = self.thumbs {
                x.serialize(buf);
            }
            if let Some(ref x) = self.video_thumbs {
                x.serialize(buf);
            }
            self.dc_id.serialize(buf);
            self.attributes.serialize(buf);
        }
    }
    impl crate::Deserializable for Document {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let mime_type = String::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let thumbs = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::PhotoSize>::deserialize(buf)?)
            } else {
                None
            };
            let video_thumbs = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::VideoSize>::deserialize(buf)?)
            } else {
                None
            };
            let dc_id = i32::deserialize(buf)?;
            let attributes = Vec::<crate::enums::DocumentAttribute>::deserialize(buf)?;
            Ok(Document {
                id,
                access_hash,
                file_reference,
                date,
                mime_type,
                size,
                thumbs,
                video_thumbs,
                dc_id,
                attributes,
            })
        }
    }
    impl TryFrom<crate::enums::Document> for Document {
        type Error = ();
        fn try_from(x: crate::enums::Document) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Document::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeAnimated {}
    impl crate::Identifiable for DocumentAttributeAnimated {
        const CONSTRUCTOR_ID: u32 = 297109817;
    }
    impl crate::Serializable for DocumentAttributeAnimated {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for DocumentAttributeAnimated {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(DocumentAttributeAnimated {})
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeAnimated {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::Animated => Ok(DocumentAttributeAnimated {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeAudio {
        pub voice: bool,
        pub duration: i32,
        pub title: Option<String>,
        pub performer: Option<String>,
        pub waveform: Option<Vec<u8>>,
    }
    impl crate::Identifiable for DocumentAttributeAudio {
        const CONSTRUCTOR_ID: u32 = 2555574726;
    }
    impl crate::Serializable for DocumentAttributeAudio {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.voice { 1024 } else { 0 }
                | if self.title.is_some() { 1 } else { 0 }
                | if self.performer.is_some() { 2 } else { 0 }
                | if self.waveform.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.duration.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.performer {
                x.serialize(buf);
            }
            if let Some(ref x) = self.waveform {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for DocumentAttributeAudio {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let voice = (flags & 1024) != 0;
            let duration = i32::deserialize(buf)?;
            let title = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let performer = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let waveform = if (flags & 4) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            Ok(DocumentAttributeAudio {
                voice,
                duration,
                title,
                performer,
                waveform,
            })
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeAudio {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::Audio(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeFilename {
        pub file_name: String,
    }
    impl crate::Identifiable for DocumentAttributeFilename {
        const CONSTRUCTOR_ID: u32 = 358154344;
    }
    impl crate::Serializable for DocumentAttributeFilename {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.file_name.serialize(buf);
        }
    }
    impl crate::Deserializable for DocumentAttributeFilename {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let file_name = String::deserialize(buf)?;
            Ok(DocumentAttributeFilename { file_name })
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeFilename {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::Filename(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeHasStickers {}
    impl crate::Identifiable for DocumentAttributeHasStickers {
        const CONSTRUCTOR_ID: u32 = 2550256375;
    }
    impl crate::Serializable for DocumentAttributeHasStickers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for DocumentAttributeHasStickers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(DocumentAttributeHasStickers {})
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeHasStickers {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::HasStickers => Ok(DocumentAttributeHasStickers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeImageSize {
        pub w: i32,
        pub h: i32,
    }
    impl crate::Identifiable for DocumentAttributeImageSize {
        const CONSTRUCTOR_ID: u32 = 1815593308;
    }
    impl crate::Serializable for DocumentAttributeImageSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.w.serialize(buf);
            self.h.serialize(buf);
        }
    }
    impl crate::Deserializable for DocumentAttributeImageSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            Ok(DocumentAttributeImageSize { w, h })
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeImageSize {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::ImageSize(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeSticker {
        pub mask: bool,
        pub alt: String,
        pub stickerset: crate::enums::InputStickerSet,
        pub mask_coords: Option<crate::enums::MaskCoords>,
    }
    impl crate::Identifiable for DocumentAttributeSticker {
        const CONSTRUCTOR_ID: u32 = 1662637586;
    }
    impl crate::Serializable for DocumentAttributeSticker {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.mask { 2 } else { 0 } | if self.mask_coords.is_some() { 1 } else { 0 })
                .serialize(buf);
            self.alt.serialize(buf);
            self.stickerset.serialize(buf);
            if let Some(ref x) = self.mask_coords {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for DocumentAttributeSticker {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let mask = (flags & 2) != 0;
            let alt = String::deserialize(buf)?;
            let stickerset = crate::enums::InputStickerSet::deserialize(buf)?;
            let mask_coords = if (flags & 1) != 0 {
                Some(crate::enums::MaskCoords::deserialize(buf)?)
            } else {
                None
            };
            Ok(DocumentAttributeSticker {
                mask,
                alt,
                stickerset,
                mask_coords,
            })
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeSticker {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::Sticker(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentAttributeVideo {
        pub round_message: bool,
        pub supports_streaming: bool,
        pub duration: i32,
        pub w: i32,
        pub h: i32,
    }
    impl crate::Identifiable for DocumentAttributeVideo {
        const CONSTRUCTOR_ID: u32 = 250621158;
    }
    impl crate::Serializable for DocumentAttributeVideo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.round_message { 1 } else { 0 }
                | if self.supports_streaming { 2 } else { 0 })
            .serialize(buf);
            self.duration.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
        }
    }
    impl crate::Deserializable for DocumentAttributeVideo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let round_message = (flags & 1) != 0;
            let supports_streaming = (flags & 2) != 0;
            let duration = i32::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            Ok(DocumentAttributeVideo {
                round_message,
                supports_streaming,
                duration,
                w,
                h,
            })
        }
    }
    impl TryFrom<crate::enums::DocumentAttribute> for DocumentAttributeVideo {
        type Error = ();
        fn try_from(x: crate::enums::DocumentAttribute) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DocumentAttribute::Video(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DocumentEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for DocumentEmpty {
        const CONSTRUCTOR_ID: u32 = 922273905;
    }
    impl crate::Serializable for DocumentEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for DocumentEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(DocumentEmpty { id })
        }
    }
    impl TryFrom<crate::enums::Document> for DocumentEmpty {
        type Error = ();
        fn try_from(x: crate::enums::Document) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Document::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DraftMessage {
        pub no_webpage: bool,
        pub reply_to_msg_id: Option<i32>,
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub date: i32,
    }
    impl crate::Identifiable for DraftMessage {
        const CONSTRUCTOR_ID: u32 = 4253970719;
    }
    impl crate::Serializable for DraftMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.no_webpage { 2 } else { 0 }
                | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                | if self.entities.is_some() { 8 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.reply_to_msg_id {
                x.serialize(buf);
            }
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for DraftMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let no_webpage = (flags & 2) != 0;
            let reply_to_msg_id = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let message = String::deserialize(buf)?;
            let entities = if (flags & 8) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let date = i32::deserialize(buf)?;
            Ok(DraftMessage {
                no_webpage,
                reply_to_msg_id,
                message,
                entities,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::DraftMessage> for DraftMessage {
        type Error = ();
        fn try_from(x: crate::enums::DraftMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DraftMessage::Message(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DraftMessageEmpty {
        pub date: Option<i32>,
    }
    impl crate::Identifiable for DraftMessageEmpty {
        const CONSTRUCTOR_ID: u32 = 453805082;
    }
    impl crate::Serializable for DraftMessageEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.date.is_some() { 1 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for DraftMessageEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let date = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(DraftMessageEmpty { date })
        }
    }
    impl TryFrom<crate::enums::DraftMessage> for DraftMessageEmpty {
        type Error = ();
        fn try_from(x: crate::enums::DraftMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::DraftMessage::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EmojiKeyword {
        pub keyword: String,
        pub emoticons: Vec<String>,
    }
    impl crate::Identifiable for EmojiKeyword {
        const CONSTRUCTOR_ID: u32 = 3585325561;
    }
    impl crate::Serializable for EmojiKeyword {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.keyword.serialize(buf);
            self.emoticons.serialize(buf);
        }
    }
    impl crate::Deserializable for EmojiKeyword {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let keyword = String::deserialize(buf)?;
            let emoticons = Vec::<String>::deserialize(buf)?;
            Ok(EmojiKeyword { keyword, emoticons })
        }
    }
    impl TryFrom<crate::enums::EmojiKeyword> for EmojiKeyword {
        type Error = ();
        fn try_from(x: crate::enums::EmojiKeyword) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EmojiKeyword::Keyword(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EmojiKeywordDeleted {
        pub keyword: String,
        pub emoticons: Vec<String>,
    }
    impl crate::Identifiable for EmojiKeywordDeleted {
        const CONSTRUCTOR_ID: u32 = 594408994;
    }
    impl crate::Serializable for EmojiKeywordDeleted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.keyword.serialize(buf);
            self.emoticons.serialize(buf);
        }
    }
    impl crate::Deserializable for EmojiKeywordDeleted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let keyword = String::deserialize(buf)?;
            let emoticons = Vec::<String>::deserialize(buf)?;
            Ok(EmojiKeywordDeleted { keyword, emoticons })
        }
    }
    impl TryFrom<crate::enums::EmojiKeyword> for EmojiKeywordDeleted {
        type Error = ();
        fn try_from(x: crate::enums::EmojiKeyword) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EmojiKeyword::Deleted(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EmojiKeywordsDifference {
        pub lang_code: String,
        pub from_version: i32,
        pub version: i32,
        pub keywords: Vec<crate::enums::EmojiKeyword>,
    }
    impl crate::Identifiable for EmojiKeywordsDifference {
        const CONSTRUCTOR_ID: u32 = 1556570557;
    }
    impl crate::Serializable for EmojiKeywordsDifference {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.lang_code.serialize(buf);
            self.from_version.serialize(buf);
            self.version.serialize(buf);
            self.keywords.serialize(buf);
        }
    }
    impl crate::Deserializable for EmojiKeywordsDifference {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let lang_code = String::deserialize(buf)?;
            let from_version = i32::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            let keywords = Vec::<crate::enums::EmojiKeyword>::deserialize(buf)?;
            Ok(EmojiKeywordsDifference {
                lang_code,
                from_version,
                version,
                keywords,
            })
        }
    }
    impl From<crate::enums::EmojiKeywordsDifference> for EmojiKeywordsDifference {
        fn from(x: crate::enums::EmojiKeywordsDifference) -> Self {
            match x {
                crate::enums::EmojiKeywordsDifference::Difference(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EmojiLanguage {
        pub lang_code: String,
    }
    impl crate::Identifiable for EmojiLanguage {
        const CONSTRUCTOR_ID: u32 = 3019592545;
    }
    impl crate::Serializable for EmojiLanguage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.lang_code.serialize(buf);
        }
    }
    impl crate::Deserializable for EmojiLanguage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let lang_code = String::deserialize(buf)?;
            Ok(EmojiLanguage { lang_code })
        }
    }
    impl From<crate::enums::EmojiLanguage> for EmojiLanguage {
        fn from(x: crate::enums::EmojiLanguage) -> Self {
            match x {
                crate::enums::EmojiLanguage::Language(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EmojiUrl {
        pub url: String,
    }
    impl crate::Identifiable for EmojiUrl {
        const CONSTRUCTOR_ID: u32 = 2775937949;
    }
    impl crate::Serializable for EmojiUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for EmojiUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            Ok(EmojiUrl { url })
        }
    }
    impl From<crate::enums::EmojiUrl> for EmojiUrl {
        fn from(x: crate::enums::EmojiUrl) -> Self {
            match x {
                crate::enums::EmojiUrl::Url(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedChat {
        pub id: i32,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub g_a_or_b: Vec<u8>,
        pub key_fingerprint: i64,
    }
    impl crate::Identifiable for EncryptedChat {
        const CONSTRUCTOR_ID: u32 = 1643173063;
    }
    impl crate::Serializable for EncryptedChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.g_a_or_b.serialize(buf);
            self.key_fingerprint.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let g_a_or_b = Vec::<u8>::deserialize(buf)?;
            let key_fingerprint = i64::deserialize(buf)?;
            Ok(EncryptedChat {
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                g_a_or_b,
                key_fingerprint,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedChat> for EncryptedChat {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedChat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedChat::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedChatDiscarded {
        pub history_deleted: bool,
        pub id: i32,
    }
    impl crate::Identifiable for EncryptedChatDiscarded {
        const CONSTRUCTOR_ID: u32 = 505183301;
    }
    impl crate::Serializable for EncryptedChatDiscarded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.history_deleted { 1 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedChatDiscarded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let history_deleted = (flags & 1) != 0;
            let id = i32::deserialize(buf)?;
            Ok(EncryptedChatDiscarded {
                history_deleted,
                id,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedChat> for EncryptedChatDiscarded {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedChat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedChat::Discarded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedChatEmpty {
        pub id: i32,
    }
    impl crate::Identifiable for EncryptedChatEmpty {
        const CONSTRUCTOR_ID: u32 = 2877210784;
    }
    impl crate::Serializable for EncryptedChatEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedChatEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            Ok(EncryptedChatEmpty { id })
        }
    }
    impl TryFrom<crate::enums::EncryptedChat> for EncryptedChatEmpty {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedChat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedChat::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedChatRequested {
        pub folder_id: Option<i32>,
        pub id: i32,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub g_a: Vec<u8>,
    }
    impl crate::Identifiable for EncryptedChatRequested {
        const CONSTRUCTOR_ID: u32 = 1223809356;
    }
    impl crate::Serializable for EncryptedChatRequested {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.folder_id.is_some() { 1 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.g_a.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedChatRequested {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let folder_id = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let id = i32::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let g_a = Vec::<u8>::deserialize(buf)?;
            Ok(EncryptedChatRequested {
                folder_id,
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                g_a,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedChat> for EncryptedChatRequested {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedChat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedChat::Requested(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedChatWaiting {
        pub id: i32,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
    }
    impl crate::Identifiable for EncryptedChatWaiting {
        const CONSTRUCTOR_ID: u32 = 1722964307;
    }
    impl crate::Serializable for EncryptedChatWaiting {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedChatWaiting {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            Ok(EncryptedChatWaiting {
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedChat> for EncryptedChatWaiting {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedChat) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedChat::Waiting(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedFile {
        pub id: i64,
        pub access_hash: i64,
        pub size: i32,
        pub dc_id: i32,
        pub key_fingerprint: i32,
    }
    impl crate::Identifiable for EncryptedFile {
        const CONSTRUCTOR_ID: u32 = 1248893260;
    }
    impl crate::Serializable for EncryptedFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.size.serialize(buf);
            self.dc_id.serialize(buf);
            self.key_fingerprint.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let dc_id = i32::deserialize(buf)?;
            let key_fingerprint = i32::deserialize(buf)?;
            Ok(EncryptedFile {
                id,
                access_hash,
                size,
                dc_id,
                key_fingerprint,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedFile> for EncryptedFile {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedFile::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedFileEmpty {}
    impl crate::Identifiable for EncryptedFileEmpty {
        const CONSTRUCTOR_ID: u32 = 3256830334;
    }
    impl crate::Serializable for EncryptedFileEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for EncryptedFileEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(EncryptedFileEmpty {})
        }
    }
    impl TryFrom<crate::enums::EncryptedFile> for EncryptedFileEmpty {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedFile::Empty => Ok(EncryptedFileEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedMessage {
        pub random_id: i64,
        pub chat_id: i32,
        pub date: i32,
        pub bytes: Vec<u8>,
        pub file: crate::enums::EncryptedFile,
    }
    impl crate::Identifiable for EncryptedMessage {
        const CONSTRUCTOR_ID: u32 = 3977822488;
    }
    impl crate::Serializable for EncryptedMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.random_id.serialize(buf);
            self.chat_id.serialize(buf);
            self.date.serialize(buf);
            self.bytes.serialize(buf);
            self.file.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let random_id = i64::deserialize(buf)?;
            let chat_id = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let bytes = Vec::<u8>::deserialize(buf)?;
            let file = crate::enums::EncryptedFile::deserialize(buf)?;
            Ok(EncryptedMessage {
                random_id,
                chat_id,
                date,
                bytes,
                file,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedMessage> for EncryptedMessage {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedMessage::Message(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct EncryptedMessageService {
        pub random_id: i64,
        pub chat_id: i32,
        pub date: i32,
        pub bytes: Vec<u8>,
    }
    impl crate::Identifiable for EncryptedMessageService {
        const CONSTRUCTOR_ID: u32 = 594758406;
    }
    impl crate::Serializable for EncryptedMessageService {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.random_id.serialize(buf);
            self.chat_id.serialize(buf);
            self.date.serialize(buf);
            self.bytes.serialize(buf);
        }
    }
    impl crate::Deserializable for EncryptedMessageService {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let random_id = i64::deserialize(buf)?;
            let chat_id = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let bytes = Vec::<u8>::deserialize(buf)?;
            Ok(EncryptedMessageService {
                random_id,
                chat_id,
                date,
                bytes,
            })
        }
    }
    impl TryFrom<crate::enums::EncryptedMessage> for EncryptedMessageService {
        type Error = ();
        fn try_from(x: crate::enums::EncryptedMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::EncryptedMessage::Service(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Error {
        pub code: i32,
        pub text: String,
    }
    impl crate::Identifiable for Error {
        const CONSTRUCTOR_ID: u32 = 3300522427;
    }
    impl crate::Serializable for Error {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.code.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for Error {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let code = i32::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(Error { code, text })
        }
    }
    impl From<crate::enums::Error> for Error {
        fn from(x: crate::enums::Error) -> Self {
            match x {
                crate::enums::Error::Error(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ExportedMessageLink {
        pub link: String,
        pub html: String,
    }
    impl crate::Identifiable for ExportedMessageLink {
        const CONSTRUCTOR_ID: u32 = 1571494644;
    }
    impl crate::Serializable for ExportedMessageLink {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.link.serialize(buf);
            self.html.serialize(buf);
        }
    }
    impl crate::Deserializable for ExportedMessageLink {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let link = String::deserialize(buf)?;
            let html = String::deserialize(buf)?;
            Ok(ExportedMessageLink { link, html })
        }
    }
    impl From<crate::enums::ExportedMessageLink> for ExportedMessageLink {
        fn from(x: crate::enums::ExportedMessageLink) -> Self {
            match x {
                crate::enums::ExportedMessageLink::Link(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct FileHash {
        pub offset: i32,
        pub limit: i32,
        pub hash: Vec<u8>,
    }
    impl crate::Identifiable for FileHash {
        const CONSTRUCTOR_ID: u32 = 1648543603;
    }
    impl crate::Serializable for FileHash {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.limit.serialize(buf);
            self.hash.serialize(buf);
        }
    }
    impl crate::Deserializable for FileHash {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let limit = i32::deserialize(buf)?;
            let hash = Vec::<u8>::deserialize(buf)?;
            Ok(FileHash {
                offset,
                limit,
                hash,
            })
        }
    }
    impl From<crate::enums::FileHash> for FileHash {
        fn from(x: crate::enums::FileHash) -> Self {
            match x {
                crate::enums::FileHash::Hash(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Folder {
        pub autofill_new_broadcasts: bool,
        pub autofill_public_groups: bool,
        pub autofill_new_correspondents: bool,
        pub id: i32,
        pub title: String,
        pub photo: Option<crate::enums::ChatPhoto>,
    }
    impl crate::Identifiable for Folder {
        const CONSTRUCTOR_ID: u32 = 4283715173;
    }
    impl crate::Serializable for Folder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.autofill_new_broadcasts { 1 } else { 0 }
                | if self.autofill_public_groups { 2 } else { 0 }
                | if self.autofill_new_correspondents {
                    4
                } else {
                    0
                }
                | if self.photo.is_some() { 8 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.title.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Folder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let autofill_new_broadcasts = (flags & 1) != 0;
            let autofill_public_groups = (flags & 2) != 0;
            let autofill_new_correspondents = (flags & 4) != 0;
            let id = i32::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let photo = if (flags & 8) != 0 {
                Some(crate::enums::ChatPhoto::deserialize(buf)?)
            } else {
                None
            };
            Ok(Folder {
                autofill_new_broadcasts,
                autofill_public_groups,
                autofill_new_correspondents,
                id,
                title,
                photo,
            })
        }
    }
    impl From<crate::enums::Folder> for Folder {
        fn from(x: crate::enums::Folder) -> Self {
            match x {
                crate::enums::Folder::Folder(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct FolderPeer {
        pub peer: crate::enums::Peer,
        pub folder_id: i32,
    }
    impl crate::Identifiable for FolderPeer {
        const CONSTRUCTOR_ID: u32 = 3921323624;
    }
    impl crate::Serializable for FolderPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.folder_id.serialize(buf);
        }
    }
    impl crate::Deserializable for FolderPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let folder_id = i32::deserialize(buf)?;
            Ok(FolderPeer { peer, folder_id })
        }
    }
    impl From<crate::enums::FolderPeer> for FolderPeer {
        fn from(x: crate::enums::FolderPeer) -> Self {
            match x {
                crate::enums::FolderPeer::Peer(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct FutureSalt {
        pub valid_since: i32,
        pub valid_until: i32,
        pub salt: i64,
    }
    impl crate::Identifiable for FutureSalt {
        const CONSTRUCTOR_ID: u32 = 155834844;
    }
    impl crate::Serializable for FutureSalt {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.valid_since.serialize(buf);
            self.valid_until.serialize(buf);
            self.salt.serialize(buf);
        }
    }
    impl crate::Deserializable for FutureSalt {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let valid_since = i32::deserialize(buf)?;
            let valid_until = i32::deserialize(buf)?;
            let salt = i64::deserialize(buf)?;
            Ok(FutureSalt {
                valid_since,
                valid_until,
                salt,
            })
        }
    }
    impl From<crate::enums::FutureSalt> for FutureSalt {
        fn from(x: crate::enums::FutureSalt) -> Self {
            match x {
                crate::enums::FutureSalt::Salt(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct FutureSalts {
        pub req_msg_id: i64,
        pub now: i32,
        pub salts: crate::RawVec<crate::types::FutureSalt>,
    }
    impl crate::Identifiable for FutureSalts {
        const CONSTRUCTOR_ID: u32 = 2924480661;
    }
    impl crate::Serializable for FutureSalts {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.req_msg_id.serialize(buf);
            self.now.serialize(buf);
            self.salts.serialize(buf);
        }
    }
    impl crate::Deserializable for FutureSalts {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let req_msg_id = i64::deserialize(buf)?;
            let now = i32::deserialize(buf)?;
            let salts = crate::RawVec::<crate::types::FutureSalt>::deserialize(buf)?;
            Ok(FutureSalts {
                req_msg_id,
                now,
                salts,
            })
        }
    }
    impl From<crate::enums::FutureSalts> for FutureSalts {
        fn from(x: crate::enums::FutureSalts) -> Self {
            match x {
                crate::enums::FutureSalts::Salts(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Game {
        pub id: i64,
        pub access_hash: i64,
        pub short_name: String,
        pub title: String,
        pub description: String,
        pub photo: crate::enums::Photo,
        pub document: Option<crate::enums::Document>,
    }
    impl crate::Identifiable for Game {
        const CONSTRUCTOR_ID: u32 = 3187238203;
    }
    impl crate::Serializable for Game {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.document.is_some() { 1 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.short_name.serialize(buf);
            self.title.serialize(buf);
            self.description.serialize(buf);
            self.photo.serialize(buf);
            if let Some(ref x) = self.document {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Game {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let short_name = String::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let photo = crate::enums::Photo::deserialize(buf)?;
            let document = if (flags & 1) != 0 {
                Some(crate::enums::Document::deserialize(buf)?)
            } else {
                None
            };
            Ok(Game {
                id,
                access_hash,
                short_name,
                title,
                description,
                photo,
                document,
            })
        }
    }
    impl From<crate::enums::Game> for Game {
        fn from(x: crate::enums::Game) -> Self {
            match x {
                crate::enums::Game::Game(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GeoPoint {
        pub long: f64,
        pub lat: f64,
        pub access_hash: i64,
        pub accuracy_radius: Option<i32>,
    }
    impl crate::Identifiable for GeoPoint {
        const CONSTRUCTOR_ID: u32 = 2997024355;
    }
    impl crate::Serializable for GeoPoint {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.accuracy_radius.is_some() { 1 } else { 0 }).serialize(buf);
            self.long.serialize(buf);
            self.lat.serialize(buf);
            self.access_hash.serialize(buf);
            if let Some(ref x) = self.accuracy_radius {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for GeoPoint {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let long = f64::deserialize(buf)?;
            let lat = f64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let accuracy_radius = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(GeoPoint {
                long,
                lat,
                access_hash,
                accuracy_radius,
            })
        }
    }
    impl TryFrom<crate::enums::GeoPoint> for GeoPoint {
        type Error = ();
        fn try_from(x: crate::enums::GeoPoint) -> Result<Self, Self::Error> {
            match x {
                crate::enums::GeoPoint::Point(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GeoPointEmpty {}
    impl crate::Identifiable for GeoPointEmpty {
        const CONSTRUCTOR_ID: u32 = 286776671;
    }
    impl crate::Serializable for GeoPointEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for GeoPointEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(GeoPointEmpty {})
        }
    }
    impl TryFrom<crate::enums::GeoPoint> for GeoPointEmpty {
        type Error = ();
        fn try_from(x: crate::enums::GeoPoint) -> Result<Self, Self::Error> {
            match x {
                crate::enums::GeoPoint::Empty => Ok(GeoPointEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GlobalPrivacySettings {
        pub archive_and_mute_new_noncontact_peers: Option<bool>,
    }
    impl crate::Identifiable for GlobalPrivacySettings {
        const CONSTRUCTOR_ID: u32 = 3198350372;
    }
    impl crate::Serializable for GlobalPrivacySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.archive_and_mute_new_noncontact_peers.is_some() {
                    1
                } else {
                    0
                })
            .serialize(buf);
            if let Some(ref x) = self.archive_and_mute_new_noncontact_peers {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for GlobalPrivacySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let archive_and_mute_new_noncontact_peers = if (flags & 1) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            Ok(GlobalPrivacySettings {
                archive_and_mute_new_noncontact_peers,
            })
        }
    }
    impl From<crate::enums::GlobalPrivacySettings> for GlobalPrivacySettings {
        fn from(x: crate::enums::GlobalPrivacySettings) -> Self {
            match x {
                crate::enums::GlobalPrivacySettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GroupCall {
        pub join_muted: bool,
        pub can_change_join_muted: bool,
        pub join_date_asc: bool,
        pub schedule_start_subscribed: bool,
        pub can_start_video: bool,
        pub record_video_active: bool,
        pub id: i64,
        pub access_hash: i64,
        pub participants_count: i32,
        pub title: Option<String>,
        pub stream_dc_id: Option<i32>,
        pub record_start_date: Option<i32>,
        pub schedule_date: Option<i32>,
        pub unmuted_video_count: Option<i32>,
        pub unmuted_video_limit: i32,
        pub version: i32,
    }
    impl crate::Identifiable for GroupCall {
        const CONSTRUCTOR_ID: u32 = 3583468812;
    }
    impl crate::Serializable for GroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.join_muted { 2 } else { 0 }
                | if self.can_change_join_muted { 4 } else { 0 }
                | if self.join_date_asc { 64 } else { 0 }
                | if self.schedule_start_subscribed {
                    256
                } else {
                    0
                }
                | if self.can_start_video { 512 } else { 0 }
                | if self.record_video_active { 2048 } else { 0 }
                | if self.title.is_some() { 8 } else { 0 }
                | if self.stream_dc_id.is_some() { 16 } else { 0 }
                | if self.record_start_date.is_some() {
                    32
                } else {
                    0
                }
                | if self.schedule_date.is_some() { 128 } else { 0 }
                | if self.unmuted_video_count.is_some() {
                    1024
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.participants_count.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.stream_dc_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.record_start_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.schedule_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.unmuted_video_count {
                x.serialize(buf);
            }
            self.unmuted_video_limit.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for GroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let join_muted = (flags & 2) != 0;
            let can_change_join_muted = (flags & 4) != 0;
            let join_date_asc = (flags & 64) != 0;
            let schedule_start_subscribed = (flags & 256) != 0;
            let can_start_video = (flags & 512) != 0;
            let record_video_active = (flags & 2048) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let participants_count = i32::deserialize(buf)?;
            let title = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let stream_dc_id = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let record_start_date = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let schedule_date = if (flags & 128) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let unmuted_video_count = if (flags & 1024) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let unmuted_video_limit = i32::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(GroupCall {
                join_muted,
                can_change_join_muted,
                join_date_asc,
                schedule_start_subscribed,
                can_start_video,
                record_video_active,
                id,
                access_hash,
                participants_count,
                title,
                stream_dc_id,
                record_start_date,
                schedule_date,
                unmuted_video_count,
                unmuted_video_limit,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::GroupCall> for GroupCall {
        type Error = ();
        fn try_from(x: crate::enums::GroupCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::GroupCall::Call(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GroupCallDiscarded {
        pub id: i64,
        pub access_hash: i64,
        pub duration: i32,
    }
    impl crate::Identifiable for GroupCallDiscarded {
        const CONSTRUCTOR_ID: u32 = 2004925620;
    }
    impl crate::Serializable for GroupCallDiscarded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.duration.serialize(buf);
        }
    }
    impl crate::Deserializable for GroupCallDiscarded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let duration = i32::deserialize(buf)?;
            Ok(GroupCallDiscarded {
                id,
                access_hash,
                duration,
            })
        }
    }
    impl TryFrom<crate::enums::GroupCall> for GroupCallDiscarded {
        type Error = ();
        fn try_from(x: crate::enums::GroupCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::GroupCall::Discarded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GroupCallParticipant {
        pub muted: bool,
        pub left: bool,
        pub can_self_unmute: bool,
        pub just_joined: bool,
        pub versioned: bool,
        pub min: bool,
        pub muted_by_you: bool,
        pub volume_by_admin: bool,
        pub is_self: bool,
        pub video_joined: bool,
        pub peer: crate::enums::Peer,
        pub date: i32,
        pub active_date: Option<i32>,
        pub source: i32,
        pub volume: Option<i32>,
        pub about: Option<String>,
        pub raise_hand_rating: Option<i64>,
        pub video: Option<crate::enums::GroupCallParticipantVideo>,
        pub presentation: Option<crate::enums::GroupCallParticipantVideo>,
    }
    impl crate::Identifiable for GroupCallParticipant {
        const CONSTRUCTOR_ID: u32 = 3953538814;
    }
    impl crate::Serializable for GroupCallParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.muted { 1 } else { 0 }
                | if self.left { 2 } else { 0 }
                | if self.can_self_unmute { 4 } else { 0 }
                | if self.just_joined { 16 } else { 0 }
                | if self.versioned { 32 } else { 0 }
                | if self.min { 256 } else { 0 }
                | if self.muted_by_you { 512 } else { 0 }
                | if self.volume_by_admin { 1024 } else { 0 }
                | if self.is_self { 4096 } else { 0 }
                | if self.video_joined { 32768 } else { 0 }
                | if self.active_date.is_some() { 8 } else { 0 }
                | if self.volume.is_some() { 128 } else { 0 }
                | if self.about.is_some() { 2048 } else { 0 }
                | if self.raise_hand_rating.is_some() {
                    8192
                } else {
                    0
                }
                | if self.video.is_some() { 64 } else { 0 }
                | if self.presentation.is_some() {
                    16384
                } else {
                    0
                })
            .serialize(buf);
            self.peer.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.active_date {
                x.serialize(buf);
            }
            self.source.serialize(buf);
            if let Some(ref x) = self.volume {
                x.serialize(buf);
            }
            if let Some(ref x) = self.about {
                x.serialize(buf);
            }
            if let Some(ref x) = self.raise_hand_rating {
                x.serialize(buf);
            }
            if let Some(ref x) = self.video {
                x.serialize(buf);
            }
            if let Some(ref x) = self.presentation {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for GroupCallParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let muted = (flags & 1) != 0;
            let left = (flags & 2) != 0;
            let can_self_unmute = (flags & 4) != 0;
            let just_joined = (flags & 16) != 0;
            let versioned = (flags & 32) != 0;
            let min = (flags & 256) != 0;
            let muted_by_you = (flags & 512) != 0;
            let volume_by_admin = (flags & 1024) != 0;
            let is_self = (flags & 4096) != 0;
            let video_joined = (flags & 32768) != 0;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let active_date = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let source = i32::deserialize(buf)?;
            let volume = if (flags & 128) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let about = if (flags & 2048) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let raise_hand_rating = if (flags & 8192) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let video = if (flags & 64) != 0 {
                Some(crate::enums::GroupCallParticipantVideo::deserialize(buf)?)
            } else {
                None
            };
            let presentation = if (flags & 16384) != 0 {
                Some(crate::enums::GroupCallParticipantVideo::deserialize(buf)?)
            } else {
                None
            };
            Ok(GroupCallParticipant {
                muted,
                left,
                can_self_unmute,
                just_joined,
                versioned,
                min,
                muted_by_you,
                volume_by_admin,
                is_self,
                video_joined,
                peer,
                date,
                active_date,
                source,
                volume,
                about,
                raise_hand_rating,
                video,
                presentation,
            })
        }
    }
    impl From<crate::enums::GroupCallParticipant> for GroupCallParticipant {
        fn from(x: crate::enums::GroupCallParticipant) -> Self {
            match x {
                crate::enums::GroupCallParticipant::Participant(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GroupCallParticipantVideo {
        pub paused: bool,
        pub endpoint: String,
        pub source_groups: Vec<crate::enums::GroupCallParticipantVideoSourceGroup>,
        pub audio_source: Option<i32>,
    }
    impl crate::Identifiable for GroupCallParticipantVideo {
        const CONSTRUCTOR_ID: u32 = 1735736008;
    }
    impl crate::Serializable for GroupCallParticipantVideo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.paused { 1 } else { 0 }
                | if self.audio_source.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.endpoint.serialize(buf);
            self.source_groups.serialize(buf);
            if let Some(ref x) = self.audio_source {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for GroupCallParticipantVideo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let paused = (flags & 1) != 0;
            let endpoint = String::deserialize(buf)?;
            let source_groups =
                Vec::<crate::enums::GroupCallParticipantVideoSourceGroup>::deserialize(buf)?;
            let audio_source = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(GroupCallParticipantVideo {
                paused,
                endpoint,
                source_groups,
                audio_source,
            })
        }
    }
    impl From<crate::enums::GroupCallParticipantVideo> for GroupCallParticipantVideo {
        fn from(x: crate::enums::GroupCallParticipantVideo) -> Self {
            match x {
                crate::enums::GroupCallParticipantVideo::Video(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GroupCallParticipantVideoSourceGroup {
        pub semantics: String,
        pub sources: Vec<i32>,
    }
    impl crate::Identifiable for GroupCallParticipantVideoSourceGroup {
        const CONSTRUCTOR_ID: u32 = 3702593719;
    }
    impl crate::Serializable for GroupCallParticipantVideoSourceGroup {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.semantics.serialize(buf);
            self.sources.serialize(buf);
        }
    }
    impl crate::Deserializable for GroupCallParticipantVideoSourceGroup {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let semantics = String::deserialize(buf)?;
            let sources = Vec::<i32>::deserialize(buf)?;
            Ok(GroupCallParticipantVideoSourceGroup { semantics, sources })
        }
    }
    impl From<crate::enums::GroupCallParticipantVideoSourceGroup>
        for GroupCallParticipantVideoSourceGroup
    {
        fn from(x: crate::enums::GroupCallParticipantVideoSourceGroup) -> Self {
            match x {
                crate::enums::GroupCallParticipantVideoSourceGroup::Group(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct HighScore {
        pub pos: i32,
        pub user_id: i64,
        pub score: i32,
    }
    impl crate::Identifiable for HighScore {
        const CONSTRUCTOR_ID: u32 = 1940093419;
    }
    impl crate::Serializable for HighScore {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.pos.serialize(buf);
            self.user_id.serialize(buf);
            self.score.serialize(buf);
        }
    }
    impl crate::Deserializable for HighScore {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let pos = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let score = i32::deserialize(buf)?;
            Ok(HighScore {
                pos,
                user_id,
                score,
            })
        }
    }
    impl From<crate::enums::HighScore> for HighScore {
        fn from(x: crate::enums::HighScore) -> Self {
            match x {
                crate::enums::HighScore::Score(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct HttpWait {
        pub max_delay: i32,
        pub wait_after: i32,
        pub max_wait: i32,
    }
    impl crate::Identifiable for HttpWait {
        const CONSTRUCTOR_ID: u32 = 2459514271;
    }
    impl crate::Serializable for HttpWait {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.max_delay.serialize(buf);
            self.wait_after.serialize(buf);
            self.max_wait.serialize(buf);
        }
    }
    impl crate::Deserializable for HttpWait {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let max_delay = i32::deserialize(buf)?;
            let wait_after = i32::deserialize(buf)?;
            let max_wait = i32::deserialize(buf)?;
            Ok(HttpWait {
                max_delay,
                wait_after,
                max_wait,
            })
        }
    }
    impl From<crate::enums::HttpWait> for HttpWait {
        fn from(x: crate::enums::HttpWait) -> Self {
            match x {
                crate::enums::HttpWait::Wait(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ImportedContact {
        pub user_id: i64,
        pub client_id: i64,
    }
    impl crate::Identifiable for ImportedContact {
        const CONSTRUCTOR_ID: u32 = 3242081360;
    }
    impl crate::Serializable for ImportedContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.client_id.serialize(buf);
        }
    }
    impl crate::Deserializable for ImportedContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let client_id = i64::deserialize(buf)?;
            Ok(ImportedContact { user_id, client_id })
        }
    }
    impl From<crate::enums::ImportedContact> for ImportedContact {
        fn from(x: crate::enums::ImportedContact) -> Self {
            match x {
                crate::enums::ImportedContact::Contact(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineBotSwitchPm {
        pub text: String,
        pub start_param: String,
    }
    impl crate::Identifiable for InlineBotSwitchPm {
        const CONSTRUCTOR_ID: u32 = 1008755359;
    }
    impl crate::Serializable for InlineBotSwitchPm {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.start_param.serialize(buf);
        }
    }
    impl crate::Deserializable for InlineBotSwitchPm {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            let start_param = String::deserialize(buf)?;
            Ok(InlineBotSwitchPm { text, start_param })
        }
    }
    impl From<crate::enums::InlineBotSwitchPm> for InlineBotSwitchPm {
        fn from(x: crate::enums::InlineBotSwitchPm) -> Self {
            match x {
                crate::enums::InlineBotSwitchPm::Pm(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineQueryPeerTypeBroadcast {}
    impl crate::Identifiable for InlineQueryPeerTypeBroadcast {
        const CONSTRUCTOR_ID: u32 = 1664413338;
    }
    impl crate::Serializable for InlineQueryPeerTypeBroadcast {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InlineQueryPeerTypeBroadcast {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InlineQueryPeerTypeBroadcast {})
        }
    }
    impl TryFrom<crate::enums::InlineQueryPeerType> for InlineQueryPeerTypeBroadcast {
        type Error = ();
        fn try_from(x: crate::enums::InlineQueryPeerType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InlineQueryPeerType::Broadcast => Ok(InlineQueryPeerTypeBroadcast {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineQueryPeerTypeChat {}
    impl crate::Identifiable for InlineQueryPeerTypeChat {
        const CONSTRUCTOR_ID: u32 = 3613836554;
    }
    impl crate::Serializable for InlineQueryPeerTypeChat {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InlineQueryPeerTypeChat {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InlineQueryPeerTypeChat {})
        }
    }
    impl TryFrom<crate::enums::InlineQueryPeerType> for InlineQueryPeerTypeChat {
        type Error = ();
        fn try_from(x: crate::enums::InlineQueryPeerType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InlineQueryPeerType::Chat => Ok(InlineQueryPeerTypeChat {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineQueryPeerTypeMegagroup {}
    impl crate::Identifiable for InlineQueryPeerTypeMegagroup {
        const CONSTRUCTOR_ID: u32 = 1589952067;
    }
    impl crate::Serializable for InlineQueryPeerTypeMegagroup {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InlineQueryPeerTypeMegagroup {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InlineQueryPeerTypeMegagroup {})
        }
    }
    impl TryFrom<crate::enums::InlineQueryPeerType> for InlineQueryPeerTypeMegagroup {
        type Error = ();
        fn try_from(x: crate::enums::InlineQueryPeerType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InlineQueryPeerType::Megagroup => Ok(InlineQueryPeerTypeMegagroup {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineQueryPeerTypePm {}
    impl crate::Identifiable for InlineQueryPeerTypePm {
        const CONSTRUCTOR_ID: u32 = 2201751468;
    }
    impl crate::Serializable for InlineQueryPeerTypePm {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InlineQueryPeerTypePm {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InlineQueryPeerTypePm {})
        }
    }
    impl TryFrom<crate::enums::InlineQueryPeerType> for InlineQueryPeerTypePm {
        type Error = ();
        fn try_from(x: crate::enums::InlineQueryPeerType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InlineQueryPeerType::Pm => Ok(InlineQueryPeerTypePm {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InlineQueryPeerTypeSameBotPm {}
    impl crate::Identifiable for InlineQueryPeerTypeSameBotPm {
        const CONSTRUCTOR_ID: u32 = 813821341;
    }
    impl crate::Serializable for InlineQueryPeerTypeSameBotPm {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InlineQueryPeerTypeSameBotPm {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InlineQueryPeerTypeSameBotPm {})
        }
    }
    impl TryFrom<crate::enums::InlineQueryPeerType> for InlineQueryPeerTypeSameBotPm {
        type Error = ();
        fn try_from(x: crate::enums::InlineQueryPeerType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InlineQueryPeerType::SameBotPm => Ok(InlineQueryPeerTypeSameBotPm {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputAppEvent {
        pub time: f64,
        pub r#type: String,
        pub peer: i64,
        pub data: crate::enums::Jsonvalue,
    }
    impl crate::Identifiable for InputAppEvent {
        const CONSTRUCTOR_ID: u32 = 488313413;
    }
    impl crate::Serializable for InputAppEvent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.time.serialize(buf);
            self.r#type.serialize(buf);
            self.peer.serialize(buf);
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for InputAppEvent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let time = f64::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let peer = i64::deserialize(buf)?;
            let data = crate::enums::Jsonvalue::deserialize(buf)?;
            Ok(InputAppEvent {
                time,
                r#type,
                peer,
                data,
            })
        }
    }
    impl From<crate::enums::InputAppEvent> for InputAppEvent {
        fn from(x: crate::enums::InputAppEvent) -> Self {
            match x {
                crate::enums::InputAppEvent::Event(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageGame {
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageGame {
        const CONSTRUCTOR_ID: u32 = 1262639204;
    }
    impl crate::Serializable for InputBotInlineMessageGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.reply_markup.is_some() { 4 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageGame { reply_markup })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageGame {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::Game(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageId {
        pub dc_id: i32,
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputBotInlineMessageId {
        const CONSTRUCTOR_ID: u32 = 2299280777;
    }
    impl crate::Serializable for InputBotInlineMessageId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.dc_id.serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineMessageId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let dc_id = i32::deserialize(buf)?;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputBotInlineMessageId {
                dc_id,
                id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessageId> for InputBotInlineMessageId {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessageId) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessageId::Id(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageId64 {
        pub dc_id: i32,
        pub owner_id: i64,
        pub id: i32,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputBotInlineMessageId64 {
        const CONSTRUCTOR_ID: u32 = 3067680215;
    }
    impl crate::Serializable for InputBotInlineMessageId64 {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.dc_id.serialize(buf);
            self.owner_id.serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineMessageId64 {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let dc_id = i32::deserialize(buf)?;
            let owner_id = i64::deserialize(buf)?;
            let id = i32::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputBotInlineMessageId64 {
                dc_id,
                owner_id,
                id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessageId> for InputBotInlineMessageId64 {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessageId) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessageId::Id64(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageMediaAuto {
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageMediaAuto {
        const CONSTRUCTOR_ID: u32 = 864077702;
    }
    impl crate::Serializable for InputBotInlineMessageMediaAuto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.entities.is_some() { 2 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageMediaAuto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageMediaAuto {
                message,
                entities,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageMediaAuto {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::MediaAuto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageMediaContact {
        pub phone_number: String,
        pub first_name: String,
        pub last_name: String,
        pub vcard: String,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageMediaContact {
        const CONSTRUCTOR_ID: u32 = 2800599037;
    }
    impl crate::Serializable for InputBotInlineMessageMediaContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.reply_markup.is_some() { 4 } else { 0 }).serialize(buf);
            self.phone_number.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.vcard.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageMediaContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let phone_number = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let vcard = String::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageMediaContact {
                phone_number,
                first_name,
                last_name,
                vcard,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageMediaContact {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::MediaContact(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageMediaGeo {
        pub geo_point: crate::enums::InputGeoPoint,
        pub heading: Option<i32>,
        pub period: Option<i32>,
        pub proximity_notification_radius: Option<i32>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageMediaGeo {
        const CONSTRUCTOR_ID: u32 = 2526190213;
    }
    impl crate::Serializable for InputBotInlineMessageMediaGeo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.heading.is_some() { 1 } else { 0 }
                | if self.period.is_some() { 2 } else { 0 }
                | if self.proximity_notification_radius.is_some() {
                    8
                } else {
                    0
                }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.geo_point.serialize(buf);
            if let Some(ref x) = self.heading {
                x.serialize(buf);
            }
            if let Some(ref x) = self.period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.proximity_notification_radius {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageMediaGeo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            let heading = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let period = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let proximity_notification_radius = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageMediaGeo {
                geo_point,
                heading,
                period,
                proximity_notification_radius,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageMediaGeo {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::MediaGeo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageMediaInvoice {
        pub title: String,
        pub description: String,
        pub photo: Option<crate::enums::InputWebDocument>,
        pub invoice: crate::enums::Invoice,
        pub payload: Vec<u8>,
        pub provider: String,
        pub provider_data: crate::enums::DataJson,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageMediaInvoice {
        const CONSTRUCTOR_ID: u32 = 3622273573;
    }
    impl crate::Serializable for InputBotInlineMessageMediaInvoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.title.serialize(buf);
            self.description.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            self.invoice.serialize(buf);
            self.payload.serialize(buf);
            self.provider.serialize(buf);
            self.provider_data.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageMediaInvoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::InputWebDocument::deserialize(buf)?)
            } else {
                None
            };
            let invoice = crate::enums::Invoice::deserialize(buf)?;
            let payload = Vec::<u8>::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let provider_data = crate::enums::DataJson::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageMediaInvoice {
                title,
                description,
                photo,
                invoice,
                payload,
                provider,
                provider_data,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageMediaInvoice {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::MediaInvoice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageMediaVenue {
        pub geo_point: crate::enums::InputGeoPoint,
        pub title: String,
        pub address: String,
        pub provider: String,
        pub venue_id: String,
        pub venue_type: String,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageMediaVenue {
        const CONSTRUCTOR_ID: u32 = 1098628881;
    }
    impl crate::Serializable for InputBotInlineMessageMediaVenue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.reply_markup.is_some() { 4 } else { 0 }).serialize(buf);
            self.geo_point.serialize(buf);
            self.title.serialize(buf);
            self.address.serialize(buf);
            self.provider.serialize(buf);
            self.venue_id.serialize(buf);
            self.venue_type.serialize(buf);
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageMediaVenue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let address = String::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let venue_id = String::deserialize(buf)?;
            let venue_type = String::deserialize(buf)?;
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageMediaVenue {
                geo_point,
                title,
                address,
                provider,
                venue_id,
                venue_type,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageMediaVenue {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::MediaVenue(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineMessageText {
        pub no_webpage: bool,
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
    }
    impl crate::Identifiable for InputBotInlineMessageText {
        const CONSTRUCTOR_ID: u32 = 1036876423;
    }
    impl crate::Serializable for InputBotInlineMessageText {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.no_webpage { 1 } else { 0 }
                | if self.entities.is_some() { 2 } else { 0 }
                | if self.reply_markup.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageText {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let no_webpage = (flags & 1) != 0;
            let message = String::deserialize(buf)?;
            let entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 4) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputBotInlineMessageText {
                no_webpage,
                message,
                entities,
                reply_markup,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineMessage> for InputBotInlineMessageText {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineMessage::Text(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineResult {
        pub id: String,
        pub r#type: String,
        pub title: Option<String>,
        pub description: Option<String>,
        pub url: Option<String>,
        pub thumb: Option<crate::enums::InputWebDocument>,
        pub content: Option<crate::enums::InputWebDocument>,
        pub send_message: crate::enums::InputBotInlineMessage,
    }
    impl crate::Identifiable for InputBotInlineResult {
        const CONSTRUCTOR_ID: u32 = 2294256409;
    }
    impl crate::Serializable for InputBotInlineResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.title.is_some() { 2 } else { 0 }
                | if self.description.is_some() { 4 } else { 0 }
                | if self.url.is_some() { 8 } else { 0 }
                | if self.thumb.is_some() { 16 } else { 0 }
                | if self.content.is_some() { 32 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            if let Some(ref x) = self.url {
                x.serialize(buf);
            }
            if let Some(ref x) = self.thumb {
                x.serialize(buf);
            }
            if let Some(ref x) = self.content {
                x.serialize(buf);
            }
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = String::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let title = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let url = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let thumb = if (flags & 16) != 0 {
                Some(crate::enums::InputWebDocument::deserialize(buf)?)
            } else {
                None
            };
            let content = if (flags & 32) != 0 {
                Some(crate::enums::InputWebDocument::deserialize(buf)?)
            } else {
                None
            };
            let send_message = crate::enums::InputBotInlineMessage::deserialize(buf)?;
            Ok(InputBotInlineResult {
                id,
                r#type,
                title,
                description,
                url,
                thumb,
                content,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineResult> for InputBotInlineResult {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineResult::Result(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineResultDocument {
        pub id: String,
        pub r#type: String,
        pub title: Option<String>,
        pub description: Option<String>,
        pub document: crate::enums::InputDocument,
        pub send_message: crate::enums::InputBotInlineMessage,
    }
    impl crate::Identifiable for InputBotInlineResultDocument {
        const CONSTRUCTOR_ID: u32 = 4294507972;
    }
    impl crate::Serializable for InputBotInlineResultDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.title.is_some() { 2 } else { 0 }
                | if self.description.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            self.document.serialize(buf);
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineResultDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = String::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let title = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let document = crate::enums::InputDocument::deserialize(buf)?;
            let send_message = crate::enums::InputBotInlineMessage::deserialize(buf)?;
            Ok(InputBotInlineResultDocument {
                id,
                r#type,
                title,
                description,
                document,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineResult> for InputBotInlineResultDocument {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineResult::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineResultGame {
        pub id: String,
        pub short_name: String,
        pub send_message: crate::enums::InputBotInlineMessage,
    }
    impl crate::Identifiable for InputBotInlineResultGame {
        const CONSTRUCTOR_ID: u32 = 1336154098;
    }
    impl crate::Serializable for InputBotInlineResultGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.short_name.serialize(buf);
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineResultGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let short_name = String::deserialize(buf)?;
            let send_message = crate::enums::InputBotInlineMessage::deserialize(buf)?;
            Ok(InputBotInlineResultGame {
                id,
                short_name,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineResult> for InputBotInlineResultGame {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineResult::Game(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputBotInlineResultPhoto {
        pub id: String,
        pub r#type: String,
        pub photo: crate::enums::InputPhoto,
        pub send_message: crate::enums::InputBotInlineMessage,
    }
    impl crate::Identifiable for InputBotInlineResultPhoto {
        const CONSTRUCTOR_ID: u32 = 2832753831;
    }
    impl crate::Serializable for InputBotInlineResultPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.r#type.serialize(buf);
            self.photo.serialize(buf);
            self.send_message.serialize(buf);
        }
    }
    impl crate::Deserializable for InputBotInlineResultPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let photo = crate::enums::InputPhoto::deserialize(buf)?;
            let send_message = crate::enums::InputBotInlineMessage::deserialize(buf)?;
            Ok(InputBotInlineResultPhoto {
                id,
                r#type,
                photo,
                send_message,
            })
        }
    }
    impl TryFrom<crate::enums::InputBotInlineResult> for InputBotInlineResultPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputBotInlineResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputBotInlineResult::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChannel {
        pub channel_id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputChannel {
        const CONSTRUCTOR_ID: u32 = 4082822184;
    }
    impl crate::Serializable for InputChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputChannel {
                channel_id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputChannel> for InputChannel {
        type Error = ();
        fn try_from(x: crate::enums::InputChannel) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChannel::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChannelEmpty {}
    impl crate::Identifiable for InputChannelEmpty {
        const CONSTRUCTOR_ID: u32 = 4002160262;
    }
    impl crate::Serializable for InputChannelEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputChannelEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputChannelEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputChannel> for InputChannelEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputChannel) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChannel::Empty => Ok(InputChannelEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChannelFromMessage {
        pub peer: crate::enums::InputPeer,
        pub msg_id: i32,
        pub channel_id: i64,
    }
    impl crate::Identifiable for InputChannelFromMessage {
        const CONSTRUCTOR_ID: u32 = 1536380829;
    }
    impl crate::Serializable for InputChannelFromMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
            self.channel_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputChannelFromMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            Ok(InputChannelFromMessage {
                peer,
                msg_id,
                channel_id,
            })
        }
    }
    impl TryFrom<crate::enums::InputChannel> for InputChannelFromMessage {
        type Error = ();
        fn try_from(x: crate::enums::InputChannel) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChannel::FromMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChatPhoto {
        pub id: crate::enums::InputPhoto,
    }
    impl crate::Identifiable for InputChatPhoto {
        const CONSTRUCTOR_ID: u32 = 2303962423;
    }
    impl crate::Serializable for InputChatPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputChatPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = crate::enums::InputPhoto::deserialize(buf)?;
            Ok(InputChatPhoto { id })
        }
    }
    impl TryFrom<crate::enums::InputChatPhoto> for InputChatPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputChatPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChatPhoto::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChatPhotoEmpty {}
    impl crate::Identifiable for InputChatPhotoEmpty {
        const CONSTRUCTOR_ID: u32 = 480546647;
    }
    impl crate::Serializable for InputChatPhotoEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputChatPhotoEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputChatPhotoEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputChatPhoto> for InputChatPhotoEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputChatPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChatPhoto::Empty => Ok(InputChatPhotoEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputChatUploadedPhoto {
        pub file: Option<crate::enums::InputFile>,
        pub video: Option<crate::enums::InputFile>,
        pub video_start_ts: Option<f64>,
    }
    impl crate::Identifiable for InputChatUploadedPhoto {
        const CONSTRUCTOR_ID: u32 = 3326243406;
    }
    impl crate::Serializable for InputChatUploadedPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.file.is_some() { 1 } else { 0 }
                | if self.video.is_some() { 2 } else { 0 }
                | if self.video_start_ts.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.file {
                x.serialize(buf);
            }
            if let Some(ref x) = self.video {
                x.serialize(buf);
            }
            if let Some(ref x) = self.video_start_ts {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputChatUploadedPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let file = if (flags & 1) != 0 {
                Some(crate::enums::InputFile::deserialize(buf)?)
            } else {
                None
            };
            let video = if (flags & 2) != 0 {
                Some(crate::enums::InputFile::deserialize(buf)?)
            } else {
                None
            };
            let video_start_ts = if (flags & 4) != 0 {
                Some(f64::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputChatUploadedPhoto {
                file,
                video,
                video_start_ts,
            })
        }
    }
    impl TryFrom<crate::enums::InputChatPhoto> for InputChatUploadedPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputChatPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputChatPhoto::InputChatUploadedPhoto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputCheckPasswordEmpty {}
    impl crate::Identifiable for InputCheckPasswordEmpty {
        const CONSTRUCTOR_ID: u32 = 2558588504;
    }
    impl crate::Serializable for InputCheckPasswordEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputCheckPasswordEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputCheckPasswordEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputCheckPasswordSrp> for InputCheckPasswordEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputCheckPasswordSrp) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputCheckPasswordSrp::InputCheckPasswordEmpty => {
                    Ok(InputCheckPasswordEmpty {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputCheckPasswordSrp {
        pub srp_id: i64,
        pub a: Vec<u8>,
        pub m1: Vec<u8>,
    }
    impl crate::Identifiable for InputCheckPasswordSrp {
        const CONSTRUCTOR_ID: u32 = 3531600002;
    }
    impl crate::Serializable for InputCheckPasswordSrp {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.srp_id.serialize(buf);
            self.a.serialize(buf);
            self.m1.serialize(buf);
        }
    }
    impl crate::Deserializable for InputCheckPasswordSrp {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let srp_id = i64::deserialize(buf)?;
            let a = Vec::<u8>::deserialize(buf)?;
            let m1 = Vec::<u8>::deserialize(buf)?;
            Ok(InputCheckPasswordSrp { srp_id, a, m1 })
        }
    }
    impl TryFrom<crate::enums::InputCheckPasswordSrp> for InputCheckPasswordSrp {
        type Error = ();
        fn try_from(x: crate::enums::InputCheckPasswordSrp) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputCheckPasswordSrp::Srp(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputClientProxy {
        pub address: String,
        pub port: i32,
    }
    impl crate::Identifiable for InputClientProxy {
        const CONSTRUCTOR_ID: u32 = 1968737087;
    }
    impl crate::Serializable for InputClientProxy {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.address.serialize(buf);
            self.port.serialize(buf);
        }
    }
    impl crate::Deserializable for InputClientProxy {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let address = String::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            Ok(InputClientProxy { address, port })
        }
    }
    impl From<crate::enums::InputClientProxy> for InputClientProxy {
        fn from(x: crate::enums::InputClientProxy) -> Self {
            match x {
                crate::enums::InputClientProxy::Proxy(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputDialogPeer {
        pub peer: crate::enums::InputPeer,
    }
    impl crate::Identifiable for InputDialogPeer {
        const CONSTRUCTOR_ID: u32 = 4239064759;
    }
    impl crate::Serializable for InputDialogPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for InputDialogPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            Ok(InputDialogPeer { peer })
        }
    }
    impl TryFrom<crate::enums::InputDialogPeer> for InputDialogPeer {
        type Error = ();
        fn try_from(x: crate::enums::InputDialogPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputDialogPeer::Peer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputDialogPeerFolder {
        pub folder_id: i32,
    }
    impl crate::Identifiable for InputDialogPeerFolder {
        const CONSTRUCTOR_ID: u32 = 1684014375;
    }
    impl crate::Serializable for InputDialogPeerFolder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.folder_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputDialogPeerFolder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let folder_id = i32::deserialize(buf)?;
            Ok(InputDialogPeerFolder { folder_id })
        }
    }
    impl TryFrom<crate::enums::InputDialogPeer> for InputDialogPeerFolder {
        type Error = ();
        fn try_from(x: crate::enums::InputDialogPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputDialogPeer::Folder(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputDocument {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
    }
    impl crate::Identifiable for InputDocument {
        const CONSTRUCTOR_ID: u32 = 448771445;
    }
    impl crate::Serializable for InputDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
        }
    }
    impl crate::Deserializable for InputDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            Ok(InputDocument {
                id,
                access_hash,
                file_reference,
            })
        }
    }
    impl TryFrom<crate::enums::InputDocument> for InputDocument {
        type Error = ();
        fn try_from(x: crate::enums::InputDocument) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputDocument::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputDocumentEmpty {}
    impl crate::Identifiable for InputDocumentEmpty {
        const CONSTRUCTOR_ID: u32 = 1928391342;
    }
    impl crate::Serializable for InputDocumentEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputDocumentEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputDocumentEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputDocument> for InputDocumentEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputDocument) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputDocument::Empty => Ok(InputDocumentEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputDocumentFileLocation {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
        pub thumb_size: String,
    }
    impl crate::Identifiable for InputDocumentFileLocation {
        const CONSTRUCTOR_ID: u32 = 3134223748;
    }
    impl crate::Serializable for InputDocumentFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
            self.thumb_size.serialize(buf);
        }
    }
    impl crate::Deserializable for InputDocumentFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            let thumb_size = String::deserialize(buf)?;
            Ok(InputDocumentFileLocation {
                id,
                access_hash,
                file_reference,
                thumb_size,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputDocumentFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputDocumentFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedChat {
        pub chat_id: i32,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputEncryptedChat {
        const CONSTRUCTOR_ID: u32 = 4047615457;
    }
    impl crate::Serializable for InputEncryptedChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputEncryptedChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i32::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputEncryptedChat {
                chat_id,
                access_hash,
            })
        }
    }
    impl From<crate::enums::InputEncryptedChat> for InputEncryptedChat {
        fn from(x: crate::enums::InputEncryptedChat) -> Self {
            match x {
                crate::enums::InputEncryptedChat::Chat(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedFile {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputEncryptedFile {
        const CONSTRUCTOR_ID: u32 = 1511503333;
    }
    impl crate::Serializable for InputEncryptedFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputEncryptedFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputEncryptedFile { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputEncryptedFile> for InputEncryptedFile {
        type Error = ();
        fn try_from(x: crate::enums::InputEncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputEncryptedFile::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedFileBigUploaded {
        pub id: i64,
        pub parts: i32,
        pub key_fingerprint: i32,
    }
    impl crate::Identifiable for InputEncryptedFileBigUploaded {
        const CONSTRUCTOR_ID: u32 = 767652808;
    }
    impl crate::Serializable for InputEncryptedFileBigUploaded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.parts.serialize(buf);
            self.key_fingerprint.serialize(buf);
        }
    }
    impl crate::Deserializable for InputEncryptedFileBigUploaded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let parts = i32::deserialize(buf)?;
            let key_fingerprint = i32::deserialize(buf)?;
            Ok(InputEncryptedFileBigUploaded {
                id,
                parts,
                key_fingerprint,
            })
        }
    }
    impl TryFrom<crate::enums::InputEncryptedFile> for InputEncryptedFileBigUploaded {
        type Error = ();
        fn try_from(x: crate::enums::InputEncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputEncryptedFile::BigUploaded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedFileEmpty {}
    impl crate::Identifiable for InputEncryptedFileEmpty {
        const CONSTRUCTOR_ID: u32 = 406307684;
    }
    impl crate::Serializable for InputEncryptedFileEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputEncryptedFileEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputEncryptedFileEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputEncryptedFile> for InputEncryptedFileEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputEncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputEncryptedFile::Empty => Ok(InputEncryptedFileEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedFileLocation {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputEncryptedFileLocation {
        const CONSTRUCTOR_ID: u32 = 4112735573;
    }
    impl crate::Serializable for InputEncryptedFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputEncryptedFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputEncryptedFileLocation { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputEncryptedFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputEncryptedFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputEncryptedFileUploaded {
        pub id: i64,
        pub parts: i32,
        pub md5_checksum: String,
        pub key_fingerprint: i32,
    }
    impl crate::Identifiable for InputEncryptedFileUploaded {
        const CONSTRUCTOR_ID: u32 = 1690108678;
    }
    impl crate::Serializable for InputEncryptedFileUploaded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.parts.serialize(buf);
            self.md5_checksum.serialize(buf);
            self.key_fingerprint.serialize(buf);
        }
    }
    impl crate::Deserializable for InputEncryptedFileUploaded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let parts = i32::deserialize(buf)?;
            let md5_checksum = String::deserialize(buf)?;
            let key_fingerprint = i32::deserialize(buf)?;
            Ok(InputEncryptedFileUploaded {
                id,
                parts,
                md5_checksum,
                key_fingerprint,
            })
        }
    }
    impl TryFrom<crate::enums::InputEncryptedFile> for InputEncryptedFileUploaded {
        type Error = ();
        fn try_from(x: crate::enums::InputEncryptedFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputEncryptedFile::Uploaded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputFile {
        pub id: i64,
        pub parts: i32,
        pub name: String,
        pub md5_checksum: String,
    }
    impl crate::Identifiable for InputFile {
        const CONSTRUCTOR_ID: u32 = 4113560191;
    }
    impl crate::Serializable for InputFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.parts.serialize(buf);
            self.name.serialize(buf);
            self.md5_checksum.serialize(buf);
        }
    }
    impl crate::Deserializable for InputFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let parts = i32::deserialize(buf)?;
            let name = String::deserialize(buf)?;
            let md5_checksum = String::deserialize(buf)?;
            Ok(InputFile {
                id,
                parts,
                name,
                md5_checksum,
            })
        }
    }
    impl TryFrom<crate::enums::InputFile> for InputFile {
        type Error = ();
        fn try_from(x: crate::enums::InputFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFile::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputFileBig {
        pub id: i64,
        pub parts: i32,
        pub name: String,
    }
    impl crate::Identifiable for InputFileBig {
        const CONSTRUCTOR_ID: u32 = 4199484341;
    }
    impl crate::Serializable for InputFileBig {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.parts.serialize(buf);
            self.name.serialize(buf);
        }
    }
    impl crate::Deserializable for InputFileBig {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let parts = i32::deserialize(buf)?;
            let name = String::deserialize(buf)?;
            Ok(InputFileBig { id, parts, name })
        }
    }
    impl TryFrom<crate::enums::InputFile> for InputFileBig {
        type Error = ();
        fn try_from(x: crate::enums::InputFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFile::Big(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputFileLocation {
        pub volume_id: i64,
        pub local_id: i32,
        pub secret: i64,
        pub file_reference: Vec<u8>,
    }
    impl crate::Identifiable for InputFileLocation {
        const CONSTRUCTOR_ID: u32 = 3755650017;
    }
    impl crate::Serializable for InputFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.volume_id.serialize(buf);
            self.local_id.serialize(buf);
            self.secret.serialize(buf);
            self.file_reference.serialize(buf);
        }
    }
    impl crate::Deserializable for InputFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let volume_id = i64::deserialize(buf)?;
            let local_id = i32::deserialize(buf)?;
            let secret = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            Ok(InputFileLocation {
                volume_id,
                local_id,
                secret,
                file_reference,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::Location(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputFolderPeer {
        pub peer: crate::enums::InputPeer,
        pub folder_id: i32,
    }
    impl crate::Identifiable for InputFolderPeer {
        const CONSTRUCTOR_ID: u32 = 4224893590;
    }
    impl crate::Serializable for InputFolderPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.folder_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputFolderPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let folder_id = i32::deserialize(buf)?;
            Ok(InputFolderPeer { peer, folder_id })
        }
    }
    impl From<crate::enums::InputFolderPeer> for InputFolderPeer {
        fn from(x: crate::enums::InputFolderPeer) -> Self {
            match x {
                crate::enums::InputFolderPeer::Peer(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGameId {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputGameId {
        const CONSTRUCTOR_ID: u32 = 53231223;
    }
    impl crate::Serializable for InputGameId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputGameId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputGameId { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputGame> for InputGameId {
        type Error = ();
        fn try_from(x: crate::enums::InputGame) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputGame::Id(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGameShortName {
        pub bot_id: crate::enums::InputUser,
        pub short_name: String,
    }
    impl crate::Identifiable for InputGameShortName {
        const CONSTRUCTOR_ID: u32 = 3274827786;
    }
    impl crate::Serializable for InputGameShortName {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.bot_id.serialize(buf);
            self.short_name.serialize(buf);
        }
    }
    impl crate::Deserializable for InputGameShortName {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let bot_id = crate::enums::InputUser::deserialize(buf)?;
            let short_name = String::deserialize(buf)?;
            Ok(InputGameShortName { bot_id, short_name })
        }
    }
    impl TryFrom<crate::enums::InputGame> for InputGameShortName {
        type Error = ();
        fn try_from(x: crate::enums::InputGame) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputGame::ShortName(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGeoPoint {
        pub lat: f64,
        pub long: f64,
        pub accuracy_radius: Option<i32>,
    }
    impl crate::Identifiable for InputGeoPoint {
        const CONSTRUCTOR_ID: u32 = 1210199983;
    }
    impl crate::Serializable for InputGeoPoint {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.accuracy_radius.is_some() { 1 } else { 0 }).serialize(buf);
            self.lat.serialize(buf);
            self.long.serialize(buf);
            if let Some(ref x) = self.accuracy_radius {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputGeoPoint {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let lat = f64::deserialize(buf)?;
            let long = f64::deserialize(buf)?;
            let accuracy_radius = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputGeoPoint {
                lat,
                long,
                accuracy_radius,
            })
        }
    }
    impl TryFrom<crate::enums::InputGeoPoint> for InputGeoPoint {
        type Error = ();
        fn try_from(x: crate::enums::InputGeoPoint) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputGeoPoint::Point(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGeoPointEmpty {}
    impl crate::Identifiable for InputGeoPointEmpty {
        const CONSTRUCTOR_ID: u32 = 3837862870;
    }
    impl crate::Serializable for InputGeoPointEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputGeoPointEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputGeoPointEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputGeoPoint> for InputGeoPointEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputGeoPoint) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputGeoPoint::Empty => Ok(InputGeoPointEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGroupCall {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputGroupCall {
        const CONSTRUCTOR_ID: u32 = 3635053583;
    }
    impl crate::Serializable for InputGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputGroupCall { id, access_hash })
        }
    }
    impl From<crate::enums::InputGroupCall> for InputGroupCall {
        fn from(x: crate::enums::InputGroupCall) -> Self {
            match x {
                crate::enums::InputGroupCall::Call(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputGroupCallStream {
        pub call: crate::enums::InputGroupCall,
        pub time_ms: i64,
        pub scale: i32,
        pub video_channel: Option<i32>,
        pub video_quality: Option<i32>,
    }
    impl crate::Identifiable for InputGroupCallStream {
        const CONSTRUCTOR_ID: u32 = 93890858;
    }
    impl crate::Serializable for InputGroupCallStream {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.video_channel.is_some() { 1 } else { 0 }
                | if self.video_quality.is_some() { 1 } else { 0 })
            .serialize(buf);
            self.call.serialize(buf);
            self.time_ms.serialize(buf);
            self.scale.serialize(buf);
            if let Some(ref x) = self.video_channel {
                x.serialize(buf);
            }
            if let Some(ref x) = self.video_quality {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputGroupCallStream {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            let time_ms = i64::deserialize(buf)?;
            let scale = i32::deserialize(buf)?;
            let video_channel = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let video_quality = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputGroupCallStream {
                call,
                time_ms,
                scale,
                video_channel,
                video_quality,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputGroupCallStream {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputGroupCallStream(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputKeyboardButtonUrlAuth {
        pub request_write_access: bool,
        pub text: String,
        pub fwd_text: Option<String>,
        pub url: String,
        pub bot: crate::enums::InputUser,
    }
    impl crate::Identifiable for InputKeyboardButtonUrlAuth {
        const CONSTRUCTOR_ID: u32 = 3492708308;
    }
    impl crate::Serializable for InputKeyboardButtonUrlAuth {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.request_write_access { 1 } else { 0 }
                | if self.fwd_text.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.text.serialize(buf);
            if let Some(ref x) = self.fwd_text {
                x.serialize(buf);
            }
            self.url.serialize(buf);
            self.bot.serialize(buf);
        }
    }
    impl crate::Deserializable for InputKeyboardButtonUrlAuth {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let request_write_access = (flags & 1) != 0;
            let text = String::deserialize(buf)?;
            let fwd_text = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let url = String::deserialize(buf)?;
            let bot = crate::enums::InputUser::deserialize(buf)?;
            Ok(InputKeyboardButtonUrlAuth {
                request_write_access,
                text,
                fwd_text,
                url,
                bot,
            })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for InputKeyboardButtonUrlAuth {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::InputKeyboardButtonUrlAuth(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputKeyboardButtonUserProfile {
        pub text: String,
        pub user_id: crate::enums::InputUser,
    }
    impl crate::Identifiable for InputKeyboardButtonUserProfile {
        const CONSTRUCTOR_ID: u32 = 3918005115;
    }
    impl crate::Serializable for InputKeyboardButtonUserProfile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputKeyboardButtonUserProfile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            let user_id = crate::enums::InputUser::deserialize(buf)?;
            Ok(InputKeyboardButtonUserProfile { text, user_id })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for InputKeyboardButtonUserProfile {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::InputKeyboardButtonUserProfile(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaContact {
        pub phone_number: String,
        pub first_name: String,
        pub last_name: String,
        pub vcard: String,
    }
    impl crate::Identifiable for InputMediaContact {
        const CONSTRUCTOR_ID: u32 = 4171988475;
    }
    impl crate::Serializable for InputMediaContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone_number.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.vcard.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMediaContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone_number = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let vcard = String::deserialize(buf)?;
            Ok(InputMediaContact {
                phone_number,
                first_name,
                last_name,
                vcard,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaContact {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Contact(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaDice {
        pub emoticon: String,
    }
    impl crate::Identifiable for InputMediaDice {
        const CONSTRUCTOR_ID: u32 = 3866083195;
    }
    impl crate::Serializable for InputMediaDice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMediaDice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            Ok(InputMediaDice { emoticon })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaDice {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Dice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaDocument {
        pub id: crate::enums::InputDocument,
        pub ttl_seconds: Option<i32>,
        pub query: Option<String>,
    }
    impl crate::Identifiable for InputMediaDocument {
        const CONSTRUCTOR_ID: u32 = 860303448;
    }
    impl crate::Serializable for InputMediaDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.ttl_seconds.is_some() { 1 } else { 0 }
                | if self.query.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
            if let Some(ref x) = self.query {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = crate::enums::InputDocument::deserialize(buf)?;
            let ttl_seconds = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let query = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaDocument {
                id,
                ttl_seconds,
                query,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaDocument {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaDocumentExternal {
        pub url: String,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for InputMediaDocumentExternal {
        const CONSTRUCTOR_ID: u32 = 4216511641;
    }
    impl crate::Serializable for InputMediaDocumentExternal {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.ttl_seconds.is_some() { 1 } else { 0 }).serialize(buf);
            self.url.serialize(buf);
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaDocumentExternal {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            let ttl_seconds = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaDocumentExternal { url, ttl_seconds })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaDocumentExternal {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::DocumentExternal(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaEmpty {}
    impl crate::Identifiable for InputMediaEmpty {
        const CONSTRUCTOR_ID: u32 = 2523198847;
    }
    impl crate::Serializable for InputMediaEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMediaEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMediaEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Empty => Ok(InputMediaEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaGame {
        pub id: crate::enums::InputGame,
    }
    impl crate::Identifiable for InputMediaGame {
        const CONSTRUCTOR_ID: u32 = 3544138739;
    }
    impl crate::Serializable for InputMediaGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMediaGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = crate::enums::InputGame::deserialize(buf)?;
            Ok(InputMediaGame { id })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaGame {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Game(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaGeoLive {
        pub stopped: bool,
        pub geo_point: crate::enums::InputGeoPoint,
        pub heading: Option<i32>,
        pub period: Option<i32>,
        pub proximity_notification_radius: Option<i32>,
    }
    impl crate::Identifiable for InputMediaGeoLive {
        const CONSTRUCTOR_ID: u32 = 2535434307;
    }
    impl crate::Serializable for InputMediaGeoLive {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.stopped { 1 } else { 0 }
                | if self.heading.is_some() { 4 } else { 0 }
                | if self.period.is_some() { 2 } else { 0 }
                | if self.proximity_notification_radius.is_some() {
                    8
                } else {
                    0
                })
            .serialize(buf);
            self.geo_point.serialize(buf);
            if let Some(ref x) = self.heading {
                x.serialize(buf);
            }
            if let Some(ref x) = self.period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.proximity_notification_radius {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaGeoLive {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let stopped = (flags & 1) != 0;
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            let heading = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let period = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let proximity_notification_radius = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaGeoLive {
                stopped,
                geo_point,
                heading,
                period,
                proximity_notification_radius,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaGeoLive {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::GeoLive(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaGeoPoint {
        pub geo_point: crate::enums::InputGeoPoint,
    }
    impl crate::Identifiable for InputMediaGeoPoint {
        const CONSTRUCTOR_ID: u32 = 4190388548;
    }
    impl crate::Serializable for InputMediaGeoPoint {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo_point.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMediaGeoPoint {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            Ok(InputMediaGeoPoint { geo_point })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaGeoPoint {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::GeoPoint(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaInvoice {
        pub title: String,
        pub description: String,
        pub photo: Option<crate::enums::InputWebDocument>,
        pub invoice: crate::enums::Invoice,
        pub payload: Vec<u8>,
        pub provider: String,
        pub provider_data: crate::enums::DataJson,
        pub start_param: Option<String>,
    }
    impl crate::Identifiable for InputMediaInvoice {
        const CONSTRUCTOR_ID: u32 = 3648624756;
    }
    impl crate::Serializable for InputMediaInvoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.start_param.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.title.serialize(buf);
            self.description.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            self.invoice.serialize(buf);
            self.payload.serialize(buf);
            self.provider.serialize(buf);
            self.provider_data.serialize(buf);
            if let Some(ref x) = self.start_param {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaInvoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::InputWebDocument::deserialize(buf)?)
            } else {
                None
            };
            let invoice = crate::enums::Invoice::deserialize(buf)?;
            let payload = Vec::<u8>::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let provider_data = crate::enums::DataJson::deserialize(buf)?;
            let start_param = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaInvoice {
                title,
                description,
                photo,
                invoice,
                payload,
                provider,
                provider_data,
                start_param,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaInvoice {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Invoice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaPhoto {
        pub id: crate::enums::InputPhoto,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for InputMediaPhoto {
        const CONSTRUCTOR_ID: u32 = 3015312949;
    }
    impl crate::Serializable for InputMediaPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.ttl_seconds.is_some() { 1 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = crate::enums::InputPhoto::deserialize(buf)?;
            let ttl_seconds = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaPhoto { id, ttl_seconds })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaPhotoExternal {
        pub url: String,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for InputMediaPhotoExternal {
        const CONSTRUCTOR_ID: u32 = 3854302746;
    }
    impl crate::Serializable for InputMediaPhotoExternal {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.ttl_seconds.is_some() { 1 } else { 0 }).serialize(buf);
            self.url.serialize(buf);
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaPhotoExternal {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            let ttl_seconds = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaPhotoExternal { url, ttl_seconds })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaPhotoExternal {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::PhotoExternal(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaPoll {
        pub poll: crate::enums::Poll,
        pub correct_answers: Option<Vec<Vec<u8>>>,
        pub solution: Option<String>,
        pub solution_entities: Option<Vec<crate::enums::MessageEntity>>,
    }
    impl crate::Identifiable for InputMediaPoll {
        const CONSTRUCTOR_ID: u32 = 261416433;
    }
    impl crate::Serializable for InputMediaPoll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.correct_answers.is_some() { 1 } else { 0 }
                | if self.solution.is_some() { 2 } else { 0 }
                | if self.solution_entities.is_some() {
                    2
                } else {
                    0
                })
            .serialize(buf);
            self.poll.serialize(buf);
            if let Some(ref x) = self.correct_answers {
                x.serialize(buf);
            }
            if let Some(ref x) = self.solution {
                x.serialize(buf);
            }
            if let Some(ref x) = self.solution_entities {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaPoll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let poll = crate::enums::Poll::deserialize(buf)?;
            let correct_answers = if (flags & 1) != 0 {
                Some(Vec::<Vec<u8>>::deserialize(buf)?)
            } else {
                None
            };
            let solution = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let solution_entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaPoll {
                poll,
                correct_answers,
                solution,
                solution_entities,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaPoll {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Poll(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaUploadedDocument {
        pub nosound_video: bool,
        pub force_file: bool,
        pub file: crate::enums::InputFile,
        pub thumb: Option<crate::enums::InputFile>,
        pub mime_type: String,
        pub attributes: Vec<crate::enums::DocumentAttribute>,
        pub stickers: Option<Vec<crate::enums::InputDocument>>,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for InputMediaUploadedDocument {
        const CONSTRUCTOR_ID: u32 = 1530447553;
    }
    impl crate::Serializable for InputMediaUploadedDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.nosound_video { 8 } else { 0 }
                | if self.force_file { 16 } else { 0 }
                | if self.thumb.is_some() { 4 } else { 0 }
                | if self.stickers.is_some() { 1 } else { 0 }
                | if self.ttl_seconds.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.file.serialize(buf);
            if let Some(ref x) = self.thumb {
                x.serialize(buf);
            }
            self.mime_type.serialize(buf);
            self.attributes.serialize(buf);
            if let Some(ref x) = self.stickers {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaUploadedDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let nosound_video = (flags & 8) != 0;
            let force_file = (flags & 16) != 0;
            let file = crate::enums::InputFile::deserialize(buf)?;
            let thumb = if (flags & 4) != 0 {
                Some(crate::enums::InputFile::deserialize(buf)?)
            } else {
                None
            };
            let mime_type = String::deserialize(buf)?;
            let attributes = Vec::<crate::enums::DocumentAttribute>::deserialize(buf)?;
            let stickers = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::InputDocument>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_seconds = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaUploadedDocument {
                nosound_video,
                force_file,
                file,
                thumb,
                mime_type,
                attributes,
                stickers,
                ttl_seconds,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaUploadedDocument {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::UploadedDocument(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaUploadedPhoto {
        pub file: crate::enums::InputFile,
        pub stickers: Option<Vec<crate::enums::InputDocument>>,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for InputMediaUploadedPhoto {
        const CONSTRUCTOR_ID: u32 = 505969924;
    }
    impl crate::Serializable for InputMediaUploadedPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.stickers.is_some() { 1 } else { 0 }
                | if self.ttl_seconds.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.file.serialize(buf);
            if let Some(ref x) = self.stickers {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputMediaUploadedPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let file = crate::enums::InputFile::deserialize(buf)?;
            let stickers = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::InputDocument>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_seconds = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputMediaUploadedPhoto {
                file,
                stickers,
                ttl_seconds,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaUploadedPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::UploadedPhoto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMediaVenue {
        pub geo_point: crate::enums::InputGeoPoint,
        pub title: String,
        pub address: String,
        pub provider: String,
        pub venue_id: String,
        pub venue_type: String,
    }
    impl crate::Identifiable for InputMediaVenue {
        const CONSTRUCTOR_ID: u32 = 3242007569;
    }
    impl crate::Serializable for InputMediaVenue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo_point.serialize(buf);
            self.title.serialize(buf);
            self.address.serialize(buf);
            self.provider.serialize(buf);
            self.venue_id.serialize(buf);
            self.venue_type.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMediaVenue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let address = String::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let venue_id = String::deserialize(buf)?;
            let venue_type = String::deserialize(buf)?;
            Ok(InputMediaVenue {
                geo_point,
                title,
                address,
                provider,
                venue_id,
                venue_type,
            })
        }
    }
    impl TryFrom<crate::enums::InputMedia> for InputMediaVenue {
        type Error = ();
        fn try_from(x: crate::enums::InputMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMedia::Venue(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessageCallbackQuery {
        pub id: i32,
        pub query_id: i64,
    }
    impl crate::Identifiable for InputMessageCallbackQuery {
        const CONSTRUCTOR_ID: u32 = 2902071934;
    }
    impl crate::Serializable for InputMessageCallbackQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.query_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMessageCallbackQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            let query_id = i64::deserialize(buf)?;
            Ok(InputMessageCallbackQuery { id, query_id })
        }
    }
    impl TryFrom<crate::enums::InputMessage> for InputMessageCallbackQuery {
        type Error = ();
        fn try_from(x: crate::enums::InputMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMessage::CallbackQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessageEntityMentionName {
        pub offset: i32,
        pub length: i32,
        pub user_id: crate::enums::InputUser,
    }
    impl crate::Identifiable for InputMessageEntityMentionName {
        const CONSTRUCTOR_ID: u32 = 546203849;
    }
    impl crate::Serializable for InputMessageEntityMentionName {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMessageEntityMentionName {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            let user_id = crate::enums::InputUser::deserialize(buf)?;
            Ok(InputMessageEntityMentionName {
                offset,
                length,
                user_id,
            })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for InputMessageEntityMentionName {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::InputMessageEntityMentionName(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessageId {
        pub id: i32,
    }
    impl crate::Identifiable for InputMessageId {
        const CONSTRUCTOR_ID: u32 = 2792792866;
    }
    impl crate::Serializable for InputMessageId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMessageId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            Ok(InputMessageId { id })
        }
    }
    impl TryFrom<crate::enums::InputMessage> for InputMessageId {
        type Error = ();
        fn try_from(x: crate::enums::InputMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMessage::Id(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagePinned {}
    impl crate::Identifiable for InputMessagePinned {
        const CONSTRUCTOR_ID: u32 = 2257003832;
    }
    impl crate::Serializable for InputMessagePinned {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagePinned {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagePinned {})
        }
    }
    impl TryFrom<crate::enums::InputMessage> for InputMessagePinned {
        type Error = ();
        fn try_from(x: crate::enums::InputMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMessage::Pinned => Ok(InputMessagePinned {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessageReplyTo {
        pub id: i32,
    }
    impl crate::Identifiable for InputMessageReplyTo {
        const CONSTRUCTOR_ID: u32 = 3134751637;
    }
    impl crate::Serializable for InputMessageReplyTo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputMessageReplyTo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            Ok(InputMessageReplyTo { id })
        }
    }
    impl TryFrom<crate::enums::InputMessage> for InputMessageReplyTo {
        type Error = ();
        fn try_from(x: crate::enums::InputMessage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputMessage::ReplyTo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterChatPhotos {}
    impl crate::Identifiable for InputMessagesFilterChatPhotos {
        const CONSTRUCTOR_ID: u32 = 975236280;
    }
    impl crate::Serializable for InputMessagesFilterChatPhotos {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterChatPhotos {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterChatPhotos {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterChatPhotos {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterChatPhotos => {
                    Ok(InputMessagesFilterChatPhotos {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterContacts {}
    impl crate::Identifiable for InputMessagesFilterContacts {
        const CONSTRUCTOR_ID: u32 = 3764575107;
    }
    impl crate::Serializable for InputMessagesFilterContacts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterContacts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterContacts {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterContacts {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterContacts => {
                    Ok(InputMessagesFilterContacts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterDocument {}
    impl crate::Identifiable for InputMessagesFilterDocument {
        const CONSTRUCTOR_ID: u32 = 2665345416;
    }
    impl crate::Serializable for InputMessagesFilterDocument {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterDocument {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterDocument {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterDocument {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterDocument => {
                    Ok(InputMessagesFilterDocument {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterEmpty {}
    impl crate::Identifiable for InputMessagesFilterEmpty {
        const CONSTRUCTOR_ID: u32 = 1474492012;
    }
    impl crate::Serializable for InputMessagesFilterEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterEmpty {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterEmpty {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterEmpty => {
                    Ok(InputMessagesFilterEmpty {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterGeo {}
    impl crate::Identifiable for InputMessagesFilterGeo {
        const CONSTRUCTOR_ID: u32 = 3875695885;
    }
    impl crate::Serializable for InputMessagesFilterGeo {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterGeo {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterGeo {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterGeo {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterGeo => {
                    Ok(InputMessagesFilterGeo {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterGif {}
    impl crate::Identifiable for InputMessagesFilterGif {
        const CONSTRUCTOR_ID: u32 = 4291323271;
    }
    impl crate::Serializable for InputMessagesFilterGif {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterGif {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterGif {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterGif {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterGif => {
                    Ok(InputMessagesFilterGif {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterMusic {}
    impl crate::Identifiable for InputMessagesFilterMusic {
        const CONSTRUCTOR_ID: u32 = 928101534;
    }
    impl crate::Serializable for InputMessagesFilterMusic {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterMusic {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterMusic {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterMusic {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterMusic => {
                    Ok(InputMessagesFilterMusic {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterMyMentions {}
    impl crate::Identifiable for InputMessagesFilterMyMentions {
        const CONSTRUCTOR_ID: u32 = 3254314650;
    }
    impl crate::Serializable for InputMessagesFilterMyMentions {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterMyMentions {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterMyMentions {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterMyMentions {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterMyMentions => {
                    Ok(InputMessagesFilterMyMentions {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterPhoneCalls {
        pub missed: bool,
    }
    impl crate::Identifiable for InputMessagesFilterPhoneCalls {
        const CONSTRUCTOR_ID: u32 = 2160695144;
    }
    impl crate::Serializable for InputMessagesFilterPhoneCalls {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.missed { 1 } else { 0 }).serialize(buf);
        }
    }
    impl crate::Deserializable for InputMessagesFilterPhoneCalls {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let missed = (flags & 1) != 0;
            Ok(InputMessagesFilterPhoneCalls { missed })
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterPhoneCalls {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterPhoneCalls(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterPhotoVideo {}
    impl crate::Identifiable for InputMessagesFilterPhotoVideo {
        const CONSTRUCTOR_ID: u32 = 1458172132;
    }
    impl crate::Serializable for InputMessagesFilterPhotoVideo {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterPhotoVideo {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterPhotoVideo {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterPhotoVideo {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterPhotoVideo => {
                    Ok(InputMessagesFilterPhotoVideo {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterPhotos {}
    impl crate::Identifiable for InputMessagesFilterPhotos {
        const CONSTRUCTOR_ID: u32 = 2517214492;
    }
    impl crate::Serializable for InputMessagesFilterPhotos {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterPhotos {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterPhotos {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterPhotos {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterPhotos => {
                    Ok(InputMessagesFilterPhotos {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterPinned {}
    impl crate::Identifiable for InputMessagesFilterPinned {
        const CONSTRUCTOR_ID: u32 = 464520273;
    }
    impl crate::Serializable for InputMessagesFilterPinned {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterPinned {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterPinned {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterPinned {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterPinned => {
                    Ok(InputMessagesFilterPinned {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterRoundVideo {}
    impl crate::Identifiable for InputMessagesFilterRoundVideo {
        const CONSTRUCTOR_ID: u32 = 3041516115;
    }
    impl crate::Serializable for InputMessagesFilterRoundVideo {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterRoundVideo {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterRoundVideo {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterRoundVideo {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterRoundVideo => {
                    Ok(InputMessagesFilterRoundVideo {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterRoundVoice {}
    impl crate::Identifiable for InputMessagesFilterRoundVoice {
        const CONSTRUCTOR_ID: u32 = 2054952868;
    }
    impl crate::Serializable for InputMessagesFilterRoundVoice {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterRoundVoice {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterRoundVoice {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterRoundVoice {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterRoundVoice => {
                    Ok(InputMessagesFilterRoundVoice {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterUrl {}
    impl crate::Identifiable for InputMessagesFilterUrl {
        const CONSTRUCTOR_ID: u32 = 2129714567;
    }
    impl crate::Serializable for InputMessagesFilterUrl {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterUrl {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterUrl {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterUrl {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterUrl => {
                    Ok(InputMessagesFilterUrl {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterVideo {}
    impl crate::Identifiable for InputMessagesFilterVideo {
        const CONSTRUCTOR_ID: u32 = 2680163941;
    }
    impl crate::Serializable for InputMessagesFilterVideo {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterVideo {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterVideo {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterVideo {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterVideo => {
                    Ok(InputMessagesFilterVideo {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputMessagesFilterVoice {}
    impl crate::Identifiable for InputMessagesFilterVoice {
        const CONSTRUCTOR_ID: u32 = 1358283666;
    }
    impl crate::Serializable for InputMessagesFilterVoice {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputMessagesFilterVoice {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputMessagesFilterVoice {})
        }
    }
    impl TryFrom<crate::enums::MessagesFilter> for InputMessagesFilterVoice {
        type Error = ();
        fn try_from(x: crate::enums::MessagesFilter) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessagesFilter::InputMessagesFilterVoice => {
                    Ok(InputMessagesFilterVoice {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputNotifyBroadcasts {}
    impl crate::Identifiable for InputNotifyBroadcasts {
        const CONSTRUCTOR_ID: u32 = 2983951486;
    }
    impl crate::Serializable for InputNotifyBroadcasts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputNotifyBroadcasts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputNotifyBroadcasts {})
        }
    }
    impl TryFrom<crate::enums::InputNotifyPeer> for InputNotifyBroadcasts {
        type Error = ();
        fn try_from(x: crate::enums::InputNotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputNotifyPeer::InputNotifyBroadcasts => {
                    Ok(InputNotifyBroadcasts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputNotifyChats {}
    impl crate::Identifiable for InputNotifyChats {
        const CONSTRUCTOR_ID: u32 = 1251338318;
    }
    impl crate::Serializable for InputNotifyChats {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputNotifyChats {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputNotifyChats {})
        }
    }
    impl TryFrom<crate::enums::InputNotifyPeer> for InputNotifyChats {
        type Error = ();
        fn try_from(x: crate::enums::InputNotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputNotifyPeer::InputNotifyChats => Ok(InputNotifyChats {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputNotifyPeer {
        pub peer: crate::enums::InputPeer,
    }
    impl crate::Identifiable for InputNotifyPeer {
        const CONSTRUCTOR_ID: u32 = 3099351820;
    }
    impl crate::Serializable for InputNotifyPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for InputNotifyPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            Ok(InputNotifyPeer { peer })
        }
    }
    impl TryFrom<crate::enums::InputNotifyPeer> for InputNotifyPeer {
        type Error = ();
        fn try_from(x: crate::enums::InputNotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputNotifyPeer::Peer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputNotifyUsers {}
    impl crate::Identifiable for InputNotifyUsers {
        const CONSTRUCTOR_ID: u32 = 423314455;
    }
    impl crate::Serializable for InputNotifyUsers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputNotifyUsers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputNotifyUsers {})
        }
    }
    impl TryFrom<crate::enums::InputNotifyPeer> for InputNotifyUsers {
        type Error = ();
        fn try_from(x: crate::enums::InputNotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputNotifyPeer::InputNotifyUsers => Ok(InputNotifyUsers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPaymentCredentials {
        pub save: bool,
        pub data: crate::enums::DataJson,
    }
    impl crate::Identifiable for InputPaymentCredentials {
        const CONSTRUCTOR_ID: u32 = 873977640;
    }
    impl crate::Serializable for InputPaymentCredentials {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.save { 1 } else { 0 }).serialize(buf);
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPaymentCredentials {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let save = (flags & 1) != 0;
            let data = crate::enums::DataJson::deserialize(buf)?;
            Ok(InputPaymentCredentials { save, data })
        }
    }
    impl TryFrom<crate::enums::InputPaymentCredentials> for InputPaymentCredentials {
        type Error = ();
        fn try_from(x: crate::enums::InputPaymentCredentials) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPaymentCredentials::Credentials(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPaymentCredentialsApplePay {
        pub payment_data: crate::enums::DataJson,
    }
    impl crate::Identifiable for InputPaymentCredentialsApplePay {
        const CONSTRUCTOR_ID: u32 = 178373535;
    }
    impl crate::Serializable for InputPaymentCredentialsApplePay {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.payment_data.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPaymentCredentialsApplePay {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let payment_data = crate::enums::DataJson::deserialize(buf)?;
            Ok(InputPaymentCredentialsApplePay { payment_data })
        }
    }
    impl TryFrom<crate::enums::InputPaymentCredentials> for InputPaymentCredentialsApplePay {
        type Error = ();
        fn try_from(x: crate::enums::InputPaymentCredentials) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPaymentCredentials::ApplePay(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPaymentCredentialsGooglePay {
        pub payment_token: crate::enums::DataJson,
    }
    impl crate::Identifiable for InputPaymentCredentialsGooglePay {
        const CONSTRUCTOR_ID: u32 = 2328045569;
    }
    impl crate::Serializable for InputPaymentCredentialsGooglePay {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.payment_token.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPaymentCredentialsGooglePay {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let payment_token = crate::enums::DataJson::deserialize(buf)?;
            Ok(InputPaymentCredentialsGooglePay { payment_token })
        }
    }
    impl TryFrom<crate::enums::InputPaymentCredentials> for InputPaymentCredentialsGooglePay {
        type Error = ();
        fn try_from(x: crate::enums::InputPaymentCredentials) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPaymentCredentials::GooglePay(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPaymentCredentialsSaved {
        pub id: String,
        pub tmp_password: Vec<u8>,
    }
    impl crate::Identifiable for InputPaymentCredentialsSaved {
        const CONSTRUCTOR_ID: u32 = 3238965967;
    }
    impl crate::Serializable for InputPaymentCredentialsSaved {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.tmp_password.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPaymentCredentialsSaved {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let tmp_password = Vec::<u8>::deserialize(buf)?;
            Ok(InputPaymentCredentialsSaved { id, tmp_password })
        }
    }
    impl TryFrom<crate::enums::InputPaymentCredentials> for InputPaymentCredentialsSaved {
        type Error = ();
        fn try_from(x: crate::enums::InputPaymentCredentials) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPaymentCredentials::Saved(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerChannel {
        pub channel_id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputPeerChannel {
        const CONSTRUCTOR_ID: u32 = 666680316;
    }
    impl crate::Serializable for InputPeerChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputPeerChannel {
                channel_id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerChannel {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerChannelFromMessage {
        pub peer: crate::enums::InputPeer,
        pub msg_id: i32,
        pub channel_id: i64,
    }
    impl crate::Identifiable for InputPeerChannelFromMessage {
        const CONSTRUCTOR_ID: u32 = 3173648448;
    }
    impl crate::Serializable for InputPeerChannelFromMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
            self.channel_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerChannelFromMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            Ok(InputPeerChannelFromMessage {
                peer,
                msg_id,
                channel_id,
            })
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerChannelFromMessage {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::ChannelFromMessage(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerChat {
        pub chat_id: i64,
    }
    impl crate::Identifiable for InputPeerChat {
        const CONSTRUCTOR_ID: u32 = 900291769;
    }
    impl crate::Serializable for InputPeerChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            Ok(InputPeerChat { chat_id })
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerChat {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerEmpty {}
    impl crate::Identifiable for InputPeerEmpty {
        const CONSTRUCTOR_ID: u32 = 2134579434;
    }
    impl crate::Serializable for InputPeerEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPeerEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPeerEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::Empty => Ok(InputPeerEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerNotifySettings {
        pub show_previews: Option<bool>,
        pub silent: Option<bool>,
        pub mute_until: Option<i32>,
        pub sound: Option<String>,
    }
    impl crate::Identifiable for InputPeerNotifySettings {
        const CONSTRUCTOR_ID: u32 = 2621249934;
    }
    impl crate::Serializable for InputPeerNotifySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.show_previews.is_some() { 1 } else { 0 }
                | if self.silent.is_some() { 2 } else { 0 }
                | if self.mute_until.is_some() { 4 } else { 0 }
                | if self.sound.is_some() { 8 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.show_previews {
                x.serialize(buf);
            }
            if let Some(ref x) = self.silent {
                x.serialize(buf);
            }
            if let Some(ref x) = self.mute_until {
                x.serialize(buf);
            }
            if let Some(ref x) = self.sound {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputPeerNotifySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let show_previews = if (flags & 1) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            let silent = if (flags & 2) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            let mute_until = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let sound = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputPeerNotifySettings {
                show_previews,
                silent,
                mute_until,
                sound,
            })
        }
    }
    impl From<crate::enums::InputPeerNotifySettings> for InputPeerNotifySettings {
        fn from(x: crate::enums::InputPeerNotifySettings) -> Self {
            match x {
                crate::enums::InputPeerNotifySettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerPhotoFileLocation {
        pub big: bool,
        pub peer: crate::enums::InputPeer,
        pub photo_id: i64,
    }
    impl crate::Identifiable for InputPeerPhotoFileLocation {
        const CONSTRUCTOR_ID: u32 = 925204121;
    }
    impl crate::Serializable for InputPeerPhotoFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.big { 1 } else { 0 }).serialize(buf);
            self.peer.serialize(buf);
            self.photo_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerPhotoFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let big = (flags & 1) != 0;
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let photo_id = i64::deserialize(buf)?;
            Ok(InputPeerPhotoFileLocation {
                big,
                peer,
                photo_id,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputPeerPhotoFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputPeerPhotoFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerSelf {}
    impl crate::Identifiable for InputPeerSelf {
        const CONSTRUCTOR_ID: u32 = 2107670217;
    }
    impl crate::Serializable for InputPeerSelf {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPeerSelf {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPeerSelf {})
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerSelf {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::PeerSelf => Ok(InputPeerSelf {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerUser {
        pub user_id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputPeerUser {
        const CONSTRUCTOR_ID: u32 = 3723011404;
    }
    impl crate::Serializable for InputPeerUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputPeerUser {
                user_id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerUser {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::User(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPeerUserFromMessage {
        pub peer: crate::enums::InputPeer,
        pub msg_id: i32,
        pub user_id: i64,
    }
    impl crate::Identifiable for InputPeerUserFromMessage {
        const CONSTRUCTOR_ID: u32 = 2826635804;
    }
    impl crate::Serializable for InputPeerUserFromMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPeerUserFromMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(InputPeerUserFromMessage {
                peer,
                msg_id,
                user_id,
            })
        }
    }
    impl TryFrom<crate::enums::InputPeer> for InputPeerUserFromMessage {
        type Error = ();
        fn try_from(x: crate::enums::InputPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPeer::UserFromMessage(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhoneCall {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputPhoneCall {
        const CONSTRUCTOR_ID: u32 = 506920429;
    }
    impl crate::Serializable for InputPhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputPhoneCall { id, access_hash })
        }
    }
    impl From<crate::enums::InputPhoneCall> for InputPhoneCall {
        fn from(x: crate::enums::InputPhoneCall) -> Self {
            match x {
                crate::enums::InputPhoneCall::Call(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhoneContact {
        pub client_id: i64,
        pub phone: String,
        pub first_name: String,
        pub last_name: String,
    }
    impl crate::Identifiable for InputPhoneContact {
        const CONSTRUCTOR_ID: u32 = 4086478836;
    }
    impl crate::Serializable for InputPhoneContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.client_id.serialize(buf);
            self.phone.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPhoneContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let client_id = i64::deserialize(buf)?;
            let phone = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            Ok(InputPhoneContact {
                client_id,
                phone,
                first_name,
                last_name,
            })
        }
    }
    impl From<crate::enums::InputContact> for InputPhoneContact {
        fn from(x: crate::enums::InputContact) -> Self {
            match x {
                crate::enums::InputContact::InputPhoneContact(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhoto {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
    }
    impl crate::Identifiable for InputPhoto {
        const CONSTRUCTOR_ID: u32 = 1001634122;
    }
    impl crate::Serializable for InputPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            Ok(InputPhoto {
                id,
                access_hash,
                file_reference,
            })
        }
    }
    impl TryFrom<crate::enums::InputPhoto> for InputPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPhoto::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhotoEmpty {}
    impl crate::Identifiable for InputPhotoEmpty {
        const CONSTRUCTOR_ID: u32 = 483901197;
    }
    impl crate::Serializable for InputPhotoEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPhotoEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPhotoEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputPhoto> for InputPhotoEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputPhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPhoto::Empty => Ok(InputPhotoEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhotoFileLocation {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
        pub thumb_size: String,
    }
    impl crate::Identifiable for InputPhotoFileLocation {
        const CONSTRUCTOR_ID: u32 = 1075322878;
    }
    impl crate::Serializable for InputPhotoFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
            self.thumb_size.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPhotoFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            let thumb_size = String::deserialize(buf)?;
            Ok(InputPhotoFileLocation {
                id,
                access_hash,
                file_reference,
                thumb_size,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputPhotoFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputPhotoFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPhotoLegacyFileLocation {
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
        pub volume_id: i64,
        pub local_id: i32,
        pub secret: i64,
    }
    impl crate::Identifiable for InputPhotoLegacyFileLocation {
        const CONSTRUCTOR_ID: u32 = 3627312883;
    }
    impl crate::Serializable for InputPhotoLegacyFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
            self.volume_id.serialize(buf);
            self.local_id.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPhotoLegacyFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            let volume_id = i64::deserialize(buf)?;
            let local_id = i32::deserialize(buf)?;
            let secret = i64::deserialize(buf)?;
            Ok(InputPhotoLegacyFileLocation {
                id,
                access_hash,
                file_reference,
                volume_id,
                local_id,
                secret,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputPhotoLegacyFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputPhotoLegacyFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyAddedByPhone {}
    impl crate::Identifiable for InputPrivacyKeyAddedByPhone {
        const CONSTRUCTOR_ID: u32 = 3508640733;
    }
    impl crate::Serializable for InputPrivacyKeyAddedByPhone {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyAddedByPhone {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyAddedByPhone {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyAddedByPhone {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::AddedByPhone => Ok(InputPrivacyKeyAddedByPhone {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyChatInvite {}
    impl crate::Identifiable for InputPrivacyKeyChatInvite {
        const CONSTRUCTOR_ID: u32 = 3187344422;
    }
    impl crate::Serializable for InputPrivacyKeyChatInvite {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyChatInvite {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyChatInvite {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyChatInvite {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::ChatInvite => Ok(InputPrivacyKeyChatInvite {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyForwards {}
    impl crate::Identifiable for InputPrivacyKeyForwards {
        const CONSTRUCTOR_ID: u32 = 2765966344;
    }
    impl crate::Serializable for InputPrivacyKeyForwards {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyForwards {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyForwards {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyForwards {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::Forwards => Ok(InputPrivacyKeyForwards {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyPhoneCall {}
    impl crate::Identifiable for InputPrivacyKeyPhoneCall {
        const CONSTRUCTOR_ID: u32 = 4206550111;
    }
    impl crate::Serializable for InputPrivacyKeyPhoneCall {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyPhoneCall {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyPhoneCall {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyPhoneCall {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::PhoneCall => Ok(InputPrivacyKeyPhoneCall {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyPhoneNumber {}
    impl crate::Identifiable for InputPrivacyKeyPhoneNumber {
        const CONSTRUCTOR_ID: u32 = 55761658;
    }
    impl crate::Serializable for InputPrivacyKeyPhoneNumber {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyPhoneNumber {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyPhoneNumber {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyPhoneNumber {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::PhoneNumber => Ok(InputPrivacyKeyPhoneNumber {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyPhoneP2P {}
    impl crate::Identifiable for InputPrivacyKeyPhoneP2P {
        const CONSTRUCTOR_ID: u32 = 3684593874;
    }
    impl crate::Serializable for InputPrivacyKeyPhoneP2P {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyPhoneP2P {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyPhoneP2P {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyPhoneP2P {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::PhoneP2P => Ok(InputPrivacyKeyPhoneP2P {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyProfilePhoto {}
    impl crate::Identifiable for InputPrivacyKeyProfilePhoto {
        const CONSTRUCTOR_ID: u32 = 1461304012;
    }
    impl crate::Serializable for InputPrivacyKeyProfilePhoto {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyProfilePhoto {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyProfilePhoto {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyProfilePhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::ProfilePhoto => Ok(InputPrivacyKeyProfilePhoto {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyKeyStatusTimestamp {}
    impl crate::Identifiable for InputPrivacyKeyStatusTimestamp {
        const CONSTRUCTOR_ID: u32 = 1335282456;
    }
    impl crate::Serializable for InputPrivacyKeyStatusTimestamp {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyKeyStatusTimestamp {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyKeyStatusTimestamp {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyKey> for InputPrivacyKeyStatusTimestamp {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyKey::StatusTimestamp => {
                    Ok(InputPrivacyKeyStatusTimestamp {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueAllowAll {}
    impl crate::Identifiable for InputPrivacyValueAllowAll {
        const CONSTRUCTOR_ID: u32 = 407582158;
    }
    impl crate::Serializable for InputPrivacyValueAllowAll {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyValueAllowAll {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyValueAllowAll {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueAllowAll {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueAllowAll => {
                    Ok(InputPrivacyValueAllowAll {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueAllowChatParticipants {
        pub chats: Vec<i64>,
    }
    impl crate::Identifiable for InputPrivacyValueAllowChatParticipants {
        const CONSTRUCTOR_ID: u32 = 2215004623;
    }
    impl crate::Serializable for InputPrivacyValueAllowChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chats.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPrivacyValueAllowChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chats = Vec::<i64>::deserialize(buf)?;
            Ok(InputPrivacyValueAllowChatParticipants { chats })
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueAllowChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueAllowChatParticipants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueAllowContacts {}
    impl crate::Identifiable for InputPrivacyValueAllowContacts {
        const CONSTRUCTOR_ID: u32 = 218751099;
    }
    impl crate::Serializable for InputPrivacyValueAllowContacts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyValueAllowContacts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyValueAllowContacts {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueAllowContacts {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueAllowContacts => {
                    Ok(InputPrivacyValueAllowContacts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueAllowUsers {
        pub users: Vec<crate::enums::InputUser>,
    }
    impl crate::Identifiable for InputPrivacyValueAllowUsers {
        const CONSTRUCTOR_ID: u32 = 320652927;
    }
    impl crate::Serializable for InputPrivacyValueAllowUsers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPrivacyValueAllowUsers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let users = Vec::<crate::enums::InputUser>::deserialize(buf)?;
            Ok(InputPrivacyValueAllowUsers { users })
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueAllowUsers {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueAllowUsers(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueDisallowAll {}
    impl crate::Identifiable for InputPrivacyValueDisallowAll {
        const CONSTRUCTOR_ID: u32 = 3597362889;
    }
    impl crate::Serializable for InputPrivacyValueDisallowAll {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyValueDisallowAll {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyValueDisallowAll {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueDisallowAll {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueDisallowAll => {
                    Ok(InputPrivacyValueDisallowAll {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueDisallowChatParticipants {
        pub chats: Vec<i64>,
    }
    impl crate::Identifiable for InputPrivacyValueDisallowChatParticipants {
        const CONSTRUCTOR_ID: u32 = 3914272646;
    }
    impl crate::Serializable for InputPrivacyValueDisallowChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chats.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPrivacyValueDisallowChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chats = Vec::<i64>::deserialize(buf)?;
            Ok(InputPrivacyValueDisallowChatParticipants { chats })
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueDisallowChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueDisallowChatParticipants(x) => {
                    Ok(x)
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueDisallowContacts {}
    impl crate::Identifiable for InputPrivacyValueDisallowContacts {
        const CONSTRUCTOR_ID: u32 = 195371015;
    }
    impl crate::Serializable for InputPrivacyValueDisallowContacts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputPrivacyValueDisallowContacts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputPrivacyValueDisallowContacts {})
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueDisallowContacts {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueDisallowContacts => {
                    Ok(InputPrivacyValueDisallowContacts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputPrivacyValueDisallowUsers {
        pub users: Vec<crate::enums::InputUser>,
    }
    impl crate::Identifiable for InputPrivacyValueDisallowUsers {
        const CONSTRUCTOR_ID: u32 = 2417034343;
    }
    impl crate::Serializable for InputPrivacyValueDisallowUsers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for InputPrivacyValueDisallowUsers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let users = Vec::<crate::enums::InputUser>::deserialize(buf)?;
            Ok(InputPrivacyValueDisallowUsers { users })
        }
    }
    impl TryFrom<crate::enums::InputPrivacyRule> for InputPrivacyValueDisallowUsers {
        type Error = ();
        fn try_from(x: crate::enums::InputPrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputPrivacyRule::InputPrivacyValueDisallowUsers(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonChildAbuse {}
    impl crate::Identifiable for InputReportReasonChildAbuse {
        const CONSTRUCTOR_ID: u32 = 2918469347;
    }
    impl crate::Serializable for InputReportReasonChildAbuse {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonChildAbuse {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonChildAbuse {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonChildAbuse {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonChildAbuse => {
                    Ok(InputReportReasonChildAbuse {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonCopyright {}
    impl crate::Identifiable for InputReportReasonCopyright {
        const CONSTRUCTOR_ID: u32 = 2609510714;
    }
    impl crate::Serializable for InputReportReasonCopyright {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonCopyright {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonCopyright {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonCopyright {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonCopyright => {
                    Ok(InputReportReasonCopyright {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonFake {}
    impl crate::Identifiable for InputReportReasonFake {
        const CONSTRUCTOR_ID: u32 = 4124956391;
    }
    impl crate::Serializable for InputReportReasonFake {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonFake {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonFake {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonFake {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonFake => Ok(InputReportReasonFake {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonGeoIrrelevant {}
    impl crate::Identifiable for InputReportReasonGeoIrrelevant {
        const CONSTRUCTOR_ID: u32 = 3688169197;
    }
    impl crate::Serializable for InputReportReasonGeoIrrelevant {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonGeoIrrelevant {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonGeoIrrelevant {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonGeoIrrelevant {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonGeoIrrelevant => {
                    Ok(InputReportReasonGeoIrrelevant {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonOther {}
    impl crate::Identifiable for InputReportReasonOther {
        const CONSTRUCTOR_ID: u32 = 3252986545;
    }
    impl crate::Serializable for InputReportReasonOther {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonOther {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonOther {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonOther {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonOther => Ok(InputReportReasonOther {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonPornography {}
    impl crate::Identifiable for InputReportReasonPornography {
        const CONSTRUCTOR_ID: u32 = 777640226;
    }
    impl crate::Serializable for InputReportReasonPornography {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonPornography {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonPornography {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonPornography {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonPornography => {
                    Ok(InputReportReasonPornography {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonSpam {}
    impl crate::Identifiable for InputReportReasonSpam {
        const CONSTRUCTOR_ID: u32 = 1490799288;
    }
    impl crate::Serializable for InputReportReasonSpam {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonSpam {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonSpam {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonSpam {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonSpam => Ok(InputReportReasonSpam {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputReportReasonViolence {}
    impl crate::Identifiable for InputReportReasonViolence {
        const CONSTRUCTOR_ID: u32 = 505595789;
    }
    impl crate::Serializable for InputReportReasonViolence {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputReportReasonViolence {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputReportReasonViolence {})
        }
    }
    impl TryFrom<crate::enums::ReportReason> for InputReportReasonViolence {
        type Error = ();
        fn try_from(x: crate::enums::ReportReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReportReason::InputReportReasonViolence => {
                    Ok(InputReportReasonViolence {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputSecureFile {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputSecureFile {
        const CONSTRUCTOR_ID: u32 = 1399317950;
    }
    impl crate::Serializable for InputSecureFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputSecureFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputSecureFile { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputSecureFile> for InputSecureFile {
        type Error = ();
        fn try_from(x: crate::enums::InputSecureFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputSecureFile::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputSecureFileLocation {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputSecureFileLocation {
        const CONSTRUCTOR_ID: u32 = 3418877480;
    }
    impl crate::Serializable for InputSecureFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputSecureFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputSecureFileLocation { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputSecureFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputSecureFileLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputSecureFileUploaded {
        pub id: i64,
        pub parts: i32,
        pub md5_checksum: String,
        pub file_hash: Vec<u8>,
        pub secret: Vec<u8>,
    }
    impl crate::Identifiable for InputSecureFileUploaded {
        const CONSTRUCTOR_ID: u32 = 859091184;
    }
    impl crate::Serializable for InputSecureFileUploaded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.parts.serialize(buf);
            self.md5_checksum.serialize(buf);
            self.file_hash.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for InputSecureFileUploaded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let parts = i32::deserialize(buf)?;
            let md5_checksum = String::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let secret = Vec::<u8>::deserialize(buf)?;
            Ok(InputSecureFileUploaded {
                id,
                parts,
                md5_checksum,
                file_hash,
                secret,
            })
        }
    }
    impl TryFrom<crate::enums::InputSecureFile> for InputSecureFileUploaded {
        type Error = ();
        fn try_from(x: crate::enums::InputSecureFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputSecureFile::Uploaded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputSecureValue {
        pub r#type: crate::enums::SecureValueType,
        pub data: Option<crate::enums::SecureData>,
        pub front_side: Option<crate::enums::InputSecureFile>,
        pub reverse_side: Option<crate::enums::InputSecureFile>,
        pub selfie: Option<crate::enums::InputSecureFile>,
        pub translation: Option<Vec<crate::enums::InputSecureFile>>,
        pub files: Option<Vec<crate::enums::InputSecureFile>>,
        pub plain_data: Option<crate::enums::SecurePlainData>,
    }
    impl crate::Identifiable for InputSecureValue {
        const CONSTRUCTOR_ID: u32 = 3676426407;
    }
    impl crate::Serializable for InputSecureValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.data.is_some() { 1 } else { 0 }
                | if self.front_side.is_some() { 2 } else { 0 }
                | if self.reverse_side.is_some() { 4 } else { 0 }
                | if self.selfie.is_some() { 8 } else { 0 }
                | if self.translation.is_some() { 64 } else { 0 }
                | if self.files.is_some() { 16 } else { 0 }
                | if self.plain_data.is_some() { 32 } else { 0 })
            .serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.data {
                x.serialize(buf);
            }
            if let Some(ref x) = self.front_side {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reverse_side {
                x.serialize(buf);
            }
            if let Some(ref x) = self.selfie {
                x.serialize(buf);
            }
            if let Some(ref x) = self.translation {
                x.serialize(buf);
            }
            if let Some(ref x) = self.files {
                x.serialize(buf);
            }
            if let Some(ref x) = self.plain_data {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputSecureValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let data = if (flags & 1) != 0 {
                Some(crate::enums::SecureData::deserialize(buf)?)
            } else {
                None
            };
            let front_side = if (flags & 2) != 0 {
                Some(crate::enums::InputSecureFile::deserialize(buf)?)
            } else {
                None
            };
            let reverse_side = if (flags & 4) != 0 {
                Some(crate::enums::InputSecureFile::deserialize(buf)?)
            } else {
                None
            };
            let selfie = if (flags & 8) != 0 {
                Some(crate::enums::InputSecureFile::deserialize(buf)?)
            } else {
                None
            };
            let translation = if (flags & 64) != 0 {
                Some(Vec::<crate::enums::InputSecureFile>::deserialize(buf)?)
            } else {
                None
            };
            let files = if (flags & 16) != 0 {
                Some(Vec::<crate::enums::InputSecureFile>::deserialize(buf)?)
            } else {
                None
            };
            let plain_data = if (flags & 32) != 0 {
                Some(crate::enums::SecurePlainData::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputSecureValue {
                r#type,
                data,
                front_side,
                reverse_side,
                selfie,
                translation,
                files,
                plain_data,
            })
        }
    }
    impl From<crate::enums::InputSecureValue> for InputSecureValue {
        fn from(x: crate::enums::InputSecureValue) -> Self {
            match x {
                crate::enums::InputSecureValue::Value(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputSingleMedia {
        pub media: crate::enums::InputMedia,
        pub random_id: i64,
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
    }
    impl crate::Identifiable for InputSingleMedia {
        const CONSTRUCTOR_ID: u32 = 482797855;
    }
    impl crate::Serializable for InputSingleMedia {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.entities.is_some() { 1 } else { 0 }).serialize(buf);
            self.media.serialize(buf);
            self.random_id.serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputSingleMedia {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let media = crate::enums::InputMedia::deserialize(buf)?;
            let random_id = i64::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let entities = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputSingleMedia {
                media,
                random_id,
                message,
                entities,
            })
        }
    }
    impl From<crate::enums::InputSingleMedia> for InputSingleMedia {
        fn from(x: crate::enums::InputSingleMedia) -> Self {
            match x {
                crate::enums::InputSingleMedia::Media(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetAnimatedEmoji {}
    impl crate::Identifiable for InputStickerSetAnimatedEmoji {
        const CONSTRUCTOR_ID: u32 = 42402760;
    }
    impl crate::Serializable for InputStickerSetAnimatedEmoji {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputStickerSetAnimatedEmoji {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputStickerSetAnimatedEmoji {})
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetAnimatedEmoji {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::AnimatedEmoji => Ok(InputStickerSetAnimatedEmoji {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetAnimatedEmojiAnimations {}
    impl crate::Identifiable for InputStickerSetAnimatedEmojiAnimations {
        const CONSTRUCTOR_ID: u32 = 215889721;
    }
    impl crate::Serializable for InputStickerSetAnimatedEmojiAnimations {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputStickerSetAnimatedEmojiAnimations {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputStickerSetAnimatedEmojiAnimations {})
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetAnimatedEmojiAnimations {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::AnimatedEmojiAnimations => {
                    Ok(InputStickerSetAnimatedEmojiAnimations {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetDice {
        pub emoticon: String,
    }
    impl crate::Identifiable for InputStickerSetDice {
        const CONSTRUCTOR_ID: u32 = 3867103758;
    }
    impl crate::Serializable for InputStickerSetDice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickerSetDice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            Ok(InputStickerSetDice { emoticon })
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetDice {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::Dice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetEmpty {}
    impl crate::Identifiable for InputStickerSetEmpty {
        const CONSTRUCTOR_ID: u32 = 4290128789;
    }
    impl crate::Serializable for InputStickerSetEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputStickerSetEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputStickerSetEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::Empty => Ok(InputStickerSetEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetId {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputStickerSetId {
        const CONSTRUCTOR_ID: u32 = 2649203305;
    }
    impl crate::Serializable for InputStickerSetId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickerSetId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputStickerSetId { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetId {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::Id(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetItem {
        pub document: crate::enums::InputDocument,
        pub emoji: String,
        pub mask_coords: Option<crate::enums::MaskCoords>,
    }
    impl crate::Identifiable for InputStickerSetItem {
        const CONSTRUCTOR_ID: u32 = 4288717974;
    }
    impl crate::Serializable for InputStickerSetItem {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.mask_coords.is_some() { 1 } else { 0 }).serialize(buf);
            self.document.serialize(buf);
            self.emoji.serialize(buf);
            if let Some(ref x) = self.mask_coords {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputStickerSetItem {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let document = crate::enums::InputDocument::deserialize(buf)?;
            let emoji = String::deserialize(buf)?;
            let mask_coords = if (flags & 1) != 0 {
                Some(crate::enums::MaskCoords::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputStickerSetItem {
                document,
                emoji,
                mask_coords,
            })
        }
    }
    impl From<crate::enums::InputStickerSetItem> for InputStickerSetItem {
        fn from(x: crate::enums::InputStickerSetItem) -> Self {
            match x {
                crate::enums::InputStickerSetItem::Item(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetShortName {
        pub short_name: String,
    }
    impl crate::Identifiable for InputStickerSetShortName {
        const CONSTRUCTOR_ID: u32 = 2250033312;
    }
    impl crate::Serializable for InputStickerSetShortName {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.short_name.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickerSetShortName {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let short_name = String::deserialize(buf)?;
            Ok(InputStickerSetShortName { short_name })
        }
    }
    impl TryFrom<crate::enums::InputStickerSet> for InputStickerSetShortName {
        type Error = ();
        fn try_from(x: crate::enums::InputStickerSet) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickerSet::ShortName(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickerSetThumb {
        pub stickerset: crate::enums::InputStickerSet,
        pub thumb_version: i32,
    }
    impl crate::Identifiable for InputStickerSetThumb {
        const CONSTRUCTOR_ID: u32 = 2642736091;
    }
    impl crate::Serializable for InputStickerSetThumb {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.stickerset.serialize(buf);
            self.thumb_version.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickerSetThumb {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let stickerset = crate::enums::InputStickerSet::deserialize(buf)?;
            let thumb_version = i32::deserialize(buf)?;
            Ok(InputStickerSetThumb {
                stickerset,
                thumb_version,
            })
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputStickerSetThumb {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputStickerSetThumb(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickeredMediaDocument {
        pub id: crate::enums::InputDocument,
    }
    impl crate::Identifiable for InputStickeredMediaDocument {
        const CONSTRUCTOR_ID: u32 = 70813275;
    }
    impl crate::Serializable for InputStickeredMediaDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickeredMediaDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = crate::enums::InputDocument::deserialize(buf)?;
            Ok(InputStickeredMediaDocument { id })
        }
    }
    impl TryFrom<crate::enums::InputStickeredMedia> for InputStickeredMediaDocument {
        type Error = ();
        fn try_from(x: crate::enums::InputStickeredMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickeredMedia::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputStickeredMediaPhoto {
        pub id: crate::enums::InputPhoto,
    }
    impl crate::Identifiable for InputStickeredMediaPhoto {
        const CONSTRUCTOR_ID: u32 = 1251549527;
    }
    impl crate::Serializable for InputStickeredMediaPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputStickeredMediaPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = crate::enums::InputPhoto::deserialize(buf)?;
            Ok(InputStickeredMediaPhoto { id })
        }
    }
    impl TryFrom<crate::enums::InputStickeredMedia> for InputStickeredMediaPhoto {
        type Error = ();
        fn try_from(x: crate::enums::InputStickeredMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputStickeredMedia::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputTakeoutFileLocation {}
    impl crate::Identifiable for InputTakeoutFileLocation {
        const CONSTRUCTOR_ID: u32 = 700340377;
    }
    impl crate::Serializable for InputTakeoutFileLocation {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputTakeoutFileLocation {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputTakeoutFileLocation {})
        }
    }
    impl TryFrom<crate::enums::InputFileLocation> for InputTakeoutFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputFileLocation::InputTakeoutFileLocation => {
                    Ok(InputTakeoutFileLocation {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputTheme {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputTheme {
        const CONSTRUCTOR_ID: u32 = 1012306921;
    }
    impl crate::Serializable for InputTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputTheme { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputTheme> for InputTheme {
        type Error = ();
        fn try_from(x: crate::enums::InputTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputTheme::Theme(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputThemeSettings {
        pub message_colors_animated: bool,
        pub base_theme: crate::enums::BaseTheme,
        pub accent_color: i32,
        pub outbox_accent_color: Option<i32>,
        pub message_colors: Option<Vec<i32>>,
        pub wallpaper: Option<crate::enums::InputWallPaper>,
        pub wallpaper_settings: Option<crate::enums::WallPaperSettings>,
    }
    impl crate::Identifiable for InputThemeSettings {
        const CONSTRUCTOR_ID: u32 = 2413711439;
    }
    impl crate::Serializable for InputThemeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.message_colors_animated { 4 } else { 0 }
                | if self.outbox_accent_color.is_some() {
                    8
                } else {
                    0
                }
                | if self.message_colors.is_some() { 1 } else { 0 }
                | if self.wallpaper.is_some() { 2 } else { 0 }
                | if self.wallpaper_settings.is_some() {
                    2
                } else {
                    0
                })
            .serialize(buf);
            self.base_theme.serialize(buf);
            self.accent_color.serialize(buf);
            if let Some(ref x) = self.outbox_accent_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.message_colors {
                x.serialize(buf);
            }
            if let Some(ref x) = self.wallpaper {
                x.serialize(buf);
            }
            if let Some(ref x) = self.wallpaper_settings {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for InputThemeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let message_colors_animated = (flags & 4) != 0;
            let base_theme = crate::enums::BaseTheme::deserialize(buf)?;
            let accent_color = i32::deserialize(buf)?;
            let outbox_accent_color = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let message_colors = if (flags & 1) != 0 {
                Some(Vec::<i32>::deserialize(buf)?)
            } else {
                None
            };
            let wallpaper = if (flags & 2) != 0 {
                Some(crate::enums::InputWallPaper::deserialize(buf)?)
            } else {
                None
            };
            let wallpaper_settings = if (flags & 2) != 0 {
                Some(crate::enums::WallPaperSettings::deserialize(buf)?)
            } else {
                None
            };
            Ok(InputThemeSettings {
                message_colors_animated,
                base_theme,
                accent_color,
                outbox_accent_color,
                message_colors,
                wallpaper,
                wallpaper_settings,
            })
        }
    }
    impl From<crate::enums::InputThemeSettings> for InputThemeSettings {
        fn from(x: crate::enums::InputThemeSettings) -> Self {
            match x {
                crate::enums::InputThemeSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputThemeSlug {
        pub slug: String,
    }
    impl crate::Identifiable for InputThemeSlug {
        const CONSTRUCTOR_ID: u32 = 4119399921;
    }
    impl crate::Serializable for InputThemeSlug {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.slug.serialize(buf);
        }
    }
    impl crate::Deserializable for InputThemeSlug {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let slug = String::deserialize(buf)?;
            Ok(InputThemeSlug { slug })
        }
    }
    impl TryFrom<crate::enums::InputTheme> for InputThemeSlug {
        type Error = ();
        fn try_from(x: crate::enums::InputTheme) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputTheme::Slug(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputUser {
        pub user_id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputUser {
        const CONSTRUCTOR_ID: u32 = 4061223110;
    }
    impl crate::Serializable for InputUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputUser {
                user_id,
                access_hash,
            })
        }
    }
    impl TryFrom<crate::enums::InputUser> for InputUser {
        type Error = ();
        fn try_from(x: crate::enums::InputUser) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputUser::User(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputUserEmpty {}
    impl crate::Identifiable for InputUserEmpty {
        const CONSTRUCTOR_ID: u32 = 3112732367;
    }
    impl crate::Serializable for InputUserEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputUserEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputUserEmpty {})
        }
    }
    impl TryFrom<crate::enums::InputUser> for InputUserEmpty {
        type Error = ();
        fn try_from(x: crate::enums::InputUser) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputUser::Empty => Ok(InputUserEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputUserFromMessage {
        pub peer: crate::enums::InputPeer,
        pub msg_id: i32,
        pub user_id: i64,
    }
    impl crate::Identifiable for InputUserFromMessage {
        const CONSTRUCTOR_ID: u32 = 497305826;
    }
    impl crate::Serializable for InputUserFromMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputUserFromMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::InputPeer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(InputUserFromMessage {
                peer,
                msg_id,
                user_id,
            })
        }
    }
    impl TryFrom<crate::enums::InputUser> for InputUserFromMessage {
        type Error = ();
        fn try_from(x: crate::enums::InputUser) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputUser::FromMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputUserSelf {}
    impl crate::Identifiable for InputUserSelf {
        const CONSTRUCTOR_ID: u32 = 4156666175;
    }
    impl crate::Serializable for InputUserSelf {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for InputUserSelf {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(InputUserSelf {})
        }
    }
    impl TryFrom<crate::enums::InputUser> for InputUserSelf {
        type Error = ();
        fn try_from(x: crate::enums::InputUser) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputUser::UserSelf => Ok(InputUserSelf {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWallPaper {
        pub id: i64,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputWallPaper {
        const CONSTRUCTOR_ID: u32 = 3861952889;
    }
    impl crate::Serializable for InputWallPaper {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWallPaper {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputWallPaper { id, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputWallPaper> for InputWallPaper {
        type Error = ();
        fn try_from(x: crate::enums::InputWallPaper) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputWallPaper::Paper(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWallPaperNoFile {
        pub id: i64,
    }
    impl crate::Identifiable for InputWallPaperNoFile {
        const CONSTRUCTOR_ID: u32 = 2524595758;
    }
    impl crate::Serializable for InputWallPaperNoFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWallPaperNoFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(InputWallPaperNoFile { id })
        }
    }
    impl TryFrom<crate::enums::InputWallPaper> for InputWallPaperNoFile {
        type Error = ();
        fn try_from(x: crate::enums::InputWallPaper) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputWallPaper::NoFile(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWallPaperSlug {
        pub slug: String,
    }
    impl crate::Identifiable for InputWallPaperSlug {
        const CONSTRUCTOR_ID: u32 = 1913199744;
    }
    impl crate::Serializable for InputWallPaperSlug {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.slug.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWallPaperSlug {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let slug = String::deserialize(buf)?;
            Ok(InputWallPaperSlug { slug })
        }
    }
    impl TryFrom<crate::enums::InputWallPaper> for InputWallPaperSlug {
        type Error = ();
        fn try_from(x: crate::enums::InputWallPaper) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputWallPaper::Slug(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWebDocument {
        pub url: String,
        pub size: i32,
        pub mime_type: String,
        pub attributes: Vec<crate::enums::DocumentAttribute>,
    }
    impl crate::Identifiable for InputWebDocument {
        const CONSTRUCTOR_ID: u32 = 2616017741;
    }
    impl crate::Serializable for InputWebDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.size.serialize(buf);
            self.mime_type.serialize(buf);
            self.attributes.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWebDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let mime_type = String::deserialize(buf)?;
            let attributes = Vec::<crate::enums::DocumentAttribute>::deserialize(buf)?;
            Ok(InputWebDocument {
                url,
                size,
                mime_type,
                attributes,
            })
        }
    }
    impl From<crate::enums::InputWebDocument> for InputWebDocument {
        fn from(x: crate::enums::InputWebDocument) -> Self {
            match x {
                crate::enums::InputWebDocument::Document(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWebFileGeoPointLocation {
        pub geo_point: crate::enums::InputGeoPoint,
        pub access_hash: i64,
        pub w: i32,
        pub h: i32,
        pub zoom: i32,
        pub scale: i32,
    }
    impl crate::Identifiable for InputWebFileGeoPointLocation {
        const CONSTRUCTOR_ID: u32 = 2669814217;
    }
    impl crate::Serializable for InputWebFileGeoPointLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo_point.serialize(buf);
            self.access_hash.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.zoom.serialize(buf);
            self.scale.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWebFileGeoPointLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo_point = crate::enums::InputGeoPoint::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let zoom = i32::deserialize(buf)?;
            let scale = i32::deserialize(buf)?;
            Ok(InputWebFileGeoPointLocation {
                geo_point,
                access_hash,
                w,
                h,
                zoom,
                scale,
            })
        }
    }
    impl TryFrom<crate::enums::InputWebFileLocation> for InputWebFileGeoPointLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputWebFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputWebFileLocation::InputWebFileGeoPointLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InputWebFileLocation {
        pub url: String,
        pub access_hash: i64,
    }
    impl crate::Identifiable for InputWebFileLocation {
        const CONSTRUCTOR_ID: u32 = 3258570374;
    }
    impl crate::Serializable for InputWebFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.access_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for InputWebFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            Ok(InputWebFileLocation { url, access_hash })
        }
    }
    impl TryFrom<crate::enums::InputWebFileLocation> for InputWebFileLocation {
        type Error = ();
        fn try_from(x: crate::enums::InputWebFileLocation) -> Result<Self, Self::Error> {
            match x {
                crate::enums::InputWebFileLocation::Location(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Invoice {
        pub test: bool,
        pub name_requested: bool,
        pub phone_requested: bool,
        pub email_requested: bool,
        pub shipping_address_requested: bool,
        pub flexible: bool,
        pub phone_to_provider: bool,
        pub email_to_provider: bool,
        pub currency: String,
        pub prices: Vec<crate::enums::LabeledPrice>,
        pub max_tip_amount: Option<i64>,
        pub suggested_tip_amounts: Option<Vec<i64>>,
    }
    impl crate::Identifiable for Invoice {
        const CONSTRUCTOR_ID: u32 = 215516896;
    }
    impl crate::Serializable for Invoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.test { 1 } else { 0 }
                | if self.name_requested { 2 } else { 0 }
                | if self.phone_requested { 4 } else { 0 }
                | if self.email_requested { 8 } else { 0 }
                | if self.shipping_address_requested {
                    16
                } else {
                    0
                }
                | if self.flexible { 32 } else { 0 }
                | if self.phone_to_provider { 64 } else { 0 }
                | if self.email_to_provider { 128 } else { 0 }
                | if self.max_tip_amount.is_some() {
                    256
                } else {
                    0
                }
                | if self.suggested_tip_amounts.is_some() {
                    256
                } else {
                    0
                })
            .serialize(buf);
            self.currency.serialize(buf);
            self.prices.serialize(buf);
            if let Some(ref x) = self.max_tip_amount {
                x.serialize(buf);
            }
            if let Some(ref x) = self.suggested_tip_amounts {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Invoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let test = (flags & 1) != 0;
            let name_requested = (flags & 2) != 0;
            let phone_requested = (flags & 4) != 0;
            let email_requested = (flags & 8) != 0;
            let shipping_address_requested = (flags & 16) != 0;
            let flexible = (flags & 32) != 0;
            let phone_to_provider = (flags & 64) != 0;
            let email_to_provider = (flags & 128) != 0;
            let currency = String::deserialize(buf)?;
            let prices = Vec::<crate::enums::LabeledPrice>::deserialize(buf)?;
            let max_tip_amount = if (flags & 256) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let suggested_tip_amounts = if (flags & 256) != 0 {
                Some(Vec::<i64>::deserialize(buf)?)
            } else {
                None
            };
            Ok(Invoice {
                test,
                name_requested,
                phone_requested,
                email_requested,
                shipping_address_requested,
                flexible,
                phone_to_provider,
                email_to_provider,
                currency,
                prices,
                max_tip_amount,
                suggested_tip_amounts,
            })
        }
    }
    impl From<crate::enums::Invoice> for Invoice {
        fn from(x: crate::enums::Invoice) -> Self {
            match x {
                crate::enums::Invoice::Invoice(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct IpPort {
        pub ipv4: i32,
        pub port: i32,
    }
    impl crate::Identifiable for IpPort {
        const CONSTRUCTOR_ID: u32 = 3560156531;
    }
    impl crate::Serializable for IpPort {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.ipv4.serialize(buf);
            self.port.serialize(buf);
        }
    }
    impl crate::Deserializable for IpPort {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let ipv4 = i32::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            Ok(IpPort { ipv4, port })
        }
    }
    impl TryFrom<crate::enums::IpPort> for IpPort {
        type Error = ();
        fn try_from(x: crate::enums::IpPort) -> Result<Self, Self::Error> {
            match x {
                crate::enums::IpPort::Port(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct IpPortSecret {
        pub ipv4: i32,
        pub port: i32,
        pub secret: Vec<u8>,
    }
    impl crate::Identifiable for IpPortSecret {
        const CONSTRUCTOR_ID: u32 = 932718150;
    }
    impl crate::Serializable for IpPortSecret {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.ipv4.serialize(buf);
            self.port.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for IpPortSecret {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let ipv4 = i32::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            let secret = Vec::<u8>::deserialize(buf)?;
            Ok(IpPortSecret { ipv4, port, secret })
        }
    }
    impl TryFrom<crate::enums::IpPort> for IpPortSecret {
        type Error = ();
        fn try_from(x: crate::enums::IpPort) -> Result<Self, Self::Error> {
            match x {
                crate::enums::IpPort::Secret(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonArray {
        pub value: Vec<crate::enums::Jsonvalue>,
    }
    impl crate::Identifiable for JsonArray {
        const CONSTRUCTOR_ID: u32 = 4148447075;
    }
    impl crate::Serializable for JsonArray {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonArray {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = Vec::<crate::enums::Jsonvalue>::deserialize(buf)?;
            Ok(JsonArray { value })
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonArray {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonArray(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonBool {
        pub value: bool,
    }
    impl crate::Identifiable for JsonBool {
        const CONSTRUCTOR_ID: u32 = 3342098026;
    }
    impl crate::Serializable for JsonBool {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonBool {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = bool::deserialize(buf)?;
            Ok(JsonBool { value })
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonBool {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonBool(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonNull {}
    impl crate::Identifiable for JsonNull {
        const CONSTRUCTOR_ID: u32 = 1064139624;
    }
    impl crate::Serializable for JsonNull {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for JsonNull {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(JsonNull {})
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonNull {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonNull => Ok(JsonNull {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonNumber {
        pub value: f64,
    }
    impl crate::Identifiable for JsonNumber {
        const CONSTRUCTOR_ID: u32 = 736157604;
    }
    impl crate::Serializable for JsonNumber {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonNumber {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = f64::deserialize(buf)?;
            Ok(JsonNumber { value })
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonNumber {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonNumber(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonObject {
        pub value: Vec<crate::enums::JsonobjectValue>,
    }
    impl crate::Identifiable for JsonObject {
        const CONSTRUCTOR_ID: u32 = 2579616925;
    }
    impl crate::Serializable for JsonObject {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonObject {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = Vec::<crate::enums::JsonobjectValue>::deserialize(buf)?;
            Ok(JsonObject { value })
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonObject {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonObject(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonObjectValue {
        pub key: String,
        pub value: crate::enums::Jsonvalue,
    }
    impl crate::Identifiable for JsonObjectValue {
        const CONSTRUCTOR_ID: u32 = 3235781593;
    }
    impl crate::Serializable for JsonObjectValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.key.serialize(buf);
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonObjectValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let key = String::deserialize(buf)?;
            let value = crate::enums::Jsonvalue::deserialize(buf)?;
            Ok(JsonObjectValue { key, value })
        }
    }
    impl From<crate::enums::JsonobjectValue> for JsonObjectValue {
        fn from(x: crate::enums::JsonobjectValue) -> Self {
            match x {
                crate::enums::JsonobjectValue::JsonObjectValue(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct JsonString {
        pub value: String,
    }
    impl crate::Identifiable for JsonString {
        const CONSTRUCTOR_ID: u32 = 3072226938;
    }
    impl crate::Serializable for JsonString {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for JsonString {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = String::deserialize(buf)?;
            Ok(JsonString { value })
        }
    }
    impl TryFrom<crate::enums::Jsonvalue> for JsonString {
        type Error = ();
        fn try_from(x: crate::enums::Jsonvalue) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Jsonvalue::JsonString(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButton {
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButton {
        const CONSTRUCTOR_ID: u32 = 2734311552;
    }
    impl crate::Serializable for KeyboardButton {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButton {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(KeyboardButton { text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButton {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::Button(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonBuy {
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButtonBuy {
        const CONSTRUCTOR_ID: u32 = 2950250427;
    }
    impl crate::Serializable for KeyboardButtonBuy {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonBuy {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(KeyboardButtonBuy { text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonBuy {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::Buy(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonCallback {
        pub requires_password: bool,
        pub text: String,
        pub data: Vec<u8>,
    }
    impl crate::Identifiable for KeyboardButtonCallback {
        const CONSTRUCTOR_ID: u32 = 901503851;
    }
    impl crate::Serializable for KeyboardButtonCallback {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.requires_password { 1 } else { 0 }).serialize(buf);
            self.text.serialize(buf);
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonCallback {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let requires_password = (flags & 1) != 0;
            let text = String::deserialize(buf)?;
            let data = Vec::<u8>::deserialize(buf)?;
            Ok(KeyboardButtonCallback {
                requires_password,
                text,
                data,
            })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonCallback {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::Callback(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonGame {
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButtonGame {
        const CONSTRUCTOR_ID: u32 = 1358175439;
    }
    impl crate::Serializable for KeyboardButtonGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(KeyboardButtonGame { text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonGame {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::Game(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonRequestGeoLocation {
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButtonRequestGeoLocation {
        const CONSTRUCTOR_ID: u32 = 4235815743;
    }
    impl crate::Serializable for KeyboardButtonRequestGeoLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonRequestGeoLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(KeyboardButtonRequestGeoLocation { text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonRequestGeoLocation {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::RequestGeoLocation(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonRequestPhone {
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButtonRequestPhone {
        const CONSTRUCTOR_ID: u32 = 2976541737;
    }
    impl crate::Serializable for KeyboardButtonRequestPhone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonRequestPhone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(KeyboardButtonRequestPhone { text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonRequestPhone {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::RequestPhone(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonRequestPoll {
        pub quiz: Option<bool>,
        pub text: String,
    }
    impl crate::Identifiable for KeyboardButtonRequestPoll {
        const CONSTRUCTOR_ID: u32 = 3150401885;
    }
    impl crate::Serializable for KeyboardButtonRequestPoll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.quiz.is_some() { 1 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.quiz {
                x.serialize(buf);
            }
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonRequestPoll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let quiz = if (flags & 1) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            let text = String::deserialize(buf)?;
            Ok(KeyboardButtonRequestPoll { quiz, text })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonRequestPoll {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::RequestPoll(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonRow {
        pub buttons: Vec<crate::enums::KeyboardButton>,
    }
    impl crate::Identifiable for KeyboardButtonRow {
        const CONSTRUCTOR_ID: u32 = 2002815875;
    }
    impl crate::Serializable for KeyboardButtonRow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.buttons.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonRow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let buttons = Vec::<crate::enums::KeyboardButton>::deserialize(buf)?;
            Ok(KeyboardButtonRow { buttons })
        }
    }
    impl From<crate::enums::KeyboardButtonRow> for KeyboardButtonRow {
        fn from(x: crate::enums::KeyboardButtonRow) -> Self {
            match x {
                crate::enums::KeyboardButtonRow::Row(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonSwitchInline {
        pub same_peer: bool,
        pub text: String,
        pub query: String,
    }
    impl crate::Identifiable for KeyboardButtonSwitchInline {
        const CONSTRUCTOR_ID: u32 = 90744648;
    }
    impl crate::Serializable for KeyboardButtonSwitchInline {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.same_peer { 1 } else { 0 }).serialize(buf);
            self.text.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonSwitchInline {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let same_peer = (flags & 1) != 0;
            let text = String::deserialize(buf)?;
            let query = String::deserialize(buf)?;
            Ok(KeyboardButtonSwitchInline {
                same_peer,
                text,
                query,
            })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonSwitchInline {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::SwitchInline(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonUrl {
        pub text: String,
        pub url: String,
    }
    impl crate::Identifiable for KeyboardButtonUrl {
        const CONSTRUCTOR_ID: u32 = 629866245;
    }
    impl crate::Serializable for KeyboardButtonUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            Ok(KeyboardButtonUrl { text, url })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonUrl {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::Url(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonUrlAuth {
        pub text: String,
        pub fwd_text: Option<String>,
        pub url: String,
        pub button_id: i32,
    }
    impl crate::Identifiable for KeyboardButtonUrlAuth {
        const CONSTRUCTOR_ID: u32 = 280464681;
    }
    impl crate::Serializable for KeyboardButtonUrlAuth {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.fwd_text.is_some() { 1 } else { 0 }).serialize(buf);
            self.text.serialize(buf);
            if let Some(ref x) = self.fwd_text {
                x.serialize(buf);
            }
            self.url.serialize(buf);
            self.button_id.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonUrlAuth {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            let fwd_text = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let url = String::deserialize(buf)?;
            let button_id = i32::deserialize(buf)?;
            Ok(KeyboardButtonUrlAuth {
                text,
                fwd_text,
                url,
                button_id,
            })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonUrlAuth {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::UrlAuth(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyboardButtonUserProfile {
        pub text: String,
        pub user_id: i64,
    }
    impl crate::Identifiable for KeyboardButtonUserProfile {
        const CONSTRUCTOR_ID: u32 = 814112961;
    }
    impl crate::Serializable for KeyboardButtonUserProfile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for KeyboardButtonUserProfile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(KeyboardButtonUserProfile { text, user_id })
        }
    }
    impl TryFrom<crate::enums::KeyboardButton> for KeyboardButtonUserProfile {
        type Error = ();
        fn try_from(x: crate::enums::KeyboardButton) -> Result<Self, Self::Error> {
            match x {
                crate::enums::KeyboardButton::UserProfile(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LabeledPrice {
        pub label: String,
        pub amount: i64,
    }
    impl crate::Identifiable for LabeledPrice {
        const CONSTRUCTOR_ID: u32 = 3408489464;
    }
    impl crate::Serializable for LabeledPrice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.label.serialize(buf);
            self.amount.serialize(buf);
        }
    }
    impl crate::Deserializable for LabeledPrice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let label = String::deserialize(buf)?;
            let amount = i64::deserialize(buf)?;
            Ok(LabeledPrice { label, amount })
        }
    }
    impl From<crate::enums::LabeledPrice> for LabeledPrice {
        fn from(x: crate::enums::LabeledPrice) -> Self {
            match x {
                crate::enums::LabeledPrice::Price(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LangPackDifference {
        pub lang_code: String,
        pub from_version: i32,
        pub version: i32,
        pub strings: Vec<crate::enums::LangPackString>,
    }
    impl crate::Identifiable for LangPackDifference {
        const CONSTRUCTOR_ID: u32 = 4085629430;
    }
    impl crate::Serializable for LangPackDifference {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.lang_code.serialize(buf);
            self.from_version.serialize(buf);
            self.version.serialize(buf);
            self.strings.serialize(buf);
        }
    }
    impl crate::Deserializable for LangPackDifference {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let lang_code = String::deserialize(buf)?;
            let from_version = i32::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            let strings = Vec::<crate::enums::LangPackString>::deserialize(buf)?;
            Ok(LangPackDifference {
                lang_code,
                from_version,
                version,
                strings,
            })
        }
    }
    impl From<crate::enums::LangPackDifference> for LangPackDifference {
        fn from(x: crate::enums::LangPackDifference) -> Self {
            match x {
                crate::enums::LangPackDifference::Difference(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LangPackLanguage {
        pub official: bool,
        pub rtl: bool,
        pub beta: bool,
        pub name: String,
        pub native_name: String,
        pub lang_code: String,
        pub base_lang_code: Option<String>,
        pub plural_code: String,
        pub strings_count: i32,
        pub translated_count: i32,
        pub translations_url: String,
    }
    impl crate::Identifiable for LangPackLanguage {
        const CONSTRUCTOR_ID: u32 = 4006239459;
    }
    impl crate::Serializable for LangPackLanguage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.official { 1 } else { 0 }
                | if self.rtl { 4 } else { 0 }
                | if self.beta { 8 } else { 0 }
                | if self.base_lang_code.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.name.serialize(buf);
            self.native_name.serialize(buf);
            self.lang_code.serialize(buf);
            if let Some(ref x) = self.base_lang_code {
                x.serialize(buf);
            }
            self.plural_code.serialize(buf);
            self.strings_count.serialize(buf);
            self.translated_count.serialize(buf);
            self.translations_url.serialize(buf);
        }
    }
    impl crate::Deserializable for LangPackLanguage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let official = (flags & 1) != 0;
            let rtl = (flags & 4) != 0;
            let beta = (flags & 8) != 0;
            let name = String::deserialize(buf)?;
            let native_name = String::deserialize(buf)?;
            let lang_code = String::deserialize(buf)?;
            let base_lang_code = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let plural_code = String::deserialize(buf)?;
            let strings_count = i32::deserialize(buf)?;
            let translated_count = i32::deserialize(buf)?;
            let translations_url = String::deserialize(buf)?;
            Ok(LangPackLanguage {
                official,
                rtl,
                beta,
                name,
                native_name,
                lang_code,
                base_lang_code,
                plural_code,
                strings_count,
                translated_count,
                translations_url,
            })
        }
    }
    impl From<crate::enums::LangPackLanguage> for LangPackLanguage {
        fn from(x: crate::enums::LangPackLanguage) -> Self {
            match x {
                crate::enums::LangPackLanguage::Language(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LangPackString {
        pub key: String,
        pub value: String,
    }
    impl crate::Identifiable for LangPackString {
        const CONSTRUCTOR_ID: u32 = 3402727926;
    }
    impl crate::Serializable for LangPackString {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.key.serialize(buf);
            self.value.serialize(buf);
        }
    }
    impl crate::Deserializable for LangPackString {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let key = String::deserialize(buf)?;
            let value = String::deserialize(buf)?;
            Ok(LangPackString { key, value })
        }
    }
    impl TryFrom<crate::enums::LangPackString> for LangPackString {
        type Error = ();
        fn try_from(x: crate::enums::LangPackString) -> Result<Self, Self::Error> {
            match x {
                crate::enums::LangPackString::String(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LangPackStringDeleted {
        pub key: String,
    }
    impl crate::Identifiable for LangPackStringDeleted {
        const CONSTRUCTOR_ID: u32 = 695856818;
    }
    impl crate::Serializable for LangPackStringDeleted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.key.serialize(buf);
        }
    }
    impl crate::Deserializable for LangPackStringDeleted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let key = String::deserialize(buf)?;
            Ok(LangPackStringDeleted { key })
        }
    }
    impl TryFrom<crate::enums::LangPackString> for LangPackStringDeleted {
        type Error = ();
        fn try_from(x: crate::enums::LangPackString) -> Result<Self, Self::Error> {
            match x {
                crate::enums::LangPackString::Deleted(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct LangPackStringPluralized {
        pub key: String,
        pub zero_value: Option<String>,
        pub one_value: Option<String>,
        pub two_value: Option<String>,
        pub few_value: Option<String>,
        pub many_value: Option<String>,
        pub other_value: String,
    }
    impl crate::Identifiable for LangPackStringPluralized {
        const CONSTRUCTOR_ID: u32 = 1816636575;
    }
    impl crate::Serializable for LangPackStringPluralized {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.zero_value.is_some() { 1 } else { 0 }
                | if self.one_value.is_some() { 2 } else { 0 }
                | if self.two_value.is_some() { 4 } else { 0 }
                | if self.few_value.is_some() { 8 } else { 0 }
                | if self.many_value.is_some() { 16 } else { 0 })
            .serialize(buf);
            self.key.serialize(buf);
            if let Some(ref x) = self.zero_value {
                x.serialize(buf);
            }
            if let Some(ref x) = self.one_value {
                x.serialize(buf);
            }
            if let Some(ref x) = self.two_value {
                x.serialize(buf);
            }
            if let Some(ref x) = self.few_value {
                x.serialize(buf);
            }
            if let Some(ref x) = self.many_value {
                x.serialize(buf);
            }
            self.other_value.serialize(buf);
        }
    }
    impl crate::Deserializable for LangPackStringPluralized {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let key = String::deserialize(buf)?;
            let zero_value = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let one_value = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let two_value = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let few_value = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let many_value = if (flags & 16) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let other_value = String::deserialize(buf)?;
            Ok(LangPackStringPluralized {
                key,
                zero_value,
                one_value,
                two_value,
                few_value,
                many_value,
                other_value,
            })
        }
    }
    impl TryFrom<crate::enums::LangPackString> for LangPackStringPluralized {
        type Error = ();
        fn try_from(x: crate::enums::LangPackString) -> Result<Self, Self::Error> {
            match x {
                crate::enums::LangPackString::Pluralized(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MaskCoords {
        pub n: i32,
        pub x: f64,
        pub y: f64,
        pub zoom: f64,
    }
    impl crate::Identifiable for MaskCoords {
        const CONSTRUCTOR_ID: u32 = 2933316530;
    }
    impl crate::Serializable for MaskCoords {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.n.serialize(buf);
            self.x.serialize(buf);
            self.y.serialize(buf);
            self.zoom.serialize(buf);
        }
    }
    impl crate::Deserializable for MaskCoords {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let n = i32::deserialize(buf)?;
            let x = f64::deserialize(buf)?;
            let y = f64::deserialize(buf)?;
            let zoom = f64::deserialize(buf)?;
            Ok(MaskCoords { n, x, y, zoom })
        }
    }
    impl From<crate::enums::MaskCoords> for MaskCoords {
        fn from(x: crate::enums::MaskCoords) -> Self {
            match x {
                crate::enums::MaskCoords::Coords(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Message {
        pub out: bool,
        pub mentioned: bool,
        pub media_unread: bool,
        pub silent: bool,
        pub post: bool,
        pub from_scheduled: bool,
        pub legacy: bool,
        pub edit_hide: bool,
        pub pinned: bool,
        pub noforwards: bool,
        pub id: i32,
        pub from_id: Option<crate::enums::Peer>,
        pub peer_id: crate::enums::Peer,
        pub fwd_from: Option<crate::enums::MessageFwdHeader>,
        pub via_bot_id: Option<i64>,
        pub reply_to: Option<crate::enums::MessageReplyHeader>,
        pub date: i32,
        pub message: String,
        pub media: Option<crate::enums::MessageMedia>,
        pub reply_markup: Option<crate::enums::ReplyMarkup>,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub views: Option<i32>,
        pub forwards: Option<i32>,
        pub replies: Option<crate::enums::MessageReplies>,
        pub edit_date: Option<i32>,
        pub post_author: Option<String>,
        pub grouped_id: Option<i64>,
        pub restriction_reason: Option<Vec<crate::enums::RestrictionReason>>,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for Message {
        const CONSTRUCTOR_ID: u32 = 2245446626;
    }
    impl crate::Serializable for Message {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.out { 2 } else { 0 }
                | if self.mentioned { 16 } else { 0 }
                | if self.media_unread { 32 } else { 0 }
                | if self.silent { 8192 } else { 0 }
                | if self.post { 16384 } else { 0 }
                | if self.from_scheduled { 262144 } else { 0 }
                | if self.legacy { 524288 } else { 0 }
                | if self.edit_hide { 2097152 } else { 0 }
                | if self.pinned { 16777216 } else { 0 }
                | if self.noforwards { 67108864 } else { 0 }
                | if self.from_id.is_some() { 256 } else { 0 }
                | if self.fwd_from.is_some() { 4 } else { 0 }
                | if self.via_bot_id.is_some() { 2048 } else { 0 }
                | if self.reply_to.is_some() { 8 } else { 0 }
                | if self.media.is_some() { 512 } else { 0 }
                | if self.reply_markup.is_some() { 64 } else { 0 }
                | if self.entities.is_some() { 128 } else { 0 }
                | if self.views.is_some() { 1024 } else { 0 }
                | if self.forwards.is_some() { 1024 } else { 0 }
                | if self.replies.is_some() { 8388608 } else { 0 }
                | if self.edit_date.is_some() { 32768 } else { 0 }
                | if self.post_author.is_some() { 65536 } else { 0 }
                | if self.grouped_id.is_some() { 131072 } else { 0 }
                | if self.restriction_reason.is_some() {
                    4194304
                } else {
                    0
                }
                | if self.ttl_period.is_some() {
                    33554432
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.from_id {
                x.serialize(buf);
            }
            self.peer_id.serialize(buf);
            if let Some(ref x) = self.fwd_from {
                x.serialize(buf);
            }
            if let Some(ref x) = self.via_bot_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_to {
                x.serialize(buf);
            }
            self.date.serialize(buf);
            self.message.serialize(buf);
            if let Some(ref x) = self.media {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_markup {
                x.serialize(buf);
            }
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.views {
                x.serialize(buf);
            }
            if let Some(ref x) = self.forwards {
                x.serialize(buf);
            }
            if let Some(ref x) = self.replies {
                x.serialize(buf);
            }
            if let Some(ref x) = self.edit_date {
                x.serialize(buf);
            }
            if let Some(ref x) = self.post_author {
                x.serialize(buf);
            }
            if let Some(ref x) = self.grouped_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.restriction_reason {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Message {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let out = (flags & 2) != 0;
            let mentioned = (flags & 16) != 0;
            let media_unread = (flags & 32) != 0;
            let silent = (flags & 8192) != 0;
            let post = (flags & 16384) != 0;
            let from_scheduled = (flags & 262144) != 0;
            let legacy = (flags & 524288) != 0;
            let edit_hide = (flags & 2097152) != 0;
            let pinned = (flags & 16777216) != 0;
            let noforwards = (flags & 67108864) != 0;
            let id = i32::deserialize(buf)?;
            let from_id = if (flags & 256) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let peer_id = crate::enums::Peer::deserialize(buf)?;
            let fwd_from = if (flags & 4) != 0 {
                Some(crate::enums::MessageFwdHeader::deserialize(buf)?)
            } else {
                None
            };
            let via_bot_id = if (flags & 2048) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let reply_to = if (flags & 8) != 0 {
                Some(crate::enums::MessageReplyHeader::deserialize(buf)?)
            } else {
                None
            };
            let date = i32::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let media = if (flags & 512) != 0 {
                Some(crate::enums::MessageMedia::deserialize(buf)?)
            } else {
                None
            };
            let reply_markup = if (flags & 64) != 0 {
                Some(crate::enums::ReplyMarkup::deserialize(buf)?)
            } else {
                None
            };
            let entities = if (flags & 128) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let views = if (flags & 1024) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let forwards = if (flags & 1024) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let replies = if (flags & 8388608) != 0 {
                Some(crate::enums::MessageReplies::deserialize(buf)?)
            } else {
                None
            };
            let edit_date = if (flags & 32768) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let post_author = if (flags & 65536) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let grouped_id = if (flags & 131072) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let restriction_reason = if (flags & 4194304) != 0 {
                Some(Vec::<crate::enums::RestrictionReason>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 33554432) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Message {
                out,
                mentioned,
                media_unread,
                silent,
                post,
                from_scheduled,
                legacy,
                edit_hide,
                pinned,
                noforwards,
                id,
                from_id,
                peer_id,
                fwd_from,
                via_bot_id,
                reply_to,
                date,
                message,
                media,
                reply_markup,
                entities,
                views,
                forwards,
                replies,
                edit_date,
                post_author,
                grouped_id,
                restriction_reason,
                ttl_period,
            })
        }
    }
    impl TryFrom<crate::enums::Message> for Message {
        type Error = ();
        fn try_from(x: crate::enums::Message) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Message::Message(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionBotAllowed {
        pub domain: String,
    }
    impl crate::Identifiable for MessageActionBotAllowed {
        const CONSTRUCTOR_ID: u32 = 2884218878;
    }
    impl crate::Serializable for MessageActionBotAllowed {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.domain.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionBotAllowed {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let domain = String::deserialize(buf)?;
            Ok(MessageActionBotAllowed { domain })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionBotAllowed {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::BotAllowed(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChannelCreate {
        pub title: String,
    }
    impl crate::Identifiable for MessageActionChannelCreate {
        const CONSTRUCTOR_ID: u32 = 2513611922;
    }
    impl crate::Serializable for MessageActionChannelCreate {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.title.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChannelCreate {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let title = String::deserialize(buf)?;
            Ok(MessageActionChannelCreate { title })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChannelCreate {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChannelCreate(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChannelMigrateFrom {
        pub title: String,
        pub chat_id: i64,
    }
    impl crate::Identifiable for MessageActionChannelMigrateFrom {
        const CONSTRUCTOR_ID: u32 = 3929622761;
    }
    impl crate::Serializable for MessageActionChannelMigrateFrom {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.title.serialize(buf);
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChannelMigrateFrom {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let title = String::deserialize(buf)?;
            let chat_id = i64::deserialize(buf)?;
            Ok(MessageActionChannelMigrateFrom { title, chat_id })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChannelMigrateFrom {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChannelMigrateFrom(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatAddUser {
        pub users: Vec<i64>,
    }
    impl crate::Identifiable for MessageActionChatAddUser {
        const CONSTRUCTOR_ID: u32 = 365886720;
    }
    impl crate::Serializable for MessageActionChatAddUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatAddUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let users = Vec::<i64>::deserialize(buf)?;
            Ok(MessageActionChatAddUser { users })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatAddUser {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatAddUser(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatCreate {
        pub title: String,
        pub users: Vec<i64>,
    }
    impl crate::Identifiable for MessageActionChatCreate {
        const CONSTRUCTOR_ID: u32 = 3175599021;
    }
    impl crate::Serializable for MessageActionChatCreate {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.title.serialize(buf);
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatCreate {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let title = String::deserialize(buf)?;
            let users = Vec::<i64>::deserialize(buf)?;
            Ok(MessageActionChatCreate { title, users })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatCreate {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatCreate(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatDeletePhoto {}
    impl crate::Identifiable for MessageActionChatDeletePhoto {
        const CONSTRUCTOR_ID: u32 = 2514746351;
    }
    impl crate::Serializable for MessageActionChatDeletePhoto {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionChatDeletePhoto {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionChatDeletePhoto {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatDeletePhoto {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatDeletePhoto => Ok(MessageActionChatDeletePhoto {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatDeleteUser {
        pub user_id: i64,
    }
    impl crate::Identifiable for MessageActionChatDeleteUser {
        const CONSTRUCTOR_ID: u32 = 2755604684;
    }
    impl crate::Serializable for MessageActionChatDeleteUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatDeleteUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            Ok(MessageActionChatDeleteUser { user_id })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatDeleteUser {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatDeleteUser(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatEditPhoto {
        pub photo: crate::enums::Photo,
    }
    impl crate::Identifiable for MessageActionChatEditPhoto {
        const CONSTRUCTOR_ID: u32 = 2144015272;
    }
    impl crate::Serializable for MessageActionChatEditPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.photo.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatEditPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let photo = crate::enums::Photo::deserialize(buf)?;
            Ok(MessageActionChatEditPhoto { photo })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatEditPhoto {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatEditPhoto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatEditTitle {
        pub title: String,
    }
    impl crate::Identifiable for MessageActionChatEditTitle {
        const CONSTRUCTOR_ID: u32 = 3047280218;
    }
    impl crate::Serializable for MessageActionChatEditTitle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.title.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatEditTitle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let title = String::deserialize(buf)?;
            Ok(MessageActionChatEditTitle { title })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatEditTitle {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatEditTitle(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatJoinedByLink {
        pub inviter_id: i64,
    }
    impl crate::Identifiable for MessageActionChatJoinedByLink {
        const CONSTRUCTOR_ID: u32 = 51520707;
    }
    impl crate::Serializable for MessageActionChatJoinedByLink {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.inviter_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatJoinedByLink {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let inviter_id = i64::deserialize(buf)?;
            Ok(MessageActionChatJoinedByLink { inviter_id })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatJoinedByLink {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatJoinedByLink(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatJoinedByRequest {}
    impl crate::Identifiable for MessageActionChatJoinedByRequest {
        const CONSTRUCTOR_ID: u32 = 3955008459;
    }
    impl crate::Serializable for MessageActionChatJoinedByRequest {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionChatJoinedByRequest {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionChatJoinedByRequest {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatJoinedByRequest {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatJoinedByRequest => {
                    Ok(MessageActionChatJoinedByRequest {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionChatMigrateTo {
        pub channel_id: i64,
    }
    impl crate::Identifiable for MessageActionChatMigrateTo {
        const CONSTRUCTOR_ID: u32 = 3775102866;
    }
    impl crate::Serializable for MessageActionChatMigrateTo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionChatMigrateTo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            Ok(MessageActionChatMigrateTo { channel_id })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionChatMigrateTo {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ChatMigrateTo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionContactSignUp {}
    impl crate::Identifiable for MessageActionContactSignUp {
        const CONSTRUCTOR_ID: u32 = 4092747638;
    }
    impl crate::Serializable for MessageActionContactSignUp {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionContactSignUp {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionContactSignUp {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionContactSignUp {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ContactSignUp => Ok(MessageActionContactSignUp {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionCustomAction {
        pub message: String,
    }
    impl crate::Identifiable for MessageActionCustomAction {
        const CONSTRUCTOR_ID: u32 = 4209418070;
    }
    impl crate::Serializable for MessageActionCustomAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionCustomAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = String::deserialize(buf)?;
            Ok(MessageActionCustomAction { message })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionCustomAction {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::CustomAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionEmpty {}
    impl crate::Identifiable for MessageActionEmpty {
        const CONSTRUCTOR_ID: u32 = 3064919984;
    }
    impl crate::Serializable for MessageActionEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionEmpty {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionEmpty {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::Empty => Ok(MessageActionEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionGameScore {
        pub game_id: i64,
        pub score: i32,
    }
    impl crate::Identifiable for MessageActionGameScore {
        const CONSTRUCTOR_ID: u32 = 2460428406;
    }
    impl crate::Serializable for MessageActionGameScore {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.game_id.serialize(buf);
            self.score.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionGameScore {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let game_id = i64::deserialize(buf)?;
            let score = i32::deserialize(buf)?;
            Ok(MessageActionGameScore { game_id, score })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionGameScore {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::GameScore(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionGeoProximityReached {
        pub from_id: crate::enums::Peer,
        pub to_id: crate::enums::Peer,
        pub distance: i32,
    }
    impl crate::Identifiable for MessageActionGeoProximityReached {
        const CONSTRUCTOR_ID: u32 = 2564871831;
    }
    impl crate::Serializable for MessageActionGeoProximityReached {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.from_id.serialize(buf);
            self.to_id.serialize(buf);
            self.distance.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionGeoProximityReached {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let from_id = crate::enums::Peer::deserialize(buf)?;
            let to_id = crate::enums::Peer::deserialize(buf)?;
            let distance = i32::deserialize(buf)?;
            Ok(MessageActionGeoProximityReached {
                from_id,
                to_id,
                distance,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionGeoProximityReached {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::GeoProximityReached(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionGroupCall {
        pub call: crate::enums::InputGroupCall,
        pub duration: Option<i32>,
    }
    impl crate::Identifiable for MessageActionGroupCall {
        const CONSTRUCTOR_ID: u32 = 2047704898;
    }
    impl crate::Serializable for MessageActionGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.duration.is_some() { 1 } else { 0 }).serialize(buf);
            self.call.serialize(buf);
            if let Some(ref x) = self.duration {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageActionGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            let duration = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageActionGroupCall { call, duration })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionGroupCall {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::GroupCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionGroupCallScheduled {
        pub call: crate::enums::InputGroupCall,
        pub schedule_date: i32,
    }
    impl crate::Identifiable for MessageActionGroupCallScheduled {
        const CONSTRUCTOR_ID: u32 = 3013637729;
    }
    impl crate::Serializable for MessageActionGroupCallScheduled {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.call.serialize(buf);
            self.schedule_date.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionGroupCallScheduled {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            let schedule_date = i32::deserialize(buf)?;
            Ok(MessageActionGroupCallScheduled {
                call,
                schedule_date,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionGroupCallScheduled {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::GroupCallScheduled(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionHistoryClear {}
    impl crate::Identifiable for MessageActionHistoryClear {
        const CONSTRUCTOR_ID: u32 = 2679813636;
    }
    impl crate::Serializable for MessageActionHistoryClear {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionHistoryClear {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionHistoryClear {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionHistoryClear {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::HistoryClear => Ok(MessageActionHistoryClear {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionInviteToGroupCall {
        pub call: crate::enums::InputGroupCall,
        pub users: Vec<i64>,
    }
    impl crate::Identifiable for MessageActionInviteToGroupCall {
        const CONSTRUCTOR_ID: u32 = 1345295095;
    }
    impl crate::Serializable for MessageActionInviteToGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.call.serialize(buf);
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionInviteToGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            let users = Vec::<i64>::deserialize(buf)?;
            Ok(MessageActionInviteToGroupCall { call, users })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionInviteToGroupCall {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::InviteToGroupCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionPaymentSent {
        pub currency: String,
        pub total_amount: i64,
    }
    impl crate::Identifiable for MessageActionPaymentSent {
        const CONSTRUCTOR_ID: u32 = 1080663248;
    }
    impl crate::Serializable for MessageActionPaymentSent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.currency.serialize(buf);
            self.total_amount.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionPaymentSent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let currency = String::deserialize(buf)?;
            let total_amount = i64::deserialize(buf)?;
            Ok(MessageActionPaymentSent {
                currency,
                total_amount,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionPaymentSent {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::PaymentSent(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionPaymentSentMe {
        pub currency: String,
        pub total_amount: i64,
        pub payload: Vec<u8>,
        pub info: Option<crate::enums::PaymentRequestedInfo>,
        pub shipping_option_id: Option<String>,
        pub charge: crate::enums::PaymentCharge,
    }
    impl crate::Identifiable for MessageActionPaymentSentMe {
        const CONSTRUCTOR_ID: u32 = 2402399015;
    }
    impl crate::Serializable for MessageActionPaymentSentMe {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.info.is_some() { 1 } else { 0 }
                | if self.shipping_option_id.is_some() {
                    2
                } else {
                    0
                })
            .serialize(buf);
            self.currency.serialize(buf);
            self.total_amount.serialize(buf);
            self.payload.serialize(buf);
            if let Some(ref x) = self.info {
                x.serialize(buf);
            }
            if let Some(ref x) = self.shipping_option_id {
                x.serialize(buf);
            }
            self.charge.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionPaymentSentMe {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let currency = String::deserialize(buf)?;
            let total_amount = i64::deserialize(buf)?;
            let payload = Vec::<u8>::deserialize(buf)?;
            let info = if (flags & 1) != 0 {
                Some(crate::enums::PaymentRequestedInfo::deserialize(buf)?)
            } else {
                None
            };
            let shipping_option_id = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let charge = crate::enums::PaymentCharge::deserialize(buf)?;
            Ok(MessageActionPaymentSentMe {
                currency,
                total_amount,
                payload,
                info,
                shipping_option_id,
                charge,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionPaymentSentMe {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::PaymentSentMe(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionPhoneCall {
        pub video: bool,
        pub call_id: i64,
        pub reason: Option<crate::enums::PhoneCallDiscardReason>,
        pub duration: Option<i32>,
    }
    impl crate::Identifiable for MessageActionPhoneCall {
        const CONSTRUCTOR_ID: u32 = 2162236031;
    }
    impl crate::Serializable for MessageActionPhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.video { 4 } else { 0 }
                | if self.reason.is_some() { 1 } else { 0 }
                | if self.duration.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.call_id.serialize(buf);
            if let Some(ref x) = self.reason {
                x.serialize(buf);
            }
            if let Some(ref x) = self.duration {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageActionPhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let video = (flags & 4) != 0;
            let call_id = i64::deserialize(buf)?;
            let reason = if (flags & 1) != 0 {
                Some(crate::enums::PhoneCallDiscardReason::deserialize(buf)?)
            } else {
                None
            };
            let duration = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageActionPhoneCall {
                video,
                call_id,
                reason,
                duration,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionPhoneCall {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::PhoneCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionPinMessage {}
    impl crate::Identifiable for MessageActionPinMessage {
        const CONSTRUCTOR_ID: u32 = 2495428845;
    }
    impl crate::Serializable for MessageActionPinMessage {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionPinMessage {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionPinMessage {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionPinMessage {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::PinMessage => Ok(MessageActionPinMessage {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionScreenshotTaken {}
    impl crate::Identifiable for MessageActionScreenshotTaken {
        const CONSTRUCTOR_ID: u32 = 1200788123;
    }
    impl crate::Serializable for MessageActionScreenshotTaken {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageActionScreenshotTaken {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageActionScreenshotTaken {})
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionScreenshotTaken {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::ScreenshotTaken => Ok(MessageActionScreenshotTaken {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionSecureValuesSent {
        pub types: Vec<crate::enums::SecureValueType>,
    }
    impl crate::Identifiable for MessageActionSecureValuesSent {
        const CONSTRUCTOR_ID: u32 = 3646710100;
    }
    impl crate::Serializable for MessageActionSecureValuesSent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.types.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionSecureValuesSent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let types = Vec::<crate::enums::SecureValueType>::deserialize(buf)?;
            Ok(MessageActionSecureValuesSent { types })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionSecureValuesSent {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::SecureValuesSent(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionSecureValuesSentMe {
        pub values: Vec<crate::enums::SecureValue>,
        pub credentials: crate::enums::SecureCredentialsEncrypted,
    }
    impl crate::Identifiable for MessageActionSecureValuesSentMe {
        const CONSTRUCTOR_ID: u32 = 455635795;
    }
    impl crate::Serializable for MessageActionSecureValuesSentMe {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.values.serialize(buf);
            self.credentials.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionSecureValuesSentMe {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let values = Vec::<crate::enums::SecureValue>::deserialize(buf)?;
            let credentials = crate::enums::SecureCredentialsEncrypted::deserialize(buf)?;
            Ok(MessageActionSecureValuesSentMe {
                values,
                credentials,
            })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionSecureValuesSentMe {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::SecureValuesSentMe(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionSetChatTheme {
        pub emoticon: String,
    }
    impl crate::Identifiable for MessageActionSetChatTheme {
        const CONSTRUCTOR_ID: u32 = 2860016453;
    }
    impl crate::Serializable for MessageActionSetChatTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionSetChatTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            Ok(MessageActionSetChatTheme { emoticon })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionSetChatTheme {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::SetChatTheme(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageActionSetMessagesTtl {
        pub period: i32,
    }
    impl crate::Identifiable for MessageActionSetMessagesTtl {
        const CONSTRUCTOR_ID: u32 = 2853895165;
    }
    impl crate::Serializable for MessageActionSetMessagesTtl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.period.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageActionSetMessagesTtl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let period = i32::deserialize(buf)?;
            Ok(MessageActionSetMessagesTtl { period })
        }
    }
    impl TryFrom<crate::enums::MessageAction> for MessageActionSetMessagesTtl {
        type Error = ();
        fn try_from(x: crate::enums::MessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageAction::SetMessagesTtl(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEmpty {
        pub id: i32,
        pub peer_id: Option<crate::enums::Peer>,
    }
    impl crate::Identifiable for MessageEmpty {
        const CONSTRUCTOR_ID: u32 = 2426849924;
    }
    impl crate::Serializable for MessageEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.peer_id.is_some() { 1 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.peer_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = i32::deserialize(buf)?;
            let peer_id = if (flags & 1) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageEmpty { id, peer_id })
        }
    }
    impl TryFrom<crate::enums::Message> for MessageEmpty {
        type Error = ();
        fn try_from(x: crate::enums::Message) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Message::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityBankCard {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityBankCard {
        const CONSTRUCTOR_ID: u32 = 1981704948;
    }
    impl crate::Serializable for MessageEntityBankCard {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityBankCard {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityBankCard { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityBankCard {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::BankCard(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityBlockquote {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityBlockquote {
        const CONSTRUCTOR_ID: u32 = 34469328;
    }
    impl crate::Serializable for MessageEntityBlockquote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityBlockquote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityBlockquote { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityBlockquote {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Blockquote(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityBold {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityBold {
        const CONSTRUCTOR_ID: u32 = 3177253833;
    }
    impl crate::Serializable for MessageEntityBold {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityBold {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityBold { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityBold {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Bold(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityBotCommand {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityBotCommand {
        const CONSTRUCTOR_ID: u32 = 1827637959;
    }
    impl crate::Serializable for MessageEntityBotCommand {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityBotCommand {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityBotCommand { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityBotCommand {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::BotCommand(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityCashtag {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityCashtag {
        const CONSTRUCTOR_ID: u32 = 1280209983;
    }
    impl crate::Serializable for MessageEntityCashtag {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityCashtag {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityCashtag { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityCashtag {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Cashtag(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityCode {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityCode {
        const CONSTRUCTOR_ID: u32 = 681706865;
    }
    impl crate::Serializable for MessageEntityCode {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityCode {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityCode { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityCode {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Code(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityEmail {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityEmail {
        const CONSTRUCTOR_ID: u32 = 1692693954;
    }
    impl crate::Serializable for MessageEntityEmail {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityEmail {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityEmail { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityEmail {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Email(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityHashtag {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityHashtag {
        const CONSTRUCTOR_ID: u32 = 1868782349;
    }
    impl crate::Serializable for MessageEntityHashtag {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityHashtag {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityHashtag { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityHashtag {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Hashtag(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityItalic {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityItalic {
        const CONSTRUCTOR_ID: u32 = 2188348256;
    }
    impl crate::Serializable for MessageEntityItalic {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityItalic {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityItalic { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityItalic {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Italic(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityMention {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityMention {
        const CONSTRUCTOR_ID: u32 = 4194588573;
    }
    impl crate::Serializable for MessageEntityMention {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityMention {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityMention { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityMention {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Mention(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityMentionName {
        pub offset: i32,
        pub length: i32,
        pub user_id: i64,
    }
    impl crate::Identifiable for MessageEntityMentionName {
        const CONSTRUCTOR_ID: u32 = 3699052864;
    }
    impl crate::Serializable for MessageEntityMentionName {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityMentionName {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(MessageEntityMentionName {
                offset,
                length,
                user_id,
            })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityMentionName {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::MentionName(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityPhone {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityPhone {
        const CONSTRUCTOR_ID: u32 = 2607407947;
    }
    impl crate::Serializable for MessageEntityPhone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityPhone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityPhone { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityPhone {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Phone(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityPre {
        pub offset: i32,
        pub length: i32,
        pub language: String,
    }
    impl crate::Identifiable for MessageEntityPre {
        const CONSTRUCTOR_ID: u32 = 1938967520;
    }
    impl crate::Serializable for MessageEntityPre {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
            self.language.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityPre {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            let language = String::deserialize(buf)?;
            Ok(MessageEntityPre {
                offset,
                length,
                language,
            })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityPre {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Pre(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityStrike {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityStrike {
        const CONSTRUCTOR_ID: u32 = 3204879316;
    }
    impl crate::Serializable for MessageEntityStrike {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityStrike {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityStrike { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityStrike {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Strike(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityTextUrl {
        pub offset: i32,
        pub length: i32,
        pub url: String,
    }
    impl crate::Identifiable for MessageEntityTextUrl {
        const CONSTRUCTOR_ID: u32 = 1990644519;
    }
    impl crate::Serializable for MessageEntityTextUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityTextUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            Ok(MessageEntityTextUrl {
                offset,
                length,
                url,
            })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityTextUrl {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::TextUrl(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityUnderline {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityUnderline {
        const CONSTRUCTOR_ID: u32 = 2622389899;
    }
    impl crate::Serializable for MessageEntityUnderline {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityUnderline {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityUnderline { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityUnderline {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Underline(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityUnknown {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityUnknown {
        const CONSTRUCTOR_ID: u32 = 3146955413;
    }
    impl crate::Serializable for MessageEntityUnknown {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityUnknown {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityUnknown { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityUnknown {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Unknown(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageEntityUrl {
        pub offset: i32,
        pub length: i32,
    }
    impl crate::Identifiable for MessageEntityUrl {
        const CONSTRUCTOR_ID: u32 = 1859134776;
    }
    impl crate::Serializable for MessageEntityUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.offset.serialize(buf);
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageEntityUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let offset = i32::deserialize(buf)?;
            let length = i32::deserialize(buf)?;
            Ok(MessageEntityUrl { offset, length })
        }
    }
    impl TryFrom<crate::enums::MessageEntity> for MessageEntityUrl {
        type Error = ();
        fn try_from(x: crate::enums::MessageEntity) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageEntity::Url(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageFwdHeader {
        pub imported: bool,
        pub from_id: Option<crate::enums::Peer>,
        pub from_name: Option<String>,
        pub date: i32,
        pub channel_post: Option<i32>,
        pub post_author: Option<String>,
        pub saved_from_peer: Option<crate::enums::Peer>,
        pub saved_from_msg_id: Option<i32>,
        pub psa_type: Option<String>,
    }
    impl crate::Identifiable for MessageFwdHeader {
        const CONSTRUCTOR_ID: u32 = 1601666510;
    }
    impl crate::Serializable for MessageFwdHeader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.imported { 128 } else { 0 }
                | if self.from_id.is_some() { 1 } else { 0 }
                | if self.from_name.is_some() { 32 } else { 0 }
                | if self.channel_post.is_some() { 4 } else { 0 }
                | if self.post_author.is_some() { 8 } else { 0 }
                | if self.saved_from_peer.is_some() {
                    16
                } else {
                    0
                }
                | if self.saved_from_msg_id.is_some() {
                    16
                } else {
                    0
                }
                | if self.psa_type.is_some() { 64 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.from_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.from_name {
                x.serialize(buf);
            }
            self.date.serialize(buf);
            if let Some(ref x) = self.channel_post {
                x.serialize(buf);
            }
            if let Some(ref x) = self.post_author {
                x.serialize(buf);
            }
            if let Some(ref x) = self.saved_from_peer {
                x.serialize(buf);
            }
            if let Some(ref x) = self.saved_from_msg_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.psa_type {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageFwdHeader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let imported = (flags & 128) != 0;
            let from_id = if (flags & 1) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let from_name = if (flags & 32) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let date = i32::deserialize(buf)?;
            let channel_post = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let post_author = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let saved_from_peer = if (flags & 16) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let saved_from_msg_id = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let psa_type = if (flags & 64) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageFwdHeader {
                imported,
                from_id,
                from_name,
                date,
                channel_post,
                post_author,
                saved_from_peer,
                saved_from_msg_id,
                psa_type,
            })
        }
    }
    impl From<crate::enums::MessageFwdHeader> for MessageFwdHeader {
        fn from(x: crate::enums::MessageFwdHeader) -> Self {
            match x {
                crate::enums::MessageFwdHeader::Header(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageInteractionCounters {
        pub msg_id: i32,
        pub views: i32,
        pub forwards: i32,
    }
    impl crate::Identifiable for MessageInteractionCounters {
        const CONSTRUCTOR_ID: u32 = 2907687357;
    }
    impl crate::Serializable for MessageInteractionCounters {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_id.serialize(buf);
            self.views.serialize(buf);
            self.forwards.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageInteractionCounters {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_id = i32::deserialize(buf)?;
            let views = i32::deserialize(buf)?;
            let forwards = i32::deserialize(buf)?;
            Ok(MessageInteractionCounters {
                msg_id,
                views,
                forwards,
            })
        }
    }
    impl From<crate::enums::MessageInteractionCounters> for MessageInteractionCounters {
        fn from(x: crate::enums::MessageInteractionCounters) -> Self {
            match x {
                crate::enums::MessageInteractionCounters::Counters(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaContact {
        pub phone_number: String,
        pub first_name: String,
        pub last_name: String,
        pub vcard: String,
        pub user_id: i64,
    }
    impl crate::Identifiable for MessageMediaContact {
        const CONSTRUCTOR_ID: u32 = 1882335561;
    }
    impl crate::Serializable for MessageMediaContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone_number.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.vcard.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone_number = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let vcard = String::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(MessageMediaContact {
                phone_number,
                first_name,
                last_name,
                vcard,
                user_id,
            })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaContact {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Contact(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaDice {
        pub value: i32,
        pub emoticon: String,
    }
    impl crate::Identifiable for MessageMediaDice {
        const CONSTRUCTOR_ID: u32 = 1065280907;
    }
    impl crate::Serializable for MessageMediaDice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.value.serialize(buf);
            self.emoticon.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaDice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let value = i32::deserialize(buf)?;
            let emoticon = String::deserialize(buf)?;
            Ok(MessageMediaDice { value, emoticon })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaDice {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Dice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaDocument {
        pub document: Option<crate::enums::Document>,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for MessageMediaDocument {
        const CONSTRUCTOR_ID: u32 = 2628808919;
    }
    impl crate::Serializable for MessageMediaDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.document.is_some() { 1 } else { 0 }
                | if self.ttl_seconds.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.document {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageMediaDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let document = if (flags & 1) != 0 {
                Some(crate::enums::Document::deserialize(buf)?)
            } else {
                None
            };
            let ttl_seconds = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageMediaDocument {
                document,
                ttl_seconds,
            })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaDocument {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaEmpty {}
    impl crate::Identifiable for MessageMediaEmpty {
        const CONSTRUCTOR_ID: u32 = 1038967584;
    }
    impl crate::Serializable for MessageMediaEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageMediaEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageMediaEmpty {})
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaEmpty {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Empty => Ok(MessageMediaEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaGame {
        pub game: crate::enums::Game,
    }
    impl crate::Identifiable for MessageMediaGame {
        const CONSTRUCTOR_ID: u32 = 4256272392;
    }
    impl crate::Serializable for MessageMediaGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.game.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let game = crate::enums::Game::deserialize(buf)?;
            Ok(MessageMediaGame { game })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaGame {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Game(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaGeo {
        pub geo: crate::enums::GeoPoint,
    }
    impl crate::Identifiable for MessageMediaGeo {
        const CONSTRUCTOR_ID: u32 = 1457575028;
    }
    impl crate::Serializable for MessageMediaGeo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaGeo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            Ok(MessageMediaGeo { geo })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaGeo {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Geo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaGeoLive {
        pub geo: crate::enums::GeoPoint,
        pub heading: Option<i32>,
        pub period: i32,
        pub proximity_notification_radius: Option<i32>,
    }
    impl crate::Identifiable for MessageMediaGeoLive {
        const CONSTRUCTOR_ID: u32 = 3108030054;
    }
    impl crate::Serializable for MessageMediaGeoLive {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.heading.is_some() { 1 } else { 0 }
                | if self.proximity_notification_radius.is_some() {
                    2
                } else {
                    0
                })
            .serialize(buf);
            self.geo.serialize(buf);
            if let Some(ref x) = self.heading {
                x.serialize(buf);
            }
            self.period.serialize(buf);
            if let Some(ref x) = self.proximity_notification_radius {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageMediaGeoLive {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            let heading = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let period = i32::deserialize(buf)?;
            let proximity_notification_radius = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageMediaGeoLive {
                geo,
                heading,
                period,
                proximity_notification_radius,
            })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaGeoLive {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::GeoLive(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaInvoice {
        pub shipping_address_requested: bool,
        pub test: bool,
        pub title: String,
        pub description: String,
        pub photo: Option<crate::enums::WebDocument>,
        pub receipt_msg_id: Option<i32>,
        pub currency: String,
        pub total_amount: i64,
        pub start_param: String,
    }
    impl crate::Identifiable for MessageMediaInvoice {
        const CONSTRUCTOR_ID: u32 = 2220168007;
    }
    impl crate::Serializable for MessageMediaInvoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.shipping_address_requested {
                    2
                } else {
                    0
                }
                | if self.test { 8 } else { 0 }
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.receipt_msg_id.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.title.serialize(buf);
            self.description.serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.receipt_msg_id {
                x.serialize(buf);
            }
            self.currency.serialize(buf);
            self.total_amount.serialize(buf);
            self.start_param.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaInvoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let shipping_address_requested = (flags & 2) != 0;
            let test = (flags & 8) != 0;
            let title = String::deserialize(buf)?;
            let description = String::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::WebDocument::deserialize(buf)?)
            } else {
                None
            };
            let receipt_msg_id = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let currency = String::deserialize(buf)?;
            let total_amount = i64::deserialize(buf)?;
            let start_param = String::deserialize(buf)?;
            Ok(MessageMediaInvoice {
                shipping_address_requested,
                test,
                title,
                description,
                photo,
                receipt_msg_id,
                currency,
                total_amount,
                start_param,
            })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaInvoice {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Invoice(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaPhoto {
        pub photo: Option<crate::enums::Photo>,
        pub ttl_seconds: Option<i32>,
    }
    impl crate::Identifiable for MessageMediaPhoto {
        const CONSTRUCTOR_ID: u32 = 1766936791;
    }
    impl crate::Serializable for MessageMediaPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.photo.is_some() { 1 } else { 0 }
                | if self.ttl_seconds.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_seconds {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageMediaPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let photo = if (flags & 1) != 0 {
                Some(crate::enums::Photo::deserialize(buf)?)
            } else {
                None
            };
            let ttl_seconds = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageMediaPhoto { photo, ttl_seconds })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaPhoto {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaPoll {
        pub poll: crate::enums::Poll,
        pub results: crate::enums::PollResults,
    }
    impl crate::Identifiable for MessageMediaPoll {
        const CONSTRUCTOR_ID: u32 = 1272375192;
    }
    impl crate::Serializable for MessageMediaPoll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.poll.serialize(buf);
            self.results.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaPoll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let poll = crate::enums::Poll::deserialize(buf)?;
            let results = crate::enums::PollResults::deserialize(buf)?;
            Ok(MessageMediaPoll { poll, results })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaPoll {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Poll(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaUnsupported {}
    impl crate::Identifiable for MessageMediaUnsupported {
        const CONSTRUCTOR_ID: u32 = 2676290718;
    }
    impl crate::Serializable for MessageMediaUnsupported {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for MessageMediaUnsupported {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(MessageMediaUnsupported {})
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaUnsupported {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Unsupported => Ok(MessageMediaUnsupported {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaVenue {
        pub geo: crate::enums::GeoPoint,
        pub title: String,
        pub address: String,
        pub provider: String,
        pub venue_id: String,
        pub venue_type: String,
    }
    impl crate::Identifiable for MessageMediaVenue {
        const CONSTRUCTOR_ID: u32 = 784356159;
    }
    impl crate::Serializable for MessageMediaVenue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo.serialize(buf);
            self.title.serialize(buf);
            self.address.serialize(buf);
            self.provider.serialize(buf);
            self.venue_id.serialize(buf);
            self.venue_type.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaVenue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let address = String::deserialize(buf)?;
            let provider = String::deserialize(buf)?;
            let venue_id = String::deserialize(buf)?;
            let venue_type = String::deserialize(buf)?;
            Ok(MessageMediaVenue {
                geo,
                title,
                address,
                provider,
                venue_id,
                venue_type,
            })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaVenue {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::Venue(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageMediaWebPage {
        pub webpage: crate::enums::WebPage,
    }
    impl crate::Identifiable for MessageMediaWebPage {
        const CONSTRUCTOR_ID: u32 = 2737690112;
    }
    impl crate::Serializable for MessageMediaWebPage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.webpage.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageMediaWebPage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let webpage = crate::enums::WebPage::deserialize(buf)?;
            Ok(MessageMediaWebPage { webpage })
        }
    }
    impl TryFrom<crate::enums::MessageMedia> for MessageMediaWebPage {
        type Error = ();
        fn try_from(x: crate::enums::MessageMedia) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageMedia::WebPage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageRange {
        pub min_id: i32,
        pub max_id: i32,
    }
    impl crate::Identifiable for MessageRange {
        const CONSTRUCTOR_ID: u32 = 182649427;
    }
    impl crate::Serializable for MessageRange {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.min_id.serialize(buf);
            self.max_id.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageRange {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let min_id = i32::deserialize(buf)?;
            let max_id = i32::deserialize(buf)?;
            Ok(MessageRange { min_id, max_id })
        }
    }
    impl From<crate::enums::MessageRange> for MessageRange {
        fn from(x: crate::enums::MessageRange) -> Self {
            match x {
                crate::enums::MessageRange::Range(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageReplies {
        pub comments: bool,
        pub replies: i32,
        pub replies_pts: i32,
        pub recent_repliers: Option<Vec<crate::enums::Peer>>,
        pub channel_id: Option<i64>,
        pub max_id: Option<i32>,
        pub read_max_id: Option<i32>,
    }
    impl crate::Identifiable for MessageReplies {
        const CONSTRUCTOR_ID: u32 = 2211844034;
    }
    impl crate::Serializable for MessageReplies {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.comments { 1 } else { 0 }
                | if self.recent_repliers.is_some() { 2 } else { 0 }
                | if self.channel_id.is_some() { 1 } else { 0 }
                | if self.max_id.is_some() { 4 } else { 0 }
                | if self.read_max_id.is_some() { 8 } else { 0 })
            .serialize(buf);
            self.replies.serialize(buf);
            self.replies_pts.serialize(buf);
            if let Some(ref x) = self.recent_repliers {
                x.serialize(buf);
            }
            if let Some(ref x) = self.channel_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.max_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.read_max_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageReplies {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let comments = (flags & 1) != 0;
            let replies = i32::deserialize(buf)?;
            let replies_pts = i32::deserialize(buf)?;
            let recent_repliers = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::Peer>::deserialize(buf)?)
            } else {
                None
            };
            let channel_id = if (flags & 1) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let max_id = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let read_max_id = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageReplies {
                comments,
                replies,
                replies_pts,
                recent_repliers,
                channel_id,
                max_id,
                read_max_id,
            })
        }
    }
    impl From<crate::enums::MessageReplies> for MessageReplies {
        fn from(x: crate::enums::MessageReplies) -> Self {
            match x {
                crate::enums::MessageReplies::Replies(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageReplyHeader {
        pub reply_to_msg_id: i32,
        pub reply_to_peer_id: Option<crate::enums::Peer>,
        pub reply_to_top_id: Option<i32>,
    }
    impl crate::Identifiable for MessageReplyHeader {
        const CONSTRUCTOR_ID: u32 = 2799007587;
    }
    impl crate::Serializable for MessageReplyHeader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.reply_to_peer_id.is_some() {
                    1
                } else {
                    0
                }
                | if self.reply_to_top_id.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.reply_to_msg_id.serialize(buf);
            if let Some(ref x) = self.reply_to_peer_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_to_top_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageReplyHeader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let reply_to_msg_id = i32::deserialize(buf)?;
            let reply_to_peer_id = if (flags & 1) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let reply_to_top_id = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageReplyHeader {
                reply_to_msg_id,
                reply_to_peer_id,
                reply_to_top_id,
            })
        }
    }
    impl From<crate::enums::MessageReplyHeader> for MessageReplyHeader {
        fn from(x: crate::enums::MessageReplyHeader) -> Self {
            match x {
                crate::enums::MessageReplyHeader::Header(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageService {
        pub out: bool,
        pub mentioned: bool,
        pub media_unread: bool,
        pub silent: bool,
        pub post: bool,
        pub legacy: bool,
        pub id: i32,
        pub from_id: Option<crate::enums::Peer>,
        pub peer_id: crate::enums::Peer,
        pub reply_to: Option<crate::enums::MessageReplyHeader>,
        pub date: i32,
        pub action: crate::enums::MessageAction,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for MessageService {
        const CONSTRUCTOR_ID: u32 = 721967202;
    }
    impl crate::Serializable for MessageService {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.out { 2 } else { 0 }
                | if self.mentioned { 16 } else { 0 }
                | if self.media_unread { 32 } else { 0 }
                | if self.silent { 8192 } else { 0 }
                | if self.post { 16384 } else { 0 }
                | if self.legacy { 524288 } else { 0 }
                | if self.from_id.is_some() { 256 } else { 0 }
                | if self.reply_to.is_some() { 8 } else { 0 }
                | if self.ttl_period.is_some() {
                    33554432
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.from_id {
                x.serialize(buf);
            }
            self.peer_id.serialize(buf);
            if let Some(ref x) = self.reply_to {
                x.serialize(buf);
            }
            self.date.serialize(buf);
            self.action.serialize(buf);
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageService {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let out = (flags & 2) != 0;
            let mentioned = (flags & 16) != 0;
            let media_unread = (flags & 32) != 0;
            let silent = (flags & 8192) != 0;
            let post = (flags & 16384) != 0;
            let legacy = (flags & 524288) != 0;
            let id = i32::deserialize(buf)?;
            let from_id = if (flags & 256) != 0 {
                Some(crate::enums::Peer::deserialize(buf)?)
            } else {
                None
            };
            let peer_id = crate::enums::Peer::deserialize(buf)?;
            let reply_to = if (flags & 8) != 0 {
                Some(crate::enums::MessageReplyHeader::deserialize(buf)?)
            } else {
                None
            };
            let date = i32::deserialize(buf)?;
            let action = crate::enums::MessageAction::deserialize(buf)?;
            let ttl_period = if (flags & 33554432) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageService {
                out,
                mentioned,
                media_unread,
                silent,
                post,
                legacy,
                id,
                from_id,
                peer_id,
                reply_to,
                date,
                action,
                ttl_period,
            })
        }
    }
    impl TryFrom<crate::enums::Message> for MessageService {
        type Error = ();
        fn try_from(x: crate::enums::Message) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Message::Service(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageUserVote {
        pub user_id: i64,
        pub option: Vec<u8>,
        pub date: i32,
    }
    impl crate::Identifiable for MessageUserVote {
        const CONSTRUCTOR_ID: u32 = 886196148;
    }
    impl crate::Serializable for MessageUserVote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.option.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageUserVote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let option = Vec::<u8>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(MessageUserVote {
                user_id,
                option,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::MessageUserVote> for MessageUserVote {
        type Error = ();
        fn try_from(x: crate::enums::MessageUserVote) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageUserVote::Vote(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageUserVoteInputOption {
        pub user_id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for MessageUserVoteInputOption {
        const CONSTRUCTOR_ID: u32 = 1017491692;
    }
    impl crate::Serializable for MessageUserVoteInputOption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageUserVoteInputOption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(MessageUserVoteInputOption { user_id, date })
        }
    }
    impl TryFrom<crate::enums::MessageUserVote> for MessageUserVoteInputOption {
        type Error = ();
        fn try_from(x: crate::enums::MessageUserVote) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageUserVote::InputOption(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageUserVoteMultiple {
        pub user_id: i64,
        pub options: Vec<Vec<u8>>,
        pub date: i32,
    }
    impl crate::Identifiable for MessageUserVoteMultiple {
        const CONSTRUCTOR_ID: u32 = 2321933655;
    }
    impl crate::Serializable for MessageUserVoteMultiple {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.options.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for MessageUserVoteMultiple {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let options = Vec::<Vec<u8>>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(MessageUserVoteMultiple {
                user_id,
                options,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::MessageUserVote> for MessageUserVoteMultiple {
        type Error = ();
        fn try_from(x: crate::enums::MessageUserVote) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MessageUserVote::Multiple(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageViews {
        pub views: Option<i32>,
        pub forwards: Option<i32>,
        pub replies: Option<crate::enums::MessageReplies>,
    }
    impl crate::Identifiable for MessageViews {
        const CONSTRUCTOR_ID: u32 = 1163625789;
    }
    impl crate::Serializable for MessageViews {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.views.is_some() { 1 } else { 0 }
                | if self.forwards.is_some() { 2 } else { 0 }
                | if self.replies.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.views {
                x.serialize(buf);
            }
            if let Some(ref x) = self.forwards {
                x.serialize(buf);
            }
            if let Some(ref x) = self.replies {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for MessageViews {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let views = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let forwards = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let replies = if (flags & 4) != 0 {
                Some(crate::enums::MessageReplies::deserialize(buf)?)
            } else {
                None
            };
            Ok(MessageViews {
                views,
                forwards,
                replies,
            })
        }
    }
    impl From<crate::enums::MessageViews> for MessageViews {
        fn from(x: crate::enums::MessageViews) -> Self {
            match x {
                crate::enums::MessageViews::Views(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgDetailedInfo {
        pub msg_id: i64,
        pub answer_msg_id: i64,
        pub bytes: i32,
        pub status: i32,
    }
    impl crate::Identifiable for MsgDetailedInfo {
        const CONSTRUCTOR_ID: u32 = 661470918;
    }
    impl crate::Serializable for MsgDetailedInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_id.serialize(buf);
            self.answer_msg_id.serialize(buf);
            self.bytes.serialize(buf);
            self.status.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgDetailedInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_id = i64::deserialize(buf)?;
            let answer_msg_id = i64::deserialize(buf)?;
            let bytes = i32::deserialize(buf)?;
            let status = i32::deserialize(buf)?;
            Ok(MsgDetailedInfo {
                msg_id,
                answer_msg_id,
                bytes,
                status,
            })
        }
    }
    impl TryFrom<crate::enums::MsgDetailedInfo> for MsgDetailedInfo {
        type Error = ();
        fn try_from(x: crate::enums::MsgDetailedInfo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MsgDetailedInfo::Info(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgNewDetailedInfo {
        pub answer_msg_id: i64,
        pub bytes: i32,
        pub status: i32,
    }
    impl crate::Identifiable for MsgNewDetailedInfo {
        const CONSTRUCTOR_ID: u32 = 2157819615;
    }
    impl crate::Serializable for MsgNewDetailedInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.answer_msg_id.serialize(buf);
            self.bytes.serialize(buf);
            self.status.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgNewDetailedInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let answer_msg_id = i64::deserialize(buf)?;
            let bytes = i32::deserialize(buf)?;
            let status = i32::deserialize(buf)?;
            Ok(MsgNewDetailedInfo {
                answer_msg_id,
                bytes,
                status,
            })
        }
    }
    impl TryFrom<crate::enums::MsgDetailedInfo> for MsgNewDetailedInfo {
        type Error = ();
        fn try_from(x: crate::enums::MsgDetailedInfo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MsgDetailedInfo::MsgNewDetailedInfo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgResendAnsReq {
        pub msg_ids: Vec<i64>,
    }
    impl crate::Identifiable for MsgResendAnsReq {
        const CONSTRUCTOR_ID: u32 = 2249243371;
    }
    impl crate::Serializable for MsgResendAnsReq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_ids.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgResendAnsReq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_ids = Vec::<i64>::deserialize(buf)?;
            Ok(MsgResendAnsReq { msg_ids })
        }
    }
    impl TryFrom<crate::enums::MsgResendReq> for MsgResendAnsReq {
        type Error = ();
        fn try_from(x: crate::enums::MsgResendReq) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MsgResendReq::MsgResendAnsReq(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgResendReq {
        pub msg_ids: Vec<i64>,
    }
    impl crate::Identifiable for MsgResendReq {
        const CONSTRUCTOR_ID: u32 = 2105940488;
    }
    impl crate::Serializable for MsgResendReq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_ids.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgResendReq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_ids = Vec::<i64>::deserialize(buf)?;
            Ok(MsgResendReq { msg_ids })
        }
    }
    impl TryFrom<crate::enums::MsgResendReq> for MsgResendReq {
        type Error = ();
        fn try_from(x: crate::enums::MsgResendReq) -> Result<Self, Self::Error> {
            match x {
                crate::enums::MsgResendReq::Req(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgsAck {
        pub msg_ids: Vec<i64>,
    }
    impl crate::Identifiable for MsgsAck {
        const CONSTRUCTOR_ID: u32 = 1658238041;
    }
    impl crate::Serializable for MsgsAck {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_ids.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgsAck {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_ids = Vec::<i64>::deserialize(buf)?;
            Ok(MsgsAck { msg_ids })
        }
    }
    impl From<crate::enums::MsgsAck> for MsgsAck {
        fn from(x: crate::enums::MsgsAck) -> Self {
            match x {
                crate::enums::MsgsAck::Ack(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgsAllInfo {
        pub msg_ids: Vec<i64>,
        pub info: Vec<u8>,
    }
    impl crate::Identifiable for MsgsAllInfo {
        const CONSTRUCTOR_ID: u32 = 2361446705;
    }
    impl crate::Serializable for MsgsAllInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_ids.serialize(buf);
            self.info.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgsAllInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_ids = Vec::<i64>::deserialize(buf)?;
            let info = Vec::<u8>::deserialize(buf)?;
            Ok(MsgsAllInfo { msg_ids, info })
        }
    }
    impl From<crate::enums::MsgsAllInfo> for MsgsAllInfo {
        fn from(x: crate::enums::MsgsAllInfo) -> Self {
            match x {
                crate::enums::MsgsAllInfo::Info(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgsStateInfo {
        pub req_msg_id: i64,
        pub info: Vec<u8>,
    }
    impl crate::Identifiable for MsgsStateInfo {
        const CONSTRUCTOR_ID: u32 = 81704317;
    }
    impl crate::Serializable for MsgsStateInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.req_msg_id.serialize(buf);
            self.info.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgsStateInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let req_msg_id = i64::deserialize(buf)?;
            let info = Vec::<u8>::deserialize(buf)?;
            Ok(MsgsStateInfo { req_msg_id, info })
        }
    }
    impl From<crate::enums::MsgsStateInfo> for MsgsStateInfo {
        fn from(x: crate::enums::MsgsStateInfo) -> Self {
            match x {
                crate::enums::MsgsStateInfo::Info(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MsgsStateReq {
        pub msg_ids: Vec<i64>,
    }
    impl crate::Identifiable for MsgsStateReq {
        const CONSTRUCTOR_ID: u32 = 3664378706;
    }
    impl crate::Serializable for MsgsStateReq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_ids.serialize(buf);
        }
    }
    impl crate::Deserializable for MsgsStateReq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_ids = Vec::<i64>::deserialize(buf)?;
            Ok(MsgsStateReq { msg_ids })
        }
    }
    impl From<crate::enums::MsgsStateReq> for MsgsStateReq {
        fn from(x: crate::enums::MsgsStateReq) -> Self {
            match x {
                crate::enums::MsgsStateReq::Req(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NearestDc {
        pub country: String,
        pub this_dc: i32,
        pub nearest_dc: i32,
    }
    impl crate::Identifiable for NearestDc {
        const CONSTRUCTOR_ID: u32 = 2384074613;
    }
    impl crate::Serializable for NearestDc {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.country.serialize(buf);
            self.this_dc.serialize(buf);
            self.nearest_dc.serialize(buf);
        }
    }
    impl crate::Deserializable for NearestDc {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let country = String::deserialize(buf)?;
            let this_dc = i32::deserialize(buf)?;
            let nearest_dc = i32::deserialize(buf)?;
            Ok(NearestDc {
                country,
                this_dc,
                nearest_dc,
            })
        }
    }
    impl From<crate::enums::NearestDc> for NearestDc {
        fn from(x: crate::enums::NearestDc) -> Self {
            match x {
                crate::enums::NearestDc::Dc(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NewSessionCreated {
        pub first_msg_id: i64,
        pub unique_id: i64,
        pub server_salt: i64,
    }
    impl crate::Identifiable for NewSessionCreated {
        const CONSTRUCTOR_ID: u32 = 2663516424;
    }
    impl crate::Serializable for NewSessionCreated {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.first_msg_id.serialize(buf);
            self.unique_id.serialize(buf);
            self.server_salt.serialize(buf);
        }
    }
    impl crate::Deserializable for NewSessionCreated {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let first_msg_id = i64::deserialize(buf)?;
            let unique_id = i64::deserialize(buf)?;
            let server_salt = i64::deserialize(buf)?;
            Ok(NewSessionCreated {
                first_msg_id,
                unique_id,
                server_salt,
            })
        }
    }
    impl From<crate::enums::NewSession> for NewSessionCreated {
        fn from(x: crate::enums::NewSession) -> Self {
            match x {
                crate::enums::NewSession::Created(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NotifyBroadcasts {}
    impl crate::Identifiable for NotifyBroadcasts {
        const CONSTRUCTOR_ID: u32 = 3591563503;
    }
    impl crate::Serializable for NotifyBroadcasts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for NotifyBroadcasts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(NotifyBroadcasts {})
        }
    }
    impl TryFrom<crate::enums::NotifyPeer> for NotifyBroadcasts {
        type Error = ();
        fn try_from(x: crate::enums::NotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::NotifyPeer::NotifyBroadcasts => Ok(NotifyBroadcasts {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NotifyChats {}
    impl crate::Identifiable for NotifyChats {
        const CONSTRUCTOR_ID: u32 = 3221737155;
    }
    impl crate::Serializable for NotifyChats {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for NotifyChats {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(NotifyChats {})
        }
    }
    impl TryFrom<crate::enums::NotifyPeer> for NotifyChats {
        type Error = ();
        fn try_from(x: crate::enums::NotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::NotifyPeer::NotifyChats => Ok(NotifyChats {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NotifyPeer {
        pub peer: crate::enums::Peer,
    }
    impl crate::Identifiable for NotifyPeer {
        const CONSTRUCTOR_ID: u32 = 2681474008;
    }
    impl crate::Serializable for NotifyPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for NotifyPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            Ok(NotifyPeer { peer })
        }
    }
    impl TryFrom<crate::enums::NotifyPeer> for NotifyPeer {
        type Error = ();
        fn try_from(x: crate::enums::NotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::NotifyPeer::Peer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct NotifyUsers {}
    impl crate::Identifiable for NotifyUsers {
        const CONSTRUCTOR_ID: u32 = 3033021260;
    }
    impl crate::Serializable for NotifyUsers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for NotifyUsers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(NotifyUsers {})
        }
    }
    impl TryFrom<crate::enums::NotifyPeer> for NotifyUsers {
        type Error = ();
        fn try_from(x: crate::enums::NotifyPeer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::NotifyPeer::NotifyUsers => Ok(NotifyUsers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Null {}
    impl crate::Identifiable for Null {
        const CONSTRUCTOR_ID: u32 = 1450380236;
    }
    impl crate::Serializable for Null {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for Null {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(Null {})
        }
    }
    impl From<crate::enums::Null> for Null {
        fn from(x: crate::enums::Null) -> Self {
            match x {
                crate::enums::Null::Null => Null {},
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PQInnerData {
        pub pq: Vec<u8>,
        pub p: Vec<u8>,
        pub q: Vec<u8>,
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce: [u8; 32],
    }
    impl crate::Identifiable for PQInnerData {
        const CONSTRUCTOR_ID: u32 = 2211011308;
    }
    impl crate::Serializable for PQInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.pq.serialize(buf);
            self.p.serialize(buf);
            self.q.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce.serialize(buf);
        }
    }
    impl crate::Deserializable for PQInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let pq = Vec::<u8>::deserialize(buf)?;
            let p = Vec::<u8>::deserialize(buf)?;
            let q = Vec::<u8>::deserialize(buf)?;
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce = <[u8; 32]>::deserialize(buf)?;
            Ok(PQInnerData {
                pq,
                p,
                q,
                nonce,
                server_nonce,
                new_nonce,
            })
        }
    }
    impl TryFrom<crate::enums::PQInnerData> for PQInnerData {
        type Error = ();
        fn try_from(x: crate::enums::PQInnerData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PQInnerData::Data(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PQInnerDataDc {
        pub pq: Vec<u8>,
        pub p: Vec<u8>,
        pub q: Vec<u8>,
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce: [u8; 32],
        pub dc: i32,
    }
    impl crate::Identifiable for PQInnerDataDc {
        const CONSTRUCTOR_ID: u32 = 2851430293;
    }
    impl crate::Serializable for PQInnerDataDc {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.pq.serialize(buf);
            self.p.serialize(buf);
            self.q.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce.serialize(buf);
            self.dc.serialize(buf);
        }
    }
    impl crate::Deserializable for PQInnerDataDc {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let pq = Vec::<u8>::deserialize(buf)?;
            let p = Vec::<u8>::deserialize(buf)?;
            let q = Vec::<u8>::deserialize(buf)?;
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce = <[u8; 32]>::deserialize(buf)?;
            let dc = i32::deserialize(buf)?;
            Ok(PQInnerDataDc {
                pq,
                p,
                q,
                nonce,
                server_nonce,
                new_nonce,
                dc,
            })
        }
    }
    impl TryFrom<crate::enums::PQInnerData> for PQInnerDataDc {
        type Error = ();
        fn try_from(x: crate::enums::PQInnerData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PQInnerData::Dc(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PQInnerDataTemp {
        pub pq: Vec<u8>,
        pub p: Vec<u8>,
        pub q: Vec<u8>,
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce: [u8; 32],
        pub expires_in: i32,
    }
    impl crate::Identifiable for PQInnerDataTemp {
        const CONSTRUCTOR_ID: u32 = 1013613780;
    }
    impl crate::Serializable for PQInnerDataTemp {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.pq.serialize(buf);
            self.p.serialize(buf);
            self.q.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce.serialize(buf);
            self.expires_in.serialize(buf);
        }
    }
    impl crate::Deserializable for PQInnerDataTemp {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let pq = Vec::<u8>::deserialize(buf)?;
            let p = Vec::<u8>::deserialize(buf)?;
            let q = Vec::<u8>::deserialize(buf)?;
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce = <[u8; 32]>::deserialize(buf)?;
            let expires_in = i32::deserialize(buf)?;
            Ok(PQInnerDataTemp {
                pq,
                p,
                q,
                nonce,
                server_nonce,
                new_nonce,
                expires_in,
            })
        }
    }
    impl TryFrom<crate::enums::PQInnerData> for PQInnerDataTemp {
        type Error = ();
        fn try_from(x: crate::enums::PQInnerData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PQInnerData::Temp(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PQInnerDataTempDc {
        pub pq: Vec<u8>,
        pub p: Vec<u8>,
        pub q: Vec<u8>,
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce: [u8; 32],
        pub dc: i32,
        pub expires_in: i32,
    }
    impl crate::Identifiable for PQInnerDataTempDc {
        const CONSTRUCTOR_ID: u32 = 1459478408;
    }
    impl crate::Serializable for PQInnerDataTempDc {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.pq.serialize(buf);
            self.p.serialize(buf);
            self.q.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce.serialize(buf);
            self.dc.serialize(buf);
            self.expires_in.serialize(buf);
        }
    }
    impl crate::Deserializable for PQInnerDataTempDc {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let pq = Vec::<u8>::deserialize(buf)?;
            let p = Vec::<u8>::deserialize(buf)?;
            let q = Vec::<u8>::deserialize(buf)?;
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce = <[u8; 32]>::deserialize(buf)?;
            let dc = i32::deserialize(buf)?;
            let expires_in = i32::deserialize(buf)?;
            Ok(PQInnerDataTempDc {
                pq,
                p,
                q,
                nonce,
                server_nonce,
                new_nonce,
                dc,
                expires_in,
            })
        }
    }
    impl TryFrom<crate::enums::PQInnerData> for PQInnerDataTempDc {
        type Error = ();
        fn try_from(x: crate::enums::PQInnerData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PQInnerData::TempDc(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Page {
        pub part: bool,
        pub rtl: bool,
        pub v2: bool,
        pub url: String,
        pub blocks: Vec<crate::enums::PageBlock>,
        pub photos: Vec<crate::enums::Photo>,
        pub documents: Vec<crate::enums::Document>,
        pub views: Option<i32>,
    }
    impl crate::Identifiable for Page {
        const CONSTRUCTOR_ID: u32 = 2556788493;
    }
    impl crate::Serializable for Page {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.part { 1 } else { 0 }
                | if self.rtl { 2 } else { 0 }
                | if self.v2 { 4 } else { 0 }
                | if self.views.is_some() { 8 } else { 0 })
            .serialize(buf);
            self.url.serialize(buf);
            self.blocks.serialize(buf);
            self.photos.serialize(buf);
            self.documents.serialize(buf);
            if let Some(ref x) = self.views {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Page {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let part = (flags & 1) != 0;
            let rtl = (flags & 2) != 0;
            let v2 = (flags & 4) != 0;
            let url = String::deserialize(buf)?;
            let blocks = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            let photos = Vec::<crate::enums::Photo>::deserialize(buf)?;
            let documents = Vec::<crate::enums::Document>::deserialize(buf)?;
            let views = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Page {
                part,
                rtl,
                v2,
                url,
                blocks,
                photos,
                documents,
                views,
            })
        }
    }
    impl From<crate::enums::Page> for Page {
        fn from(x: crate::enums::Page) -> Self {
            match x {
                crate::enums::Page::Page(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockAnchor {
        pub name: String,
    }
    impl crate::Identifiable for PageBlockAnchor {
        const CONSTRUCTOR_ID: u32 = 3456972720;
    }
    impl crate::Serializable for PageBlockAnchor {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.name.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockAnchor {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let name = String::deserialize(buf)?;
            Ok(PageBlockAnchor { name })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockAnchor {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Anchor(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockAudio {
        pub audio_id: i64,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockAudio {
        const CONSTRUCTOR_ID: u32 = 2151899626;
    }
    impl crate::Serializable for PageBlockAudio {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.audio_id.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockAudio {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let audio_id = i64::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockAudio { audio_id, caption })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockAudio {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Audio(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockAuthorDate {
        pub author: crate::enums::RichText,
        pub published_date: i32,
    }
    impl crate::Identifiable for PageBlockAuthorDate {
        const CONSTRUCTOR_ID: u32 = 3132089824;
    }
    impl crate::Serializable for PageBlockAuthorDate {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.author.serialize(buf);
            self.published_date.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockAuthorDate {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let author = crate::enums::RichText::deserialize(buf)?;
            let published_date = i32::deserialize(buf)?;
            Ok(PageBlockAuthorDate {
                author,
                published_date,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockAuthorDate {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::AuthorDate(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockBlockquote {
        pub text: crate::enums::RichText,
        pub caption: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockBlockquote {
        const CONSTRUCTOR_ID: u32 = 641563686;
    }
    impl crate::Serializable for PageBlockBlockquote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockBlockquote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let caption = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockBlockquote { text, caption })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockBlockquote {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Blockquote(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockChannel {
        pub channel: crate::enums::Chat,
    }
    impl crate::Identifiable for PageBlockChannel {
        const CONSTRUCTOR_ID: u32 = 4011282869;
    }
    impl crate::Serializable for PageBlockChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel = crate::enums::Chat::deserialize(buf)?;
            Ok(PageBlockChannel { channel })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockChannel {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockCollage {
        pub items: Vec<crate::enums::PageBlock>,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockCollage {
        const CONSTRUCTOR_ID: u32 = 1705048653;
    }
    impl crate::Serializable for PageBlockCollage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.items.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockCollage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let items = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockCollage { items, caption })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockCollage {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Collage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockCover {
        pub cover: crate::enums::PageBlock,
    }
    impl crate::Identifiable for PageBlockCover {
        const CONSTRUCTOR_ID: u32 = 972174080;
    }
    impl crate::Serializable for PageBlockCover {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.cover.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockCover {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let cover = crate::enums::PageBlock::deserialize(buf)?;
            Ok(PageBlockCover { cover })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockCover {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Cover(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockDetails {
        pub open: bool,
        pub blocks: Vec<crate::enums::PageBlock>,
        pub title: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockDetails {
        const CONSTRUCTOR_ID: u32 = 1987480557;
    }
    impl crate::Serializable for PageBlockDetails {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.open { 1 } else { 0 }).serialize(buf);
            self.blocks.serialize(buf);
            self.title.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockDetails {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let open = (flags & 1) != 0;
            let blocks = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            let title = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockDetails {
                open,
                blocks,
                title,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockDetails {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Details(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockDivider {}
    impl crate::Identifiable for PageBlockDivider {
        const CONSTRUCTOR_ID: u32 = 3676352904;
    }
    impl crate::Serializable for PageBlockDivider {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PageBlockDivider {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PageBlockDivider {})
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockDivider {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Divider => Ok(PageBlockDivider {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockEmbed {
        pub full_width: bool,
        pub allow_scrolling: bool,
        pub url: Option<String>,
        pub html: Option<String>,
        pub poster_photo_id: Option<i64>,
        pub w: Option<i32>,
        pub h: Option<i32>,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockEmbed {
        const CONSTRUCTOR_ID: u32 = 2826014149;
    }
    impl crate::Serializable for PageBlockEmbed {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.full_width { 1 } else { 0 }
                | if self.allow_scrolling { 8 } else { 0 }
                | if self.url.is_some() { 2 } else { 0 }
                | if self.html.is_some() { 4 } else { 0 }
                | if self.poster_photo_id.is_some() {
                    16
                } else {
                    0
                }
                | if self.w.is_some() { 32 } else { 0 }
                | if self.h.is_some() { 32 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.url {
                x.serialize(buf);
            }
            if let Some(ref x) = self.html {
                x.serialize(buf);
            }
            if let Some(ref x) = self.poster_photo_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.w {
                x.serialize(buf);
            }
            if let Some(ref x) = self.h {
                x.serialize(buf);
            }
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockEmbed {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let full_width = (flags & 1) != 0;
            let allow_scrolling = (flags & 8) != 0;
            let url = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let html = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let poster_photo_id = if (flags & 16) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let w = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let h = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockEmbed {
                full_width,
                allow_scrolling,
                url,
                html,
                poster_photo_id,
                w,
                h,
                caption,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockEmbed {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Embed(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockEmbedPost {
        pub url: String,
        pub webpage_id: i64,
        pub author_photo_id: i64,
        pub author: String,
        pub date: i32,
        pub blocks: Vec<crate::enums::PageBlock>,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockEmbedPost {
        const CONSTRUCTOR_ID: u32 = 4065961995;
    }
    impl crate::Serializable for PageBlockEmbedPost {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.webpage_id.serialize(buf);
            self.author_photo_id.serialize(buf);
            self.author.serialize(buf);
            self.date.serialize(buf);
            self.blocks.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockEmbedPost {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let webpage_id = i64::deserialize(buf)?;
            let author_photo_id = i64::deserialize(buf)?;
            let author = String::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let blocks = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockEmbedPost {
                url,
                webpage_id,
                author_photo_id,
                author,
                date,
                blocks,
                caption,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockEmbedPost {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::EmbedPost(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockFooter {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockFooter {
        const CONSTRUCTOR_ID: u32 = 1216809369;
    }
    impl crate::Serializable for PageBlockFooter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockFooter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockFooter { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockFooter {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Footer(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockHeader {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockHeader {
        const CONSTRUCTOR_ID: u32 = 3218105580;
    }
    impl crate::Serializable for PageBlockHeader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockHeader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockHeader { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockHeader {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Header(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockKicker {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockKicker {
        const CONSTRUCTOR_ID: u32 = 504660880;
    }
    impl crate::Serializable for PageBlockKicker {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockKicker {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockKicker { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockKicker {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Kicker(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockList {
        pub items: Vec<crate::enums::PageListItem>,
    }
    impl crate::Identifiable for PageBlockList {
        const CONSTRUCTOR_ID: u32 = 3840442385;
    }
    impl crate::Serializable for PageBlockList {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.items.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockList {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let items = Vec::<crate::enums::PageListItem>::deserialize(buf)?;
            Ok(PageBlockList { items })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockList {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::List(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockMap {
        pub geo: crate::enums::GeoPoint,
        pub zoom: i32,
        pub w: i32,
        pub h: i32,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockMap {
        const CONSTRUCTOR_ID: u32 = 2756656886;
    }
    impl crate::Serializable for PageBlockMap {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.geo.serialize(buf);
            self.zoom.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockMap {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let geo = crate::enums::GeoPoint::deserialize(buf)?;
            let zoom = i32::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockMap {
                geo,
                zoom,
                w,
                h,
                caption,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockMap {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Map(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockOrderedList {
        pub items: Vec<crate::enums::PageListOrderedItem>,
    }
    impl crate::Identifiable for PageBlockOrderedList {
        const CONSTRUCTOR_ID: u32 = 2592793057;
    }
    impl crate::Serializable for PageBlockOrderedList {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.items.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockOrderedList {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let items = Vec::<crate::enums::PageListOrderedItem>::deserialize(buf)?;
            Ok(PageBlockOrderedList { items })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockOrderedList {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::OrderedList(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockParagraph {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockParagraph {
        const CONSTRUCTOR_ID: u32 = 1182402406;
    }
    impl crate::Serializable for PageBlockParagraph {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockParagraph {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockParagraph { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockParagraph {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Paragraph(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockPhoto {
        pub photo_id: i64,
        pub caption: crate::enums::PageCaption,
        pub url: Option<String>,
        pub webpage_id: Option<i64>,
    }
    impl crate::Identifiable for PageBlockPhoto {
        const CONSTRUCTOR_ID: u32 = 391759200;
    }
    impl crate::Serializable for PageBlockPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.url.is_some() { 1 } else { 0 }
                | if self.webpage_id.is_some() { 1 } else { 0 })
            .serialize(buf);
            self.photo_id.serialize(buf);
            self.caption.serialize(buf);
            if let Some(ref x) = self.url {
                x.serialize(buf);
            }
            if let Some(ref x) = self.webpage_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PageBlockPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let photo_id = i64::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            let url = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let webpage_id = if (flags & 1) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            Ok(PageBlockPhoto {
                photo_id,
                caption,
                url,
                webpage_id,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockPhoto {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockPreformatted {
        pub text: crate::enums::RichText,
        pub language: String,
    }
    impl crate::Identifiable for PageBlockPreformatted {
        const CONSTRUCTOR_ID: u32 = 3228621118;
    }
    impl crate::Serializable for PageBlockPreformatted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.language.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockPreformatted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let language = String::deserialize(buf)?;
            Ok(PageBlockPreformatted { text, language })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockPreformatted {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Preformatted(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockPullquote {
        pub text: crate::enums::RichText,
        pub caption: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockPullquote {
        const CONSTRUCTOR_ID: u32 = 1329878739;
    }
    impl crate::Serializable for PageBlockPullquote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockPullquote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let caption = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockPullquote { text, caption })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockPullquote {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Pullquote(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockRelatedArticles {
        pub title: crate::enums::RichText,
        pub articles: Vec<crate::enums::PageRelatedArticle>,
    }
    impl crate::Identifiable for PageBlockRelatedArticles {
        const CONSTRUCTOR_ID: u32 = 370236054;
    }
    impl crate::Serializable for PageBlockRelatedArticles {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.title.serialize(buf);
            self.articles.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockRelatedArticles {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let title = crate::enums::RichText::deserialize(buf)?;
            let articles = Vec::<crate::enums::PageRelatedArticle>::deserialize(buf)?;
            Ok(PageBlockRelatedArticles { title, articles })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockRelatedArticles {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::RelatedArticles(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockSlideshow {
        pub items: Vec<crate::enums::PageBlock>,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockSlideshow {
        const CONSTRUCTOR_ID: u32 = 52401552;
    }
    impl crate::Serializable for PageBlockSlideshow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.items.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockSlideshow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let items = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockSlideshow { items, caption })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockSlideshow {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Slideshow(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockSubheader {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockSubheader {
        const CONSTRUCTOR_ID: u32 = 4046173921;
    }
    impl crate::Serializable for PageBlockSubheader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockSubheader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockSubheader { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockSubheader {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Subheader(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockSubtitle {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockSubtitle {
        const CONSTRUCTOR_ID: u32 = 2415565343;
    }
    impl crate::Serializable for PageBlockSubtitle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockSubtitle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockSubtitle { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockSubtitle {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Subtitle(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockTable {
        pub bordered: bool,
        pub striped: bool,
        pub title: crate::enums::RichText,
        pub rows: Vec<crate::enums::PageTableRow>,
    }
    impl crate::Identifiable for PageBlockTable {
        const CONSTRUCTOR_ID: u32 = 3209554562;
    }
    impl crate::Serializable for PageBlockTable {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.bordered { 1 } else { 0 } | if self.striped { 2 } else { 0 })
                .serialize(buf);
            self.title.serialize(buf);
            self.rows.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockTable {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let bordered = (flags & 1) != 0;
            let striped = (flags & 2) != 0;
            let title = crate::enums::RichText::deserialize(buf)?;
            let rows = Vec::<crate::enums::PageTableRow>::deserialize(buf)?;
            Ok(PageBlockTable {
                bordered,
                striped,
                title,
                rows,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockTable {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Table(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockTitle {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageBlockTitle {
        const CONSTRUCTOR_ID: u32 = 1890305021;
    }
    impl crate::Serializable for PageBlockTitle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockTitle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageBlockTitle { text })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockTitle {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Title(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockUnsupported {}
    impl crate::Identifiable for PageBlockUnsupported {
        const CONSTRUCTOR_ID: u32 = 324435594;
    }
    impl crate::Serializable for PageBlockUnsupported {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PageBlockUnsupported {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PageBlockUnsupported {})
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockUnsupported {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Unsupported => Ok(PageBlockUnsupported {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageBlockVideo {
        pub autoplay: bool,
        pub r#loop: bool,
        pub video_id: i64,
        pub caption: crate::enums::PageCaption,
    }
    impl crate::Identifiable for PageBlockVideo {
        const CONSTRUCTOR_ID: u32 = 2089805750;
    }
    impl crate::Serializable for PageBlockVideo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.autoplay { 1 } else { 0 } | if self.r#loop { 2 } else { 0 })
                .serialize(buf);
            self.video_id.serialize(buf);
            self.caption.serialize(buf);
        }
    }
    impl crate::Deserializable for PageBlockVideo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let autoplay = (flags & 1) != 0;
            let r#loop = (flags & 2) != 0;
            let video_id = i64::deserialize(buf)?;
            let caption = crate::enums::PageCaption::deserialize(buf)?;
            Ok(PageBlockVideo {
                autoplay,
                r#loop,
                video_id,
                caption,
            })
        }
    }
    impl TryFrom<crate::enums::PageBlock> for PageBlockVideo {
        type Error = ();
        fn try_from(x: crate::enums::PageBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageBlock::Video(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageCaption {
        pub text: crate::enums::RichText,
        pub credit: crate::enums::RichText,
    }
    impl crate::Identifiable for PageCaption {
        const CONSTRUCTOR_ID: u32 = 1869903447;
    }
    impl crate::Serializable for PageCaption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.credit.serialize(buf);
        }
    }
    impl crate::Deserializable for PageCaption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let credit = crate::enums::RichText::deserialize(buf)?;
            Ok(PageCaption { text, credit })
        }
    }
    impl From<crate::enums::PageCaption> for PageCaption {
        fn from(x: crate::enums::PageCaption) -> Self {
            match x {
                crate::enums::PageCaption::Caption(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageListItemBlocks {
        pub blocks: Vec<crate::enums::PageBlock>,
    }
    impl crate::Identifiable for PageListItemBlocks {
        const CONSTRUCTOR_ID: u32 = 635466748;
    }
    impl crate::Serializable for PageListItemBlocks {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.blocks.serialize(buf);
        }
    }
    impl crate::Deserializable for PageListItemBlocks {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let blocks = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            Ok(PageListItemBlocks { blocks })
        }
    }
    impl TryFrom<crate::enums::PageListItem> for PageListItemBlocks {
        type Error = ();
        fn try_from(x: crate::enums::PageListItem) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageListItem::Blocks(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageListItemText {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageListItemText {
        const CONSTRUCTOR_ID: u32 = 3106911949;
    }
    impl crate::Serializable for PageListItemText {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageListItemText {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageListItemText { text })
        }
    }
    impl TryFrom<crate::enums::PageListItem> for PageListItemText {
        type Error = ();
        fn try_from(x: crate::enums::PageListItem) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageListItem::Text(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageListOrderedItemBlocks {
        pub num: String,
        pub blocks: Vec<crate::enums::PageBlock>,
    }
    impl crate::Identifiable for PageListOrderedItemBlocks {
        const CONSTRUCTOR_ID: u32 = 2564655414;
    }
    impl crate::Serializable for PageListOrderedItemBlocks {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.num.serialize(buf);
            self.blocks.serialize(buf);
        }
    }
    impl crate::Deserializable for PageListOrderedItemBlocks {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let num = String::deserialize(buf)?;
            let blocks = Vec::<crate::enums::PageBlock>::deserialize(buf)?;
            Ok(PageListOrderedItemBlocks { num, blocks })
        }
    }
    impl TryFrom<crate::enums::PageListOrderedItem> for PageListOrderedItemBlocks {
        type Error = ();
        fn try_from(x: crate::enums::PageListOrderedItem) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageListOrderedItem::Blocks(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageListOrderedItemText {
        pub num: String,
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for PageListOrderedItemText {
        const CONSTRUCTOR_ID: u32 = 1577484359;
    }
    impl crate::Serializable for PageListOrderedItemText {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.num.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for PageListOrderedItemText {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let num = String::deserialize(buf)?;
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(PageListOrderedItemText { num, text })
        }
    }
    impl TryFrom<crate::enums::PageListOrderedItem> for PageListOrderedItemText {
        type Error = ();
        fn try_from(x: crate::enums::PageListOrderedItem) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PageListOrderedItem::Text(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageRelatedArticle {
        pub url: String,
        pub webpage_id: i64,
        pub title: Option<String>,
        pub description: Option<String>,
        pub photo_id: Option<i64>,
        pub author: Option<String>,
        pub published_date: Option<i32>,
    }
    impl crate::Identifiable for PageRelatedArticle {
        const CONSTRUCTOR_ID: u32 = 3012615176;
    }
    impl crate::Serializable for PageRelatedArticle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.title.is_some() { 1 } else { 0 }
                | if self.description.is_some() { 2 } else { 0 }
                | if self.photo_id.is_some() { 4 } else { 0 }
                | if self.author.is_some() { 8 } else { 0 }
                | if self.published_date.is_some() { 16 } else { 0 })
            .serialize(buf);
            self.url.serialize(buf);
            self.webpage_id.serialize(buf);
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            if let Some(ref x) = self.photo_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.author {
                x.serialize(buf);
            }
            if let Some(ref x) = self.published_date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PageRelatedArticle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            let webpage_id = i64::deserialize(buf)?;
            let title = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let photo_id = if (flags & 4) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let author = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let published_date = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(PageRelatedArticle {
                url,
                webpage_id,
                title,
                description,
                photo_id,
                author,
                published_date,
            })
        }
    }
    impl From<crate::enums::PageRelatedArticle> for PageRelatedArticle {
        fn from(x: crate::enums::PageRelatedArticle) -> Self {
            match x {
                crate::enums::PageRelatedArticle::Article(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageTableCell {
        pub header: bool,
        pub align_center: bool,
        pub align_right: bool,
        pub valign_middle: bool,
        pub valign_bottom: bool,
        pub text: Option<crate::enums::RichText>,
        pub colspan: Option<i32>,
        pub rowspan: Option<i32>,
    }
    impl crate::Identifiable for PageTableCell {
        const CONSTRUCTOR_ID: u32 = 878078826;
    }
    impl crate::Serializable for PageTableCell {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.header { 1 } else { 0 }
                | if self.align_center { 8 } else { 0 }
                | if self.align_right { 16 } else { 0 }
                | if self.valign_middle { 32 } else { 0 }
                | if self.valign_bottom { 64 } else { 0 }
                | if self.text.is_some() { 128 } else { 0 }
                | if self.colspan.is_some() { 2 } else { 0 }
                | if self.rowspan.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.text {
                x.serialize(buf);
            }
            if let Some(ref x) = self.colspan {
                x.serialize(buf);
            }
            if let Some(ref x) = self.rowspan {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PageTableCell {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let header = (flags & 1) != 0;
            let align_center = (flags & 8) != 0;
            let align_right = (flags & 16) != 0;
            let valign_middle = (flags & 32) != 0;
            let valign_bottom = (flags & 64) != 0;
            let text = if (flags & 128) != 0 {
                Some(crate::enums::RichText::deserialize(buf)?)
            } else {
                None
            };
            let colspan = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let rowspan = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(PageTableCell {
                header,
                align_center,
                align_right,
                valign_middle,
                valign_bottom,
                text,
                colspan,
                rowspan,
            })
        }
    }
    impl From<crate::enums::PageTableCell> for PageTableCell {
        fn from(x: crate::enums::PageTableCell) -> Self {
            match x {
                crate::enums::PageTableCell::Cell(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PageTableRow {
        pub cells: Vec<crate::enums::PageTableCell>,
    }
    impl crate::Identifiable for PageTableRow {
        const CONSTRUCTOR_ID: u32 = 3770729957;
    }
    impl crate::Serializable for PageTableRow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.cells.serialize(buf);
        }
    }
    impl crate::Deserializable for PageTableRow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let cells = Vec::<crate::enums::PageTableCell>::deserialize(buf)?;
            Ok(PageTableRow { cells })
        }
    }
    impl From<crate::enums::PageTableRow> for PageTableRow {
        fn from(x: crate::enums::PageTableRow) -> Self {
            match x {
                crate::enums::PageTableRow::Row(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow {
        pub salt1: Vec<u8>,
        pub salt2: Vec<u8>,
        pub g: i32,
        pub p: Vec<u8>,
    }
    impl crate::Identifiable for PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow {
        const CONSTRUCTOR_ID: u32 = 982592842;
    }
    impl crate::Serializable for PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.salt1.serialize(buf);
            self.salt2.serialize(buf);
            self.g.serialize(buf);
            self.p.serialize(buf);
        }
    }
    impl crate::Deserializable for PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let salt1 = Vec::<u8>::deserialize(buf)?;
            let salt2 = Vec::<u8>::deserialize(buf)?;
            let g = i32::deserialize(buf)?;
            let p = Vec::<u8>::deserialize(buf)?;
            Ok(
                PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow {
                    salt1,
                    salt2,
                    g,
                    p,
                },
            )
        }
    }
    impl TryFrom<crate::enums::PasswordKdfAlgo>
        for PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow
    {
        type Error = ();
        fn try_from(x: crate::enums::PasswordKdfAlgo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PasswordKdfAlgo::Sha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow(x) => Ok(x),
                _ => Err(())
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PasswordKdfAlgoUnknown {}
    impl crate::Identifiable for PasswordKdfAlgoUnknown {
        const CONSTRUCTOR_ID: u32 = 3562713238;
    }
    impl crate::Serializable for PasswordKdfAlgoUnknown {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PasswordKdfAlgoUnknown {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PasswordKdfAlgoUnknown {})
        }
    }
    impl TryFrom<crate::enums::PasswordKdfAlgo> for PasswordKdfAlgoUnknown {
        type Error = ();
        fn try_from(x: crate::enums::PasswordKdfAlgo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PasswordKdfAlgo::Unknown => Ok(PasswordKdfAlgoUnknown {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PaymentCharge {
        pub id: String,
        pub provider_charge_id: String,
    }
    impl crate::Identifiable for PaymentCharge {
        const CONSTRUCTOR_ID: u32 = 3926049406;
    }
    impl crate::Serializable for PaymentCharge {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.provider_charge_id.serialize(buf);
        }
    }
    impl crate::Deserializable for PaymentCharge {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let provider_charge_id = String::deserialize(buf)?;
            Ok(PaymentCharge {
                id,
                provider_charge_id,
            })
        }
    }
    impl From<crate::enums::PaymentCharge> for PaymentCharge {
        fn from(x: crate::enums::PaymentCharge) -> Self {
            match x {
                crate::enums::PaymentCharge::Charge(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PaymentRequestedInfo {
        pub name: Option<String>,
        pub phone: Option<String>,
        pub email: Option<String>,
        pub shipping_address: Option<crate::enums::PostAddress>,
    }
    impl crate::Identifiable for PaymentRequestedInfo {
        const CONSTRUCTOR_ID: u32 = 2426158996;
    }
    impl crate::Serializable for PaymentRequestedInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.name.is_some() { 1 } else { 0 }
                | if self.phone.is_some() { 2 } else { 0 }
                | if self.email.is_some() { 4 } else { 0 }
                | if self.shipping_address.is_some() {
                    8
                } else {
                    0
                })
            .serialize(buf);
            if let Some(ref x) = self.name {
                x.serialize(buf);
            }
            if let Some(ref x) = self.phone {
                x.serialize(buf);
            }
            if let Some(ref x) = self.email {
                x.serialize(buf);
            }
            if let Some(ref x) = self.shipping_address {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PaymentRequestedInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let name = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let phone = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let email = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let shipping_address = if (flags & 8) != 0 {
                Some(crate::enums::PostAddress::deserialize(buf)?)
            } else {
                None
            };
            Ok(PaymentRequestedInfo {
                name,
                phone,
                email,
                shipping_address,
            })
        }
    }
    impl From<crate::enums::PaymentRequestedInfo> for PaymentRequestedInfo {
        fn from(x: crate::enums::PaymentRequestedInfo) -> Self {
            match x {
                crate::enums::PaymentRequestedInfo::Info(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PaymentSavedCredentialsCard {
        pub id: String,
        pub title: String,
    }
    impl crate::Identifiable for PaymentSavedCredentialsCard {
        const CONSTRUCTOR_ID: u32 = 3452074527;
    }
    impl crate::Serializable for PaymentSavedCredentialsCard {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.title.serialize(buf);
        }
    }
    impl crate::Deserializable for PaymentSavedCredentialsCard {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            Ok(PaymentSavedCredentialsCard { id, title })
        }
    }
    impl From<crate::enums::PaymentSavedCredentials> for PaymentSavedCredentialsCard {
        fn from(x: crate::enums::PaymentSavedCredentials) -> Self {
            match x {
                crate::enums::PaymentSavedCredentials::Card(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerBlocked {
        pub peer_id: crate::enums::Peer,
        pub date: i32,
    }
    impl crate::Identifiable for PeerBlocked {
        const CONSTRUCTOR_ID: u32 = 3908927508;
    }
    impl crate::Serializable for PeerBlocked {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer_id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerBlocked {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer_id = crate::enums::Peer::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(PeerBlocked { peer_id, date })
        }
    }
    impl From<crate::enums::PeerBlocked> for PeerBlocked {
        fn from(x: crate::enums::PeerBlocked) -> Self {
            match x {
                crate::enums::PeerBlocked::Blocked(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerChannel {
        pub channel_id: i64,
    }
    impl crate::Identifiable for PeerChannel {
        const CONSTRUCTOR_ID: u32 = 2728736542;
    }
    impl crate::Serializable for PeerChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            Ok(PeerChannel { channel_id })
        }
    }
    impl TryFrom<crate::enums::Peer> for PeerChannel {
        type Error = ();
        fn try_from(x: crate::enums::Peer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Peer::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerChat {
        pub chat_id: i64,
    }
    impl crate::Identifiable for PeerChat {
        const CONSTRUCTOR_ID: u32 = 918946202;
    }
    impl crate::Serializable for PeerChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            Ok(PeerChat { chat_id })
        }
    }
    impl TryFrom<crate::enums::Peer> for PeerChat {
        type Error = ();
        fn try_from(x: crate::enums::Peer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Peer::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerLocated {
        pub peer: crate::enums::Peer,
        pub expires: i32,
        pub distance: i32,
    }
    impl crate::Identifiable for PeerLocated {
        const CONSTRUCTOR_ID: u32 = 3393592157;
    }
    impl crate::Serializable for PeerLocated {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.expires.serialize(buf);
            self.distance.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerLocated {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let expires = i32::deserialize(buf)?;
            let distance = i32::deserialize(buf)?;
            Ok(PeerLocated {
                peer,
                expires,
                distance,
            })
        }
    }
    impl TryFrom<crate::enums::PeerLocated> for PeerLocated {
        type Error = ();
        fn try_from(x: crate::enums::PeerLocated) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PeerLocated::Located(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerNotifySettings {
        pub show_previews: Option<bool>,
        pub silent: Option<bool>,
        pub mute_until: Option<i32>,
        pub sound: Option<String>,
    }
    impl crate::Identifiable for PeerNotifySettings {
        const CONSTRUCTOR_ID: u32 = 2941295904;
    }
    impl crate::Serializable for PeerNotifySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.show_previews.is_some() { 1 } else { 0 }
                | if self.silent.is_some() { 2 } else { 0 }
                | if self.mute_until.is_some() { 4 } else { 0 }
                | if self.sound.is_some() { 8 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.show_previews {
                x.serialize(buf);
            }
            if let Some(ref x) = self.silent {
                x.serialize(buf);
            }
            if let Some(ref x) = self.mute_until {
                x.serialize(buf);
            }
            if let Some(ref x) = self.sound {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PeerNotifySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let show_previews = if (flags & 1) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            let silent = if (flags & 2) != 0 {
                Some(bool::deserialize(buf)?)
            } else {
                None
            };
            let mute_until = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let sound = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(PeerNotifySettings {
                show_previews,
                silent,
                mute_until,
                sound,
            })
        }
    }
    impl From<crate::enums::PeerNotifySettings> for PeerNotifySettings {
        fn from(x: crate::enums::PeerNotifySettings) -> Self {
            match x {
                crate::enums::PeerNotifySettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerSelfLocated {
        pub expires: i32,
    }
    impl crate::Identifiable for PeerSelfLocated {
        const CONSTRUCTOR_ID: u32 = 4176226379;
    }
    impl crate::Serializable for PeerSelfLocated {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.expires.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerSelfLocated {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let expires = i32::deserialize(buf)?;
            Ok(PeerSelfLocated { expires })
        }
    }
    impl TryFrom<crate::enums::PeerLocated> for PeerSelfLocated {
        type Error = ();
        fn try_from(x: crate::enums::PeerLocated) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PeerLocated::PeerSelfLocated(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerSettings {
        pub report_spam: bool,
        pub add_contact: bool,
        pub block_contact: bool,
        pub share_contact: bool,
        pub need_contacts_exception: bool,
        pub report_geo: bool,
        pub autoarchived: bool,
        pub invite_members: bool,
        pub request_chat_broadcast: bool,
        pub geo_distance: Option<i32>,
        pub request_chat_title: Option<String>,
        pub request_chat_date: Option<i32>,
    }
    impl crate::Identifiable for PeerSettings {
        const CONSTRUCTOR_ID: u32 = 2769817869;
    }
    impl crate::Serializable for PeerSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.report_spam { 1 } else { 0 }
                | if self.add_contact { 2 } else { 0 }
                | if self.block_contact { 4 } else { 0 }
                | if self.share_contact { 8 } else { 0 }
                | if self.need_contacts_exception { 16 } else { 0 }
                | if self.report_geo { 32 } else { 0 }
                | if self.autoarchived { 128 } else { 0 }
                | if self.invite_members { 256 } else { 0 }
                | if self.request_chat_broadcast { 1024 } else { 0 }
                | if self.geo_distance.is_some() { 64 } else { 0 }
                | if self.request_chat_title.is_some() {
                    512
                } else {
                    0
                }
                | if self.request_chat_date.is_some() {
                    512
                } else {
                    0
                })
            .serialize(buf);
            if let Some(ref x) = self.geo_distance {
                x.serialize(buf);
            }
            if let Some(ref x) = self.request_chat_title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.request_chat_date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PeerSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let report_spam = (flags & 1) != 0;
            let add_contact = (flags & 2) != 0;
            let block_contact = (flags & 4) != 0;
            let share_contact = (flags & 8) != 0;
            let need_contacts_exception = (flags & 16) != 0;
            let report_geo = (flags & 32) != 0;
            let autoarchived = (flags & 128) != 0;
            let invite_members = (flags & 256) != 0;
            let request_chat_broadcast = (flags & 1024) != 0;
            let geo_distance = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let request_chat_title = if (flags & 512) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let request_chat_date = if (flags & 512) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(PeerSettings {
                report_spam,
                add_contact,
                block_contact,
                share_contact,
                need_contacts_exception,
                report_geo,
                autoarchived,
                invite_members,
                request_chat_broadcast,
                geo_distance,
                request_chat_title,
                request_chat_date,
            })
        }
    }
    impl From<crate::enums::PeerSettings> for PeerSettings {
        fn from(x: crate::enums::PeerSettings) -> Self {
            match x {
                crate::enums::PeerSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PeerUser {
        pub user_id: i64,
    }
    impl crate::Identifiable for PeerUser {
        const CONSTRUCTOR_ID: u32 = 1498486562;
    }
    impl crate::Serializable for PeerUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for PeerUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            Ok(PeerUser { user_id })
        }
    }
    impl TryFrom<crate::enums::Peer> for PeerUser {
        type Error = ();
        fn try_from(x: crate::enums::Peer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Peer::User(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCall {
        pub p2p_allowed: bool,
        pub video: bool,
        pub id: i64,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub g_a_or_b: Vec<u8>,
        pub key_fingerprint: i64,
        pub protocol: crate::enums::PhoneCallProtocol,
        pub connections: Vec<crate::enums::PhoneConnection>,
        pub start_date: i32,
    }
    impl crate::Identifiable for PhoneCall {
        const CONSTRUCTOR_ID: u32 = 2524937319;
    }
    impl crate::Serializable for PhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.p2p_allowed { 32 } else { 0 } | if self.video { 64 } else { 0 })
                .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.g_a_or_b.serialize(buf);
            self.key_fingerprint.serialize(buf);
            self.protocol.serialize(buf);
            self.connections.serialize(buf);
            self.start_date.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let p2p_allowed = (flags & 32) != 0;
            let video = (flags & 64) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let g_a_or_b = Vec::<u8>::deserialize(buf)?;
            let key_fingerprint = i64::deserialize(buf)?;
            let protocol = crate::enums::PhoneCallProtocol::deserialize(buf)?;
            let connections = Vec::<crate::enums::PhoneConnection>::deserialize(buf)?;
            let start_date = i32::deserialize(buf)?;
            Ok(PhoneCall {
                p2p_allowed,
                video,
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                g_a_or_b,
                key_fingerprint,
                protocol,
                connections,
                start_date,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCall {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Call(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallAccepted {
        pub video: bool,
        pub id: i64,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub g_b: Vec<u8>,
        pub protocol: crate::enums::PhoneCallProtocol,
    }
    impl crate::Identifiable for PhoneCallAccepted {
        const CONSTRUCTOR_ID: u32 = 912311057;
    }
    impl crate::Serializable for PhoneCallAccepted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.video { 64 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.g_b.serialize(buf);
            self.protocol.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneCallAccepted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let video = (flags & 64) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let g_b = Vec::<u8>::deserialize(buf)?;
            let protocol = crate::enums::PhoneCallProtocol::deserialize(buf)?;
            Ok(PhoneCallAccepted {
                video,
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                g_b,
                protocol,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCallAccepted {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Accepted(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallDiscardReasonBusy {}
    impl crate::Identifiable for PhoneCallDiscardReasonBusy {
        const CONSTRUCTOR_ID: u32 = 4210550985;
    }
    impl crate::Serializable for PhoneCallDiscardReasonBusy {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PhoneCallDiscardReasonBusy {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PhoneCallDiscardReasonBusy {})
        }
    }
    impl TryFrom<crate::enums::PhoneCallDiscardReason> for PhoneCallDiscardReasonBusy {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCallDiscardReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCallDiscardReason::Busy => Ok(PhoneCallDiscardReasonBusy {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallDiscardReasonDisconnect {}
    impl crate::Identifiable for PhoneCallDiscardReasonDisconnect {
        const CONSTRUCTOR_ID: u32 = 3767910816;
    }
    impl crate::Serializable for PhoneCallDiscardReasonDisconnect {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PhoneCallDiscardReasonDisconnect {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PhoneCallDiscardReasonDisconnect {})
        }
    }
    impl TryFrom<crate::enums::PhoneCallDiscardReason> for PhoneCallDiscardReasonDisconnect {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCallDiscardReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCallDiscardReason::Disconnect => {
                    Ok(PhoneCallDiscardReasonDisconnect {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallDiscardReasonHangup {}
    impl crate::Identifiable for PhoneCallDiscardReasonHangup {
        const CONSTRUCTOR_ID: u32 = 1471006352;
    }
    impl crate::Serializable for PhoneCallDiscardReasonHangup {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PhoneCallDiscardReasonHangup {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PhoneCallDiscardReasonHangup {})
        }
    }
    impl TryFrom<crate::enums::PhoneCallDiscardReason> for PhoneCallDiscardReasonHangup {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCallDiscardReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCallDiscardReason::Hangup => Ok(PhoneCallDiscardReasonHangup {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallDiscardReasonMissed {}
    impl crate::Identifiable for PhoneCallDiscardReasonMissed {
        const CONSTRUCTOR_ID: u32 = 2246320897;
    }
    impl crate::Serializable for PhoneCallDiscardReasonMissed {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PhoneCallDiscardReasonMissed {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PhoneCallDiscardReasonMissed {})
        }
    }
    impl TryFrom<crate::enums::PhoneCallDiscardReason> for PhoneCallDiscardReasonMissed {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCallDiscardReason) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCallDiscardReason::Missed => Ok(PhoneCallDiscardReasonMissed {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallDiscarded {
        pub need_rating: bool,
        pub need_debug: bool,
        pub video: bool,
        pub id: i64,
        pub reason: Option<crate::enums::PhoneCallDiscardReason>,
        pub duration: Option<i32>,
    }
    impl crate::Identifiable for PhoneCallDiscarded {
        const CONSTRUCTOR_ID: u32 = 1355435489;
    }
    impl crate::Serializable for PhoneCallDiscarded {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.need_rating { 4 } else { 0 }
                | if self.need_debug { 8 } else { 0 }
                | if self.video { 64 } else { 0 }
                | if self.reason.is_some() { 1 } else { 0 }
                | if self.duration.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.reason {
                x.serialize(buf);
            }
            if let Some(ref x) = self.duration {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PhoneCallDiscarded {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let need_rating = (flags & 4) != 0;
            let need_debug = (flags & 8) != 0;
            let video = (flags & 64) != 0;
            let id = i64::deserialize(buf)?;
            let reason = if (flags & 1) != 0 {
                Some(crate::enums::PhoneCallDiscardReason::deserialize(buf)?)
            } else {
                None
            };
            let duration = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(PhoneCallDiscarded {
                need_rating,
                need_debug,
                video,
                id,
                reason,
                duration,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCallDiscarded {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Discarded(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for PhoneCallEmpty {
        const CONSTRUCTOR_ID: u32 = 1399245077;
    }
    impl crate::Serializable for PhoneCallEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneCallEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(PhoneCallEmpty { id })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCallEmpty {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallProtocol {
        pub udp_p2p: bool,
        pub udp_reflector: bool,
        pub min_layer: i32,
        pub max_layer: i32,
        pub library_versions: Vec<String>,
    }
    impl crate::Identifiable for PhoneCallProtocol {
        const CONSTRUCTOR_ID: u32 = 4236742600;
    }
    impl crate::Serializable for PhoneCallProtocol {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.udp_p2p { 1 } else { 0 } | if self.udp_reflector { 2 } else { 0 })
                .serialize(buf);
            self.min_layer.serialize(buf);
            self.max_layer.serialize(buf);
            self.library_versions.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneCallProtocol {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let udp_p2p = (flags & 1) != 0;
            let udp_reflector = (flags & 2) != 0;
            let min_layer = i32::deserialize(buf)?;
            let max_layer = i32::deserialize(buf)?;
            let library_versions = Vec::<String>::deserialize(buf)?;
            Ok(PhoneCallProtocol {
                udp_p2p,
                udp_reflector,
                min_layer,
                max_layer,
                library_versions,
            })
        }
    }
    impl From<crate::enums::PhoneCallProtocol> for PhoneCallProtocol {
        fn from(x: crate::enums::PhoneCallProtocol) -> Self {
            match x {
                crate::enums::PhoneCallProtocol::Protocol(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallRequested {
        pub video: bool,
        pub id: i64,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub g_a_hash: Vec<u8>,
        pub protocol: crate::enums::PhoneCallProtocol,
    }
    impl crate::Identifiable for PhoneCallRequested {
        const CONSTRUCTOR_ID: u32 = 347139340;
    }
    impl crate::Serializable for PhoneCallRequested {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.video { 64 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.g_a_hash.serialize(buf);
            self.protocol.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneCallRequested {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let video = (flags & 64) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let g_a_hash = Vec::<u8>::deserialize(buf)?;
            let protocol = crate::enums::PhoneCallProtocol::deserialize(buf)?;
            Ok(PhoneCallRequested {
                video,
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                g_a_hash,
                protocol,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCallRequested {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Requested(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneCallWaiting {
        pub video: bool,
        pub id: i64,
        pub access_hash: i64,
        pub date: i32,
        pub admin_id: i64,
        pub participant_id: i64,
        pub protocol: crate::enums::PhoneCallProtocol,
        pub receive_date: Option<i32>,
    }
    impl crate::Identifiable for PhoneCallWaiting {
        const CONSTRUCTOR_ID: u32 = 3307368215;
    }
    impl crate::Serializable for PhoneCallWaiting {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.video { 64 } else { 0 }
                | if self.receive_date.is_some() { 1 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.date.serialize(buf);
            self.admin_id.serialize(buf);
            self.participant_id.serialize(buf);
            self.protocol.serialize(buf);
            if let Some(ref x) = self.receive_date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PhoneCallWaiting {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let video = (flags & 64) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let admin_id = i64::deserialize(buf)?;
            let participant_id = i64::deserialize(buf)?;
            let protocol = crate::enums::PhoneCallProtocol::deserialize(buf)?;
            let receive_date = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(PhoneCallWaiting {
                video,
                id,
                access_hash,
                date,
                admin_id,
                participant_id,
                protocol,
                receive_date,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneCall> for PhoneCallWaiting {
        type Error = ();
        fn try_from(x: crate::enums::PhoneCall) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneCall::Waiting(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneConnection {
        pub id: i64,
        pub ip: String,
        pub ipv6: String,
        pub port: i32,
        pub peer_tag: Vec<u8>,
    }
    impl crate::Identifiable for PhoneConnection {
        const CONSTRUCTOR_ID: u32 = 2639009728;
    }
    impl crate::Serializable for PhoneConnection {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.ip.serialize(buf);
            self.ipv6.serialize(buf);
            self.port.serialize(buf);
            self.peer_tag.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneConnection {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let ip = String::deserialize(buf)?;
            let ipv6 = String::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            let peer_tag = Vec::<u8>::deserialize(buf)?;
            Ok(PhoneConnection {
                id,
                ip,
                ipv6,
                port,
                peer_tag,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneConnection> for PhoneConnection {
        type Error = ();
        fn try_from(x: crate::enums::PhoneConnection) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneConnection::Connection(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhoneConnectionWebrtc {
        pub turn: bool,
        pub stun: bool,
        pub id: i64,
        pub ip: String,
        pub ipv6: String,
        pub port: i32,
        pub username: String,
        pub password: String,
    }
    impl crate::Identifiable for PhoneConnectionWebrtc {
        const CONSTRUCTOR_ID: u32 = 1667228533;
    }
    impl crate::Serializable for PhoneConnectionWebrtc {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.turn { 1 } else { 0 } | if self.stun { 2 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            self.ip.serialize(buf);
            self.ipv6.serialize(buf);
            self.port.serialize(buf);
            self.username.serialize(buf);
            self.password.serialize(buf);
        }
    }
    impl crate::Deserializable for PhoneConnectionWebrtc {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let turn = (flags & 1) != 0;
            let stun = (flags & 2) != 0;
            let id = i64::deserialize(buf)?;
            let ip = String::deserialize(buf)?;
            let ipv6 = String::deserialize(buf)?;
            let port = i32::deserialize(buf)?;
            let username = String::deserialize(buf)?;
            let password = String::deserialize(buf)?;
            Ok(PhoneConnectionWebrtc {
                turn,
                stun,
                id,
                ip,
                ipv6,
                port,
                username,
                password,
            })
        }
    }
    impl TryFrom<crate::enums::PhoneConnection> for PhoneConnectionWebrtc {
        type Error = ();
        fn try_from(x: crate::enums::PhoneConnection) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhoneConnection::Webrtc(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Photo {
        pub has_stickers: bool,
        pub id: i64,
        pub access_hash: i64,
        pub file_reference: Vec<u8>,
        pub date: i32,
        pub sizes: Vec<crate::enums::PhotoSize>,
        pub video_sizes: Option<Vec<crate::enums::VideoSize>>,
        pub dc_id: i32,
    }
    impl crate::Identifiable for Photo {
        const CONSTRUCTOR_ID: u32 = 4212750949;
    }
    impl crate::Serializable for Photo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.has_stickers { 1 } else { 0 }
                | if self.video_sizes.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.file_reference.serialize(buf);
            self.date.serialize(buf);
            self.sizes.serialize(buf);
            if let Some(ref x) = self.video_sizes {
                x.serialize(buf);
            }
            self.dc_id.serialize(buf);
        }
    }
    impl crate::Deserializable for Photo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let has_stickers = (flags & 1) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let file_reference = Vec::<u8>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let sizes = Vec::<crate::enums::PhotoSize>::deserialize(buf)?;
            let video_sizes = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::VideoSize>::deserialize(buf)?)
            } else {
                None
            };
            let dc_id = i32::deserialize(buf)?;
            Ok(Photo {
                has_stickers,
                id,
                access_hash,
                file_reference,
                date,
                sizes,
                video_sizes,
                dc_id,
            })
        }
    }
    impl TryFrom<crate::enums::Photo> for Photo {
        type Error = ();
        fn try_from(x: crate::enums::Photo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Photo::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoCachedSize {
        pub r#type: String,
        pub w: i32,
        pub h: i32,
        pub bytes: Vec<u8>,
    }
    impl crate::Identifiable for PhotoCachedSize {
        const CONSTRUCTOR_ID: u32 = 35527382;
    }
    impl crate::Serializable for PhotoCachedSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.bytes.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoCachedSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let bytes = Vec::<u8>::deserialize(buf)?;
            Ok(PhotoCachedSize {
                r#type,
                w,
                h,
                bytes,
            })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoCachedSize {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::PhotoCachedSize(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for PhotoEmpty {
        const CONSTRUCTOR_ID: u32 = 590459437;
    }
    impl crate::Serializable for PhotoEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(PhotoEmpty { id })
        }
    }
    impl TryFrom<crate::enums::Photo> for PhotoEmpty {
        type Error = ();
        fn try_from(x: crate::enums::Photo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Photo::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoPathSize {
        pub r#type: String,
        pub bytes: Vec<u8>,
    }
    impl crate::Identifiable for PhotoPathSize {
        const CONSTRUCTOR_ID: u32 = 3626061121;
    }
    impl crate::Serializable for PhotoPathSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.bytes.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoPathSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            let bytes = Vec::<u8>::deserialize(buf)?;
            Ok(PhotoPathSize { r#type, bytes })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoPathSize {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::PhotoPathSize(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoSize {
        pub r#type: String,
        pub w: i32,
        pub h: i32,
        pub size: i32,
    }
    impl crate::Identifiable for PhotoSize {
        const CONSTRUCTOR_ID: u32 = 1976012384;
    }
    impl crate::Serializable for PhotoSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.size.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            Ok(PhotoSize { r#type, w, h, size })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoSize {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::Size(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoSizeEmpty {
        pub r#type: String,
    }
    impl crate::Identifiable for PhotoSizeEmpty {
        const CONSTRUCTOR_ID: u32 = 236446268;
    }
    impl crate::Serializable for PhotoSizeEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoSizeEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            Ok(PhotoSizeEmpty { r#type })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoSizeEmpty {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoSizeProgressive {
        pub r#type: String,
        pub w: i32,
        pub h: i32,
        pub sizes: Vec<i32>,
    }
    impl crate::Identifiable for PhotoSizeProgressive {
        const CONSTRUCTOR_ID: u32 = 4198431637;
    }
    impl crate::Serializable for PhotoSizeProgressive {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.sizes.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoSizeProgressive {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let sizes = Vec::<i32>::deserialize(buf)?;
            Ok(PhotoSizeProgressive {
                r#type,
                w,
                h,
                sizes,
            })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoSizeProgressive {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::Progressive(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhotoStrippedSize {
        pub r#type: String,
        pub bytes: Vec<u8>,
    }
    impl crate::Identifiable for PhotoStrippedSize {
        const CONSTRUCTOR_ID: u32 = 3769678894;
    }
    impl crate::Serializable for PhotoStrippedSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.bytes.serialize(buf);
        }
    }
    impl crate::Deserializable for PhotoStrippedSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = String::deserialize(buf)?;
            let bytes = Vec::<u8>::deserialize(buf)?;
            Ok(PhotoStrippedSize { r#type, bytes })
        }
    }
    impl TryFrom<crate::enums::PhotoSize> for PhotoStrippedSize {
        type Error = ();
        fn try_from(x: crate::enums::PhotoSize) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PhotoSize::PhotoStrippedSize(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Poll {
        pub id: i64,
        pub closed: bool,
        pub public_voters: bool,
        pub multiple_choice: bool,
        pub quiz: bool,
        pub question: String,
        pub answers: Vec<crate::enums::PollAnswer>,
        pub close_period: Option<i32>,
        pub close_date: Option<i32>,
    }
    impl crate::Identifiable for Poll {
        const CONSTRUCTOR_ID: u32 = 2262925665;
    }
    impl crate::Serializable for Poll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            (0u32
                | if self.closed { 1 } else { 0 }
                | if self.public_voters { 2 } else { 0 }
                | if self.multiple_choice { 4 } else { 0 }
                | if self.quiz { 8 } else { 0 }
                | if self.close_period.is_some() { 16 } else { 0 }
                | if self.close_date.is_some() { 32 } else { 0 })
            .serialize(buf);
            self.question.serialize(buf);
            self.answers.serialize(buf);
            if let Some(ref x) = self.close_period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.close_date {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Poll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let flags = u32::deserialize(buf)?;
            let closed = (flags & 1) != 0;
            let public_voters = (flags & 2) != 0;
            let multiple_choice = (flags & 4) != 0;
            let quiz = (flags & 8) != 0;
            let question = String::deserialize(buf)?;
            let answers = Vec::<crate::enums::PollAnswer>::deserialize(buf)?;
            let close_period = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let close_date = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Poll {
                id,
                closed,
                public_voters,
                multiple_choice,
                quiz,
                question,
                answers,
                close_period,
                close_date,
            })
        }
    }
    impl From<crate::enums::Poll> for Poll {
        fn from(x: crate::enums::Poll) -> Self {
            match x {
                crate::enums::Poll::Poll(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PollAnswer {
        pub text: String,
        pub option: Vec<u8>,
    }
    impl crate::Identifiable for PollAnswer {
        const CONSTRUCTOR_ID: u32 = 1823064809;
    }
    impl crate::Serializable for PollAnswer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.option.serialize(buf);
        }
    }
    impl crate::Deserializable for PollAnswer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            let option = Vec::<u8>::deserialize(buf)?;
            Ok(PollAnswer { text, option })
        }
    }
    impl From<crate::enums::PollAnswer> for PollAnswer {
        fn from(x: crate::enums::PollAnswer) -> Self {
            match x {
                crate::enums::PollAnswer::Answer(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PollAnswerVoters {
        pub chosen: bool,
        pub correct: bool,
        pub option: Vec<u8>,
        pub voters: i32,
    }
    impl crate::Identifiable for PollAnswerVoters {
        const CONSTRUCTOR_ID: u32 = 997055186;
    }
    impl crate::Serializable for PollAnswerVoters {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.chosen { 1 } else { 0 } | if self.correct { 2 } else { 0 })
                .serialize(buf);
            self.option.serialize(buf);
            self.voters.serialize(buf);
        }
    }
    impl crate::Deserializable for PollAnswerVoters {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let chosen = (flags & 1) != 0;
            let correct = (flags & 2) != 0;
            let option = Vec::<u8>::deserialize(buf)?;
            let voters = i32::deserialize(buf)?;
            Ok(PollAnswerVoters {
                chosen,
                correct,
                option,
                voters,
            })
        }
    }
    impl From<crate::enums::PollAnswerVoters> for PollAnswerVoters {
        fn from(x: crate::enums::PollAnswerVoters) -> Self {
            match x {
                crate::enums::PollAnswerVoters::Voters(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PollResults {
        pub min: bool,
        pub results: Option<Vec<crate::enums::PollAnswerVoters>>,
        pub total_voters: Option<i32>,
        pub recent_voters: Option<Vec<i64>>,
        pub solution: Option<String>,
        pub solution_entities: Option<Vec<crate::enums::MessageEntity>>,
    }
    impl crate::Identifiable for PollResults {
        const CONSTRUCTOR_ID: u32 = 3703058083;
    }
    impl crate::Serializable for PollResults {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.min { 1 } else { 0 }
                | if self.results.is_some() { 2 } else { 0 }
                | if self.total_voters.is_some() { 4 } else { 0 }
                | if self.recent_voters.is_some() { 8 } else { 0 }
                | if self.solution.is_some() { 16 } else { 0 }
                | if self.solution_entities.is_some() {
                    16
                } else {
                    0
                })
            .serialize(buf);
            if let Some(ref x) = self.results {
                x.serialize(buf);
            }
            if let Some(ref x) = self.total_voters {
                x.serialize(buf);
            }
            if let Some(ref x) = self.recent_voters {
                x.serialize(buf);
            }
            if let Some(ref x) = self.solution {
                x.serialize(buf);
            }
            if let Some(ref x) = self.solution_entities {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for PollResults {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let min = (flags & 1) != 0;
            let results = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::PollAnswerVoters>::deserialize(buf)?)
            } else {
                None
            };
            let total_voters = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let recent_voters = if (flags & 8) != 0 {
                Some(Vec::<i64>::deserialize(buf)?)
            } else {
                None
            };
            let solution = if (flags & 16) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let solution_entities = if (flags & 16) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            Ok(PollResults {
                min,
                results,
                total_voters,
                recent_voters,
                solution,
                solution_entities,
            })
        }
    }
    impl From<crate::enums::PollResults> for PollResults {
        fn from(x: crate::enums::PollResults) -> Self {
            match x {
                crate::enums::PollResults::Results(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Pong {
        pub msg_id: i64,
        pub ping_id: i64,
    }
    impl crate::Identifiable for Pong {
        const CONSTRUCTOR_ID: u32 = 880243653;
    }
    impl crate::Serializable for Pong {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_id.serialize(buf);
            self.ping_id.serialize(buf);
        }
    }
    impl crate::Deserializable for Pong {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_id = i64::deserialize(buf)?;
            let ping_id = i64::deserialize(buf)?;
            Ok(Pong { msg_id, ping_id })
        }
    }
    impl From<crate::enums::Pong> for Pong {
        fn from(x: crate::enums::Pong) -> Self {
            match x {
                crate::enums::Pong::Pong(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PopularContact {
        pub client_id: i64,
        pub importers: i32,
    }
    impl crate::Identifiable for PopularContact {
        const CONSTRUCTOR_ID: u32 = 1558266229;
    }
    impl crate::Serializable for PopularContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.client_id.serialize(buf);
            self.importers.serialize(buf);
        }
    }
    impl crate::Deserializable for PopularContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let client_id = i64::deserialize(buf)?;
            let importers = i32::deserialize(buf)?;
            Ok(PopularContact {
                client_id,
                importers,
            })
        }
    }
    impl From<crate::enums::PopularContact> for PopularContact {
        fn from(x: crate::enums::PopularContact) -> Self {
            match x {
                crate::enums::PopularContact::Contact(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PostAddress {
        pub street_line1: String,
        pub street_line2: String,
        pub city: String,
        pub state: String,
        pub country_iso2: String,
        pub post_code: String,
    }
    impl crate::Identifiable for PostAddress {
        const CONSTRUCTOR_ID: u32 = 512535275;
    }
    impl crate::Serializable for PostAddress {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.street_line1.serialize(buf);
            self.street_line2.serialize(buf);
            self.city.serialize(buf);
            self.state.serialize(buf);
            self.country_iso2.serialize(buf);
            self.post_code.serialize(buf);
        }
    }
    impl crate::Deserializable for PostAddress {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let street_line1 = String::deserialize(buf)?;
            let street_line2 = String::deserialize(buf)?;
            let city = String::deserialize(buf)?;
            let state = String::deserialize(buf)?;
            let country_iso2 = String::deserialize(buf)?;
            let post_code = String::deserialize(buf)?;
            Ok(PostAddress {
                street_line1,
                street_line2,
                city,
                state,
                country_iso2,
                post_code,
            })
        }
    }
    impl From<crate::enums::PostAddress> for PostAddress {
        fn from(x: crate::enums::PostAddress) -> Self {
            match x {
                crate::enums::PostAddress::Address(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyAddedByPhone {}
    impl crate::Identifiable for PrivacyKeyAddedByPhone {
        const CONSTRUCTOR_ID: u32 = 1124062251;
    }
    impl crate::Serializable for PrivacyKeyAddedByPhone {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyAddedByPhone {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyAddedByPhone {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyAddedByPhone {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::AddedByPhone => Ok(PrivacyKeyAddedByPhone {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyChatInvite {}
    impl crate::Identifiable for PrivacyKeyChatInvite {
        const CONSTRUCTOR_ID: u32 = 1343122938;
    }
    impl crate::Serializable for PrivacyKeyChatInvite {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyChatInvite {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyChatInvite {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyChatInvite {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::ChatInvite => Ok(PrivacyKeyChatInvite {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyForwards {}
    impl crate::Identifiable for PrivacyKeyForwards {
        const CONSTRUCTOR_ID: u32 = 1777096355;
    }
    impl crate::Serializable for PrivacyKeyForwards {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyForwards {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyForwards {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyForwards {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::Forwards => Ok(PrivacyKeyForwards {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyPhoneCall {}
    impl crate::Identifiable for PrivacyKeyPhoneCall {
        const CONSTRUCTOR_ID: u32 = 1030105979;
    }
    impl crate::Serializable for PrivacyKeyPhoneCall {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyPhoneCall {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyPhoneCall {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyPhoneCall {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::PhoneCall => Ok(PrivacyKeyPhoneCall {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyPhoneNumber {}
    impl crate::Identifiable for PrivacyKeyPhoneNumber {
        const CONSTRUCTOR_ID: u32 = 3516589165;
    }
    impl crate::Serializable for PrivacyKeyPhoneNumber {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyPhoneNumber {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyPhoneNumber {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyPhoneNumber {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::PhoneNumber => Ok(PrivacyKeyPhoneNumber {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyPhoneP2P {}
    impl crate::Identifiable for PrivacyKeyPhoneP2P {
        const CONSTRUCTOR_ID: u32 = 961092808;
    }
    impl crate::Serializable for PrivacyKeyPhoneP2P {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyPhoneP2P {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyPhoneP2P {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyPhoneP2P {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::PhoneP2P => Ok(PrivacyKeyPhoneP2P {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyProfilePhoto {}
    impl crate::Identifiable for PrivacyKeyProfilePhoto {
        const CONSTRUCTOR_ID: u32 = 2517966829;
    }
    impl crate::Serializable for PrivacyKeyProfilePhoto {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyProfilePhoto {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyProfilePhoto {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyProfilePhoto {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::ProfilePhoto => Ok(PrivacyKeyProfilePhoto {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyKeyStatusTimestamp {}
    impl crate::Identifiable for PrivacyKeyStatusTimestamp {
        const CONSTRUCTOR_ID: u32 = 3157175088;
    }
    impl crate::Serializable for PrivacyKeyStatusTimestamp {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyKeyStatusTimestamp {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyKeyStatusTimestamp {})
        }
    }
    impl TryFrom<crate::enums::PrivacyKey> for PrivacyKeyStatusTimestamp {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyKey) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyKey::StatusTimestamp => Ok(PrivacyKeyStatusTimestamp {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueAllowAll {}
    impl crate::Identifiable for PrivacyValueAllowAll {
        const CONSTRUCTOR_ID: u32 = 1698855810;
    }
    impl crate::Serializable for PrivacyValueAllowAll {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyValueAllowAll {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyValueAllowAll {})
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueAllowAll {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueAllowAll => Ok(PrivacyValueAllowAll {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueAllowChatParticipants {
        pub chats: Vec<i64>,
    }
    impl crate::Identifiable for PrivacyValueAllowChatParticipants {
        const CONSTRUCTOR_ID: u32 = 1796427406;
    }
    impl crate::Serializable for PrivacyValueAllowChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chats.serialize(buf);
        }
    }
    impl crate::Deserializable for PrivacyValueAllowChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chats = Vec::<i64>::deserialize(buf)?;
            Ok(PrivacyValueAllowChatParticipants { chats })
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueAllowChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueAllowChatParticipants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueAllowContacts {}
    impl crate::Identifiable for PrivacyValueAllowContacts {
        const CONSTRUCTOR_ID: u32 = 4294843308;
    }
    impl crate::Serializable for PrivacyValueAllowContacts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyValueAllowContacts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyValueAllowContacts {})
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueAllowContacts {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueAllowContacts => {
                    Ok(PrivacyValueAllowContacts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueAllowUsers {
        pub users: Vec<i64>,
    }
    impl crate::Identifiable for PrivacyValueAllowUsers {
        const CONSTRUCTOR_ID: u32 = 3096469426;
    }
    impl crate::Serializable for PrivacyValueAllowUsers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for PrivacyValueAllowUsers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let users = Vec::<i64>::deserialize(buf)?;
            Ok(PrivacyValueAllowUsers { users })
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueAllowUsers {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueAllowUsers(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueDisallowAll {}
    impl crate::Identifiable for PrivacyValueDisallowAll {
        const CONSTRUCTOR_ID: u32 = 2339628899;
    }
    impl crate::Serializable for PrivacyValueDisallowAll {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyValueDisallowAll {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyValueDisallowAll {})
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueDisallowAll {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueDisallowAll => {
                    Ok(PrivacyValueDisallowAll {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueDisallowChatParticipants {
        pub chats: Vec<i64>,
    }
    impl crate::Identifiable for PrivacyValueDisallowChatParticipants {
        const CONSTRUCTOR_ID: u32 = 1103656293;
    }
    impl crate::Serializable for PrivacyValueDisallowChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chats.serialize(buf);
        }
    }
    impl crate::Deserializable for PrivacyValueDisallowChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chats = Vec::<i64>::deserialize(buf)?;
            Ok(PrivacyValueDisallowChatParticipants { chats })
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueDisallowChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueDisallowChatParticipants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueDisallowContacts {}
    impl crate::Identifiable for PrivacyValueDisallowContacts {
        const CONSTRUCTOR_ID: u32 = 4169726490;
    }
    impl crate::Serializable for PrivacyValueDisallowContacts {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for PrivacyValueDisallowContacts {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(PrivacyValueDisallowContacts {})
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueDisallowContacts {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueDisallowContacts => {
                    Ok(PrivacyValueDisallowContacts {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrivacyValueDisallowUsers {
        pub users: Vec<i64>,
    }
    impl crate::Identifiable for PrivacyValueDisallowUsers {
        const CONSTRUCTOR_ID: u32 = 3831632193;
    }
    impl crate::Serializable for PrivacyValueDisallowUsers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.users.serialize(buf);
        }
    }
    impl crate::Deserializable for PrivacyValueDisallowUsers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let users = Vec::<i64>::deserialize(buf)?;
            Ok(PrivacyValueDisallowUsers { users })
        }
    }
    impl TryFrom<crate::enums::PrivacyRule> for PrivacyValueDisallowUsers {
        type Error = ();
        fn try_from(x: crate::enums::PrivacyRule) -> Result<Self, Self::Error> {
            match x {
                crate::enums::PrivacyRule::PrivacyValueDisallowUsers(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReceivedNotifyMessage {
        pub id: i32,
        pub flags: i32,
    }
    impl crate::Identifiable for ReceivedNotifyMessage {
        const CONSTRUCTOR_ID: u32 = 2743383929;
    }
    impl crate::Serializable for ReceivedNotifyMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.flags.serialize(buf);
        }
    }
    impl crate::Deserializable for ReceivedNotifyMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            let flags = i32::deserialize(buf)?;
            Ok(ReceivedNotifyMessage { id, flags })
        }
    }
    impl From<crate::enums::ReceivedNotifyMessage> for ReceivedNotifyMessage {
        fn from(x: crate::enums::ReceivedNotifyMessage) -> Self {
            match x {
                crate::enums::ReceivedNotifyMessage::Message(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecentMeUrlChat {
        pub url: String,
        pub chat_id: i64,
    }
    impl crate::Identifiable for RecentMeUrlChat {
        const CONSTRUCTOR_ID: u32 = 3000660434;
    }
    impl crate::Serializable for RecentMeUrlChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for RecentMeUrlChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let chat_id = i64::deserialize(buf)?;
            Ok(RecentMeUrlChat { url, chat_id })
        }
    }
    impl TryFrom<crate::enums::RecentMeUrl> for RecentMeUrlChat {
        type Error = ();
        fn try_from(x: crate::enums::RecentMeUrl) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RecentMeUrl::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecentMeUrlChatInvite {
        pub url: String,
        pub chat_invite: crate::enums::ChatInvite,
    }
    impl crate::Identifiable for RecentMeUrlChatInvite {
        const CONSTRUCTOR_ID: u32 = 3947431965;
    }
    impl crate::Serializable for RecentMeUrlChatInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.chat_invite.serialize(buf);
        }
    }
    impl crate::Deserializable for RecentMeUrlChatInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let chat_invite = crate::enums::ChatInvite::deserialize(buf)?;
            Ok(RecentMeUrlChatInvite { url, chat_invite })
        }
    }
    impl TryFrom<crate::enums::RecentMeUrl> for RecentMeUrlChatInvite {
        type Error = ();
        fn try_from(x: crate::enums::RecentMeUrl) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RecentMeUrl::ChatInvite(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecentMeUrlStickerSet {
        pub url: String,
        pub set: crate::enums::StickerSetCovered,
    }
    impl crate::Identifiable for RecentMeUrlStickerSet {
        const CONSTRUCTOR_ID: u32 = 3154794460;
    }
    impl crate::Serializable for RecentMeUrlStickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.set.serialize(buf);
        }
    }
    impl crate::Deserializable for RecentMeUrlStickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let set = crate::enums::StickerSetCovered::deserialize(buf)?;
            Ok(RecentMeUrlStickerSet { url, set })
        }
    }
    impl TryFrom<crate::enums::RecentMeUrl> for RecentMeUrlStickerSet {
        type Error = ();
        fn try_from(x: crate::enums::RecentMeUrl) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RecentMeUrl::StickerSet(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecentMeUrlUnknown {
        pub url: String,
    }
    impl crate::Identifiable for RecentMeUrlUnknown {
        const CONSTRUCTOR_ID: u32 = 1189204285;
    }
    impl crate::Serializable for RecentMeUrlUnknown {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for RecentMeUrlUnknown {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            Ok(RecentMeUrlUnknown { url })
        }
    }
    impl TryFrom<crate::enums::RecentMeUrl> for RecentMeUrlUnknown {
        type Error = ();
        fn try_from(x: crate::enums::RecentMeUrl) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RecentMeUrl::Unknown(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecentMeUrlUser {
        pub url: String,
        pub user_id: i64,
    }
    impl crate::Identifiable for RecentMeUrlUser {
        const CONSTRUCTOR_ID: u32 = 3106671074;
    }
    impl crate::Serializable for RecentMeUrlUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.user_id.serialize(buf);
        }
    }
    impl crate::Deserializable for RecentMeUrlUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            Ok(RecentMeUrlUser { url, user_id })
        }
    }
    impl TryFrom<crate::enums::RecentMeUrl> for RecentMeUrlUser {
        type Error = ();
        fn try_from(x: crate::enums::RecentMeUrl) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RecentMeUrl::User(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReplyInlineMarkup {
        pub rows: Vec<crate::enums::KeyboardButtonRow>,
    }
    impl crate::Identifiable for ReplyInlineMarkup {
        const CONSTRUCTOR_ID: u32 = 1218642516;
    }
    impl crate::Serializable for ReplyInlineMarkup {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.rows.serialize(buf);
        }
    }
    impl crate::Deserializable for ReplyInlineMarkup {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let rows = Vec::<crate::enums::KeyboardButtonRow>::deserialize(buf)?;
            Ok(ReplyInlineMarkup { rows })
        }
    }
    impl TryFrom<crate::enums::ReplyMarkup> for ReplyInlineMarkup {
        type Error = ();
        fn try_from(x: crate::enums::ReplyMarkup) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReplyMarkup::ReplyInlineMarkup(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReplyKeyboardForceReply {
        pub single_use: bool,
        pub selective: bool,
        pub placeholder: Option<String>,
    }
    impl crate::Identifiable for ReplyKeyboardForceReply {
        const CONSTRUCTOR_ID: u32 = 2259946248;
    }
    impl crate::Serializable for ReplyKeyboardForceReply {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.single_use { 2 } else { 0 }
                | if self.selective { 4 } else { 0 }
                | if self.placeholder.is_some() { 8 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.placeholder {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ReplyKeyboardForceReply {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let single_use = (flags & 2) != 0;
            let selective = (flags & 4) != 0;
            let placeholder = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(ReplyKeyboardForceReply {
                single_use,
                selective,
                placeholder,
            })
        }
    }
    impl TryFrom<crate::enums::ReplyMarkup> for ReplyKeyboardForceReply {
        type Error = ();
        fn try_from(x: crate::enums::ReplyMarkup) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReplyMarkup::ReplyKeyboardForceReply(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReplyKeyboardHide {
        pub selective: bool,
    }
    impl crate::Identifiable for ReplyKeyboardHide {
        const CONSTRUCTOR_ID: u32 = 2688441221;
    }
    impl crate::Serializable for ReplyKeyboardHide {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.selective { 4 } else { 0 }).serialize(buf);
        }
    }
    impl crate::Deserializable for ReplyKeyboardHide {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let selective = (flags & 4) != 0;
            Ok(ReplyKeyboardHide { selective })
        }
    }
    impl TryFrom<crate::enums::ReplyMarkup> for ReplyKeyboardHide {
        type Error = ();
        fn try_from(x: crate::enums::ReplyMarkup) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReplyMarkup::ReplyKeyboardHide(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReplyKeyboardMarkup {
        pub resize: bool,
        pub single_use: bool,
        pub selective: bool,
        pub rows: Vec<crate::enums::KeyboardButtonRow>,
        pub placeholder: Option<String>,
    }
    impl crate::Identifiable for ReplyKeyboardMarkup {
        const CONSTRUCTOR_ID: u32 = 2245892561;
    }
    impl crate::Serializable for ReplyKeyboardMarkup {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.resize { 1 } else { 0 }
                | if self.single_use { 2 } else { 0 }
                | if self.selective { 4 } else { 0 }
                | if self.placeholder.is_some() { 8 } else { 0 })
            .serialize(buf);
            self.rows.serialize(buf);
            if let Some(ref x) = self.placeholder {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ReplyKeyboardMarkup {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let resize = (flags & 1) != 0;
            let single_use = (flags & 2) != 0;
            let selective = (flags & 4) != 0;
            let rows = Vec::<crate::enums::KeyboardButtonRow>::deserialize(buf)?;
            let placeholder = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(ReplyKeyboardMarkup {
                resize,
                single_use,
                selective,
                rows,
                placeholder,
            })
        }
    }
    impl TryFrom<crate::enums::ReplyMarkup> for ReplyKeyboardMarkup {
        type Error = ();
        fn try_from(x: crate::enums::ReplyMarkup) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ReplyMarkup::ReplyKeyboardMarkup(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ResPq {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub pq: Vec<u8>,
        pub server_public_key_fingerprints: Vec<i64>,
    }
    impl crate::Identifiable for ResPq {
        const CONSTRUCTOR_ID: u32 = 85337187;
    }
    impl crate::Serializable for ResPq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.pq.serialize(buf);
            self.server_public_key_fingerprints.serialize(buf);
        }
    }
    impl crate::Deserializable for ResPq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let pq = Vec::<u8>::deserialize(buf)?;
            let server_public_key_fingerprints = Vec::<i64>::deserialize(buf)?;
            Ok(ResPq {
                nonce,
                server_nonce,
                pq,
                server_public_key_fingerprints,
            })
        }
    }
    impl From<crate::enums::ResPq> for ResPq {
        fn from(x: crate::enums::ResPq) -> Self {
            match x {
                crate::enums::ResPq::Pq(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RestrictionReason {
        pub platform: String,
        pub reason: String,
        pub text: String,
    }
    impl crate::Identifiable for RestrictionReason {
        const CONSTRUCTOR_ID: u32 = 3497176244;
    }
    impl crate::Serializable for RestrictionReason {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.platform.serialize(buf);
            self.reason.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for RestrictionReason {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let platform = String::deserialize(buf)?;
            let reason = String::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(RestrictionReason {
                platform,
                reason,
                text,
            })
        }
    }
    impl From<crate::enums::RestrictionReason> for RestrictionReason {
        fn from(x: crate::enums::RestrictionReason) -> Self {
            match x {
                crate::enums::RestrictionReason::Reason(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RpcAnswerDropped {
        pub msg_id: i64,
        pub seq_no: i32,
        pub bytes: i32,
    }
    impl crate::Identifiable for RpcAnswerDropped {
        const CONSTRUCTOR_ID: u32 = 2755319991;
    }
    impl crate::Serializable for RpcAnswerDropped {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_id.serialize(buf);
            self.seq_no.serialize(buf);
            self.bytes.serialize(buf);
        }
    }
    impl crate::Deserializable for RpcAnswerDropped {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_id = i64::deserialize(buf)?;
            let seq_no = i32::deserialize(buf)?;
            let bytes = i32::deserialize(buf)?;
            Ok(RpcAnswerDropped {
                msg_id,
                seq_no,
                bytes,
            })
        }
    }
    impl TryFrom<crate::enums::RpcDropAnswer> for RpcAnswerDropped {
        type Error = ();
        fn try_from(x: crate::enums::RpcDropAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RpcDropAnswer::RpcAnswerDropped(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RpcAnswerDroppedRunning {}
    impl crate::Identifiable for RpcAnswerDroppedRunning {
        const CONSTRUCTOR_ID: u32 = 3447252358;
    }
    impl crate::Serializable for RpcAnswerDroppedRunning {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for RpcAnswerDroppedRunning {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(RpcAnswerDroppedRunning {})
        }
    }
    impl TryFrom<crate::enums::RpcDropAnswer> for RpcAnswerDroppedRunning {
        type Error = ();
        fn try_from(x: crate::enums::RpcDropAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RpcDropAnswer::RpcAnswerDroppedRunning => {
                    Ok(RpcAnswerDroppedRunning {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RpcAnswerUnknown {}
    impl crate::Identifiable for RpcAnswerUnknown {
        const CONSTRUCTOR_ID: u32 = 1579864942;
    }
    impl crate::Serializable for RpcAnswerUnknown {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for RpcAnswerUnknown {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(RpcAnswerUnknown {})
        }
    }
    impl TryFrom<crate::enums::RpcDropAnswer> for RpcAnswerUnknown {
        type Error = ();
        fn try_from(x: crate::enums::RpcDropAnswer) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RpcDropAnswer::RpcAnswerUnknown => Ok(RpcAnswerUnknown {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RpcError {
        pub error_code: i32,
        pub error_message: String,
    }
    impl crate::Identifiable for RpcError {
        const CONSTRUCTOR_ID: u32 = 558156313;
    }
    impl crate::Serializable for RpcError {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.error_code.serialize(buf);
            self.error_message.serialize(buf);
        }
    }
    impl crate::Deserializable for RpcError {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let error_code = i32::deserialize(buf)?;
            let error_message = String::deserialize(buf)?;
            Ok(RpcError {
                error_code,
                error_message,
            })
        }
    }
    impl From<crate::enums::RpcError> for RpcError {
        fn from(x: crate::enums::RpcError) -> Self {
            match x {
                crate::enums::RpcError::Error(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SavedPhoneContact {
        pub phone: String,
        pub first_name: String,
        pub last_name: String,
        pub date: i32,
    }
    impl crate::Identifiable for SavedPhoneContact {
        const CONSTRUCTOR_ID: u32 = 289586518;
    }
    impl crate::Serializable for SavedPhoneContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for SavedPhoneContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone = String::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(SavedPhoneContact {
                phone,
                first_name,
                last_name,
                date,
            })
        }
    }
    impl From<crate::enums::SavedContact> for SavedPhoneContact {
        fn from(x: crate::enums::SavedContact) -> Self {
            match x {
                crate::enums::SavedContact::SavedPhoneContact(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SearchResultPosition {
        pub msg_id: i32,
        pub date: i32,
        pub offset: i32,
    }
    impl crate::Identifiable for SearchResultPosition {
        const CONSTRUCTOR_ID: u32 = 2137295719;
    }
    impl crate::Serializable for SearchResultPosition {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.msg_id.serialize(buf);
            self.date.serialize(buf);
            self.offset.serialize(buf);
        }
    }
    impl crate::Deserializable for SearchResultPosition {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let msg_id = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let offset = i32::deserialize(buf)?;
            Ok(SearchResultPosition {
                msg_id,
                date,
                offset,
            })
        }
    }
    impl From<crate::enums::SearchResultsPosition> for SearchResultPosition {
        fn from(x: crate::enums::SearchResultsPosition) -> Self {
            match x {
                crate::enums::SearchResultsPosition::SearchResultPosition(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SearchResultsCalendarPeriod {
        pub date: i32,
        pub min_msg_id: i32,
        pub max_msg_id: i32,
        pub count: i32,
    }
    impl crate::Identifiable for SearchResultsCalendarPeriod {
        const CONSTRUCTOR_ID: u32 = 3383776159;
    }
    impl crate::Serializable for SearchResultsCalendarPeriod {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.date.serialize(buf);
            self.min_msg_id.serialize(buf);
            self.max_msg_id.serialize(buf);
            self.count.serialize(buf);
        }
    }
    impl crate::Deserializable for SearchResultsCalendarPeriod {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let date = i32::deserialize(buf)?;
            let min_msg_id = i32::deserialize(buf)?;
            let max_msg_id = i32::deserialize(buf)?;
            let count = i32::deserialize(buf)?;
            Ok(SearchResultsCalendarPeriod {
                date,
                min_msg_id,
                max_msg_id,
                count,
            })
        }
    }
    impl From<crate::enums::SearchResultsCalendarPeriod> for SearchResultsCalendarPeriod {
        fn from(x: crate::enums::SearchResultsCalendarPeriod) -> Self {
            match x {
                crate::enums::SearchResultsCalendarPeriod::Period(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureCredentialsEncrypted {
        pub data: Vec<u8>,
        pub hash: Vec<u8>,
        pub secret: Vec<u8>,
    }
    impl crate::Identifiable for SecureCredentialsEncrypted {
        const CONSTRUCTOR_ID: u32 = 871426631;
    }
    impl crate::Serializable for SecureCredentialsEncrypted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.data.serialize(buf);
            self.hash.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureCredentialsEncrypted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let data = Vec::<u8>::deserialize(buf)?;
            let hash = Vec::<u8>::deserialize(buf)?;
            let secret = Vec::<u8>::deserialize(buf)?;
            Ok(SecureCredentialsEncrypted { data, hash, secret })
        }
    }
    impl From<crate::enums::SecureCredentialsEncrypted> for SecureCredentialsEncrypted {
        fn from(x: crate::enums::SecureCredentialsEncrypted) -> Self {
            match x {
                crate::enums::SecureCredentialsEncrypted::Encrypted(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureData {
        pub data: Vec<u8>,
        pub data_hash: Vec<u8>,
        pub secret: Vec<u8>,
    }
    impl crate::Identifiable for SecureData {
        const CONSTRUCTOR_ID: u32 = 2330640067;
    }
    impl crate::Serializable for SecureData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.data.serialize(buf);
            self.data_hash.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let data = Vec::<u8>::deserialize(buf)?;
            let data_hash = Vec::<u8>::deserialize(buf)?;
            let secret = Vec::<u8>::deserialize(buf)?;
            Ok(SecureData {
                data,
                data_hash,
                secret,
            })
        }
    }
    impl From<crate::enums::SecureData> for SecureData {
        fn from(x: crate::enums::SecureData) -> Self {
            match x {
                crate::enums::SecureData::Data(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureFile {
        pub id: i64,
        pub access_hash: i64,
        pub size: i32,
        pub dc_id: i32,
        pub date: i32,
        pub file_hash: Vec<u8>,
        pub secret: Vec<u8>,
    }
    impl crate::Identifiable for SecureFile {
        const CONSTRUCTOR_ID: u32 = 3760683618;
    }
    impl crate::Serializable for SecureFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.size.serialize(buf);
            self.dc_id.serialize(buf);
            self.date.serialize(buf);
            self.file_hash.serialize(buf);
            self.secret.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let dc_id = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let secret = Vec::<u8>::deserialize(buf)?;
            Ok(SecureFile {
                id,
                access_hash,
                size,
                dc_id,
                date,
                file_hash,
                secret,
            })
        }
    }
    impl TryFrom<crate::enums::SecureFile> for SecureFile {
        type Error = ();
        fn try_from(x: crate::enums::SecureFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureFile::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureFileEmpty {}
    impl crate::Identifiable for SecureFileEmpty {
        const CONSTRUCTOR_ID: u32 = 1679398724;
    }
    impl crate::Serializable for SecureFileEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureFileEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureFileEmpty {})
        }
    }
    impl TryFrom<crate::enums::SecureFile> for SecureFileEmpty {
        type Error = ();
        fn try_from(x: crate::enums::SecureFile) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureFile::Empty => Ok(SecureFileEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000 {
        pub salt: Vec<u8>,
    }
    impl crate::Identifiable for SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000 {
        const CONSTRUCTOR_ID: u32 = 3153255840;
    }
    impl crate::Serializable for SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000 {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.salt.serialize(buf);
        }
    }
    impl crate::Deserializable for SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000 {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let salt = Vec::<u8>::deserialize(buf)?;
            Ok(SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000 { salt })
        }
    }
    impl TryFrom<crate::enums::SecurePasswordKdfAlgo>
        for SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000
    {
        type Error = ();
        fn try_from(x: crate::enums::SecurePasswordKdfAlgo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecurePasswordKdfAlgo::Pbkdf2Hmacsha512iter100000(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecurePasswordKdfAlgoSha512 {
        pub salt: Vec<u8>,
    }
    impl crate::Identifiable for SecurePasswordKdfAlgoSha512 {
        const CONSTRUCTOR_ID: u32 = 2252807570;
    }
    impl crate::Serializable for SecurePasswordKdfAlgoSha512 {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.salt.serialize(buf);
        }
    }
    impl crate::Deserializable for SecurePasswordKdfAlgoSha512 {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let salt = Vec::<u8>::deserialize(buf)?;
            Ok(SecurePasswordKdfAlgoSha512 { salt })
        }
    }
    impl TryFrom<crate::enums::SecurePasswordKdfAlgo> for SecurePasswordKdfAlgoSha512 {
        type Error = ();
        fn try_from(x: crate::enums::SecurePasswordKdfAlgo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecurePasswordKdfAlgo::Sha512(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecurePasswordKdfAlgoUnknown {}
    impl crate::Identifiable for SecurePasswordKdfAlgoUnknown {
        const CONSTRUCTOR_ID: u32 = 4883767;
    }
    impl crate::Serializable for SecurePasswordKdfAlgoUnknown {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecurePasswordKdfAlgoUnknown {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecurePasswordKdfAlgoUnknown {})
        }
    }
    impl TryFrom<crate::enums::SecurePasswordKdfAlgo> for SecurePasswordKdfAlgoUnknown {
        type Error = ();
        fn try_from(x: crate::enums::SecurePasswordKdfAlgo) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecurePasswordKdfAlgo::Unknown => Ok(SecurePasswordKdfAlgoUnknown {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecurePlainEmail {
        pub email: String,
    }
    impl crate::Identifiable for SecurePlainEmail {
        const CONSTRUCTOR_ID: u32 = 569137759;
    }
    impl crate::Serializable for SecurePlainEmail {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.email.serialize(buf);
        }
    }
    impl crate::Deserializable for SecurePlainEmail {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let email = String::deserialize(buf)?;
            Ok(SecurePlainEmail { email })
        }
    }
    impl TryFrom<crate::enums::SecurePlainData> for SecurePlainEmail {
        type Error = ();
        fn try_from(x: crate::enums::SecurePlainData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecurePlainData::SecurePlainEmail(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecurePlainPhone {
        pub phone: String,
    }
    impl crate::Identifiable for SecurePlainPhone {
        const CONSTRUCTOR_ID: u32 = 2103482845;
    }
    impl crate::Serializable for SecurePlainPhone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone.serialize(buf);
        }
    }
    impl crate::Deserializable for SecurePlainPhone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone = String::deserialize(buf)?;
            Ok(SecurePlainPhone { phone })
        }
    }
    impl TryFrom<crate::enums::SecurePlainData> for SecurePlainPhone {
        type Error = ();
        fn try_from(x: crate::enums::SecurePlainData) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecurePlainData::SecurePlainPhone(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureRequiredType {
        pub native_names: bool,
        pub selfie_required: bool,
        pub translation_required: bool,
        pub r#type: crate::enums::SecureValueType,
    }
    impl crate::Identifiable for SecureRequiredType {
        const CONSTRUCTOR_ID: u32 = 2191366618;
    }
    impl crate::Serializable for SecureRequiredType {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.native_names { 1 } else { 0 }
                | if self.selfie_required { 2 } else { 0 }
                | if self.translation_required { 4 } else { 0 })
            .serialize(buf);
            self.r#type.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureRequiredType {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let native_names = (flags & 1) != 0;
            let selfie_required = (flags & 2) != 0;
            let translation_required = (flags & 4) != 0;
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            Ok(SecureRequiredType {
                native_names,
                selfie_required,
                translation_required,
                r#type,
            })
        }
    }
    impl TryFrom<crate::enums::SecureRequiredType> for SecureRequiredType {
        type Error = ();
        fn try_from(x: crate::enums::SecureRequiredType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureRequiredType::Type(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureRequiredTypeOneOf {
        pub types: Vec<crate::enums::SecureRequiredType>,
    }
    impl crate::Identifiable for SecureRequiredTypeOneOf {
        const CONSTRUCTOR_ID: u32 = 41187252;
    }
    impl crate::Serializable for SecureRequiredTypeOneOf {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.types.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureRequiredTypeOneOf {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let types = Vec::<crate::enums::SecureRequiredType>::deserialize(buf)?;
            Ok(SecureRequiredTypeOneOf { types })
        }
    }
    impl TryFrom<crate::enums::SecureRequiredType> for SecureRequiredTypeOneOf {
        type Error = ();
        fn try_from(x: crate::enums::SecureRequiredType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureRequiredType::OneOf(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureSecretSettings {
        pub secure_algo: crate::enums::SecurePasswordKdfAlgo,
        pub secure_secret: Vec<u8>,
        pub secure_secret_id: i64,
    }
    impl crate::Identifiable for SecureSecretSettings {
        const CONSTRUCTOR_ID: u32 = 354925740;
    }
    impl crate::Serializable for SecureSecretSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.secure_algo.serialize(buf);
            self.secure_secret.serialize(buf);
            self.secure_secret_id.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureSecretSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let secure_algo = crate::enums::SecurePasswordKdfAlgo::deserialize(buf)?;
            let secure_secret = Vec::<u8>::deserialize(buf)?;
            let secure_secret_id = i64::deserialize(buf)?;
            Ok(SecureSecretSettings {
                secure_algo,
                secure_secret,
                secure_secret_id,
            })
        }
    }
    impl From<crate::enums::SecureSecretSettings> for SecureSecretSettings {
        fn from(x: crate::enums::SecureSecretSettings) -> Self {
            match x {
                crate::enums::SecureSecretSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValue {
        pub r#type: crate::enums::SecureValueType,
        pub data: Option<crate::enums::SecureData>,
        pub front_side: Option<crate::enums::SecureFile>,
        pub reverse_side: Option<crate::enums::SecureFile>,
        pub selfie: Option<crate::enums::SecureFile>,
        pub translation: Option<Vec<crate::enums::SecureFile>>,
        pub files: Option<Vec<crate::enums::SecureFile>>,
        pub plain_data: Option<crate::enums::SecurePlainData>,
        pub hash: Vec<u8>,
    }
    impl crate::Identifiable for SecureValue {
        const CONSTRUCTOR_ID: u32 = 411017418;
    }
    impl crate::Serializable for SecureValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.data.is_some() { 1 } else { 0 }
                | if self.front_side.is_some() { 2 } else { 0 }
                | if self.reverse_side.is_some() { 4 } else { 0 }
                | if self.selfie.is_some() { 8 } else { 0 }
                | if self.translation.is_some() { 64 } else { 0 }
                | if self.files.is_some() { 16 } else { 0 }
                | if self.plain_data.is_some() { 32 } else { 0 })
            .serialize(buf);
            self.r#type.serialize(buf);
            if let Some(ref x) = self.data {
                x.serialize(buf);
            }
            if let Some(ref x) = self.front_side {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reverse_side {
                x.serialize(buf);
            }
            if let Some(ref x) = self.selfie {
                x.serialize(buf);
            }
            if let Some(ref x) = self.translation {
                x.serialize(buf);
            }
            if let Some(ref x) = self.files {
                x.serialize(buf);
            }
            if let Some(ref x) = self.plain_data {
                x.serialize(buf);
            }
            self.hash.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let data = if (flags & 1) != 0 {
                Some(crate::enums::SecureData::deserialize(buf)?)
            } else {
                None
            };
            let front_side = if (flags & 2) != 0 {
                Some(crate::enums::SecureFile::deserialize(buf)?)
            } else {
                None
            };
            let reverse_side = if (flags & 4) != 0 {
                Some(crate::enums::SecureFile::deserialize(buf)?)
            } else {
                None
            };
            let selfie = if (flags & 8) != 0 {
                Some(crate::enums::SecureFile::deserialize(buf)?)
            } else {
                None
            };
            let translation = if (flags & 64) != 0 {
                Some(Vec::<crate::enums::SecureFile>::deserialize(buf)?)
            } else {
                None
            };
            let files = if (flags & 16) != 0 {
                Some(Vec::<crate::enums::SecureFile>::deserialize(buf)?)
            } else {
                None
            };
            let plain_data = if (flags & 32) != 0 {
                Some(crate::enums::SecurePlainData::deserialize(buf)?)
            } else {
                None
            };
            let hash = Vec::<u8>::deserialize(buf)?;
            Ok(SecureValue {
                r#type,
                data,
                front_side,
                reverse_side,
                selfie,
                translation,
                files,
                plain_data,
                hash,
            })
        }
    }
    impl From<crate::enums::SecureValue> for SecureValue {
        fn from(x: crate::enums::SecureValue) -> Self {
            match x {
                crate::enums::SecureValue::Value(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueError {
        pub r#type: crate::enums::SecureValueType,
        pub hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueError {
        const CONSTRUCTOR_ID: u32 = 2258466191;
    }
    impl crate::Serializable for SecureValueError {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueError {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueError { r#type, hash, text })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueError {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::Error(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorData {
        pub r#type: crate::enums::SecureValueType,
        pub data_hash: Vec<u8>,
        pub field: String,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorData {
        const CONSTRUCTOR_ID: u32 = 3903065049;
    }
    impl crate::Serializable for SecureValueErrorData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.data_hash.serialize(buf);
            self.field.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let data_hash = Vec::<u8>::deserialize(buf)?;
            let field = String::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorData {
                r#type,
                data_hash,
                field,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorData {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::Data(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorFile {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorFile {
        const CONSTRUCTOR_ID: u32 = 2054162547;
    }
    impl crate::Serializable for SecureValueErrorFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorFile {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorFile {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::File(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorFiles {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<Vec<u8>>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorFiles {
        const CONSTRUCTOR_ID: u32 = 1717706985;
    }
    impl crate::Serializable for SecureValueErrorFiles {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorFiles {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<Vec<u8>>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorFiles {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorFiles {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::Files(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorFrontSide {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorFrontSide {
        const CONSTRUCTOR_ID: u32 = 12467706;
    }
    impl crate::Serializable for SecureValueErrorFrontSide {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorFrontSide {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorFrontSide {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorFrontSide {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::FrontSide(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorReverseSide {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorReverseSide {
        const CONSTRUCTOR_ID: u32 = 2257201829;
    }
    impl crate::Serializable for SecureValueErrorReverseSide {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorReverseSide {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorReverseSide {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorReverseSide {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::ReverseSide(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorSelfie {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorSelfie {
        const CONSTRUCTOR_ID: u32 = 3845639894;
    }
    impl crate::Serializable for SecureValueErrorSelfie {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorSelfie {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorSelfie {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorSelfie {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::Selfie(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorTranslationFile {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<u8>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorTranslationFile {
        const CONSTRUCTOR_ID: u32 = 2702460784;
    }
    impl crate::Serializable for SecureValueErrorTranslationFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorTranslationFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<u8>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorTranslationFile {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorTranslationFile {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::TranslationFile(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueErrorTranslationFiles {
        pub r#type: crate::enums::SecureValueType,
        pub file_hash: Vec<Vec<u8>>,
        pub text: String,
    }
    impl crate::Identifiable for SecureValueErrorTranslationFiles {
        const CONSTRUCTOR_ID: u32 = 878931416;
    }
    impl crate::Serializable for SecureValueErrorTranslationFiles {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.file_hash.serialize(buf);
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueErrorTranslationFiles {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let file_hash = Vec::<Vec<u8>>::deserialize(buf)?;
            let text = String::deserialize(buf)?;
            Ok(SecureValueErrorTranslationFiles {
                r#type,
                file_hash,
                text,
            })
        }
    }
    impl TryFrom<crate::enums::SecureValueError> for SecureValueErrorTranslationFiles {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueError) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueError::TranslationFiles(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueHash {
        pub r#type: crate::enums::SecureValueType,
        pub hash: Vec<u8>,
    }
    impl crate::Identifiable for SecureValueHash {
        const CONSTRUCTOR_ID: u32 = 3978218928;
    }
    impl crate::Serializable for SecureValueHash {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.r#type.serialize(buf);
            self.hash.serialize(buf);
        }
    }
    impl crate::Deserializable for SecureValueHash {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let r#type = crate::enums::SecureValueType::deserialize(buf)?;
            let hash = Vec::<u8>::deserialize(buf)?;
            Ok(SecureValueHash { r#type, hash })
        }
    }
    impl From<crate::enums::SecureValueHash> for SecureValueHash {
        fn from(x: crate::enums::SecureValueHash) -> Self {
            match x {
                crate::enums::SecureValueHash::Hash(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeAddress {}
    impl crate::Identifiable for SecureValueTypeAddress {
        const CONSTRUCTOR_ID: u32 = 3420659238;
    }
    impl crate::Serializable for SecureValueTypeAddress {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeAddress {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeAddress {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeAddress {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::Address => Ok(SecureValueTypeAddress {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeBankStatement {}
    impl crate::Identifiable for SecureValueTypeBankStatement {
        const CONSTRUCTOR_ID: u32 = 2299755533;
    }
    impl crate::Serializable for SecureValueTypeBankStatement {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeBankStatement {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeBankStatement {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeBankStatement {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::BankStatement => Ok(SecureValueTypeBankStatement {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeDriverLicense {}
    impl crate::Identifiable for SecureValueTypeDriverLicense {
        const CONSTRUCTOR_ID: u32 = 115615172;
    }
    impl crate::Serializable for SecureValueTypeDriverLicense {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeDriverLicense {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeDriverLicense {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeDriverLicense {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::DriverLicense => Ok(SecureValueTypeDriverLicense {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeEmail {}
    impl crate::Identifiable for SecureValueTypeEmail {
        const CONSTRUCTOR_ID: u32 = 2386339822;
    }
    impl crate::Serializable for SecureValueTypeEmail {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeEmail {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeEmail {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeEmail {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::Email => Ok(SecureValueTypeEmail {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeIdentityCard {}
    impl crate::Identifiable for SecureValueTypeIdentityCard {
        const CONSTRUCTOR_ID: u32 = 2698015819;
    }
    impl crate::Serializable for SecureValueTypeIdentityCard {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeIdentityCard {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeIdentityCard {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeIdentityCard {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::IdentityCard => Ok(SecureValueTypeIdentityCard {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeInternalPassport {}
    impl crate::Identifiable for SecureValueTypeInternalPassport {
        const CONSTRUCTOR_ID: u32 = 2577698595;
    }
    impl crate::Serializable for SecureValueTypeInternalPassport {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeInternalPassport {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeInternalPassport {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeInternalPassport {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::InternalPassport => {
                    Ok(SecureValueTypeInternalPassport {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypePassport {}
    impl crate::Identifiable for SecureValueTypePassport {
        const CONSTRUCTOR_ID: u32 = 1034709504;
    }
    impl crate::Serializable for SecureValueTypePassport {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypePassport {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypePassport {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypePassport {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::Passport => Ok(SecureValueTypePassport {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypePassportRegistration {}
    impl crate::Identifiable for SecureValueTypePassportRegistration {
        const CONSTRUCTOR_ID: u32 = 2581823594;
    }
    impl crate::Serializable for SecureValueTypePassportRegistration {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypePassportRegistration {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypePassportRegistration {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypePassportRegistration {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::PassportRegistration => {
                    Ok(SecureValueTypePassportRegistration {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypePersonalDetails {}
    impl crate::Identifiable for SecureValueTypePersonalDetails {
        const CONSTRUCTOR_ID: u32 = 2636808675;
    }
    impl crate::Serializable for SecureValueTypePersonalDetails {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypePersonalDetails {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypePersonalDetails {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypePersonalDetails {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::PersonalDetails => {
                    Ok(SecureValueTypePersonalDetails {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypePhone {}
    impl crate::Identifiable for SecureValueTypePhone {
        const CONSTRUCTOR_ID: u32 = 3005262555;
    }
    impl crate::Serializable for SecureValueTypePhone {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypePhone {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypePhone {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypePhone {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::Phone => Ok(SecureValueTypePhone {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeRentalAgreement {}
    impl crate::Identifiable for SecureValueTypeRentalAgreement {
        const CONSTRUCTOR_ID: u32 = 2340959368;
    }
    impl crate::Serializable for SecureValueTypeRentalAgreement {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeRentalAgreement {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeRentalAgreement {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeRentalAgreement {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::RentalAgreement => {
                    Ok(SecureValueTypeRentalAgreement {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeTemporaryRegistration {}
    impl crate::Identifiable for SecureValueTypeTemporaryRegistration {
        const CONSTRUCTOR_ID: u32 = 3926060083;
    }
    impl crate::Serializable for SecureValueTypeTemporaryRegistration {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeTemporaryRegistration {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeTemporaryRegistration {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeTemporaryRegistration {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::TemporaryRegistration => {
                    Ok(SecureValueTypeTemporaryRegistration {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SecureValueTypeUtilityBill {}
    impl crate::Identifiable for SecureValueTypeUtilityBill {
        const CONSTRUCTOR_ID: u32 = 4231435598;
    }
    impl crate::Serializable for SecureValueTypeUtilityBill {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SecureValueTypeUtilityBill {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SecureValueTypeUtilityBill {})
        }
    }
    impl TryFrom<crate::enums::SecureValueType> for SecureValueTypeUtilityBill {
        type Error = ();
        fn try_from(x: crate::enums::SecureValueType) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SecureValueType::UtilityBill => Ok(SecureValueTypeUtilityBill {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageCancelAction {}
    impl crate::Identifiable for SendMessageCancelAction {
        const CONSTRUCTOR_ID: u32 = 4250847477;
    }
    impl crate::Serializable for SendMessageCancelAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageCancelAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageCancelAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageCancelAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageCancelAction => {
                    Ok(SendMessageCancelAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageChooseContactAction {}
    impl crate::Identifiable for SendMessageChooseContactAction {
        const CONSTRUCTOR_ID: u32 = 1653390447;
    }
    impl crate::Serializable for SendMessageChooseContactAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageChooseContactAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageChooseContactAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageChooseContactAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageChooseContactAction => {
                    Ok(SendMessageChooseContactAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageChooseStickerAction {}
    impl crate::Identifiable for SendMessageChooseStickerAction {
        const CONSTRUCTOR_ID: u32 = 2958739121;
    }
    impl crate::Serializable for SendMessageChooseStickerAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageChooseStickerAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageChooseStickerAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageChooseStickerAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageChooseStickerAction => {
                    Ok(SendMessageChooseStickerAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageEmojiInteraction {
        pub emoticon: String,
        pub msg_id: i32,
        pub interaction: crate::enums::DataJson,
    }
    impl crate::Identifiable for SendMessageEmojiInteraction {
        const CONSTRUCTOR_ID: u32 = 630664139;
    }
    impl crate::Serializable for SendMessageEmojiInteraction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
            self.msg_id.serialize(buf);
            self.interaction.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageEmojiInteraction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let interaction = crate::enums::DataJson::deserialize(buf)?;
            Ok(SendMessageEmojiInteraction {
                emoticon,
                msg_id,
                interaction,
            })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageEmojiInteraction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageEmojiInteraction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageEmojiInteractionSeen {
        pub emoticon: String,
    }
    impl crate::Identifiable for SendMessageEmojiInteractionSeen {
        const CONSTRUCTOR_ID: u32 = 3060109358;
    }
    impl crate::Serializable for SendMessageEmojiInteractionSeen {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageEmojiInteractionSeen {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            Ok(SendMessageEmojiInteractionSeen { emoticon })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageEmojiInteractionSeen {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageEmojiInteractionSeen(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageGamePlayAction {}
    impl crate::Identifiable for SendMessageGamePlayAction {
        const CONSTRUCTOR_ID: u32 = 3714748232;
    }
    impl crate::Serializable for SendMessageGamePlayAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageGamePlayAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageGamePlayAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageGamePlayAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageGamePlayAction => {
                    Ok(SendMessageGamePlayAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageGeoLocationAction {}
    impl crate::Identifiable for SendMessageGeoLocationAction {
        const CONSTRUCTOR_ID: u32 = 393186209;
    }
    impl crate::Serializable for SendMessageGeoLocationAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageGeoLocationAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageGeoLocationAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageGeoLocationAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageGeoLocationAction => {
                    Ok(SendMessageGeoLocationAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageHistoryImportAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageHistoryImportAction {
        const CONSTRUCTOR_ID: u32 = 3688534598;
    }
    impl crate::Serializable for SendMessageHistoryImportAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageHistoryImportAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageHistoryImportAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageHistoryImportAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageHistoryImportAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageRecordAudioAction {}
    impl crate::Identifiable for SendMessageRecordAudioAction {
        const CONSTRUCTOR_ID: u32 = 3576656887;
    }
    impl crate::Serializable for SendMessageRecordAudioAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageRecordAudioAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageRecordAudioAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageRecordAudioAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageRecordAudioAction => {
                    Ok(SendMessageRecordAudioAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageRecordRoundAction {}
    impl crate::Identifiable for SendMessageRecordRoundAction {
        const CONSTRUCTOR_ID: u32 = 2297593788;
    }
    impl crate::Serializable for SendMessageRecordRoundAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageRecordRoundAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageRecordRoundAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageRecordRoundAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageRecordRoundAction => {
                    Ok(SendMessageRecordRoundAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageRecordVideoAction {}
    impl crate::Identifiable for SendMessageRecordVideoAction {
        const CONSTRUCTOR_ID: u32 = 2710034031;
    }
    impl crate::Serializable for SendMessageRecordVideoAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageRecordVideoAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageRecordVideoAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageRecordVideoAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageRecordVideoAction => {
                    Ok(SendMessageRecordVideoAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageTypingAction {}
    impl crate::Identifiable for SendMessageTypingAction {
        const CONSTRUCTOR_ID: u32 = 381645902;
    }
    impl crate::Serializable for SendMessageTypingAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SendMessageTypingAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SendMessageTypingAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageTypingAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageTypingAction => {
                    Ok(SendMessageTypingAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageUploadAudioAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageUploadAudioAction {
        const CONSTRUCTOR_ID: u32 = 4082227115;
    }
    impl crate::Serializable for SendMessageUploadAudioAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageUploadAudioAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageUploadAudioAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageUploadAudioAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageUploadAudioAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageUploadDocumentAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageUploadDocumentAction {
        const CONSTRUCTOR_ID: u32 = 2852968932;
    }
    impl crate::Serializable for SendMessageUploadDocumentAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageUploadDocumentAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageUploadDocumentAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageUploadDocumentAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageUploadDocumentAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageUploadPhotoAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageUploadPhotoAction {
        const CONSTRUCTOR_ID: u32 = 3520285222;
    }
    impl crate::Serializable for SendMessageUploadPhotoAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageUploadPhotoAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageUploadPhotoAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageUploadPhotoAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageUploadPhotoAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageUploadRoundAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageUploadRoundAction {
        const CONSTRUCTOR_ID: u32 = 608050278;
    }
    impl crate::Serializable for SendMessageUploadRoundAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageUploadRoundAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageUploadRoundAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageUploadRoundAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageUploadRoundAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendMessageUploadVideoAction {
        pub progress: i32,
    }
    impl crate::Identifiable for SendMessageUploadVideoAction {
        const CONSTRUCTOR_ID: u32 = 3916839660;
    }
    impl crate::Serializable for SendMessageUploadVideoAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.progress.serialize(buf);
        }
    }
    impl crate::Deserializable for SendMessageUploadVideoAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let progress = i32::deserialize(buf)?;
            Ok(SendMessageUploadVideoAction { progress })
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SendMessageUploadVideoAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SendMessageUploadVideoAction(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ServerDhInnerData {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub g: i32,
        pub dh_prime: Vec<u8>,
        pub g_a: Vec<u8>,
        pub server_time: i32,
    }
    impl crate::Identifiable for ServerDhInnerData {
        const CONSTRUCTOR_ID: u32 = 3045658042;
    }
    impl crate::Serializable for ServerDhInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.g.serialize(buf);
            self.dh_prime.serialize(buf);
            self.g_a.serialize(buf);
            self.server_time.serialize(buf);
        }
    }
    impl crate::Deserializable for ServerDhInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let g = i32::deserialize(buf)?;
            let dh_prime = Vec::<u8>::deserialize(buf)?;
            let g_a = Vec::<u8>::deserialize(buf)?;
            let server_time = i32::deserialize(buf)?;
            Ok(ServerDhInnerData {
                nonce,
                server_nonce,
                g,
                dh_prime,
                g_a,
                server_time,
            })
        }
    }
    impl From<crate::enums::ServerDhInnerData> for ServerDhInnerData {
        fn from(x: crate::enums::ServerDhInnerData) -> Self {
            match x {
                crate::enums::ServerDhInnerData::Data(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ServerDhParamsFail {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub new_nonce_hash: [u8; 16],
    }
    impl crate::Identifiable for ServerDhParamsFail {
        const CONSTRUCTOR_ID: u32 = 2043348061;
    }
    impl crate::Serializable for ServerDhParamsFail {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.new_nonce_hash.serialize(buf);
        }
    }
    impl crate::Deserializable for ServerDhParamsFail {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let new_nonce_hash = <[u8; 16]>::deserialize(buf)?;
            Ok(ServerDhParamsFail {
                nonce,
                server_nonce,
                new_nonce_hash,
            })
        }
    }
    impl TryFrom<crate::enums::ServerDhParams> for ServerDhParamsFail {
        type Error = ();
        fn try_from(x: crate::enums::ServerDhParams) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ServerDhParams::Fail(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ServerDhParamsOk {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub encrypted_answer: Vec<u8>,
    }
    impl crate::Identifiable for ServerDhParamsOk {
        const CONSTRUCTOR_ID: u32 = 3504867164;
    }
    impl crate::Serializable for ServerDhParamsOk {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.encrypted_answer.serialize(buf);
        }
    }
    impl crate::Deserializable for ServerDhParamsOk {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let nonce = <[u8; 16]>::deserialize(buf)?;
            let server_nonce = <[u8; 16]>::deserialize(buf)?;
            let encrypted_answer = Vec::<u8>::deserialize(buf)?;
            Ok(ServerDhParamsOk {
                nonce,
                server_nonce,
                encrypted_answer,
            })
        }
    }
    impl TryFrom<crate::enums::ServerDhParams> for ServerDhParamsOk {
        type Error = ();
        fn try_from(x: crate::enums::ServerDhParams) -> Result<Self, Self::Error> {
            match x {
                crate::enums::ServerDhParams::Ok(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShippingOption {
        pub id: String,
        pub title: String,
        pub prices: Vec<crate::enums::LabeledPrice>,
    }
    impl crate::Identifiable for ShippingOption {
        const CONSTRUCTOR_ID: u32 = 3055631583;
    }
    impl crate::Serializable for ShippingOption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.title.serialize(buf);
            self.prices.serialize(buf);
        }
    }
    impl crate::Deserializable for ShippingOption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = String::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let prices = Vec::<crate::enums::LabeledPrice>::deserialize(buf)?;
            Ok(ShippingOption { id, title, prices })
        }
    }
    impl From<crate::enums::ShippingOption> for ShippingOption {
        fn from(x: crate::enums::ShippingOption) -> Self {
            match x {
                crate::enums::ShippingOption::Option(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpeakingInGroupCallAction {}
    impl crate::Identifiable for SpeakingInGroupCallAction {
        const CONSTRUCTOR_ID: u32 = 3643548293;
    }
    impl crate::Serializable for SpeakingInGroupCallAction {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for SpeakingInGroupCallAction {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(SpeakingInGroupCallAction {})
        }
    }
    impl TryFrom<crate::enums::SendMessageAction> for SpeakingInGroupCallAction {
        type Error = ();
        fn try_from(x: crate::enums::SendMessageAction) -> Result<Self, Self::Error> {
            match x {
                crate::enums::SendMessageAction::SpeakingInGroupCallAction => {
                    Ok(SpeakingInGroupCallAction {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SponsoredMessage {
        pub random_id: Vec<u8>,
        pub from_id: crate::enums::Peer,
        pub channel_post: Option<i32>,
        pub start_param: Option<String>,
        pub message: String,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
    }
    impl crate::Identifiable for SponsoredMessage {
        const CONSTRUCTOR_ID: u32 = 3511804314;
    }
    impl crate::Serializable for SponsoredMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.channel_post.is_some() { 4 } else { 0 }
                | if self.start_param.is_some() { 1 } else { 0 }
                | if self.entities.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.random_id.serialize(buf);
            self.from_id.serialize(buf);
            if let Some(ref x) = self.channel_post {
                x.serialize(buf);
            }
            if let Some(ref x) = self.start_param {
                x.serialize(buf);
            }
            self.message.serialize(buf);
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for SponsoredMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let random_id = Vec::<u8>::deserialize(buf)?;
            let from_id = crate::enums::Peer::deserialize(buf)?;
            let channel_post = if (flags & 4) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let start_param = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let message = String::deserialize(buf)?;
            let entities = if (flags & 2) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            Ok(SponsoredMessage {
                random_id,
                from_id,
                channel_post,
                start_param,
                message,
                entities,
            })
        }
    }
    impl From<crate::enums::SponsoredMessage> for SponsoredMessage {
        fn from(x: crate::enums::SponsoredMessage) -> Self {
            match x {
                crate::enums::SponsoredMessage::Message(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsAbsValueAndPrev {
        pub current: f64,
        pub previous: f64,
    }
    impl crate::Identifiable for StatsAbsValueAndPrev {
        const CONSTRUCTOR_ID: u32 = 3410210014;
    }
    impl crate::Serializable for StatsAbsValueAndPrev {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.current.serialize(buf);
            self.previous.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsAbsValueAndPrev {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let current = f64::deserialize(buf)?;
            let previous = f64::deserialize(buf)?;
            Ok(StatsAbsValueAndPrev { current, previous })
        }
    }
    impl From<crate::enums::StatsAbsValueAndPrev> for StatsAbsValueAndPrev {
        fn from(x: crate::enums::StatsAbsValueAndPrev) -> Self {
            match x {
                crate::enums::StatsAbsValueAndPrev::Prev(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsDateRangeDays {
        pub min_date: i32,
        pub max_date: i32,
    }
    impl crate::Identifiable for StatsDateRangeDays {
        const CONSTRUCTOR_ID: u32 = 3057118639;
    }
    impl crate::Serializable for StatsDateRangeDays {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.min_date.serialize(buf);
            self.max_date.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsDateRangeDays {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let min_date = i32::deserialize(buf)?;
            let max_date = i32::deserialize(buf)?;
            Ok(StatsDateRangeDays { min_date, max_date })
        }
    }
    impl From<crate::enums::StatsDateRangeDays> for StatsDateRangeDays {
        fn from(x: crate::enums::StatsDateRangeDays) -> Self {
            match x {
                crate::enums::StatsDateRangeDays::Days(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGraph {
        pub json: crate::enums::DataJson,
        pub zoom_token: Option<String>,
    }
    impl crate::Identifiable for StatsGraph {
        const CONSTRUCTOR_ID: u32 = 2393138358;
    }
    impl crate::Serializable for StatsGraph {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.zoom_token.is_some() { 1 } else { 0 }).serialize(buf);
            self.json.serialize(buf);
            if let Some(ref x) = self.zoom_token {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for StatsGraph {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let json = crate::enums::DataJson::deserialize(buf)?;
            let zoom_token = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(StatsGraph { json, zoom_token })
        }
    }
    impl TryFrom<crate::enums::StatsGraph> for StatsGraph {
        type Error = ();
        fn try_from(x: crate::enums::StatsGraph) -> Result<Self, Self::Error> {
            match x {
                crate::enums::StatsGraph::Graph(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGraphAsync {
        pub token: String,
    }
    impl crate::Identifiable for StatsGraphAsync {
        const CONSTRUCTOR_ID: u32 = 1244130093;
    }
    impl crate::Serializable for StatsGraphAsync {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.token.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsGraphAsync {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let token = String::deserialize(buf)?;
            Ok(StatsGraphAsync { token })
        }
    }
    impl TryFrom<crate::enums::StatsGraph> for StatsGraphAsync {
        type Error = ();
        fn try_from(x: crate::enums::StatsGraph) -> Result<Self, Self::Error> {
            match x {
                crate::enums::StatsGraph::Async(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGraphError {
        pub error: String,
    }
    impl crate::Identifiable for StatsGraphError {
        const CONSTRUCTOR_ID: u32 = 3202127906;
    }
    impl crate::Serializable for StatsGraphError {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.error.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsGraphError {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let error = String::deserialize(buf)?;
            Ok(StatsGraphError { error })
        }
    }
    impl TryFrom<crate::enums::StatsGraph> for StatsGraphError {
        type Error = ();
        fn try_from(x: crate::enums::StatsGraph) -> Result<Self, Self::Error> {
            match x {
                crate::enums::StatsGraph::Error(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGroupTopAdmin {
        pub user_id: i64,
        pub deleted: i32,
        pub kicked: i32,
        pub banned: i32,
    }
    impl crate::Identifiable for StatsGroupTopAdmin {
        const CONSTRUCTOR_ID: u32 = 3612888199;
    }
    impl crate::Serializable for StatsGroupTopAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.deleted.serialize(buf);
            self.kicked.serialize(buf);
            self.banned.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsGroupTopAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let deleted = i32::deserialize(buf)?;
            let kicked = i32::deserialize(buf)?;
            let banned = i32::deserialize(buf)?;
            Ok(StatsGroupTopAdmin {
                user_id,
                deleted,
                kicked,
                banned,
            })
        }
    }
    impl From<crate::enums::StatsGroupTopAdmin> for StatsGroupTopAdmin {
        fn from(x: crate::enums::StatsGroupTopAdmin) -> Self {
            match x {
                crate::enums::StatsGroupTopAdmin::Admin(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGroupTopInviter {
        pub user_id: i64,
        pub invitations: i32,
    }
    impl crate::Identifiable for StatsGroupTopInviter {
        const CONSTRUCTOR_ID: u32 = 1398765469;
    }
    impl crate::Serializable for StatsGroupTopInviter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.invitations.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsGroupTopInviter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let invitations = i32::deserialize(buf)?;
            Ok(StatsGroupTopInviter {
                user_id,
                invitations,
            })
        }
    }
    impl From<crate::enums::StatsGroupTopInviter> for StatsGroupTopInviter {
        fn from(x: crate::enums::StatsGroupTopInviter) -> Self {
            match x {
                crate::enums::StatsGroupTopInviter::Inviter(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsGroupTopPoster {
        pub user_id: i64,
        pub messages: i32,
        pub avg_chars: i32,
    }
    impl crate::Identifiable for StatsGroupTopPoster {
        const CONSTRUCTOR_ID: u32 = 2634330011;
    }
    impl crate::Serializable for StatsGroupTopPoster {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.messages.serialize(buf);
            self.avg_chars.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsGroupTopPoster {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let messages = i32::deserialize(buf)?;
            let avg_chars = i32::deserialize(buf)?;
            Ok(StatsGroupTopPoster {
                user_id,
                messages,
                avg_chars,
            })
        }
    }
    impl From<crate::enums::StatsGroupTopPoster> for StatsGroupTopPoster {
        fn from(x: crate::enums::StatsGroupTopPoster) -> Self {
            match x {
                crate::enums::StatsGroupTopPoster::Poster(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsPercentValue {
        pub part: f64,
        pub total: f64,
    }
    impl crate::Identifiable for StatsPercentValue {
        const CONSTRUCTOR_ID: u32 = 3419287520;
    }
    impl crate::Serializable for StatsPercentValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.part.serialize(buf);
            self.total.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsPercentValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let part = f64::deserialize(buf)?;
            let total = f64::deserialize(buf)?;
            Ok(StatsPercentValue { part, total })
        }
    }
    impl From<crate::enums::StatsPercentValue> for StatsPercentValue {
        fn from(x: crate::enums::StatsPercentValue) -> Self {
            match x {
                crate::enums::StatsPercentValue::Value(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatsUrl {
        pub url: String,
    }
    impl crate::Identifiable for StatsUrl {
        const CONSTRUCTOR_ID: u32 = 1202287072;
    }
    impl crate::Serializable for StatsUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for StatsUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            Ok(StatsUrl { url })
        }
    }
    impl From<crate::enums::StatsUrl> for StatsUrl {
        fn from(x: crate::enums::StatsUrl) -> Self {
            match x {
                crate::enums::StatsUrl::Url(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StickerPack {
        pub emoticon: String,
        pub documents: Vec<i64>,
    }
    impl crate::Identifiable for StickerPack {
        const CONSTRUCTOR_ID: u32 = 313694676;
    }
    impl crate::Serializable for StickerPack {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.emoticon.serialize(buf);
            self.documents.serialize(buf);
        }
    }
    impl crate::Deserializable for StickerPack {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let emoticon = String::deserialize(buf)?;
            let documents = Vec::<i64>::deserialize(buf)?;
            Ok(StickerPack {
                emoticon,
                documents,
            })
        }
    }
    impl From<crate::enums::StickerPack> for StickerPack {
        fn from(x: crate::enums::StickerPack) -> Self {
            match x {
                crate::enums::StickerPack::Pack(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StickerSet {
        pub archived: bool,
        pub official: bool,
        pub masks: bool,
        pub animated: bool,
        pub installed_date: Option<i32>,
        pub id: i64,
        pub access_hash: i64,
        pub title: String,
        pub short_name: String,
        pub thumbs: Option<Vec<crate::enums::PhotoSize>>,
        pub thumb_dc_id: Option<i32>,
        pub thumb_version: Option<i32>,
        pub count: i32,
        pub hash: i32,
    }
    impl crate::Identifiable for StickerSet {
        const CONSTRUCTOR_ID: u32 = 3621724538;
    }
    impl crate::Serializable for StickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.archived { 2 } else { 0 }
                | if self.official { 4 } else { 0 }
                | if self.masks { 8 } else { 0 }
                | if self.animated { 32 } else { 0 }
                | if self.installed_date.is_some() { 1 } else { 0 }
                | if self.thumbs.is_some() { 16 } else { 0 }
                | if self.thumb_dc_id.is_some() { 16 } else { 0 }
                | if self.thumb_version.is_some() { 16 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.installed_date {
                x.serialize(buf);
            }
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.title.serialize(buf);
            self.short_name.serialize(buf);
            if let Some(ref x) = self.thumbs {
                x.serialize(buf);
            }
            if let Some(ref x) = self.thumb_dc_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.thumb_version {
                x.serialize(buf);
            }
            self.count.serialize(buf);
            self.hash.serialize(buf);
        }
    }
    impl crate::Deserializable for StickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let archived = (flags & 2) != 0;
            let official = (flags & 4) != 0;
            let masks = (flags & 8) != 0;
            let animated = (flags & 32) != 0;
            let installed_date = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let short_name = String::deserialize(buf)?;
            let thumbs = if (flags & 16) != 0 {
                Some(Vec::<crate::enums::PhotoSize>::deserialize(buf)?)
            } else {
                None
            };
            let thumb_dc_id = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let thumb_version = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let count = i32::deserialize(buf)?;
            let hash = i32::deserialize(buf)?;
            Ok(StickerSet {
                archived,
                official,
                masks,
                animated,
                installed_date,
                id,
                access_hash,
                title,
                short_name,
                thumbs,
                thumb_dc_id,
                thumb_version,
                count,
                hash,
            })
        }
    }
    impl From<crate::enums::StickerSet> for StickerSet {
        fn from(x: crate::enums::StickerSet) -> Self {
            match x {
                crate::enums::StickerSet::Set(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StickerSetCovered {
        pub set: crate::enums::StickerSet,
        pub cover: crate::enums::Document,
    }
    impl crate::Identifiable for StickerSetCovered {
        const CONSTRUCTOR_ID: u32 = 1678812626;
    }
    impl crate::Serializable for StickerSetCovered {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.set.serialize(buf);
            self.cover.serialize(buf);
        }
    }
    impl crate::Deserializable for StickerSetCovered {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let set = crate::enums::StickerSet::deserialize(buf)?;
            let cover = crate::enums::Document::deserialize(buf)?;
            Ok(StickerSetCovered { set, cover })
        }
    }
    impl TryFrom<crate::enums::StickerSetCovered> for StickerSetCovered {
        type Error = ();
        fn try_from(x: crate::enums::StickerSetCovered) -> Result<Self, Self::Error> {
            match x {
                crate::enums::StickerSetCovered::Covered(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct StickerSetMultiCovered {
        pub set: crate::enums::StickerSet,
        pub covers: Vec<crate::enums::Document>,
    }
    impl crate::Identifiable for StickerSetMultiCovered {
        const CONSTRUCTOR_ID: u32 = 872932635;
    }
    impl crate::Serializable for StickerSetMultiCovered {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.set.serialize(buf);
            self.covers.serialize(buf);
        }
    }
    impl crate::Deserializable for StickerSetMultiCovered {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let set = crate::enums::StickerSet::deserialize(buf)?;
            let covers = Vec::<crate::enums::Document>::deserialize(buf)?;
            Ok(StickerSetMultiCovered { set, covers })
        }
    }
    impl TryFrom<crate::enums::StickerSetCovered> for StickerSetMultiCovered {
        type Error = ();
        fn try_from(x: crate::enums::StickerSetCovered) -> Result<Self, Self::Error> {
            match x {
                crate::enums::StickerSetCovered::StickerSetMultiCovered(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextAnchor {
        pub text: crate::enums::RichText,
        pub name: String,
    }
    impl crate::Identifiable for TextAnchor {
        const CONSTRUCTOR_ID: u32 = 894777186;
    }
    impl crate::Serializable for TextAnchor {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.name.serialize(buf);
        }
    }
    impl crate::Deserializable for TextAnchor {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let name = String::deserialize(buf)?;
            Ok(TextAnchor { text, name })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextAnchor {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextAnchor(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextBold {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextBold {
        const CONSTRUCTOR_ID: u32 = 1730456516;
    }
    impl crate::Serializable for TextBold {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextBold {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextBold { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextBold {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextBold(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextConcat {
        pub texts: Vec<crate::enums::RichText>,
    }
    impl crate::Identifiable for TextConcat {
        const CONSTRUCTOR_ID: u32 = 2120376535;
    }
    impl crate::Serializable for TextConcat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.texts.serialize(buf);
        }
    }
    impl crate::Deserializable for TextConcat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let texts = Vec::<crate::enums::RichText>::deserialize(buf)?;
            Ok(TextConcat { texts })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextConcat {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextConcat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextEmail {
        pub text: crate::enums::RichText,
        pub email: String,
    }
    impl crate::Identifiable for TextEmail {
        const CONSTRUCTOR_ID: u32 = 3730443734;
    }
    impl crate::Serializable for TextEmail {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.email.serialize(buf);
        }
    }
    impl crate::Deserializable for TextEmail {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let email = String::deserialize(buf)?;
            Ok(TextEmail { text, email })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextEmail {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextEmail(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextEmpty {}
    impl crate::Identifiable for TextEmpty {
        const CONSTRUCTOR_ID: u32 = 3695018575;
    }
    impl crate::Serializable for TextEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TextEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TextEmpty {})
        }
    }
    impl TryFrom<crate::enums::RichText> for TextEmpty {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextEmpty => Ok(TextEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextFixed {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextFixed {
        const CONSTRUCTOR_ID: u32 = 1816074681;
    }
    impl crate::Serializable for TextFixed {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextFixed {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextFixed { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextFixed {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextFixed(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextImage {
        pub document_id: i64,
        pub w: i32,
        pub h: i32,
    }
    impl crate::Identifiable for TextImage {
        const CONSTRUCTOR_ID: u32 = 136105807;
    }
    impl crate::Serializable for TextImage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.document_id.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
        }
    }
    impl crate::Deserializable for TextImage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let document_id = i64::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            Ok(TextImage { document_id, w, h })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextImage {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextImage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextItalic {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextItalic {
        const CONSTRUCTOR_ID: u32 = 3641877916;
    }
    impl crate::Serializable for TextItalic {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextItalic {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextItalic { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextItalic {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextItalic(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextMarked {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextMarked {
        const CONSTRUCTOR_ID: u32 = 55281185;
    }
    impl crate::Serializable for TextMarked {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextMarked {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextMarked { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextMarked {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextMarked(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextPhone {
        pub text: crate::enums::RichText,
        pub phone: String,
    }
    impl crate::Identifiable for TextPhone {
        const CONSTRUCTOR_ID: u32 = 483104362;
    }
    impl crate::Serializable for TextPhone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.phone.serialize(buf);
        }
    }
    impl crate::Deserializable for TextPhone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let phone = String::deserialize(buf)?;
            Ok(TextPhone { text, phone })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextPhone {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextPhone(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextPlain {
        pub text: String,
    }
    impl crate::Identifiable for TextPlain {
        const CONSTRUCTOR_ID: u32 = 1950782688;
    }
    impl crate::Serializable for TextPlain {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextPlain {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = String::deserialize(buf)?;
            Ok(TextPlain { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextPlain {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextPlain(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextStrike {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextStrike {
        const CONSTRUCTOR_ID: u32 = 2616769429;
    }
    impl crate::Serializable for TextStrike {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextStrike {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextStrike { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextStrike {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextStrike(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextSubscript {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextSubscript {
        const CONSTRUCTOR_ID: u32 = 3983181060;
    }
    impl crate::Serializable for TextSubscript {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextSubscript {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextSubscript { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextSubscript {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextSubscript(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextSuperscript {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextSuperscript {
        const CONSTRUCTOR_ID: u32 = 3355139585;
    }
    impl crate::Serializable for TextSuperscript {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextSuperscript {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextSuperscript { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextSuperscript {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextSuperscript(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextUnderline {
        pub text: crate::enums::RichText,
    }
    impl crate::Identifiable for TextUnderline {
        const CONSTRUCTOR_ID: u32 = 3240501956;
    }
    impl crate::Serializable for TextUnderline {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
        }
    }
    impl crate::Deserializable for TextUnderline {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            Ok(TextUnderline { text })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextUnderline {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextUnderline(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextUrl {
        pub text: crate::enums::RichText,
        pub url: String,
        pub webpage_id: i64,
    }
    impl crate::Identifiable for TextUrl {
        const CONSTRUCTOR_ID: u32 = 1009288385;
    }
    impl crate::Serializable for TextUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.text.serialize(buf);
            self.url.serialize(buf);
            self.webpage_id.serialize(buf);
        }
    }
    impl crate::Deserializable for TextUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let text = crate::enums::RichText::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            let webpage_id = i64::deserialize(buf)?;
            Ok(TextUrl {
                text,
                url,
                webpage_id,
            })
        }
    }
    impl TryFrom<crate::enums::RichText> for TextUrl {
        type Error = ();
        fn try_from(x: crate::enums::RichText) -> Result<Self, Self::Error> {
            match x {
                crate::enums::RichText::TextUrl(x) => Ok(*x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Theme {
        pub creator: bool,
        pub default: bool,
        pub for_chat: bool,
        pub id: i64,
        pub access_hash: i64,
        pub slug: String,
        pub title: String,
        pub document: Option<crate::enums::Document>,
        pub settings: Option<Vec<crate::enums::ThemeSettings>>,
        pub emoticon: Option<String>,
        pub installs_count: Option<i32>,
    }
    impl crate::Identifiable for Theme {
        const CONSTRUCTOR_ID: u32 = 2685298646;
    }
    impl crate::Serializable for Theme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.creator { 1 } else { 0 }
                | if self.default { 2 } else { 0 }
                | if self.for_chat { 32 } else { 0 }
                | if self.document.is_some() { 4 } else { 0 }
                | if self.settings.is_some() { 8 } else { 0 }
                | if self.emoticon.is_some() { 64 } else { 0 }
                | if self.installs_count.is_some() { 16 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.access_hash.serialize(buf);
            self.slug.serialize(buf);
            self.title.serialize(buf);
            if let Some(ref x) = self.document {
                x.serialize(buf);
            }
            if let Some(ref x) = self.settings {
                x.serialize(buf);
            }
            if let Some(ref x) = self.emoticon {
                x.serialize(buf);
            }
            if let Some(ref x) = self.installs_count {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for Theme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let creator = (flags & 1) != 0;
            let default = (flags & 2) != 0;
            let for_chat = (flags & 32) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let slug = String::deserialize(buf)?;
            let title = String::deserialize(buf)?;
            let document = if (flags & 4) != 0 {
                Some(crate::enums::Document::deserialize(buf)?)
            } else {
                None
            };
            let settings = if (flags & 8) != 0 {
                Some(Vec::<crate::enums::ThemeSettings>::deserialize(buf)?)
            } else {
                None
            };
            let emoticon = if (flags & 64) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let installs_count = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(Theme {
                creator,
                default,
                for_chat,
                id,
                access_hash,
                slug,
                title,
                document,
                settings,
                emoticon,
                installs_count,
            })
        }
    }
    impl From<crate::enums::Theme> for Theme {
        fn from(x: crate::enums::Theme) -> Self {
            match x {
                crate::enums::Theme::Theme(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ThemeSettings {
        pub message_colors_animated: bool,
        pub base_theme: crate::enums::BaseTheme,
        pub accent_color: i32,
        pub outbox_accent_color: Option<i32>,
        pub message_colors: Option<Vec<i32>>,
        pub wallpaper: Option<crate::enums::WallPaper>,
    }
    impl crate::Identifiable for ThemeSettings {
        const CONSTRUCTOR_ID: u32 = 4200117972;
    }
    impl crate::Serializable for ThemeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.message_colors_animated { 4 } else { 0 }
                | if self.outbox_accent_color.is_some() {
                    8
                } else {
                    0
                }
                | if self.message_colors.is_some() { 1 } else { 0 }
                | if self.wallpaper.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.base_theme.serialize(buf);
            self.accent_color.serialize(buf);
            if let Some(ref x) = self.outbox_accent_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.message_colors {
                x.serialize(buf);
            }
            if let Some(ref x) = self.wallpaper {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for ThemeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let message_colors_animated = (flags & 4) != 0;
            let base_theme = crate::enums::BaseTheme::deserialize(buf)?;
            let accent_color = i32::deserialize(buf)?;
            let outbox_accent_color = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let message_colors = if (flags & 1) != 0 {
                Some(Vec::<i32>::deserialize(buf)?)
            } else {
                None
            };
            let wallpaper = if (flags & 2) != 0 {
                Some(crate::enums::WallPaper::deserialize(buf)?)
            } else {
                None
            };
            Ok(ThemeSettings {
                message_colors_animated,
                base_theme,
                accent_color,
                outbox_accent_color,
                message_colors,
                wallpaper,
            })
        }
    }
    impl From<crate::enums::ThemeSettings> for ThemeSettings {
        fn from(x: crate::enums::ThemeSettings) -> Self {
            match x {
                crate::enums::ThemeSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockDomain {}
    impl crate::Identifiable for TlsBlockDomain {
        const CONSTRUCTOR_ID: u32 = 283665263;
    }
    impl crate::Serializable for TlsBlockDomain {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TlsBlockDomain {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TlsBlockDomain {})
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockDomain {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::Domain => Ok(TlsBlockDomain {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockGrease {
        pub seed: i32,
    }
    impl crate::Identifiable for TlsBlockGrease {
        const CONSTRUCTOR_ID: u32 = 3866468801;
    }
    impl crate::Serializable for TlsBlockGrease {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.seed.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsBlockGrease {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let seed = i32::deserialize(buf)?;
            Ok(TlsBlockGrease { seed })
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockGrease {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::Grease(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockPublicKey {}
    impl crate::Identifiable for TlsBlockPublicKey {
        const CONSTRUCTOR_ID: u32 = 2662947676;
    }
    impl crate::Serializable for TlsBlockPublicKey {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TlsBlockPublicKey {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TlsBlockPublicKey {})
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockPublicKey {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::PublicKey => Ok(TlsBlockPublicKey {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockRandom {
        pub length: i32,
    }
    impl crate::Identifiable for TlsBlockRandom {
        const CONSTRUCTOR_ID: u32 = 1296942110;
    }
    impl crate::Serializable for TlsBlockRandom {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsBlockRandom {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let length = i32::deserialize(buf)?;
            Ok(TlsBlockRandom { length })
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockRandom {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::Random(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockScope {
        pub entries: Vec<crate::enums::TlsBlock>,
    }
    impl crate::Identifiable for TlsBlockScope {
        const CONSTRUCTOR_ID: u32 = 3878016079;
    }
    impl crate::Serializable for TlsBlockScope {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.entries.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsBlockScope {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let entries = Vec::<crate::enums::TlsBlock>::deserialize(buf)?;
            Ok(TlsBlockScope { entries })
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockScope {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::Scope(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockString {
        pub data: Vec<u8>,
    }
    impl crate::Identifiable for TlsBlockString {
        const CONSTRUCTOR_ID: u32 = 2998214090;
    }
    impl crate::Serializable for TlsBlockString {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsBlockString {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let data = Vec::<u8>::deserialize(buf)?;
            Ok(TlsBlockString { data })
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockString {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::String(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsBlockZero {
        pub length: i32,
    }
    impl crate::Identifiable for TlsBlockZero {
        const CONSTRUCTOR_ID: u32 = 154352379;
    }
    impl crate::Serializable for TlsBlockZero {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.length.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsBlockZero {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let length = i32::deserialize(buf)?;
            Ok(TlsBlockZero { length })
        }
    }
    impl TryFrom<crate::enums::TlsBlock> for TlsBlockZero {
        type Error = ();
        fn try_from(x: crate::enums::TlsBlock) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TlsBlock::Zero(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TlsClientHello {
        pub blocks: crate::RawVec<crate::enums::TlsBlock>,
    }
    impl crate::Identifiable for TlsClientHello {
        const CONSTRUCTOR_ID: u32 = 1817363588;
    }
    impl crate::Serializable for TlsClientHello {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.blocks.serialize(buf);
        }
    }
    impl crate::Deserializable for TlsClientHello {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let blocks = crate::RawVec::<crate::enums::TlsBlock>::deserialize(buf)?;
            Ok(TlsClientHello { blocks })
        }
    }
    impl From<crate::enums::TlsClientHello> for TlsClientHello {
        fn from(x: crate::enums::TlsClientHello) -> Self {
            match x {
                crate::enums::TlsClientHello::Hello(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeer {
        pub peer: crate::enums::Peer,
        pub rating: f64,
    }
    impl crate::Identifiable for TopPeer {
        const CONSTRUCTOR_ID: u32 = 3989684315;
    }
    impl crate::Serializable for TopPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.rating.serialize(buf);
        }
    }
    impl crate::Deserializable for TopPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let rating = f64::deserialize(buf)?;
            Ok(TopPeer { peer, rating })
        }
    }
    impl From<crate::enums::TopPeer> for TopPeer {
        fn from(x: crate::enums::TopPeer) -> Self {
            match x {
                crate::enums::TopPeer::Peer(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryBotsInline {}
    impl crate::Identifiable for TopPeerCategoryBotsInline {
        const CONSTRUCTOR_ID: u32 = 344356834;
    }
    impl crate::Serializable for TopPeerCategoryBotsInline {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryBotsInline {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryBotsInline {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryBotsInline {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::BotsInline => Ok(TopPeerCategoryBotsInline {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryBotsPm {}
    impl crate::Identifiable for TopPeerCategoryBotsPm {
        const CONSTRUCTOR_ID: u32 = 2875595611;
    }
    impl crate::Serializable for TopPeerCategoryBotsPm {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryBotsPm {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryBotsPm {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryBotsPm {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::BotsPm => Ok(TopPeerCategoryBotsPm {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryChannels {}
    impl crate::Identifiable for TopPeerCategoryChannels {
        const CONSTRUCTOR_ID: u32 = 371037736;
    }
    impl crate::Serializable for TopPeerCategoryChannels {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryChannels {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryChannels {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryChannels {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::Channels => Ok(TopPeerCategoryChannels {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryCorrespondents {}
    impl crate::Identifiable for TopPeerCategoryCorrespondents {
        const CONSTRUCTOR_ID: u32 = 104314861;
    }
    impl crate::Serializable for TopPeerCategoryCorrespondents {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryCorrespondents {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryCorrespondents {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryCorrespondents {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::Correspondents => {
                    Ok(TopPeerCategoryCorrespondents {})
                }
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryForwardChats {}
    impl crate::Identifiable for TopPeerCategoryForwardChats {
        const CONSTRUCTOR_ID: u32 = 4226728176;
    }
    impl crate::Serializable for TopPeerCategoryForwardChats {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryForwardChats {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryForwardChats {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryForwardChats {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::ForwardChats => Ok(TopPeerCategoryForwardChats {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryForwardUsers {}
    impl crate::Identifiable for TopPeerCategoryForwardUsers {
        const CONSTRUCTOR_ID: u32 = 2822794409;
    }
    impl crate::Serializable for TopPeerCategoryForwardUsers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryForwardUsers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryForwardUsers {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryForwardUsers {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::ForwardUsers => Ok(TopPeerCategoryForwardUsers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryGroups {}
    impl crate::Identifiable for TopPeerCategoryGroups {
        const CONSTRUCTOR_ID: u32 = 3172442442;
    }
    impl crate::Serializable for TopPeerCategoryGroups {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryGroups {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryGroups {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryGroups {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::Groups => Ok(TopPeerCategoryGroups {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryPeers {
        pub category: crate::enums::TopPeerCategory,
        pub count: i32,
        pub peers: Vec<crate::enums::TopPeer>,
    }
    impl crate::Identifiable for TopPeerCategoryPeers {
        const CONSTRUCTOR_ID: u32 = 4219683473;
    }
    impl crate::Serializable for TopPeerCategoryPeers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.category.serialize(buf);
            self.count.serialize(buf);
            self.peers.serialize(buf);
        }
    }
    impl crate::Deserializable for TopPeerCategoryPeers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let category = crate::enums::TopPeerCategory::deserialize(buf)?;
            let count = i32::deserialize(buf)?;
            let peers = Vec::<crate::enums::TopPeer>::deserialize(buf)?;
            Ok(TopPeerCategoryPeers {
                category,
                count,
                peers,
            })
        }
    }
    impl From<crate::enums::TopPeerCategoryPeers> for TopPeerCategoryPeers {
        fn from(x: crate::enums::TopPeerCategoryPeers) -> Self {
            match x {
                crate::enums::TopPeerCategoryPeers::Peers(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TopPeerCategoryPhoneCalls {}
    impl crate::Identifiable for TopPeerCategoryPhoneCalls {
        const CONSTRUCTOR_ID: u32 = 511092620;
    }
    impl crate::Serializable for TopPeerCategoryPhoneCalls {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for TopPeerCategoryPhoneCalls {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(TopPeerCategoryPhoneCalls {})
        }
    }
    impl TryFrom<crate::enums::TopPeerCategory> for TopPeerCategoryPhoneCalls {
        type Error = ();
        fn try_from(x: crate::enums::TopPeerCategory) -> Result<Self, Self::Error> {
            match x {
                crate::enums::TopPeerCategory::PhoneCalls => Ok(TopPeerCategoryPhoneCalls {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct True {}
    impl crate::Identifiable for True {
        const CONSTRUCTOR_ID: u32 = 1072550713;
    }
    impl crate::Serializable for True {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for True {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(True {})
        }
    }
    impl From<crate::enums::True> for True {
        fn from(x: crate::enums::True) -> Self {
            match x {
                crate::enums::True::True => True {},
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotCallbackQuery {
        pub query_id: i64,
        pub user_id: i64,
        pub peer: crate::enums::Peer,
        pub msg_id: i32,
        pub chat_instance: i64,
        pub data: Option<Vec<u8>>,
        pub game_short_name: Option<String>,
    }
    impl crate::Identifiable for UpdateBotCallbackQuery {
        const CONSTRUCTOR_ID: u32 = 3117401229;
    }
    impl crate::Serializable for UpdateBotCallbackQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.data.is_some() { 1 } else { 0 }
                | if self.game_short_name.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.query_id.serialize(buf);
            self.user_id.serialize(buf);
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
            self.chat_instance.serialize(buf);
            if let Some(ref x) = self.data {
                x.serialize(buf);
            }
            if let Some(ref x) = self.game_short_name {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateBotCallbackQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let query_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            let chat_instance = i64::deserialize(buf)?;
            let data = if (flags & 1) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            let game_short_name = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateBotCallbackQuery {
                query_id,
                user_id,
                peer,
                msg_id,
                chat_instance,
                data,
                game_short_name,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotCallbackQuery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotCallbackQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotChatInviteRequester {
        pub peer: crate::enums::Peer,
        pub date: i32,
        pub user_id: i64,
        pub about: String,
        pub invite: crate::enums::ExportedChatInvite,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateBotChatInviteRequester {
        const CONSTRUCTOR_ID: u32 = 299870598;
    }
    impl crate::Serializable for UpdateBotChatInviteRequester {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.date.serialize(buf);
            self.user_id.serialize(buf);
            self.about.serialize(buf);
            self.invite.serialize(buf);
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotChatInviteRequester {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let about = String::deserialize(buf)?;
            let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
            let qts = i32::deserialize(buf)?;
            Ok(UpdateBotChatInviteRequester {
                peer,
                date,
                user_id,
                about,
                invite,
                qts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotChatInviteRequester {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotChatInviteRequester(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotCommands {
        pub peer: crate::enums::Peer,
        pub bot_id: i64,
        pub commands: Vec<crate::enums::BotCommand>,
    }
    impl crate::Identifiable for UpdateBotCommands {
        const CONSTRUCTOR_ID: u32 = 1299263278;
    }
    impl crate::Serializable for UpdateBotCommands {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.bot_id.serialize(buf);
            self.commands.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotCommands {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let bot_id = i64::deserialize(buf)?;
            let commands = Vec::<crate::enums::BotCommand>::deserialize(buf)?;
            Ok(UpdateBotCommands {
                peer,
                bot_id,
                commands,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotCommands {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotCommands(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotInlineQuery {
        pub query_id: i64,
        pub user_id: i64,
        pub query: String,
        pub geo: Option<crate::enums::GeoPoint>,
        pub peer_type: Option<crate::enums::InlineQueryPeerType>,
        pub offset: String,
    }
    impl crate::Identifiable for UpdateBotInlineQuery {
        const CONSTRUCTOR_ID: u32 = 1232025500;
    }
    impl crate::Serializable for UpdateBotInlineQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.geo.is_some() { 1 } else { 0 }
                | if self.peer_type.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.query_id.serialize(buf);
            self.user_id.serialize(buf);
            self.query.serialize(buf);
            if let Some(ref x) = self.geo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.peer_type {
                x.serialize(buf);
            }
            self.offset.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotInlineQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let query_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let query = String::deserialize(buf)?;
            let geo = if (flags & 1) != 0 {
                Some(crate::enums::GeoPoint::deserialize(buf)?)
            } else {
                None
            };
            let peer_type = if (flags & 2) != 0 {
                Some(crate::enums::InlineQueryPeerType::deserialize(buf)?)
            } else {
                None
            };
            let offset = String::deserialize(buf)?;
            Ok(UpdateBotInlineQuery {
                query_id,
                user_id,
                query,
                geo,
                peer_type,
                offset,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotInlineQuery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotInlineQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotInlineSend {
        pub user_id: i64,
        pub query: String,
        pub geo: Option<crate::enums::GeoPoint>,
        pub id: String,
        pub msg_id: Option<crate::enums::InputBotInlineMessageId>,
    }
    impl crate::Identifiable for UpdateBotInlineSend {
        const CONSTRUCTOR_ID: u32 = 317794823;
    }
    impl crate::Serializable for UpdateBotInlineSend {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.geo.is_some() { 1 } else { 0 }
                | if self.msg_id.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.user_id.serialize(buf);
            self.query.serialize(buf);
            if let Some(ref x) = self.geo {
                x.serialize(buf);
            }
            self.id.serialize(buf);
            if let Some(ref x) = self.msg_id {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateBotInlineSend {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let query = String::deserialize(buf)?;
            let geo = if (flags & 1) != 0 {
                Some(crate::enums::GeoPoint::deserialize(buf)?)
            } else {
                None
            };
            let id = String::deserialize(buf)?;
            let msg_id = if (flags & 2) != 0 {
                Some(crate::enums::InputBotInlineMessageId::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateBotInlineSend {
                user_id,
                query,
                geo,
                id,
                msg_id,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotInlineSend {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotInlineSend(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotPrecheckoutQuery {
        pub query_id: i64,
        pub user_id: i64,
        pub payload: Vec<u8>,
        pub info: Option<crate::enums::PaymentRequestedInfo>,
        pub shipping_option_id: Option<String>,
        pub currency: String,
        pub total_amount: i64,
    }
    impl crate::Identifiable for UpdateBotPrecheckoutQuery {
        const CONSTRUCTOR_ID: u32 = 2359990934;
    }
    impl crate::Serializable for UpdateBotPrecheckoutQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.info.is_some() { 1 } else { 0 }
                | if self.shipping_option_id.is_some() {
                    2
                } else {
                    0
                })
            .serialize(buf);
            self.query_id.serialize(buf);
            self.user_id.serialize(buf);
            self.payload.serialize(buf);
            if let Some(ref x) = self.info {
                x.serialize(buf);
            }
            if let Some(ref x) = self.shipping_option_id {
                x.serialize(buf);
            }
            self.currency.serialize(buf);
            self.total_amount.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotPrecheckoutQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let query_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let payload = Vec::<u8>::deserialize(buf)?;
            let info = if (flags & 1) != 0 {
                Some(crate::enums::PaymentRequestedInfo::deserialize(buf)?)
            } else {
                None
            };
            let shipping_option_id = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let currency = String::deserialize(buf)?;
            let total_amount = i64::deserialize(buf)?;
            Ok(UpdateBotPrecheckoutQuery {
                query_id,
                user_id,
                payload,
                info,
                shipping_option_id,
                currency,
                total_amount,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotPrecheckoutQuery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotPrecheckoutQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotShippingQuery {
        pub query_id: i64,
        pub user_id: i64,
        pub payload: Vec<u8>,
        pub shipping_address: crate::enums::PostAddress,
    }
    impl crate::Identifiable for UpdateBotShippingQuery {
        const CONSTRUCTOR_ID: u32 = 3048144253;
    }
    impl crate::Serializable for UpdateBotShippingQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.query_id.serialize(buf);
            self.user_id.serialize(buf);
            self.payload.serialize(buf);
            self.shipping_address.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotShippingQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let query_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let payload = Vec::<u8>::deserialize(buf)?;
            let shipping_address = crate::enums::PostAddress::deserialize(buf)?;
            Ok(UpdateBotShippingQuery {
                query_id,
                user_id,
                payload,
                shipping_address,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotShippingQuery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotShippingQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotStopped {
        pub user_id: i64,
        pub date: i32,
        pub stopped: bool,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateBotStopped {
        const CONSTRUCTOR_ID: u32 = 3297184329;
    }
    impl crate::Serializable for UpdateBotStopped {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.date.serialize(buf);
            self.stopped.serialize(buf);
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotStopped {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let stopped = bool::deserialize(buf)?;
            let qts = i32::deserialize(buf)?;
            Ok(UpdateBotStopped {
                user_id,
                date,
                stopped,
                qts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotStopped {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotStopped(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotWebhookJson {
        pub data: crate::enums::DataJson,
    }
    impl crate::Identifiable for UpdateBotWebhookJson {
        const CONSTRUCTOR_ID: u32 = 2199371971;
    }
    impl crate::Serializable for UpdateBotWebhookJson {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotWebhookJson {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let data = crate::enums::DataJson::deserialize(buf)?;
            Ok(UpdateBotWebhookJson { data })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotWebhookJson {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotWebhookJson(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateBotWebhookJsonquery {
        pub query_id: i64,
        pub data: crate::enums::DataJson,
        pub timeout: i32,
    }
    impl crate::Identifiable for UpdateBotWebhookJsonquery {
        const CONSTRUCTOR_ID: u32 = 2610053286;
    }
    impl crate::Serializable for UpdateBotWebhookJsonquery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.query_id.serialize(buf);
            self.data.serialize(buf);
            self.timeout.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateBotWebhookJsonquery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let query_id = i64::deserialize(buf)?;
            let data = crate::enums::DataJson::deserialize(buf)?;
            let timeout = i32::deserialize(buf)?;
            Ok(UpdateBotWebhookJsonquery {
                query_id,
                data,
                timeout,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateBotWebhookJsonquery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::BotWebhookJsonquery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannel {
        pub channel_id: i64,
    }
    impl crate::Identifiable for UpdateChannel {
        const CONSTRUCTOR_ID: u32 = 1666927625;
    }
    impl crate::Serializable for UpdateChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            Ok(UpdateChannel { channel_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannel {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Channel(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelAvailableMessages {
        pub channel_id: i64,
        pub available_min_id: i32,
    }
    impl crate::Identifiable for UpdateChannelAvailableMessages {
        const CONSTRUCTOR_ID: u32 = 2990524056;
    }
    impl crate::Serializable for UpdateChannelAvailableMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.available_min_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelAvailableMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let available_min_id = i32::deserialize(buf)?;
            Ok(UpdateChannelAvailableMessages {
                channel_id,
                available_min_id,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelAvailableMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelAvailableMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelMessageForwards {
        pub channel_id: i64,
        pub id: i32,
        pub forwards: i32,
    }
    impl crate::Identifiable for UpdateChannelMessageForwards {
        const CONSTRUCTOR_ID: u32 = 3533318132;
    }
    impl crate::Serializable for UpdateChannelMessageForwards {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.id.serialize(buf);
            self.forwards.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelMessageForwards {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let id = i32::deserialize(buf)?;
            let forwards = i32::deserialize(buf)?;
            Ok(UpdateChannelMessageForwards {
                channel_id,
                id,
                forwards,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelMessageForwards {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelMessageForwards(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelMessageViews {
        pub channel_id: i64,
        pub id: i32,
        pub views: i32,
    }
    impl crate::Identifiable for UpdateChannelMessageViews {
        const CONSTRUCTOR_ID: u32 = 4062620680;
    }
    impl crate::Serializable for UpdateChannelMessageViews {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.id.serialize(buf);
            self.views.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelMessageViews {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let id = i32::deserialize(buf)?;
            let views = i32::deserialize(buf)?;
            Ok(UpdateChannelMessageViews {
                channel_id,
                id,
                views,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelMessageViews {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelMessageViews(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelParticipant {
        pub channel_id: i64,
        pub date: i32,
        pub actor_id: i64,
        pub user_id: i64,
        pub prev_participant: Option<crate::enums::ChannelParticipant>,
        pub new_participant: Option<crate::enums::ChannelParticipant>,
        pub invite: Option<crate::enums::ExportedChatInvite>,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateChannelParticipant {
        const CONSTRUCTOR_ID: u32 = 2556246715;
    }
    impl crate::Serializable for UpdateChannelParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.prev_participant.is_some() {
                    1
                } else {
                    0
                }
                | if self.new_participant.is_some() { 2 } else { 0 }
                | if self.invite.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.channel_id.serialize(buf);
            self.date.serialize(buf);
            self.actor_id.serialize(buf);
            self.user_id.serialize(buf);
            if let Some(ref x) = self.prev_participant {
                x.serialize(buf);
            }
            if let Some(ref x) = self.new_participant {
                x.serialize(buf);
            }
            if let Some(ref x) = self.invite {
                x.serialize(buf);
            }
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let actor_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let prev_participant = if (flags & 1) != 0 {
                Some(crate::enums::ChannelParticipant::deserialize(buf)?)
            } else {
                None
            };
            let new_participant = if (flags & 2) != 0 {
                Some(crate::enums::ChannelParticipant::deserialize(buf)?)
            } else {
                None
            };
            let invite = if (flags & 4) != 0 {
                Some(crate::enums::ExportedChatInvite::deserialize(buf)?)
            } else {
                None
            };
            let qts = i32::deserialize(buf)?;
            Ok(UpdateChannelParticipant {
                channel_id,
                date,
                actor_id,
                user_id,
                prev_participant,
                new_participant,
                invite,
                qts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelParticipant {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelParticipant(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelReadMessagesContents {
        pub channel_id: i64,
        pub messages: Vec<i32>,
    }
    impl crate::Identifiable for UpdateChannelReadMessagesContents {
        const CONSTRUCTOR_ID: u32 = 1153291573;
    }
    impl crate::Serializable for UpdateChannelReadMessagesContents {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.messages.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelReadMessagesContents {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let messages = Vec::<i32>::deserialize(buf)?;
            Ok(UpdateChannelReadMessagesContents {
                channel_id,
                messages,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelReadMessagesContents {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelReadMessagesContents(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelTooLong {
        pub channel_id: i64,
        pub pts: Option<i32>,
    }
    impl crate::Identifiable for UpdateChannelTooLong {
        const CONSTRUCTOR_ID: u32 = 277713951;
    }
    impl crate::Serializable for UpdateChannelTooLong {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.pts.is_some() { 1 } else { 0 }).serialize(buf);
            self.channel_id.serialize(buf);
            if let Some(ref x) = self.pts {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateChannelTooLong {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            let pts = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateChannelTooLong { channel_id, pts })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelTooLong {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelTooLong(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelUserTyping {
        pub channel_id: i64,
        pub top_msg_id: Option<i32>,
        pub from_id: crate::enums::Peer,
        pub action: crate::enums::SendMessageAction,
    }
    impl crate::Identifiable for UpdateChannelUserTyping {
        const CONSTRUCTOR_ID: u32 = 2357774627;
    }
    impl crate::Serializable for UpdateChannelUserTyping {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.top_msg_id.is_some() { 1 } else { 0 }).serialize(buf);
            self.channel_id.serialize(buf);
            if let Some(ref x) = self.top_msg_id {
                x.serialize(buf);
            }
            self.from_id.serialize(buf);
            self.action.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelUserTyping {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            let top_msg_id = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let from_id = crate::enums::Peer::deserialize(buf)?;
            let action = crate::enums::SendMessageAction::deserialize(buf)?;
            Ok(UpdateChannelUserTyping {
                channel_id,
                top_msg_id,
                from_id,
                action,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelUserTyping {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelUserTyping(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChannelWebPage {
        pub channel_id: i64,
        pub webpage: crate::enums::WebPage,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateChannelWebPage {
        const CONSTRUCTOR_ID: u32 = 791390623;
    }
    impl crate::Serializable for UpdateChannelWebPage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.webpage.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChannelWebPage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let webpage = crate::enums::WebPage::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateChannelWebPage {
                channel_id,
                webpage,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChannelWebPage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChannelWebPage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChat {
        pub chat_id: i64,
    }
    impl crate::Identifiable for UpdateChat {
        const CONSTRUCTOR_ID: u32 = 4170869326;
    }
    impl crate::Serializable for UpdateChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            Ok(UpdateChat { chat_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChat {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Chat(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatDefaultBannedRights {
        pub peer: crate::enums::Peer,
        pub default_banned_rights: crate::enums::ChatBannedRights,
        pub version: i32,
    }
    impl crate::Identifiable for UpdateChatDefaultBannedRights {
        const CONSTRUCTOR_ID: u32 = 1421875280;
    }
    impl crate::Serializable for UpdateChatDefaultBannedRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.default_banned_rights.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatDefaultBannedRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let default_banned_rights = crate::enums::ChatBannedRights::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(UpdateChatDefaultBannedRights {
                peer,
                default_banned_rights,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatDefaultBannedRights {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatDefaultBannedRights(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatParticipant {
        pub chat_id: i64,
        pub date: i32,
        pub actor_id: i64,
        pub user_id: i64,
        pub prev_participant: Option<crate::enums::ChatParticipant>,
        pub new_participant: Option<crate::enums::ChatParticipant>,
        pub invite: Option<crate::enums::ExportedChatInvite>,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateChatParticipant {
        const CONSTRUCTOR_ID: u32 = 3498534458;
    }
    impl crate::Serializable for UpdateChatParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.prev_participant.is_some() {
                    1
                } else {
                    0
                }
                | if self.new_participant.is_some() { 2 } else { 0 }
                | if self.invite.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.chat_id.serialize(buf);
            self.date.serialize(buf);
            self.actor_id.serialize(buf);
            self.user_id.serialize(buf);
            if let Some(ref x) = self.prev_participant {
                x.serialize(buf);
            }
            if let Some(ref x) = self.new_participant {
                x.serialize(buf);
            }
            if let Some(ref x) = self.invite {
                x.serialize(buf);
            }
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let chat_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let actor_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let prev_participant = if (flags & 1) != 0 {
                Some(crate::enums::ChatParticipant::deserialize(buf)?)
            } else {
                None
            };
            let new_participant = if (flags & 2) != 0 {
                Some(crate::enums::ChatParticipant::deserialize(buf)?)
            } else {
                None
            };
            let invite = if (flags & 4) != 0 {
                Some(crate::enums::ExportedChatInvite::deserialize(buf)?)
            } else {
                None
            };
            let qts = i32::deserialize(buf)?;
            Ok(UpdateChatParticipant {
                chat_id,
                date,
                actor_id,
                user_id,
                prev_participant,
                new_participant,
                invite,
                qts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatParticipant {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatParticipant(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatParticipantAdd {
        pub chat_id: i64,
        pub user_id: i64,
        pub inviter_id: i64,
        pub date: i32,
        pub version: i32,
    }
    impl crate::Identifiable for UpdateChatParticipantAdd {
        const CONSTRUCTOR_ID: u32 = 1037718609;
    }
    impl crate::Serializable for UpdateChatParticipantAdd {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.user_id.serialize(buf);
            self.inviter_id.serialize(buf);
            self.date.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatParticipantAdd {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let inviter_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(UpdateChatParticipantAdd {
                chat_id,
                user_id,
                inviter_id,
                date,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatParticipantAdd {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatParticipantAdd(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatParticipantAdmin {
        pub chat_id: i64,
        pub user_id: i64,
        pub is_admin: bool,
        pub version: i32,
    }
    impl crate::Identifiable for UpdateChatParticipantAdmin {
        const CONSTRUCTOR_ID: u32 = 3620364706;
    }
    impl crate::Serializable for UpdateChatParticipantAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.user_id.serialize(buf);
            self.is_admin.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatParticipantAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let is_admin = bool::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(UpdateChatParticipantAdmin {
                chat_id,
                user_id,
                is_admin,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatParticipantAdmin {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatParticipantAdmin(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatParticipantDelete {
        pub chat_id: i64,
        pub user_id: i64,
        pub version: i32,
    }
    impl crate::Identifiable for UpdateChatParticipantDelete {
        const CONSTRUCTOR_ID: u32 = 3811523959;
    }
    impl crate::Serializable for UpdateChatParticipantDelete {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.user_id.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatParticipantDelete {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(UpdateChatParticipantDelete {
                chat_id,
                user_id,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatParticipantDelete {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatParticipantDelete(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatParticipants {
        pub participants: crate::enums::ChatParticipants,
    }
    impl crate::Identifiable for UpdateChatParticipants {
        const CONSTRUCTOR_ID: u32 = 125178264;
    }
    impl crate::Serializable for UpdateChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.participants.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let participants = crate::enums::ChatParticipants::deserialize(buf)?;
            Ok(UpdateChatParticipants { participants })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatParticipants {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatParticipants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateChatUserTyping {
        pub chat_id: i64,
        pub from_id: crate::enums::Peer,
        pub action: crate::enums::SendMessageAction,
    }
    impl crate::Identifiable for UpdateChatUserTyping {
        const CONSTRUCTOR_ID: u32 = 2202565360;
    }
    impl crate::Serializable for UpdateChatUserTyping {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.from_id.serialize(buf);
            self.action.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateChatUserTyping {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let from_id = crate::enums::Peer::deserialize(buf)?;
            let action = crate::enums::SendMessageAction::deserialize(buf)?;
            Ok(UpdateChatUserTyping {
                chat_id,
                from_id,
                action,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateChatUserTyping {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ChatUserTyping(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateConfig {}
    impl crate::Identifiable for UpdateConfig {
        const CONSTRUCTOR_ID: u32 = 2720652550;
    }
    impl crate::Serializable for UpdateConfig {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateConfig {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateConfig {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateConfig {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Config => Ok(UpdateConfig {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateContactsReset {}
    impl crate::Identifiable for UpdateContactsReset {
        const CONSTRUCTOR_ID: u32 = 1887741886;
    }
    impl crate::Serializable for UpdateContactsReset {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateContactsReset {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateContactsReset {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateContactsReset {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ContactsReset => Ok(UpdateContactsReset {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDcOptions {
        pub dc_options: Vec<crate::enums::DcOption>,
    }
    impl crate::Identifiable for UpdateDcOptions {
        const CONSTRUCTOR_ID: u32 = 2388564083;
    }
    impl crate::Serializable for UpdateDcOptions {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.dc_options.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDcOptions {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let dc_options = Vec::<crate::enums::DcOption>::deserialize(buf)?;
            Ok(UpdateDcOptions { dc_options })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDcOptions {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DcOptions(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDeleteChannelMessages {
        pub channel_id: i64,
        pub messages: Vec<i32>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateDeleteChannelMessages {
        const CONSTRUCTOR_ID: u32 = 3274529554;
    }
    impl crate::Serializable for UpdateDeleteChannelMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.messages.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDeleteChannelMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let messages = Vec::<i32>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateDeleteChannelMessages {
                channel_id,
                messages,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDeleteChannelMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DeleteChannelMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDeleteMessages {
        pub messages: Vec<i32>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateDeleteMessages {
        const CONSTRUCTOR_ID: u32 = 2718806245;
    }
    impl crate::Serializable for UpdateDeleteMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.messages.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDeleteMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let messages = Vec::<i32>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateDeleteMessages {
                messages,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDeleteMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DeleteMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDeleteScheduledMessages {
        pub peer: crate::enums::Peer,
        pub messages: Vec<i32>,
    }
    impl crate::Identifiable for UpdateDeleteScheduledMessages {
        const CONSTRUCTOR_ID: u32 = 2424728814;
    }
    impl crate::Serializable for UpdateDeleteScheduledMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.messages.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDeleteScheduledMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let messages = Vec::<i32>::deserialize(buf)?;
            Ok(UpdateDeleteScheduledMessages { peer, messages })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDeleteScheduledMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DeleteScheduledMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDialogFilter {
        pub id: i32,
        pub filter: Option<crate::enums::DialogFilter>,
    }
    impl crate::Identifiable for UpdateDialogFilter {
        const CONSTRUCTOR_ID: u32 = 654302845;
    }
    impl crate::Serializable for UpdateDialogFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.filter.is_some() { 1 } else { 0 }).serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.filter {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateDialogFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = i32::deserialize(buf)?;
            let filter = if (flags & 1) != 0 {
                Some(crate::enums::DialogFilter::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateDialogFilter { id, filter })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDialogFilter {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DialogFilter(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDialogFilterOrder {
        pub order: Vec<i32>,
    }
    impl crate::Identifiable for UpdateDialogFilterOrder {
        const CONSTRUCTOR_ID: u32 = 2782339333;
    }
    impl crate::Serializable for UpdateDialogFilterOrder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.order.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDialogFilterOrder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let order = Vec::<i32>::deserialize(buf)?;
            Ok(UpdateDialogFilterOrder { order })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDialogFilterOrder {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DialogFilterOrder(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDialogFilters {}
    impl crate::Identifiable for UpdateDialogFilters {
        const CONSTRUCTOR_ID: u32 = 889491791;
    }
    impl crate::Serializable for UpdateDialogFilters {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateDialogFilters {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateDialogFilters {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDialogFilters {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DialogFilters => Ok(UpdateDialogFilters {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDialogPinned {
        pub pinned: bool,
        pub folder_id: Option<i32>,
        pub peer: crate::enums::DialogPeer,
    }
    impl crate::Identifiable for UpdateDialogPinned {
        const CONSTRUCTOR_ID: u32 = 1852826908;
    }
    impl crate::Serializable for UpdateDialogPinned {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.pinned { 1 } else { 0 } | if self.folder_id.is_some() { 2 } else { 0 })
                .serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDialogPinned {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let pinned = (flags & 1) != 0;
            let folder_id = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let peer = crate::enums::DialogPeer::deserialize(buf)?;
            Ok(UpdateDialogPinned {
                pinned,
                folder_id,
                peer,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDialogPinned {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DialogPinned(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDialogUnreadMark {
        pub unread: bool,
        pub peer: crate::enums::DialogPeer,
    }
    impl crate::Identifiable for UpdateDialogUnreadMark {
        const CONSTRUCTOR_ID: u32 = 3781450179;
    }
    impl crate::Serializable for UpdateDialogUnreadMark {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.unread { 1 } else { 0 }).serialize(buf);
            self.peer.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDialogUnreadMark {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let unread = (flags & 1) != 0;
            let peer = crate::enums::DialogPeer::deserialize(buf)?;
            Ok(UpdateDialogUnreadMark { unread, peer })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDialogUnreadMark {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DialogUnreadMark(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateDraftMessage {
        pub peer: crate::enums::Peer,
        pub draft: crate::enums::DraftMessage,
    }
    impl crate::Identifiable for UpdateDraftMessage {
        const CONSTRUCTOR_ID: u32 = 3995842921;
    }
    impl crate::Serializable for UpdateDraftMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.draft.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateDraftMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let draft = crate::enums::DraftMessage::deserialize(buf)?;
            Ok(UpdateDraftMessage { peer, draft })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateDraftMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::DraftMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateEditChannelMessage {
        pub message: crate::enums::Message,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateEditChannelMessage {
        const CONSTRUCTOR_ID: u32 = 457133559;
    }
    impl crate::Serializable for UpdateEditChannelMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateEditChannelMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateEditChannelMessage {
                message,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateEditChannelMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::EditChannelMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateEditMessage {
        pub message: crate::enums::Message,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateEditMessage {
        const CONSTRUCTOR_ID: u32 = 3825430691;
    }
    impl crate::Serializable for UpdateEditMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateEditMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateEditMessage {
                message,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateEditMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::EditMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateEncryptedChatTyping {
        pub chat_id: i32,
    }
    impl crate::Identifiable for UpdateEncryptedChatTyping {
        const CONSTRUCTOR_ID: u32 = 386986326;
    }
    impl crate::Serializable for UpdateEncryptedChatTyping {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateEncryptedChatTyping {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i32::deserialize(buf)?;
            Ok(UpdateEncryptedChatTyping { chat_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateEncryptedChatTyping {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::EncryptedChatTyping(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateEncryptedMessagesRead {
        pub chat_id: i32,
        pub max_date: i32,
        pub date: i32,
    }
    impl crate::Identifiable for UpdateEncryptedMessagesRead {
        const CONSTRUCTOR_ID: u32 = 956179895;
    }
    impl crate::Serializable for UpdateEncryptedMessagesRead {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.max_date.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateEncryptedMessagesRead {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i32::deserialize(buf)?;
            let max_date = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(UpdateEncryptedMessagesRead {
                chat_id,
                max_date,
                date,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateEncryptedMessagesRead {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::EncryptedMessagesRead(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateEncryption {
        pub chat: crate::enums::EncryptedChat,
        pub date: i32,
    }
    impl crate::Identifiable for UpdateEncryption {
        const CONSTRUCTOR_ID: u32 = 3030575245;
    }
    impl crate::Serializable for UpdateEncryption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateEncryption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat = crate::enums::EncryptedChat::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(UpdateEncryption { chat, date })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateEncryption {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Encryption(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateFavedStickers {}
    impl crate::Identifiable for UpdateFavedStickers {
        const CONSTRUCTOR_ID: u32 = 3843135853;
    }
    impl crate::Serializable for UpdateFavedStickers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateFavedStickers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateFavedStickers {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateFavedStickers {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::FavedStickers => Ok(UpdateFavedStickers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateFolderPeers {
        pub folder_peers: Vec<crate::enums::FolderPeer>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateFolderPeers {
        const CONSTRUCTOR_ID: u32 = 422972864;
    }
    impl crate::Serializable for UpdateFolderPeers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.folder_peers.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateFolderPeers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let folder_peers = Vec::<crate::enums::FolderPeer>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateFolderPeers {
                folder_peers,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateFolderPeers {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::FolderPeers(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateGeoLiveViewed {
        pub peer: crate::enums::Peer,
        pub msg_id: i32,
    }
    impl crate::Identifiable for UpdateGeoLiveViewed {
        const CONSTRUCTOR_ID: u32 = 2267003193;
    }
    impl crate::Serializable for UpdateGeoLiveViewed {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.msg_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateGeoLiveViewed {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let msg_id = i32::deserialize(buf)?;
            Ok(UpdateGeoLiveViewed { peer, msg_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateGeoLiveViewed {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::GeoLiveViewed(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateGroupCall {
        pub chat_id: i64,
        pub call: crate::enums::GroupCall,
    }
    impl crate::Identifiable for UpdateGroupCall {
        const CONSTRUCTOR_ID: u32 = 347227392;
    }
    impl crate::Serializable for UpdateGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.chat_id.serialize(buf);
            self.call.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let chat_id = i64::deserialize(buf)?;
            let call = crate::enums::GroupCall::deserialize(buf)?;
            Ok(UpdateGroupCall { chat_id, call })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateGroupCall {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::GroupCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateGroupCallConnection {
        pub presentation: bool,
        pub params: crate::enums::DataJson,
    }
    impl crate::Identifiable for UpdateGroupCallConnection {
        const CONSTRUCTOR_ID: u32 = 192428418;
    }
    impl crate::Serializable for UpdateGroupCallConnection {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.presentation { 1 } else { 0 }).serialize(buf);
            self.params.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateGroupCallConnection {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let presentation = (flags & 1) != 0;
            let params = crate::enums::DataJson::deserialize(buf)?;
            Ok(UpdateGroupCallConnection {
                presentation,
                params,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateGroupCallConnection {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::GroupCallConnection(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateGroupCallParticipants {
        pub call: crate::enums::InputGroupCall,
        pub participants: Vec<crate::enums::GroupCallParticipant>,
        pub version: i32,
    }
    impl crate::Identifiable for UpdateGroupCallParticipants {
        const CONSTRUCTOR_ID: u32 = 4075543374;
    }
    impl crate::Serializable for UpdateGroupCallParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.call.serialize(buf);
            self.participants.serialize(buf);
            self.version.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateGroupCallParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let call = crate::enums::InputGroupCall::deserialize(buf)?;
            let participants = Vec::<crate::enums::GroupCallParticipant>::deserialize(buf)?;
            let version = i32::deserialize(buf)?;
            Ok(UpdateGroupCallParticipants {
                call,
                participants,
                version,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateGroupCallParticipants {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::GroupCallParticipants(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateInlineBotCallbackQuery {
        pub query_id: i64,
        pub user_id: i64,
        pub msg_id: crate::enums::InputBotInlineMessageId,
        pub chat_instance: i64,
        pub data: Option<Vec<u8>>,
        pub game_short_name: Option<String>,
    }
    impl crate::Identifiable for UpdateInlineBotCallbackQuery {
        const CONSTRUCTOR_ID: u32 = 1763610706;
    }
    impl crate::Serializable for UpdateInlineBotCallbackQuery {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.data.is_some() { 1 } else { 0 }
                | if self.game_short_name.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.query_id.serialize(buf);
            self.user_id.serialize(buf);
            self.msg_id.serialize(buf);
            self.chat_instance.serialize(buf);
            if let Some(ref x) = self.data {
                x.serialize(buf);
            }
            if let Some(ref x) = self.game_short_name {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateInlineBotCallbackQuery {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let query_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let msg_id = crate::enums::InputBotInlineMessageId::deserialize(buf)?;
            let chat_instance = i64::deserialize(buf)?;
            let data = if (flags & 1) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            let game_short_name = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateInlineBotCallbackQuery {
                query_id,
                user_id,
                msg_id,
                chat_instance,
                data,
                game_short_name,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateInlineBotCallbackQuery {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::InlineBotCallbackQuery(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateLangPack {
        pub difference: crate::enums::LangPackDifference,
    }
    impl crate::Identifiable for UpdateLangPack {
        const CONSTRUCTOR_ID: u32 = 1442983757;
    }
    impl crate::Serializable for UpdateLangPack {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.difference.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateLangPack {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let difference = crate::enums::LangPackDifference::deserialize(buf)?;
            Ok(UpdateLangPack { difference })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateLangPack {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::LangPack(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateLangPackTooLong {
        pub lang_code: String,
    }
    impl crate::Identifiable for UpdateLangPackTooLong {
        const CONSTRUCTOR_ID: u32 = 1180041828;
    }
    impl crate::Serializable for UpdateLangPackTooLong {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.lang_code.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateLangPackTooLong {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let lang_code = String::deserialize(buf)?;
            Ok(UpdateLangPackTooLong { lang_code })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateLangPackTooLong {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::LangPackTooLong(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateLoginToken {}
    impl crate::Identifiable for UpdateLoginToken {
        const CONSTRUCTOR_ID: u32 = 1448076945;
    }
    impl crate::Serializable for UpdateLoginToken {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateLoginToken {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateLoginToken {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateLoginToken {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::LoginToken => Ok(UpdateLoginToken {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateMessageId {
        pub id: i32,
        pub random_id: i64,
    }
    impl crate::Identifiable for UpdateMessageId {
        const CONSTRUCTOR_ID: u32 = 1318109142;
    }
    impl crate::Serializable for UpdateMessageId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.random_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateMessageId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i32::deserialize(buf)?;
            let random_id = i64::deserialize(buf)?;
            Ok(UpdateMessageId { id, random_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateMessageId {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::MessageId(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateMessagePoll {
        pub poll_id: i64,
        pub poll: Option<crate::enums::Poll>,
        pub results: crate::enums::PollResults,
    }
    impl crate::Identifiable for UpdateMessagePoll {
        const CONSTRUCTOR_ID: u32 = 2896258427;
    }
    impl crate::Serializable for UpdateMessagePoll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.poll.is_some() { 1 } else { 0 }).serialize(buf);
            self.poll_id.serialize(buf);
            if let Some(ref x) = self.poll {
                x.serialize(buf);
            }
            self.results.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateMessagePoll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let poll_id = i64::deserialize(buf)?;
            let poll = if (flags & 1) != 0 {
                Some(crate::enums::Poll::deserialize(buf)?)
            } else {
                None
            };
            let results = crate::enums::PollResults::deserialize(buf)?;
            Ok(UpdateMessagePoll {
                poll_id,
                poll,
                results,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateMessagePoll {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::MessagePoll(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateMessagePollVote {
        pub poll_id: i64,
        pub user_id: i64,
        pub options: Vec<Vec<u8>>,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateMessagePollVote {
        const CONSTRUCTOR_ID: u32 = 274961865;
    }
    impl crate::Serializable for UpdateMessagePollVote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.poll_id.serialize(buf);
            self.user_id.serialize(buf);
            self.options.serialize(buf);
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateMessagePollVote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let poll_id = i64::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let options = Vec::<Vec<u8>>::deserialize(buf)?;
            let qts = i32::deserialize(buf)?;
            Ok(UpdateMessagePollVote {
                poll_id,
                user_id,
                options,
                qts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateMessagePollVote {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::MessagePollVote(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNewChannelMessage {
        pub message: crate::enums::Message,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateNewChannelMessage {
        const CONSTRUCTOR_ID: u32 = 1656358105;
    }
    impl crate::Serializable for UpdateNewChannelMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNewChannelMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateNewChannelMessage {
                message,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNewChannelMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NewChannelMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNewEncryptedMessage {
        pub message: crate::enums::EncryptedMessage,
        pub qts: i32,
    }
    impl crate::Identifiable for UpdateNewEncryptedMessage {
        const CONSTRUCTOR_ID: u32 = 314359194;
    }
    impl crate::Serializable for UpdateNewEncryptedMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
            self.qts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNewEncryptedMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::EncryptedMessage::deserialize(buf)?;
            let qts = i32::deserialize(buf)?;
            Ok(UpdateNewEncryptedMessage { message, qts })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNewEncryptedMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NewEncryptedMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNewMessage {
        pub message: crate::enums::Message,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateNewMessage {
        const CONSTRUCTOR_ID: u32 = 522914557;
    }
    impl crate::Serializable for UpdateNewMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNewMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateNewMessage {
                message,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNewMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NewMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNewScheduledMessage {
        pub message: crate::enums::Message,
    }
    impl crate::Identifiable for UpdateNewScheduledMessage {
        const CONSTRUCTOR_ID: u32 = 967122427;
    }
    impl crate::Serializable for UpdateNewScheduledMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.message.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNewScheduledMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let message = crate::enums::Message::deserialize(buf)?;
            Ok(UpdateNewScheduledMessage { message })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNewScheduledMessage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NewScheduledMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNewStickerSet {
        pub stickerset: crate::enums::messages::StickerSet,
    }
    impl crate::Identifiable for UpdateNewStickerSet {
        const CONSTRUCTOR_ID: u32 = 1753886890;
    }
    impl crate::Serializable for UpdateNewStickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.stickerset.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNewStickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let stickerset = crate::enums::messages::StickerSet::deserialize(buf)?;
            Ok(UpdateNewStickerSet { stickerset })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNewStickerSet {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NewStickerSet(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateNotifySettings {
        pub peer: crate::enums::NotifyPeer,
        pub notify_settings: crate::enums::PeerNotifySettings,
    }
    impl crate::Identifiable for UpdateNotifySettings {
        const CONSTRUCTOR_ID: u32 = 3200411887;
    }
    impl crate::Serializable for UpdateNotifySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.notify_settings.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateNotifySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::NotifyPeer::deserialize(buf)?;
            let notify_settings = crate::enums::PeerNotifySettings::deserialize(buf)?;
            Ok(UpdateNotifySettings {
                peer,
                notify_settings,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateNotifySettings {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::NotifySettings(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePeerBlocked {
        pub peer_id: crate::enums::Peer,
        pub blocked: bool,
    }
    impl crate::Identifiable for UpdatePeerBlocked {
        const CONSTRUCTOR_ID: u32 = 610945826;
    }
    impl crate::Serializable for UpdatePeerBlocked {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer_id.serialize(buf);
            self.blocked.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePeerBlocked {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer_id = crate::enums::Peer::deserialize(buf)?;
            let blocked = bool::deserialize(buf)?;
            Ok(UpdatePeerBlocked { peer_id, blocked })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePeerBlocked {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PeerBlocked(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePeerHistoryTtl {
        pub peer: crate::enums::Peer,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for UpdatePeerHistoryTtl {
        const CONSTRUCTOR_ID: u32 = 3147544997;
    }
    impl crate::Serializable for UpdatePeerHistoryTtl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.ttl_period.is_some() { 1 } else { 0 }).serialize(buf);
            self.peer.serialize(buf);
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdatePeerHistoryTtl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let ttl_period = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdatePeerHistoryTtl { peer, ttl_period })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePeerHistoryTtl {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PeerHistoryTtl(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePeerLocated {
        pub peers: Vec<crate::enums::PeerLocated>,
    }
    impl crate::Identifiable for UpdatePeerLocated {
        const CONSTRUCTOR_ID: u32 = 3031420848;
    }
    impl crate::Serializable for UpdatePeerLocated {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peers.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePeerLocated {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peers = Vec::<crate::enums::PeerLocated>::deserialize(buf)?;
            Ok(UpdatePeerLocated { peers })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePeerLocated {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PeerLocated(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePeerSettings {
        pub peer: crate::enums::Peer,
        pub settings: crate::enums::PeerSettings,
    }
    impl crate::Identifiable for UpdatePeerSettings {
        const CONSTRUCTOR_ID: u32 = 1786671974;
    }
    impl crate::Serializable for UpdatePeerSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.settings.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePeerSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let settings = crate::enums::PeerSettings::deserialize(buf)?;
            Ok(UpdatePeerSettings { peer, settings })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePeerSettings {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PeerSettings(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePendingJoinRequests {
        pub peer: crate::enums::Peer,
        pub requests_pending: i32,
        pub recent_requesters: Vec<i64>,
    }
    impl crate::Identifiable for UpdatePendingJoinRequests {
        const CONSTRUCTOR_ID: u32 = 1885586395;
    }
    impl crate::Serializable for UpdatePendingJoinRequests {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.requests_pending.serialize(buf);
            self.recent_requesters.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePendingJoinRequests {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let requests_pending = i32::deserialize(buf)?;
            let recent_requesters = Vec::<i64>::deserialize(buf)?;
            Ok(UpdatePendingJoinRequests {
                peer,
                requests_pending,
                recent_requesters,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePendingJoinRequests {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PendingJoinRequests(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePhoneCall {
        pub phone_call: crate::enums::PhoneCall,
    }
    impl crate::Identifiable for UpdatePhoneCall {
        const CONSTRUCTOR_ID: u32 = 2869914398;
    }
    impl crate::Serializable for UpdatePhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone_call.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone_call = crate::enums::PhoneCall::deserialize(buf)?;
            Ok(UpdatePhoneCall { phone_call })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePhoneCall {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PhoneCall(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePhoneCallSignalingData {
        pub phone_call_id: i64,
        pub data: Vec<u8>,
    }
    impl crate::Identifiable for UpdatePhoneCallSignalingData {
        const CONSTRUCTOR_ID: u32 = 643940105;
    }
    impl crate::Serializable for UpdatePhoneCallSignalingData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.phone_call_id.serialize(buf);
            self.data.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePhoneCallSignalingData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let phone_call_id = i64::deserialize(buf)?;
            let data = Vec::<u8>::deserialize(buf)?;
            Ok(UpdatePhoneCallSignalingData {
                phone_call_id,
                data,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePhoneCallSignalingData {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PhoneCallSignalingData(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePinnedChannelMessages {
        pub pinned: bool,
        pub channel_id: i64,
        pub messages: Vec<i32>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdatePinnedChannelMessages {
        const CONSTRUCTOR_ID: u32 = 1538885128;
    }
    impl crate::Serializable for UpdatePinnedChannelMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.pinned { 1 } else { 0 }).serialize(buf);
            self.channel_id.serialize(buf);
            self.messages.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePinnedChannelMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let pinned = (flags & 1) != 0;
            let channel_id = i64::deserialize(buf)?;
            let messages = Vec::<i32>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdatePinnedChannelMessages {
                pinned,
                channel_id,
                messages,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePinnedChannelMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PinnedChannelMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePinnedDialogs {
        pub folder_id: Option<i32>,
        pub order: Option<Vec<crate::enums::DialogPeer>>,
    }
    impl crate::Identifiable for UpdatePinnedDialogs {
        const CONSTRUCTOR_ID: u32 = 4195302562;
    }
    impl crate::Serializable for UpdatePinnedDialogs {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.folder_id.is_some() { 2 } else { 0 }
                | if self.order.is_some() { 1 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.order {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdatePinnedDialogs {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let folder_id = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let order = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::DialogPeer>::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdatePinnedDialogs { folder_id, order })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePinnedDialogs {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PinnedDialogs(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePinnedMessages {
        pub pinned: bool,
        pub peer: crate::enums::Peer,
        pub messages: Vec<i32>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdatePinnedMessages {
        const CONSTRUCTOR_ID: u32 = 3984976565;
    }
    impl crate::Serializable for UpdatePinnedMessages {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.pinned { 1 } else { 0 }).serialize(buf);
            self.peer.serialize(buf);
            self.messages.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePinnedMessages {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let pinned = (flags & 1) != 0;
            let peer = crate::enums::Peer::deserialize(buf)?;
            let messages = Vec::<i32>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdatePinnedMessages {
                pinned,
                peer,
                messages,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePinnedMessages {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PinnedMessages(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePrivacy {
        pub key: crate::enums::PrivacyKey,
        pub rules: Vec<crate::enums::PrivacyRule>,
    }
    impl crate::Identifiable for UpdatePrivacy {
        const CONSTRUCTOR_ID: u32 = 3996854058;
    }
    impl crate::Serializable for UpdatePrivacy {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.key.serialize(buf);
            self.rules.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatePrivacy {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let key = crate::enums::PrivacyKey::deserialize(buf)?;
            let rules = Vec::<crate::enums::PrivacyRule>::deserialize(buf)?;
            Ok(UpdatePrivacy { key, rules })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePrivacy {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Privacy(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatePtsChanged {}
    impl crate::Identifiable for UpdatePtsChanged {
        const CONSTRUCTOR_ID: u32 = 861169551;
    }
    impl crate::Serializable for UpdatePtsChanged {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdatePtsChanged {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdatePtsChanged {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdatePtsChanged {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::PtsChanged => Ok(UpdatePtsChanged {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadChannelDiscussionInbox {
        pub channel_id: i64,
        pub top_msg_id: i32,
        pub read_max_id: i32,
        pub broadcast_id: Option<i64>,
        pub broadcast_post: Option<i32>,
    }
    impl crate::Identifiable for UpdateReadChannelDiscussionInbox {
        const CONSTRUCTOR_ID: u32 = 3601962310;
    }
    impl crate::Serializable for UpdateReadChannelDiscussionInbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.broadcast_id.is_some() { 1 } else { 0 }
                | if self.broadcast_post.is_some() { 1 } else { 0 })
            .serialize(buf);
            self.channel_id.serialize(buf);
            self.top_msg_id.serialize(buf);
            self.read_max_id.serialize(buf);
            if let Some(ref x) = self.broadcast_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.broadcast_post {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateReadChannelDiscussionInbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let channel_id = i64::deserialize(buf)?;
            let top_msg_id = i32::deserialize(buf)?;
            let read_max_id = i32::deserialize(buf)?;
            let broadcast_id = if (flags & 1) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let broadcast_post = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateReadChannelDiscussionInbox {
                channel_id,
                top_msg_id,
                read_max_id,
                broadcast_id,
                broadcast_post,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadChannelDiscussionInbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadChannelDiscussionInbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadChannelDiscussionOutbox {
        pub channel_id: i64,
        pub top_msg_id: i32,
        pub read_max_id: i32,
    }
    impl crate::Identifiable for UpdateReadChannelDiscussionOutbox {
        const CONSTRUCTOR_ID: u32 = 1767677564;
    }
    impl crate::Serializable for UpdateReadChannelDiscussionOutbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.top_msg_id.serialize(buf);
            self.read_max_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadChannelDiscussionOutbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let top_msg_id = i32::deserialize(buf)?;
            let read_max_id = i32::deserialize(buf)?;
            Ok(UpdateReadChannelDiscussionOutbox {
                channel_id,
                top_msg_id,
                read_max_id,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadChannelDiscussionOutbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadChannelDiscussionOutbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadChannelInbox {
        pub folder_id: Option<i32>,
        pub channel_id: i64,
        pub max_id: i32,
        pub still_unread_count: i32,
        pub pts: i32,
    }
    impl crate::Identifiable for UpdateReadChannelInbox {
        const CONSTRUCTOR_ID: u32 = 2452516368;
    }
    impl crate::Serializable for UpdateReadChannelInbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.folder_id.is_some() { 1 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            self.channel_id.serialize(buf);
            self.max_id.serialize(buf);
            self.still_unread_count.serialize(buf);
            self.pts.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadChannelInbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let folder_id = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let channel_id = i64::deserialize(buf)?;
            let max_id = i32::deserialize(buf)?;
            let still_unread_count = i32::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            Ok(UpdateReadChannelInbox {
                folder_id,
                channel_id,
                max_id,
                still_unread_count,
                pts,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadChannelInbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadChannelInbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadChannelOutbox {
        pub channel_id: i64,
        pub max_id: i32,
    }
    impl crate::Identifiable for UpdateReadChannelOutbox {
        const CONSTRUCTOR_ID: u32 = 3076495785;
    }
    impl crate::Serializable for UpdateReadChannelOutbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.channel_id.serialize(buf);
            self.max_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadChannelOutbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let channel_id = i64::deserialize(buf)?;
            let max_id = i32::deserialize(buf)?;
            Ok(UpdateReadChannelOutbox { channel_id, max_id })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadChannelOutbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadChannelOutbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadFeaturedStickers {}
    impl crate::Identifiable for UpdateReadFeaturedStickers {
        const CONSTRUCTOR_ID: u32 = 1461528386;
    }
    impl crate::Serializable for UpdateReadFeaturedStickers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateReadFeaturedStickers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateReadFeaturedStickers {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadFeaturedStickers {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadFeaturedStickers => Ok(UpdateReadFeaturedStickers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadHistoryInbox {
        pub folder_id: Option<i32>,
        pub peer: crate::enums::Peer,
        pub max_id: i32,
        pub still_unread_count: i32,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateReadHistoryInbox {
        const CONSTRUCTOR_ID: u32 = 2627162079;
    }
    impl crate::Serializable for UpdateReadHistoryInbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.folder_id.is_some() { 1 } else { 0 }).serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            self.peer.serialize(buf);
            self.max_id.serialize(buf);
            self.still_unread_count.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadHistoryInbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let folder_id = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let peer = crate::enums::Peer::deserialize(buf)?;
            let max_id = i32::deserialize(buf)?;
            let still_unread_count = i32::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateReadHistoryInbox {
                folder_id,
                peer,
                max_id,
                still_unread_count,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadHistoryInbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadHistoryInbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadHistoryOutbox {
        pub peer: crate::enums::Peer,
        pub max_id: i32,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateReadHistoryOutbox {
        const CONSTRUCTOR_ID: u32 = 791617983;
    }
    impl crate::Serializable for UpdateReadHistoryOutbox {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.peer.serialize(buf);
            self.max_id.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadHistoryOutbox {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let peer = crate::enums::Peer::deserialize(buf)?;
            let max_id = i32::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateReadHistoryOutbox {
                peer,
                max_id,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadHistoryOutbox {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadHistoryOutbox(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateReadMessagesContents {
        pub messages: Vec<i32>,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateReadMessagesContents {
        const CONSTRUCTOR_ID: u32 = 1757493555;
    }
    impl crate::Serializable for UpdateReadMessagesContents {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.messages.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateReadMessagesContents {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let messages = Vec::<i32>::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateReadMessagesContents {
                messages,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateReadMessagesContents {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ReadMessagesContents(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateRecentStickers {}
    impl crate::Identifiable for UpdateRecentStickers {
        const CONSTRUCTOR_ID: u32 = 2588027936;
    }
    impl crate::Serializable for UpdateRecentStickers {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateRecentStickers {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateRecentStickers {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateRecentStickers {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::RecentStickers => Ok(UpdateRecentStickers {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateSavedGifs {}
    impl crate::Identifiable for UpdateSavedGifs {
        const CONSTRUCTOR_ID: u32 = 2473931806;
    }
    impl crate::Serializable for UpdateSavedGifs {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateSavedGifs {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateSavedGifs {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateSavedGifs {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::SavedGifs => Ok(UpdateSavedGifs {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateServiceNotification {
        pub popup: bool,
        pub inbox_date: Option<i32>,
        pub r#type: String,
        pub message: String,
        pub media: crate::enums::MessageMedia,
        pub entities: Vec<crate::enums::MessageEntity>,
    }
    impl crate::Identifiable for UpdateServiceNotification {
        const CONSTRUCTOR_ID: u32 = 3957614617;
    }
    impl crate::Serializable for UpdateServiceNotification {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.popup { 1 } else { 0 } | if self.inbox_date.is_some() { 2 } else { 0 })
                .serialize(buf);
            if let Some(ref x) = self.inbox_date {
                x.serialize(buf);
            }
            self.r#type.serialize(buf);
            self.message.serialize(buf);
            self.media.serialize(buf);
            self.entities.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateServiceNotification {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let popup = (flags & 1) != 0;
            let inbox_date = if (flags & 2) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let r#type = String::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let media = crate::enums::MessageMedia::deserialize(buf)?;
            let entities = Vec::<crate::enums::MessageEntity>::deserialize(buf)?;
            Ok(UpdateServiceNotification {
                popup,
                inbox_date,
                r#type,
                message,
                media,
                entities,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateServiceNotification {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::ServiceNotification(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateShort {
        pub update: crate::enums::Update,
        pub date: i32,
    }
    impl crate::Identifiable for UpdateShort {
        const CONSTRUCTOR_ID: u32 = 2027216577;
    }
    impl crate::Serializable for UpdateShort {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.update.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateShort {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let update = crate::enums::Update::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(UpdateShort { update, date })
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdateShort {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::UpdateShort(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateShortChatMessage {
        pub out: bool,
        pub mentioned: bool,
        pub media_unread: bool,
        pub silent: bool,
        pub id: i32,
        pub from_id: i64,
        pub chat_id: i64,
        pub message: String,
        pub pts: i32,
        pub pts_count: i32,
        pub date: i32,
        pub fwd_from: Option<crate::enums::MessageFwdHeader>,
        pub via_bot_id: Option<i64>,
        pub reply_to: Option<crate::enums::MessageReplyHeader>,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for UpdateShortChatMessage {
        const CONSTRUCTOR_ID: u32 = 1299050149;
    }
    impl crate::Serializable for UpdateShortChatMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.out { 2 } else { 0 }
                | if self.mentioned { 16 } else { 0 }
                | if self.media_unread { 32 } else { 0 }
                | if self.silent { 8192 } else { 0 }
                | if self.fwd_from.is_some() { 4 } else { 0 }
                | if self.via_bot_id.is_some() { 2048 } else { 0 }
                | if self.reply_to.is_some() { 8 } else { 0 }
                | if self.entities.is_some() { 128 } else { 0 }
                | if self.ttl_period.is_some() {
                    33554432
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.from_id.serialize(buf);
            self.chat_id.serialize(buf);
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.fwd_from {
                x.serialize(buf);
            }
            if let Some(ref x) = self.via_bot_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_to {
                x.serialize(buf);
            }
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateShortChatMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let out = (flags & 2) != 0;
            let mentioned = (flags & 16) != 0;
            let media_unread = (flags & 32) != 0;
            let silent = (flags & 8192) != 0;
            let id = i32::deserialize(buf)?;
            let from_id = i64::deserialize(buf)?;
            let chat_id = i64::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let fwd_from = if (flags & 4) != 0 {
                Some(crate::enums::MessageFwdHeader::deserialize(buf)?)
            } else {
                None
            };
            let via_bot_id = if (flags & 2048) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let reply_to = if (flags & 8) != 0 {
                Some(crate::enums::MessageReplyHeader::deserialize(buf)?)
            } else {
                None
            };
            let entities = if (flags & 128) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 33554432) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateShortChatMessage {
                out,
                mentioned,
                media_unread,
                silent,
                id,
                from_id,
                chat_id,
                message,
                pts,
                pts_count,
                date,
                fwd_from,
                via_bot_id,
                reply_to,
                entities,
                ttl_period,
            })
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdateShortChatMessage {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::UpdateShortChatMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateShortMessage {
        pub out: bool,
        pub mentioned: bool,
        pub media_unread: bool,
        pub silent: bool,
        pub id: i32,
        pub user_id: i64,
        pub message: String,
        pub pts: i32,
        pub pts_count: i32,
        pub date: i32,
        pub fwd_from: Option<crate::enums::MessageFwdHeader>,
        pub via_bot_id: Option<i64>,
        pub reply_to: Option<crate::enums::MessageReplyHeader>,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for UpdateShortMessage {
        const CONSTRUCTOR_ID: u32 = 826001400;
    }
    impl crate::Serializable for UpdateShortMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.out { 2 } else { 0 }
                | if self.mentioned { 16 } else { 0 }
                | if self.media_unread { 32 } else { 0 }
                | if self.silent { 8192 } else { 0 }
                | if self.fwd_from.is_some() { 4 } else { 0 }
                | if self.via_bot_id.is_some() { 2048 } else { 0 }
                | if self.reply_to.is_some() { 8 } else { 0 }
                | if self.entities.is_some() { 128 } else { 0 }
                | if self.ttl_period.is_some() {
                    33554432
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.user_id.serialize(buf);
            self.message.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.fwd_from {
                x.serialize(buf);
            }
            if let Some(ref x) = self.via_bot_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.reply_to {
                x.serialize(buf);
            }
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateShortMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let out = (flags & 2) != 0;
            let mentioned = (flags & 16) != 0;
            let media_unread = (flags & 32) != 0;
            let silent = (flags & 8192) != 0;
            let id = i32::deserialize(buf)?;
            let user_id = i64::deserialize(buf)?;
            let message = String::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let fwd_from = if (flags & 4) != 0 {
                Some(crate::enums::MessageFwdHeader::deserialize(buf)?)
            } else {
                None
            };
            let via_bot_id = if (flags & 2048) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let reply_to = if (flags & 8) != 0 {
                Some(crate::enums::MessageReplyHeader::deserialize(buf)?)
            } else {
                None
            };
            let entities = if (flags & 128) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 33554432) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateShortMessage {
                out,
                mentioned,
                media_unread,
                silent,
                id,
                user_id,
                message,
                pts,
                pts_count,
                date,
                fwd_from,
                via_bot_id,
                reply_to,
                entities,
                ttl_period,
            })
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdateShortMessage {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::UpdateShortMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateShortSentMessage {
        pub out: bool,
        pub id: i32,
        pub pts: i32,
        pub pts_count: i32,
        pub date: i32,
        pub media: Option<crate::enums::MessageMedia>,
        pub entities: Option<Vec<crate::enums::MessageEntity>>,
        pub ttl_period: Option<i32>,
    }
    impl crate::Identifiable for UpdateShortSentMessage {
        const CONSTRUCTOR_ID: u32 = 2417352961;
    }
    impl crate::Serializable for UpdateShortSentMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.out { 2 } else { 0 }
                | if self.media.is_some() { 512 } else { 0 }
                | if self.entities.is_some() { 128 } else { 0 }
                | if self.ttl_period.is_some() {
                    33554432
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
            self.date.serialize(buf);
            if let Some(ref x) = self.media {
                x.serialize(buf);
            }
            if let Some(ref x) = self.entities {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UpdateShortSentMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let out = (flags & 2) != 0;
            let id = i32::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let media = if (flags & 512) != 0 {
                Some(crate::enums::MessageMedia::deserialize(buf)?)
            } else {
                None
            };
            let entities = if (flags & 128) != 0 {
                Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 33554432) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(UpdateShortSentMessage {
                out,
                id,
                pts,
                pts_count,
                date,
                media,
                entities,
                ttl_period,
            })
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdateShortSentMessage {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::UpdateShortSentMessage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateStickerSets {}
    impl crate::Identifiable for UpdateStickerSets {
        const CONSTRUCTOR_ID: u32 = 1135492588;
    }
    impl crate::Serializable for UpdateStickerSets {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdateStickerSets {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdateStickerSets {})
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateStickerSets {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::StickerSets => Ok(UpdateStickerSets {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateStickerSetsOrder {
        pub masks: bool,
        pub order: Vec<i64>,
    }
    impl crate::Identifiable for UpdateStickerSetsOrder {
        const CONSTRUCTOR_ID: u32 = 196268545;
    }
    impl crate::Serializable for UpdateStickerSetsOrder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.masks { 1 } else { 0 }).serialize(buf);
            self.order.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateStickerSetsOrder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let masks = (flags & 1) != 0;
            let order = Vec::<i64>::deserialize(buf)?;
            Ok(UpdateStickerSetsOrder { masks, order })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateStickerSetsOrder {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::StickerSetsOrder(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateTheme {
        pub theme: crate::enums::Theme,
    }
    impl crate::Identifiable for UpdateTheme {
        const CONSTRUCTOR_ID: u32 = 2182544291;
    }
    impl crate::Serializable for UpdateTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.theme.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let theme = crate::enums::Theme::deserialize(buf)?;
            Ok(UpdateTheme { theme })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateTheme {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::Theme(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateUserName {
        pub user_id: i64,
        pub first_name: String,
        pub last_name: String,
        pub username: String,
    }
    impl crate::Identifiable for UpdateUserName {
        const CONSTRUCTOR_ID: u32 = 3287417568;
    }
    impl crate::Serializable for UpdateUserName {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.first_name.serialize(buf);
            self.last_name.serialize(buf);
            self.username.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateUserName {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let first_name = String::deserialize(buf)?;
            let last_name = String::deserialize(buf)?;
            let username = String::deserialize(buf)?;
            Ok(UpdateUserName {
                user_id,
                first_name,
                last_name,
                username,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateUserName {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::UserName(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateUserPhone {
        pub user_id: i64,
        pub phone: String,
    }
    impl crate::Identifiable for UpdateUserPhone {
        const CONSTRUCTOR_ID: u32 = 88680979;
    }
    impl crate::Serializable for UpdateUserPhone {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.phone.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateUserPhone {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let phone = String::deserialize(buf)?;
            Ok(UpdateUserPhone { user_id, phone })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateUserPhone {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::UserPhone(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateUserPhoto {
        pub user_id: i64,
        pub date: i32,
        pub photo: crate::enums::UserProfilePhoto,
        pub previous: bool,
    }
    impl crate::Identifiable for UpdateUserPhoto {
        const CONSTRUCTOR_ID: u32 = 4062676620;
    }
    impl crate::Serializable for UpdateUserPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.date.serialize(buf);
            self.photo.serialize(buf);
            self.previous.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateUserPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let photo = crate::enums::UserProfilePhoto::deserialize(buf)?;
            let previous = bool::deserialize(buf)?;
            Ok(UpdateUserPhoto {
                user_id,
                date,
                photo,
                previous,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateUserPhoto {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::UserPhoto(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateUserStatus {
        pub user_id: i64,
        pub status: crate::enums::UserStatus,
    }
    impl crate::Identifiable for UpdateUserStatus {
        const CONSTRUCTOR_ID: u32 = 3854432478;
    }
    impl crate::Serializable for UpdateUserStatus {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.status.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateUserStatus {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let status = crate::enums::UserStatus::deserialize(buf)?;
            Ok(UpdateUserStatus { user_id, status })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateUserStatus {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::UserStatus(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateUserTyping {
        pub user_id: i64,
        pub action: crate::enums::SendMessageAction,
    }
    impl crate::Identifiable for UpdateUserTyping {
        const CONSTRUCTOR_ID: u32 = 3223225727;
    }
    impl crate::Serializable for UpdateUserTyping {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.user_id.serialize(buf);
            self.action.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateUserTyping {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let user_id = i64::deserialize(buf)?;
            let action = crate::enums::SendMessageAction::deserialize(buf)?;
            Ok(UpdateUserTyping { user_id, action })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateUserTyping {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::UserTyping(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateWebPage {
        pub webpage: crate::enums::WebPage,
        pub pts: i32,
        pub pts_count: i32,
    }
    impl crate::Identifiable for UpdateWebPage {
        const CONSTRUCTOR_ID: u32 = 2139689491;
    }
    impl crate::Serializable for UpdateWebPage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.webpage.serialize(buf);
            self.pts.serialize(buf);
            self.pts_count.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdateWebPage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let webpage = crate::enums::WebPage::deserialize(buf)?;
            let pts = i32::deserialize(buf)?;
            let pts_count = i32::deserialize(buf)?;
            Ok(UpdateWebPage {
                webpage,
                pts,
                pts_count,
            })
        }
    }
    impl TryFrom<crate::enums::Update> for UpdateWebPage {
        type Error = ();
        fn try_from(x: crate::enums::Update) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Update::WebPage(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Updates {
        pub updates: Vec<crate::enums::Update>,
        pub users: Vec<crate::enums::User>,
        pub chats: Vec<crate::enums::Chat>,
        pub date: i32,
        pub seq: i32,
    }
    impl crate::Identifiable for Updates {
        const CONSTRUCTOR_ID: u32 = 1957577280;
    }
    impl crate::Serializable for Updates {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.updates.serialize(buf);
            self.users.serialize(buf);
            self.chats.serialize(buf);
            self.date.serialize(buf);
            self.seq.serialize(buf);
        }
    }
    impl crate::Deserializable for Updates {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let updates = Vec::<crate::enums::Update>::deserialize(buf)?;
            let users = Vec::<crate::enums::User>::deserialize(buf)?;
            let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let seq = i32::deserialize(buf)?;
            Ok(Updates {
                updates,
                users,
                chats,
                date,
                seq,
            })
        }
    }
    impl TryFrom<crate::enums::Updates> for Updates {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::Updates(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatesCombined {
        pub updates: Vec<crate::enums::Update>,
        pub users: Vec<crate::enums::User>,
        pub chats: Vec<crate::enums::Chat>,
        pub date: i32,
        pub seq_start: i32,
        pub seq: i32,
    }
    impl crate::Identifiable for UpdatesCombined {
        const CONSTRUCTOR_ID: u32 = 1918567619;
    }
    impl crate::Serializable for UpdatesCombined {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.updates.serialize(buf);
            self.users.serialize(buf);
            self.chats.serialize(buf);
            self.date.serialize(buf);
            self.seq_start.serialize(buf);
            self.seq.serialize(buf);
        }
    }
    impl crate::Deserializable for UpdatesCombined {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let updates = Vec::<crate::enums::Update>::deserialize(buf)?;
            let users = Vec::<crate::enums::User>::deserialize(buf)?;
            let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            let seq_start = i32::deserialize(buf)?;
            let seq = i32::deserialize(buf)?;
            Ok(UpdatesCombined {
                updates,
                users,
                chats,
                date,
                seq_start,
                seq,
            })
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdatesCombined {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::Combined(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdatesTooLong {}
    impl crate::Identifiable for UpdatesTooLong {
        const CONSTRUCTOR_ID: u32 = 3809980286;
    }
    impl crate::Serializable for UpdatesTooLong {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UpdatesTooLong {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UpdatesTooLong {})
        }
    }
    impl TryFrom<crate::enums::Updates> for UpdatesTooLong {
        type Error = ();
        fn try_from(x: crate::enums::Updates) -> Result<Self, Self::Error> {
            match x {
                crate::enums::Updates::TooLong => Ok(UpdatesTooLong {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UrlAuthResultAccepted {
        pub url: String,
    }
    impl crate::Identifiable for UrlAuthResultAccepted {
        const CONSTRUCTOR_ID: u32 = 2408320590;
    }
    impl crate::Serializable for UrlAuthResultAccepted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
        }
    }
    impl crate::Deserializable for UrlAuthResultAccepted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            Ok(UrlAuthResultAccepted { url })
        }
    }
    impl TryFrom<crate::enums::UrlAuthResult> for UrlAuthResultAccepted {
        type Error = ();
        fn try_from(x: crate::enums::UrlAuthResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UrlAuthResult::Accepted(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UrlAuthResultDefault {}
    impl crate::Identifiable for UrlAuthResultDefault {
        const CONSTRUCTOR_ID: u32 = 2849430303;
    }
    impl crate::Serializable for UrlAuthResultDefault {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UrlAuthResultDefault {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UrlAuthResultDefault {})
        }
    }
    impl TryFrom<crate::enums::UrlAuthResult> for UrlAuthResultDefault {
        type Error = ();
        fn try_from(x: crate::enums::UrlAuthResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UrlAuthResult::Default => Ok(UrlAuthResultDefault {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UrlAuthResultRequest {
        pub request_write_access: bool,
        pub bot: crate::enums::User,
        pub domain: String,
    }
    impl crate::Identifiable for UrlAuthResultRequest {
        const CONSTRUCTOR_ID: u32 = 2463316494;
    }
    impl crate::Serializable for UrlAuthResultRequest {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.request_write_access { 1 } else { 0 }).serialize(buf);
            self.bot.serialize(buf);
            self.domain.serialize(buf);
        }
    }
    impl crate::Deserializable for UrlAuthResultRequest {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let request_write_access = (flags & 1) != 0;
            let bot = crate::enums::User::deserialize(buf)?;
            let domain = String::deserialize(buf)?;
            Ok(UrlAuthResultRequest {
                request_write_access,
                bot,
                domain,
            })
        }
    }
    impl TryFrom<crate::enums::UrlAuthResult> for UrlAuthResultRequest {
        type Error = ();
        fn try_from(x: crate::enums::UrlAuthResult) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UrlAuthResult::Request(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct User {
        pub is_self: bool,
        pub contact: bool,
        pub mutual_contact: bool,
        pub deleted: bool,
        pub bot: bool,
        pub bot_chat_history: bool,
        pub bot_nochats: bool,
        pub verified: bool,
        pub restricted: bool,
        pub min: bool,
        pub bot_inline_geo: bool,
        pub support: bool,
        pub scam: bool,
        pub apply_min_photo: bool,
        pub fake: bool,
        pub id: i64,
        pub access_hash: Option<i64>,
        pub first_name: Option<String>,
        pub last_name: Option<String>,
        pub username: Option<String>,
        pub phone: Option<String>,
        pub photo: Option<crate::enums::UserProfilePhoto>,
        pub status: Option<crate::enums::UserStatus>,
        pub bot_info_version: Option<i32>,
        pub restriction_reason: Option<Vec<crate::enums::RestrictionReason>>,
        pub bot_inline_placeholder: Option<String>,
        pub lang_code: Option<String>,
    }
    impl crate::Identifiable for User {
        const CONSTRUCTOR_ID: u32 = 1073147056;
    }
    impl crate::Serializable for User {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.is_self { 1024 } else { 0 }
                | if self.contact { 2048 } else { 0 }
                | if self.mutual_contact { 4096 } else { 0 }
                | if self.deleted { 8192 } else { 0 }
                | if self.bot { 16384 } else { 0 }
                | if self.bot_chat_history { 32768 } else { 0 }
                | if self.bot_nochats { 65536 } else { 0 }
                | if self.verified { 131072 } else { 0 }
                | if self.restricted { 262144 } else { 0 }
                | if self.min { 1048576 } else { 0 }
                | if self.bot_inline_geo { 2097152 } else { 0 }
                | if self.support { 8388608 } else { 0 }
                | if self.scam { 16777216 } else { 0 }
                | if self.apply_min_photo { 33554432 } else { 0 }
                | if self.fake { 67108864 } else { 0 }
                | if self.access_hash.is_some() { 1 } else { 0 }
                | if self.first_name.is_some() { 2 } else { 0 }
                | if self.last_name.is_some() { 4 } else { 0 }
                | if self.username.is_some() { 8 } else { 0 }
                | if self.phone.is_some() { 16 } else { 0 }
                | if self.photo.is_some() { 32 } else { 0 }
                | if self.status.is_some() { 64 } else { 0 }
                | if self.bot_info_version.is_some() {
                    16384
                } else {
                    0
                }
                | if self.restriction_reason.is_some() {
                    262144
                } else {
                    0
                }
                | if self.bot_inline_placeholder.is_some() {
                    524288
                } else {
                    0
                }
                | if self.lang_code.is_some() { 4194304 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.access_hash {
                x.serialize(buf);
            }
            if let Some(ref x) = self.first_name {
                x.serialize(buf);
            }
            if let Some(ref x) = self.last_name {
                x.serialize(buf);
            }
            if let Some(ref x) = self.username {
                x.serialize(buf);
            }
            if let Some(ref x) = self.phone {
                x.serialize(buf);
            }
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.status {
                x.serialize(buf);
            }
            if let Some(ref x) = self.bot_info_version {
                x.serialize(buf);
            }
            if let Some(ref x) = self.restriction_reason {
                x.serialize(buf);
            }
            if let Some(ref x) = self.bot_inline_placeholder {
                x.serialize(buf);
            }
            if let Some(ref x) = self.lang_code {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for User {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let is_self = (flags & 1024) != 0;
            let contact = (flags & 2048) != 0;
            let mutual_contact = (flags & 4096) != 0;
            let deleted = (flags & 8192) != 0;
            let bot = (flags & 16384) != 0;
            let bot_chat_history = (flags & 32768) != 0;
            let bot_nochats = (flags & 65536) != 0;
            let verified = (flags & 131072) != 0;
            let restricted = (flags & 262144) != 0;
            let min = (flags & 1048576) != 0;
            let bot_inline_geo = (flags & 2097152) != 0;
            let support = (flags & 8388608) != 0;
            let scam = (flags & 16777216) != 0;
            let apply_min_photo = (flags & 33554432) != 0;
            let fake = (flags & 67108864) != 0;
            let id = i64::deserialize(buf)?;
            let access_hash = if (flags & 1) != 0 {
                Some(i64::deserialize(buf)?)
            } else {
                None
            };
            let first_name = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let last_name = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let username = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let phone = if (flags & 16) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let photo = if (flags & 32) != 0 {
                Some(crate::enums::UserProfilePhoto::deserialize(buf)?)
            } else {
                None
            };
            let status = if (flags & 64) != 0 {
                Some(crate::enums::UserStatus::deserialize(buf)?)
            } else {
                None
            };
            let bot_info_version = if (flags & 16384) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let restriction_reason = if (flags & 262144) != 0 {
                Some(Vec::<crate::enums::RestrictionReason>::deserialize(buf)?)
            } else {
                None
            };
            let bot_inline_placeholder = if (flags & 524288) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let lang_code = if (flags & 4194304) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(User {
                is_self,
                contact,
                mutual_contact,
                deleted,
                bot,
                bot_chat_history,
                bot_nochats,
                verified,
                restricted,
                min,
                bot_inline_geo,
                support,
                scam,
                apply_min_photo,
                fake,
                id,
                access_hash,
                first_name,
                last_name,
                username,
                phone,
                photo,
                status,
                bot_info_version,
                restriction_reason,
                bot_inline_placeholder,
                lang_code,
            })
        }
    }
    impl TryFrom<crate::enums::User> for User {
        type Error = ();
        fn try_from(x: crate::enums::User) -> Result<Self, Self::Error> {
            match x {
                crate::enums::User::User(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for UserEmpty {
        const CONSTRUCTOR_ID: u32 = 3552332666;
    }
    impl crate::Serializable for UserEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for UserEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(UserEmpty { id })
        }
    }
    impl TryFrom<crate::enums::User> for UserEmpty {
        type Error = ();
        fn try_from(x: crate::enums::User) -> Result<Self, Self::Error> {
            match x {
                crate::enums::User::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserFull {
        pub blocked: bool,
        pub phone_calls_available: bool,
        pub phone_calls_private: bool,
        pub can_pin_message: bool,
        pub has_scheduled: bool,
        pub video_calls_available: bool,
        pub id: i64,
        pub about: Option<String>,
        pub settings: crate::enums::PeerSettings,
        pub profile_photo: Option<crate::enums::Photo>,
        pub notify_settings: crate::enums::PeerNotifySettings,
        pub bot_info: Option<crate::enums::BotInfo>,
        pub pinned_msg_id: Option<i32>,
        pub common_chats_count: i32,
        pub folder_id: Option<i32>,
        pub ttl_period: Option<i32>,
        pub theme_emoticon: Option<String>,
        pub private_forward_name: Option<String>,
    }
    impl crate::Identifiable for UserFull {
        const CONSTRUCTOR_ID: u32 = 3476448545;
    }
    impl crate::Serializable for UserFull {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.blocked { 1 } else { 0 }
                | if self.phone_calls_available { 16 } else { 0 }
                | if self.phone_calls_private { 32 } else { 0 }
                | if self.can_pin_message { 128 } else { 0 }
                | if self.has_scheduled { 4096 } else { 0 }
                | if self.video_calls_available { 8192 } else { 0 }
                | if self.about.is_some() { 2 } else { 0 }
                | if self.profile_photo.is_some() { 4 } else { 0 }
                | if self.bot_info.is_some() { 8 } else { 0 }
                | if self.pinned_msg_id.is_some() { 64 } else { 0 }
                | if self.folder_id.is_some() { 2048 } else { 0 }
                | if self.ttl_period.is_some() { 16384 } else { 0 }
                | if self.theme_emoticon.is_some() {
                    32768
                } else {
                    0
                }
                | if self.private_forward_name.is_some() {
                    65536
                } else {
                    0
                })
            .serialize(buf);
            self.id.serialize(buf);
            if let Some(ref x) = self.about {
                x.serialize(buf);
            }
            self.settings.serialize(buf);
            if let Some(ref x) = self.profile_photo {
                x.serialize(buf);
            }
            self.notify_settings.serialize(buf);
            if let Some(ref x) = self.bot_info {
                x.serialize(buf);
            }
            if let Some(ref x) = self.pinned_msg_id {
                x.serialize(buf);
            }
            self.common_chats_count.serialize(buf);
            if let Some(ref x) = self.folder_id {
                x.serialize(buf);
            }
            if let Some(ref x) = self.ttl_period {
                x.serialize(buf);
            }
            if let Some(ref x) = self.theme_emoticon {
                x.serialize(buf);
            }
            if let Some(ref x) = self.private_forward_name {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for UserFull {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let blocked = (flags & 1) != 0;
            let phone_calls_available = (flags & 16) != 0;
            let phone_calls_private = (flags & 32) != 0;
            let can_pin_message = (flags & 128) != 0;
            let has_scheduled = (flags & 4096) != 0;
            let video_calls_available = (flags & 8192) != 0;
            let id = i64::deserialize(buf)?;
            let about = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let settings = crate::enums::PeerSettings::deserialize(buf)?;
            let profile_photo = if (flags & 4) != 0 {
                Some(crate::enums::Photo::deserialize(buf)?)
            } else {
                None
            };
            let notify_settings = crate::enums::PeerNotifySettings::deserialize(buf)?;
            let bot_info = if (flags & 8) != 0 {
                Some(crate::enums::BotInfo::deserialize(buf)?)
            } else {
                None
            };
            let pinned_msg_id = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let common_chats_count = i32::deserialize(buf)?;
            let folder_id = if (flags & 2048) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let ttl_period = if (flags & 16384) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let theme_emoticon = if (flags & 32768) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let private_forward_name = if (flags & 65536) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            Ok(UserFull {
                blocked,
                phone_calls_available,
                phone_calls_private,
                can_pin_message,
                has_scheduled,
                video_calls_available,
                id,
                about,
                settings,
                profile_photo,
                notify_settings,
                bot_info,
                pinned_msg_id,
                common_chats_count,
                folder_id,
                ttl_period,
                theme_emoticon,
                private_forward_name,
            })
        }
    }
    impl From<crate::enums::UserFull> for UserFull {
        fn from(x: crate::enums::UserFull) -> Self {
            match x {
                crate::enums::UserFull::Full(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserProfilePhoto {
        pub has_video: bool,
        pub photo_id: i64,
        pub stripped_thumb: Option<Vec<u8>>,
        pub dc_id: i32,
    }
    impl crate::Identifiable for UserProfilePhoto {
        const CONSTRUCTOR_ID: u32 = 2194798342;
    }
    impl crate::Serializable for UserProfilePhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.has_video { 1 } else { 0 }
                | if self.stripped_thumb.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.photo_id.serialize(buf);
            if let Some(ref x) = self.stripped_thumb {
                x.serialize(buf);
            }
            self.dc_id.serialize(buf);
        }
    }
    impl crate::Deserializable for UserProfilePhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let has_video = (flags & 1) != 0;
            let photo_id = i64::deserialize(buf)?;
            let stripped_thumb = if (flags & 2) != 0 {
                Some(Vec::<u8>::deserialize(buf)?)
            } else {
                None
            };
            let dc_id = i32::deserialize(buf)?;
            Ok(UserProfilePhoto {
                has_video,
                photo_id,
                stripped_thumb,
                dc_id,
            })
        }
    }
    impl TryFrom<crate::enums::UserProfilePhoto> for UserProfilePhoto {
        type Error = ();
        fn try_from(x: crate::enums::UserProfilePhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserProfilePhoto::Photo(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserProfilePhotoEmpty {}
    impl crate::Identifiable for UserProfilePhotoEmpty {
        const CONSTRUCTOR_ID: u32 = 1326562017;
    }
    impl crate::Serializable for UserProfilePhotoEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UserProfilePhotoEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UserProfilePhotoEmpty {})
        }
    }
    impl TryFrom<crate::enums::UserProfilePhoto> for UserProfilePhotoEmpty {
        type Error = ();
        fn try_from(x: crate::enums::UserProfilePhoto) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserProfilePhoto::Empty => Ok(UserProfilePhotoEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusEmpty {}
    impl crate::Identifiable for UserStatusEmpty {
        const CONSTRUCTOR_ID: u32 = 164646985;
    }
    impl crate::Serializable for UserStatusEmpty {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UserStatusEmpty {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UserStatusEmpty {})
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusEmpty {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::Empty => Ok(UserStatusEmpty {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusLastMonth {}
    impl crate::Identifiable for UserStatusLastMonth {
        const CONSTRUCTOR_ID: u32 = 2011940674;
    }
    impl crate::Serializable for UserStatusLastMonth {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UserStatusLastMonth {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UserStatusLastMonth {})
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusLastMonth {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::LastMonth => Ok(UserStatusLastMonth {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusLastWeek {}
    impl crate::Identifiable for UserStatusLastWeek {
        const CONSTRUCTOR_ID: u32 = 129960444;
    }
    impl crate::Serializable for UserStatusLastWeek {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UserStatusLastWeek {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UserStatusLastWeek {})
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusLastWeek {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::LastWeek => Ok(UserStatusLastWeek {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusOffline {
        pub was_online: i32,
    }
    impl crate::Identifiable for UserStatusOffline {
        const CONSTRUCTOR_ID: u32 = 9203775;
    }
    impl crate::Serializable for UserStatusOffline {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.was_online.serialize(buf);
        }
    }
    impl crate::Deserializable for UserStatusOffline {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let was_online = i32::deserialize(buf)?;
            Ok(UserStatusOffline { was_online })
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusOffline {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::Offline(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusOnline {
        pub expires: i32,
    }
    impl crate::Identifiable for UserStatusOnline {
        const CONSTRUCTOR_ID: u32 = 3988339017;
    }
    impl crate::Serializable for UserStatusOnline {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.expires.serialize(buf);
        }
    }
    impl crate::Deserializable for UserStatusOnline {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let expires = i32::deserialize(buf)?;
            Ok(UserStatusOnline { expires })
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusOnline {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::Online(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct UserStatusRecently {}
    impl crate::Identifiable for UserStatusRecently {
        const CONSTRUCTOR_ID: u32 = 3798942449;
    }
    impl crate::Serializable for UserStatusRecently {
        fn serialize(&self, _buf: crate::serialize::Buffer) {}
    }
    impl crate::Deserializable for UserStatusRecently {
        fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            Ok(UserStatusRecently {})
        }
    }
    impl TryFrom<crate::enums::UserStatus> for UserStatusRecently {
        type Error = ();
        fn try_from(x: crate::enums::UserStatus) -> Result<Self, Self::Error> {
            match x {
                crate::enums::UserStatus::Recently => Ok(UserStatusRecently {}),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct VideoSize {
        pub r#type: String,
        pub w: i32,
        pub h: i32,
        pub size: i32,
        pub video_start_ts: Option<f64>,
    }
    impl crate::Identifiable for VideoSize {
        const CONSTRUCTOR_ID: u32 = 3727929492;
    }
    impl crate::Serializable for VideoSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32 | if self.video_start_ts.is_some() { 1 } else { 0 }).serialize(buf);
            self.r#type.serialize(buf);
            self.w.serialize(buf);
            self.h.serialize(buf);
            self.size.serialize(buf);
            if let Some(ref x) = self.video_start_ts {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for VideoSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let r#type = String::deserialize(buf)?;
            let w = i32::deserialize(buf)?;
            let h = i32::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let video_start_ts = if (flags & 1) != 0 {
                Some(f64::deserialize(buf)?)
            } else {
                None
            };
            Ok(VideoSize {
                r#type,
                w,
                h,
                size,
                video_start_ts,
            })
        }
    }
    impl From<crate::enums::VideoSize> for VideoSize {
        fn from(x: crate::enums::VideoSize) -> Self {
            match x {
                crate::enums::VideoSize::Size(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WallPaper {
        pub id: i64,
        pub creator: bool,
        pub default: bool,
        pub pattern: bool,
        pub dark: bool,
        pub access_hash: i64,
        pub slug: String,
        pub document: crate::enums::Document,
        pub settings: Option<crate::enums::WallPaperSettings>,
    }
    impl crate::Identifiable for WallPaper {
        const CONSTRUCTOR_ID: u32 = 2755118061;
    }
    impl crate::Serializable for WallPaper {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            (0u32
                | if self.creator { 1 } else { 0 }
                | if self.default { 2 } else { 0 }
                | if self.pattern { 8 } else { 0 }
                | if self.dark { 16 } else { 0 }
                | if self.settings.is_some() { 4 } else { 0 })
            .serialize(buf);
            self.access_hash.serialize(buf);
            self.slug.serialize(buf);
            self.document.serialize(buf);
            if let Some(ref x) = self.settings {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WallPaper {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let flags = u32::deserialize(buf)?;
            let creator = (flags & 1) != 0;
            let default = (flags & 2) != 0;
            let pattern = (flags & 8) != 0;
            let dark = (flags & 16) != 0;
            let access_hash = i64::deserialize(buf)?;
            let slug = String::deserialize(buf)?;
            let document = crate::enums::Document::deserialize(buf)?;
            let settings = if (flags & 4) != 0 {
                Some(crate::enums::WallPaperSettings::deserialize(buf)?)
            } else {
                None
            };
            Ok(WallPaper {
                id,
                creator,
                default,
                pattern,
                dark,
                access_hash,
                slug,
                document,
                settings,
            })
        }
    }
    impl TryFrom<crate::enums::WallPaper> for WallPaper {
        type Error = ();
        fn try_from(x: crate::enums::WallPaper) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WallPaper::Paper(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WallPaperNoFile {
        pub id: i64,
        pub default: bool,
        pub dark: bool,
        pub settings: Option<crate::enums::WallPaperSettings>,
    }
    impl crate::Identifiable for WallPaperNoFile {
        const CONSTRUCTOR_ID: u32 = 3766501654;
    }
    impl crate::Serializable for WallPaperNoFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            (0u32
                | if self.default { 2 } else { 0 }
                | if self.dark { 16 } else { 0 }
                | if self.settings.is_some() { 4 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.settings {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WallPaperNoFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let flags = u32::deserialize(buf)?;
            let default = (flags & 2) != 0;
            let dark = (flags & 16) != 0;
            let settings = if (flags & 4) != 0 {
                Some(crate::enums::WallPaperSettings::deserialize(buf)?)
            } else {
                None
            };
            Ok(WallPaperNoFile {
                id,
                default,
                dark,
                settings,
            })
        }
    }
    impl TryFrom<crate::enums::WallPaper> for WallPaperNoFile {
        type Error = ();
        fn try_from(x: crate::enums::WallPaper) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WallPaper::NoFile(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WallPaperSettings {
        pub blur: bool,
        pub motion: bool,
        pub background_color: Option<i32>,
        pub second_background_color: Option<i32>,
        pub third_background_color: Option<i32>,
        pub fourth_background_color: Option<i32>,
        pub intensity: Option<i32>,
        pub rotation: Option<i32>,
    }
    impl crate::Identifiable for WallPaperSettings {
        const CONSTRUCTOR_ID: u32 = 499236004;
    }
    impl crate::Serializable for WallPaperSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.blur { 2 } else { 0 }
                | if self.motion { 4 } else { 0 }
                | if self.background_color.is_some() {
                    1
                } else {
                    0
                }
                | if self.second_background_color.is_some() {
                    16
                } else {
                    0
                }
                | if self.third_background_color.is_some() {
                    32
                } else {
                    0
                }
                | if self.fourth_background_color.is_some() {
                    64
                } else {
                    0
                }
                | if self.intensity.is_some() { 8 } else { 0 }
                | if self.rotation.is_some() { 16 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.background_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.second_background_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.third_background_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.fourth_background_color {
                x.serialize(buf);
            }
            if let Some(ref x) = self.intensity {
                x.serialize(buf);
            }
            if let Some(ref x) = self.rotation {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WallPaperSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let blur = (flags & 2) != 0;
            let motion = (flags & 4) != 0;
            let background_color = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let second_background_color = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let third_background_color = if (flags & 32) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let fourth_background_color = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let intensity = if (flags & 8) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let rotation = if (flags & 16) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(WallPaperSettings {
                blur,
                motion,
                background_color,
                second_background_color,
                third_background_color,
                fourth_background_color,
                intensity,
                rotation,
            })
        }
    }
    impl From<crate::enums::WallPaperSettings> for WallPaperSettings {
        fn from(x: crate::enums::WallPaperSettings) -> Self {
            match x {
                crate::enums::WallPaperSettings::Settings(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebAuthorization {
        pub hash: i64,
        pub bot_id: i64,
        pub domain: String,
        pub browser: String,
        pub platform: String,
        pub date_created: i32,
        pub date_active: i32,
        pub ip: String,
        pub region: String,
    }
    impl crate::Identifiable for WebAuthorization {
        const CONSTRUCTOR_ID: u32 = 2801333330;
    }
    impl crate::Serializable for WebAuthorization {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.hash.serialize(buf);
            self.bot_id.serialize(buf);
            self.domain.serialize(buf);
            self.browser.serialize(buf);
            self.platform.serialize(buf);
            self.date_created.serialize(buf);
            self.date_active.serialize(buf);
            self.ip.serialize(buf);
            self.region.serialize(buf);
        }
    }
    impl crate::Deserializable for WebAuthorization {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let hash = i64::deserialize(buf)?;
            let bot_id = i64::deserialize(buf)?;
            let domain = String::deserialize(buf)?;
            let browser = String::deserialize(buf)?;
            let platform = String::deserialize(buf)?;
            let date_created = i32::deserialize(buf)?;
            let date_active = i32::deserialize(buf)?;
            let ip = String::deserialize(buf)?;
            let region = String::deserialize(buf)?;
            Ok(WebAuthorization {
                hash,
                bot_id,
                domain,
                browser,
                platform,
                date_created,
                date_active,
                ip,
                region,
            })
        }
    }
    impl From<crate::enums::WebAuthorization> for WebAuthorization {
        fn from(x: crate::enums::WebAuthorization) -> Self {
            match x {
                crate::enums::WebAuthorization::Authorization(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebDocument {
        pub url: String,
        pub access_hash: i64,
        pub size: i32,
        pub mime_type: String,
        pub attributes: Vec<crate::enums::DocumentAttribute>,
    }
    impl crate::Identifiable for WebDocument {
        const CONSTRUCTOR_ID: u32 = 475467473;
    }
    impl crate::Serializable for WebDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.access_hash.serialize(buf);
            self.size.serialize(buf);
            self.mime_type.serialize(buf);
            self.attributes.serialize(buf);
        }
    }
    impl crate::Deserializable for WebDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let access_hash = i64::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let mime_type = String::deserialize(buf)?;
            let attributes = Vec::<crate::enums::DocumentAttribute>::deserialize(buf)?;
            Ok(WebDocument {
                url,
                access_hash,
                size,
                mime_type,
                attributes,
            })
        }
    }
    impl TryFrom<crate::enums::WebDocument> for WebDocument {
        type Error = ();
        fn try_from(x: crate::enums::WebDocument) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebDocument::Document(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebDocumentNoProxy {
        pub url: String,
        pub size: i32,
        pub mime_type: String,
        pub attributes: Vec<crate::enums::DocumentAttribute>,
    }
    impl crate::Identifiable for WebDocumentNoProxy {
        const CONSTRUCTOR_ID: u32 = 4190682310;
    }
    impl crate::Serializable for WebDocumentNoProxy {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.url.serialize(buf);
            self.size.serialize(buf);
            self.mime_type.serialize(buf);
            self.attributes.serialize(buf);
        }
    }
    impl crate::Deserializable for WebDocumentNoProxy {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let url = String::deserialize(buf)?;
            let size = i32::deserialize(buf)?;
            let mime_type = String::deserialize(buf)?;
            let attributes = Vec::<crate::enums::DocumentAttribute>::deserialize(buf)?;
            Ok(WebDocumentNoProxy {
                url,
                size,
                mime_type,
                attributes,
            })
        }
    }
    impl TryFrom<crate::enums::WebDocument> for WebDocumentNoProxy {
        type Error = ();
        fn try_from(x: crate::enums::WebDocument) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebDocument::NoProxy(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebPage {
        pub id: i64,
        pub url: String,
        pub display_url: String,
        pub hash: i32,
        pub r#type: Option<String>,
        pub site_name: Option<String>,
        pub title: Option<String>,
        pub description: Option<String>,
        pub photo: Option<crate::enums::Photo>,
        pub embed_url: Option<String>,
        pub embed_type: Option<String>,
        pub embed_width: Option<i32>,
        pub embed_height: Option<i32>,
        pub duration: Option<i32>,
        pub author: Option<String>,
        pub document: Option<crate::enums::Document>,
        pub cached_page: Option<crate::enums::Page>,
        pub attributes: Option<Vec<crate::enums::WebPageAttribute>>,
    }
    impl crate::Identifiable for WebPage {
        const CONSTRUCTOR_ID: u32 = 3902555570;
    }
    impl crate::Serializable for WebPage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.r#type.is_some() { 1 } else { 0 }
                | if self.site_name.is_some() { 2 } else { 0 }
                | if self.title.is_some() { 4 } else { 0 }
                | if self.description.is_some() { 8 } else { 0 }
                | if self.photo.is_some() { 16 } else { 0 }
                | if self.embed_url.is_some() { 32 } else { 0 }
                | if self.embed_type.is_some() { 32 } else { 0 }
                | if self.embed_width.is_some() { 64 } else { 0 }
                | if self.embed_height.is_some() { 64 } else { 0 }
                | if self.duration.is_some() { 128 } else { 0 }
                | if self.author.is_some() { 256 } else { 0 }
                | if self.document.is_some() { 512 } else { 0 }
                | if self.cached_page.is_some() { 1024 } else { 0 }
                | if self.attributes.is_some() { 4096 } else { 0 })
            .serialize(buf);
            self.id.serialize(buf);
            self.url.serialize(buf);
            self.display_url.serialize(buf);
            self.hash.serialize(buf);
            if let Some(ref x) = self.r#type {
                x.serialize(buf);
            }
            if let Some(ref x) = self.site_name {
                x.serialize(buf);
            }
            if let Some(ref x) = self.title {
                x.serialize(buf);
            }
            if let Some(ref x) = self.description {
                x.serialize(buf);
            }
            if let Some(ref x) = self.photo {
                x.serialize(buf);
            }
            if let Some(ref x) = self.embed_url {
                x.serialize(buf);
            }
            if let Some(ref x) = self.embed_type {
                x.serialize(buf);
            }
            if let Some(ref x) = self.embed_width {
                x.serialize(buf);
            }
            if let Some(ref x) = self.embed_height {
                x.serialize(buf);
            }
            if let Some(ref x) = self.duration {
                x.serialize(buf);
            }
            if let Some(ref x) = self.author {
                x.serialize(buf);
            }
            if let Some(ref x) = self.document {
                x.serialize(buf);
            }
            if let Some(ref x) = self.cached_page {
                x.serialize(buf);
            }
            if let Some(ref x) = self.attributes {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WebPage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let id = i64::deserialize(buf)?;
            let url = String::deserialize(buf)?;
            let display_url = String::deserialize(buf)?;
            let hash = i32::deserialize(buf)?;
            let r#type = if (flags & 1) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let site_name = if (flags & 2) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let title = if (flags & 4) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let description = if (flags & 8) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let photo = if (flags & 16) != 0 {
                Some(crate::enums::Photo::deserialize(buf)?)
            } else {
                None
            };
            let embed_url = if (flags & 32) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let embed_type = if (flags & 32) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let embed_width = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let embed_height = if (flags & 64) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let duration = if (flags & 128) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            let author = if (flags & 256) != 0 {
                Some(String::deserialize(buf)?)
            } else {
                None
            };
            let document = if (flags & 512) != 0 {
                Some(crate::enums::Document::deserialize(buf)?)
            } else {
                None
            };
            let cached_page = if (flags & 1024) != 0 {
                Some(crate::enums::Page::deserialize(buf)?)
            } else {
                None
            };
            let attributes = if (flags & 4096) != 0 {
                Some(Vec::<crate::enums::WebPageAttribute>::deserialize(buf)?)
            } else {
                None
            };
            Ok(WebPage {
                id,
                url,
                display_url,
                hash,
                r#type,
                site_name,
                title,
                description,
                photo,
                embed_url,
                embed_type,
                embed_width,
                embed_height,
                duration,
                author,
                document,
                cached_page,
                attributes,
            })
        }
    }
    impl TryFrom<crate::enums::WebPage> for WebPage {
        type Error = ();
        fn try_from(x: crate::enums::WebPage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebPage::Page(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebPageAttributeTheme {
        pub documents: Option<Vec<crate::enums::Document>>,
        pub settings: Option<crate::enums::ThemeSettings>,
    }
    impl crate::Identifiable for WebPageAttributeTheme {
        const CONSTRUCTOR_ID: u32 = 1421174295;
    }
    impl crate::Serializable for WebPageAttributeTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.documents.is_some() { 1 } else { 0 }
                | if self.settings.is_some() { 2 } else { 0 })
            .serialize(buf);
            if let Some(ref x) = self.documents {
                x.serialize(buf);
            }
            if let Some(ref x) = self.settings {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WebPageAttributeTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let documents = if (flags & 1) != 0 {
                Some(Vec::<crate::enums::Document>::deserialize(buf)?)
            } else {
                None
            };
            let settings = if (flags & 2) != 0 {
                Some(crate::enums::ThemeSettings::deserialize(buf)?)
            } else {
                None
            };
            Ok(WebPageAttributeTheme {
                documents,
                settings,
            })
        }
    }
    impl From<crate::enums::WebPageAttribute> for WebPageAttributeTheme {
        fn from(x: crate::enums::WebPageAttribute) -> Self {
            match x {
                crate::enums::WebPageAttribute::Theme(x) => x,
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebPageEmpty {
        pub id: i64,
    }
    impl crate::Identifiable for WebPageEmpty {
        const CONSTRUCTOR_ID: u32 = 3943987176;
    }
    impl crate::Serializable for WebPageEmpty {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
        }
    }
    impl crate::Deserializable for WebPageEmpty {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            Ok(WebPageEmpty { id })
        }
    }
    impl TryFrom<crate::enums::WebPage> for WebPageEmpty {
        type Error = ();
        fn try_from(x: crate::enums::WebPage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebPage::Empty(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebPageNotModified {
        pub cached_page_views: Option<i32>,
    }
    impl crate::Identifiable for WebPageNotModified {
        const CONSTRUCTOR_ID: u32 = 1930545681;
    }
    impl crate::Serializable for WebPageNotModified {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            (0u32
                | if self.cached_page_views.is_some() {
                    1
                } else {
                    0
                })
            .serialize(buf);
            if let Some(ref x) = self.cached_page_views {
                x.serialize(buf);
            }
        }
    }
    impl crate::Deserializable for WebPageNotModified {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let flags = u32::deserialize(buf)?;
            let cached_page_views = if (flags & 1) != 0 {
                Some(i32::deserialize(buf)?)
            } else {
                None
            };
            Ok(WebPageNotModified { cached_page_views })
        }
    }
    impl TryFrom<crate::enums::WebPage> for WebPageNotModified {
        type Error = ();
        fn try_from(x: crate::enums::WebPage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebPage::NotModified(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct WebPagePending {
        pub id: i64,
        pub date: i32,
    }
    impl crate::Identifiable for WebPagePending {
        const CONSTRUCTOR_ID: u32 = 3313949212;
    }
    impl crate::Serializable for WebPagePending {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            self.id.serialize(buf);
            self.date.serialize(buf);
        }
    }
    impl crate::Deserializable for WebPagePending {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            let id = i64::deserialize(buf)?;
            let date = i32::deserialize(buf)?;
            Ok(WebPagePending { id, date })
        }
    }
    impl TryFrom<crate::enums::WebPage> for WebPagePending {
        type Error = ();
        fn try_from(x: crate::enums::WebPage) -> Result<Self, Self::Error> {
            match x {
                crate::enums::WebPage::Pending(x) => Ok(x),
                _ => Err(()),
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod account {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct AuthorizationForm {
            pub required_types: Vec<crate::enums::SecureRequiredType>,
            pub values: Vec<crate::enums::SecureValue>,
            pub errors: Vec<crate::enums::SecureValueError>,
            pub users: Vec<crate::enums::User>,
            pub privacy_policy_url: Option<String>,
        }
        impl crate::Identifiable for AuthorizationForm {
            const CONSTRUCTOR_ID: u32 = 2905480408;
        }
        impl crate::Serializable for AuthorizationForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.privacy_policy_url.is_some() {
                        1
                    } else {
                        0
                    })
                .serialize(buf);
                self.required_types.serialize(buf);
                self.values.serialize(buf);
                self.errors.serialize(buf);
                self.users.serialize(buf);
                if let Some(ref x) = self.privacy_policy_url {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for AuthorizationForm {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let required_types = Vec::<crate::enums::SecureRequiredType>::deserialize(buf)?;
                let values = Vec::<crate::enums::SecureValue>::deserialize(buf)?;
                let errors = Vec::<crate::enums::SecureValueError>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let privacy_policy_url = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                Ok(AuthorizationForm {
                    required_types,
                    values,
                    errors,
                    users,
                    privacy_policy_url,
                })
            }
        }
        impl From<crate::enums::account::AuthorizationForm> for AuthorizationForm {
            fn from(x: crate::enums::account::AuthorizationForm) -> Self {
                match x {
                    crate::enums::account::AuthorizationForm::Form(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Authorizations {
            pub authorization_ttl_days: i32,
            pub authorizations: Vec<crate::enums::Authorization>,
        }
        impl crate::Identifiable for Authorizations {
            const CONSTRUCTOR_ID: u32 = 1275039392;
        }
        impl crate::Serializable for Authorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.authorization_ttl_days.serialize(buf);
                self.authorizations.serialize(buf);
            }
        }
        impl crate::Deserializable for Authorizations {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let authorization_ttl_days = i32::deserialize(buf)?;
                let authorizations = Vec::<crate::enums::Authorization>::deserialize(buf)?;
                Ok(Authorizations {
                    authorization_ttl_days,
                    authorizations,
                })
            }
        }
        impl From<crate::enums::account::Authorizations> for Authorizations {
            fn from(x: crate::enums::account::Authorizations) -> Self {
                match x {
                    crate::enums::account::Authorizations::Authorizations(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AutoDownloadSettings {
            pub low: crate::enums::AutoDownloadSettings,
            pub medium: crate::enums::AutoDownloadSettings,
            pub high: crate::enums::AutoDownloadSettings,
        }
        impl crate::Identifiable for AutoDownloadSettings {
            const CONSTRUCTOR_ID: u32 = 1674235686;
        }
        impl crate::Serializable for AutoDownloadSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.low.serialize(buf);
                self.medium.serialize(buf);
                self.high.serialize(buf);
            }
        }
        impl crate::Deserializable for AutoDownloadSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let low = crate::enums::AutoDownloadSettings::deserialize(buf)?;
                let medium = crate::enums::AutoDownloadSettings::deserialize(buf)?;
                let high = crate::enums::AutoDownloadSettings::deserialize(buf)?;
                Ok(AutoDownloadSettings { low, medium, high })
            }
        }
        impl From<crate::enums::account::AutoDownloadSettings> for AutoDownloadSettings {
            fn from(x: crate::enums::account::AutoDownloadSettings) -> Self {
                match x {
                    crate::enums::account::AutoDownloadSettings::Settings(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ContentSettings {
            pub sensitive_enabled: bool,
            pub sensitive_can_change: bool,
        }
        impl crate::Identifiable for ContentSettings {
            const CONSTRUCTOR_ID: u32 = 1474462241;
        }
        impl crate::Serializable for ContentSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.sensitive_enabled { 1 } else { 0 }
                    | if self.sensitive_can_change { 2 } else { 0 })
                .serialize(buf);
            }
        }
        impl crate::Deserializable for ContentSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let sensitive_enabled = (flags & 1) != 0;
                let sensitive_can_change = (flags & 2) != 0;
                Ok(ContentSettings {
                    sensitive_enabled,
                    sensitive_can_change,
                })
            }
        }
        impl From<crate::enums::account::ContentSettings> for ContentSettings {
            fn from(x: crate::enums::account::ContentSettings) -> Self {
                match x {
                    crate::enums::account::ContentSettings::Settings(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Password {
            pub has_recovery: bool,
            pub has_secure_values: bool,
            pub has_password: bool,
            pub current_algo: Option<crate::enums::PasswordKdfAlgo>,
            pub srp_b: Option<Vec<u8>>,
            pub srp_id: Option<i64>,
            pub hint: Option<String>,
            pub email_unconfirmed_pattern: Option<String>,
            pub new_algo: crate::enums::PasswordKdfAlgo,
            pub new_secure_algo: crate::enums::SecurePasswordKdfAlgo,
            pub secure_random: Vec<u8>,
            pub pending_reset_date: Option<i32>,
        }
        impl crate::Identifiable for Password {
            const CONSTRUCTOR_ID: u32 = 408623183;
        }
        impl crate::Serializable for Password {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.has_recovery { 1 } else { 0 }
                    | if self.has_secure_values { 2 } else { 0 }
                    | if self.has_password { 4 } else { 0 }
                    | if self.current_algo.is_some() { 4 } else { 0 }
                    | if self.srp_b.is_some() { 4 } else { 0 }
                    | if self.srp_id.is_some() { 4 } else { 0 }
                    | if self.hint.is_some() { 8 } else { 0 }
                    | if self.email_unconfirmed_pattern.is_some() {
                        16
                    } else {
                        0
                    }
                    | if self.pending_reset_date.is_some() {
                        32
                    } else {
                        0
                    })
                .serialize(buf);
                if let Some(ref x) = self.current_algo {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.srp_b {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.srp_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.hint {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.email_unconfirmed_pattern {
                    x.serialize(buf);
                }
                self.new_algo.serialize(buf);
                self.new_secure_algo.serialize(buf);
                self.secure_random.serialize(buf);
                if let Some(ref x) = self.pending_reset_date {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for Password {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let has_recovery = (flags & 1) != 0;
                let has_secure_values = (flags & 2) != 0;
                let has_password = (flags & 4) != 0;
                let current_algo = if (flags & 4) != 0 {
                    Some(crate::enums::PasswordKdfAlgo::deserialize(buf)?)
                } else {
                    None
                };
                let srp_b = if (flags & 4) != 0 {
                    Some(Vec::<u8>::deserialize(buf)?)
                } else {
                    None
                };
                let srp_id = if (flags & 4) != 0 {
                    Some(i64::deserialize(buf)?)
                } else {
                    None
                };
                let hint = if (flags & 8) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let email_unconfirmed_pattern = if (flags & 16) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let new_algo = crate::enums::PasswordKdfAlgo::deserialize(buf)?;
                let new_secure_algo = crate::enums::SecurePasswordKdfAlgo::deserialize(buf)?;
                let secure_random = Vec::<u8>::deserialize(buf)?;
                let pending_reset_date = if (flags & 32) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                Ok(Password {
                    has_recovery,
                    has_secure_values,
                    has_password,
                    current_algo,
                    srp_b,
                    srp_id,
                    hint,
                    email_unconfirmed_pattern,
                    new_algo,
                    new_secure_algo,
                    secure_random,
                    pending_reset_date,
                })
            }
        }
        impl From<crate::enums::account::Password> for Password {
            fn from(x: crate::enums::account::Password) -> Self {
                match x {
                    crate::enums::account::Password::Password(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PasswordInputSettings {
            pub new_algo: Option<crate::enums::PasswordKdfAlgo>,
            pub new_password_hash: Option<Vec<u8>>,
            pub hint: Option<String>,
            pub email: Option<String>,
            pub new_secure_settings: Option<crate::enums::SecureSecretSettings>,
        }
        impl crate::Identifiable for PasswordInputSettings {
            const CONSTRUCTOR_ID: u32 = 3258394569;
        }
        impl crate::Serializable for PasswordInputSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.new_algo.is_some() { 1 } else { 0 }
                    | if self.new_password_hash.is_some() {
                        1
                    } else {
                        0
                    }
                    | if self.hint.is_some() { 1 } else { 0 }
                    | if self.email.is_some() { 2 } else { 0 }
                    | if self.new_secure_settings.is_some() {
                        4
                    } else {
                        0
                    })
                .serialize(buf);
                if let Some(ref x) = self.new_algo {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.new_password_hash {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.hint {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.email {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.new_secure_settings {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for PasswordInputSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let new_algo = if (flags & 1) != 0 {
                    Some(crate::enums::PasswordKdfAlgo::deserialize(buf)?)
                } else {
                    None
                };
                let new_password_hash = if (flags & 1) != 0 {
                    Some(Vec::<u8>::deserialize(buf)?)
                } else {
                    None
                };
                let hint = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let email = if (flags & 2) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let new_secure_settings = if (flags & 4) != 0 {
                    Some(crate::enums::SecureSecretSettings::deserialize(buf)?)
                } else {
                    None
                };
                Ok(PasswordInputSettings {
                    new_algo,
                    new_password_hash,
                    hint,
                    email,
                    new_secure_settings,
                })
            }
        }
        impl From<crate::enums::account::PasswordInputSettings> for PasswordInputSettings {
            fn from(x: crate::enums::account::PasswordInputSettings) -> Self {
                match x {
                    crate::enums::account::PasswordInputSettings::Settings(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PasswordSettings {
            pub email: Option<String>,
            pub secure_settings: Option<crate::enums::SecureSecretSettings>,
        }
        impl crate::Identifiable for PasswordSettings {
            const CONSTRUCTOR_ID: u32 = 2589733861;
        }
        impl crate::Serializable for PasswordSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.email.is_some() { 1 } else { 0 }
                    | if self.secure_settings.is_some() { 2 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.email {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.secure_settings {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for PasswordSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let email = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let secure_settings = if (flags & 2) != 0 {
                    Some(crate::enums::SecureSecretSettings::deserialize(buf)?)
                } else {
                    None
                };
                Ok(PasswordSettings {
                    email,
                    secure_settings,
                })
            }
        }
        impl From<crate::enums::account::PasswordSettings> for PasswordSettings {
            fn from(x: crate::enums::account::PasswordSettings) -> Self {
                match x {
                    crate::enums::account::PasswordSettings::Settings(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PrivacyRules {
            pub rules: Vec<crate::enums::PrivacyRule>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PrivacyRules {
            const CONSTRUCTOR_ID: u32 = 1352683077;
        }
        impl crate::Serializable for PrivacyRules {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.rules.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PrivacyRules {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let rules = Vec::<crate::enums::PrivacyRule>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PrivacyRules {
                    rules,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::account::PrivacyRules> for PrivacyRules {
            fn from(x: crate::enums::account::PrivacyRules) -> Self {
                match x {
                    crate::enums::account::PrivacyRules::Rules(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetPasswordFailedWait {
            pub retry_date: i32,
        }
        impl crate::Identifiable for ResetPasswordFailedWait {
            const CONSTRUCTOR_ID: u32 = 3816265825;
        }
        impl crate::Serializable for ResetPasswordFailedWait {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.retry_date.serialize(buf);
            }
        }
        impl crate::Deserializable for ResetPasswordFailedWait {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let retry_date = i32::deserialize(buf)?;
                Ok(ResetPasswordFailedWait { retry_date })
            }
        }
        impl TryFrom<crate::enums::account::ResetPasswordResult> for ResetPasswordFailedWait {
            type Error = ();
            fn try_from(
                x: crate::enums::account::ResetPasswordResult,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::ResetPasswordResult::ResetPasswordFailedWait(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetPasswordOk {}
        impl crate::Identifiable for ResetPasswordOk {
            const CONSTRUCTOR_ID: u32 = 3911636542;
        }
        impl crate::Serializable for ResetPasswordOk {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for ResetPasswordOk {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(ResetPasswordOk {})
            }
        }
        impl TryFrom<crate::enums::account::ResetPasswordResult> for ResetPasswordOk {
            type Error = ();
            fn try_from(
                x: crate::enums::account::ResetPasswordResult,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::ResetPasswordResult::ResetPasswordOk => {
                        Ok(ResetPasswordOk {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetPasswordRequestedWait {
            pub until_date: i32,
        }
        impl crate::Identifiable for ResetPasswordRequestedWait {
            const CONSTRUCTOR_ID: u32 = 3924819069;
        }
        impl crate::Serializable for ResetPasswordRequestedWait {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.until_date.serialize(buf);
            }
        }
        impl crate::Deserializable for ResetPasswordRequestedWait {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let until_date = i32::deserialize(buf)?;
                Ok(ResetPasswordRequestedWait { until_date })
            }
        }
        impl TryFrom<crate::enums::account::ResetPasswordResult> for ResetPasswordRequestedWait {
            type Error = ();
            fn try_from(
                x: crate::enums::account::ResetPasswordResult,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::ResetPasswordResult::ResetPasswordRequestedWait(x) => {
                        Ok(x)
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentEmailCode {
            pub email_pattern: String,
            pub length: i32,
        }
        impl crate::Identifiable for SentEmailCode {
            const CONSTRUCTOR_ID: u32 = 2166326607;
        }
        impl crate::Serializable for SentEmailCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.email_pattern.serialize(buf);
                self.length.serialize(buf);
            }
        }
        impl crate::Deserializable for SentEmailCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let email_pattern = String::deserialize(buf)?;
                let length = i32::deserialize(buf)?;
                Ok(SentEmailCode {
                    email_pattern,
                    length,
                })
            }
        }
        impl From<crate::enums::account::SentEmailCode> for SentEmailCode {
            fn from(x: crate::enums::account::SentEmailCode) -> Self {
                match x {
                    crate::enums::account::SentEmailCode::Code(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Takeout {
            pub id: i64,
        }
        impl crate::Identifiable for Takeout {
            const CONSTRUCTOR_ID: u32 = 1304052993;
        }
        impl crate::Serializable for Takeout {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.id.serialize(buf);
            }
        }
        impl crate::Deserializable for Takeout {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let id = i64::deserialize(buf)?;
                Ok(Takeout { id })
            }
        }
        impl From<crate::enums::account::Takeout> for Takeout {
            fn from(x: crate::enums::account::Takeout) -> Self {
                match x {
                    crate::enums::account::Takeout::Takeout(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Themes {
            pub hash: i64,
            pub themes: Vec<crate::enums::Theme>,
        }
        impl crate::Identifiable for Themes {
            const CONSTRUCTOR_ID: u32 = 2587724909;
        }
        impl crate::Serializable for Themes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.themes.serialize(buf);
            }
        }
        impl crate::Deserializable for Themes {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let themes = Vec::<crate::enums::Theme>::deserialize(buf)?;
                Ok(Themes { hash, themes })
            }
        }
        impl TryFrom<crate::enums::account::Themes> for Themes {
            type Error = ();
            fn try_from(x: crate::enums::account::Themes) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::Themes::Themes(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ThemesNotModified {}
        impl crate::Identifiable for ThemesNotModified {
            const CONSTRUCTOR_ID: u32 = 4095653410;
        }
        impl crate::Serializable for ThemesNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for ThemesNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(ThemesNotModified {})
            }
        }
        impl TryFrom<crate::enums::account::Themes> for ThemesNotModified {
            type Error = ();
            fn try_from(x: crate::enums::account::Themes) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::Themes::NotModified => Ok(ThemesNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TmpPassword {
            pub tmp_password: Vec<u8>,
            pub valid_until: i32,
        }
        impl crate::Identifiable for TmpPassword {
            const CONSTRUCTOR_ID: u32 = 3680828724;
        }
        impl crate::Serializable for TmpPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.tmp_password.serialize(buf);
                self.valid_until.serialize(buf);
            }
        }
        impl crate::Deserializable for TmpPassword {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let tmp_password = Vec::<u8>::deserialize(buf)?;
                let valid_until = i32::deserialize(buf)?;
                Ok(TmpPassword {
                    tmp_password,
                    valid_until,
                })
            }
        }
        impl From<crate::enums::account::TmpPassword> for TmpPassword {
            fn from(x: crate::enums::account::TmpPassword) -> Self {
                match x {
                    crate::enums::account::TmpPassword::Password(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct WallPapers {
            pub hash: i64,
            pub wallpapers: Vec<crate::enums::WallPaper>,
        }
        impl crate::Identifiable for WallPapers {
            const CONSTRUCTOR_ID: u32 = 3452142988;
        }
        impl crate::Serializable for WallPapers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.wallpapers.serialize(buf);
            }
        }
        impl crate::Deserializable for WallPapers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let wallpapers = Vec::<crate::enums::WallPaper>::deserialize(buf)?;
                Ok(WallPapers { hash, wallpapers })
            }
        }
        impl TryFrom<crate::enums::account::WallPapers> for WallPapers {
            type Error = ();
            fn try_from(x: crate::enums::account::WallPapers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::WallPapers::Papers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct WallPapersNotModified {}
        impl crate::Identifiable for WallPapersNotModified {
            const CONSTRUCTOR_ID: u32 = 471437699;
        }
        impl crate::Serializable for WallPapersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for WallPapersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(WallPapersNotModified {})
            }
        }
        impl TryFrom<crate::enums::account::WallPapers> for WallPapersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::account::WallPapers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::account::WallPapers::NotModified => Ok(WallPapersNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct WebAuthorizations {
            pub authorizations: Vec<crate::enums::WebAuthorization>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for WebAuthorizations {
            const CONSTRUCTOR_ID: u32 = 3981887996;
        }
        impl crate::Serializable for WebAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.authorizations.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for WebAuthorizations {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let authorizations = Vec::<crate::enums::WebAuthorization>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(WebAuthorizations {
                    authorizations,
                    users,
                })
            }
        }
        impl From<crate::enums::account::WebAuthorizations> for WebAuthorizations {
            fn from(x: crate::enums::account::WebAuthorizations) -> Self {
                match x {
                    crate::enums::account::WebAuthorizations::Authorizations(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod auth {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct Authorization {
            pub setup_password_required: bool,
            pub otherwise_relogin_days: Option<i32>,
            pub tmp_sessions: Option<i32>,
            pub user: crate::enums::User,
        }
        impl crate::Identifiable for Authorization {
            const CONSTRUCTOR_ID: u32 = 872119224;
        }
        impl crate::Serializable for Authorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.setup_password_required { 2 } else { 0 }
                    | if self.otherwise_relogin_days.is_some() {
                        2
                    } else {
                        0
                    }
                    | if self.tmp_sessions.is_some() { 1 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.otherwise_relogin_days {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.tmp_sessions {
                    x.serialize(buf);
                }
                self.user.serialize(buf);
            }
        }
        impl crate::Deserializable for Authorization {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let setup_password_required = (flags & 2) != 0;
                let otherwise_relogin_days = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let tmp_sessions = if (flags & 1) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let user = crate::enums::User::deserialize(buf)?;
                Ok(Authorization {
                    setup_password_required,
                    otherwise_relogin_days,
                    tmp_sessions,
                    user,
                })
            }
        }
        impl TryFrom<crate::enums::auth::Authorization> for Authorization {
            type Error = ();
            fn try_from(x: crate::enums::auth::Authorization) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::Authorization::Authorization(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AuthorizationSignUpRequired {
            pub terms_of_service: Option<crate::enums::help::TermsOfService>,
        }
        impl crate::Identifiable for AuthorizationSignUpRequired {
            const CONSTRUCTOR_ID: u32 = 1148485274;
        }
        impl crate::Serializable for AuthorizationSignUpRequired {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.terms_of_service.is_some() {
                        1
                    } else {
                        0
                    })
                .serialize(buf);
                if let Some(ref x) = self.terms_of_service {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for AuthorizationSignUpRequired {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let terms_of_service = if (flags & 1) != 0 {
                    Some(crate::enums::help::TermsOfService::deserialize(buf)?)
                } else {
                    None
                };
                Ok(AuthorizationSignUpRequired { terms_of_service })
            }
        }
        impl TryFrom<crate::enums::auth::Authorization> for AuthorizationSignUpRequired {
            type Error = ();
            fn try_from(x: crate::enums::auth::Authorization) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::Authorization::SignUpRequired(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CodeTypeCall {}
        impl crate::Identifiable for CodeTypeCall {
            const CONSTRUCTOR_ID: u32 = 1948046307;
        }
        impl crate::Serializable for CodeTypeCall {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for CodeTypeCall {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(CodeTypeCall {})
            }
        }
        impl TryFrom<crate::enums::auth::CodeType> for CodeTypeCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::CodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::CodeType::Call => Ok(CodeTypeCall {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CodeTypeFlashCall {}
        impl crate::Identifiable for CodeTypeFlashCall {
            const CONSTRUCTOR_ID: u32 = 577556219;
        }
        impl crate::Serializable for CodeTypeFlashCall {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for CodeTypeFlashCall {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(CodeTypeFlashCall {})
            }
        }
        impl TryFrom<crate::enums::auth::CodeType> for CodeTypeFlashCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::CodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::CodeType::FlashCall => Ok(CodeTypeFlashCall {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CodeTypeMissedCall {}
        impl crate::Identifiable for CodeTypeMissedCall {
            const CONSTRUCTOR_ID: u32 = 3592083182;
        }
        impl crate::Serializable for CodeTypeMissedCall {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for CodeTypeMissedCall {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(CodeTypeMissedCall {})
            }
        }
        impl TryFrom<crate::enums::auth::CodeType> for CodeTypeMissedCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::CodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::CodeType::MissedCall => Ok(CodeTypeMissedCall {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CodeTypeSms {}
        impl crate::Identifiable for CodeTypeSms {
            const CONSTRUCTOR_ID: u32 = 1923290508;
        }
        impl crate::Serializable for CodeTypeSms {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for CodeTypeSms {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(CodeTypeSms {})
            }
        }
        impl TryFrom<crate::enums::auth::CodeType> for CodeTypeSms {
            type Error = ();
            fn try_from(x: crate::enums::auth::CodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::CodeType::Sms => Ok(CodeTypeSms {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportedAuthorization {
            pub id: i64,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for ExportedAuthorization {
            const CONSTRUCTOR_ID: u32 = 3023364792;
        }
        impl crate::Serializable for ExportedAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.id.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::Deserializable for ExportedAuthorization {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let id = i64::deserialize(buf)?;
                let bytes = Vec::<u8>::deserialize(buf)?;
                Ok(ExportedAuthorization { id, bytes })
            }
        }
        impl From<crate::enums::auth::ExportedAuthorization> for ExportedAuthorization {
            fn from(x: crate::enums::auth::ExportedAuthorization) -> Self {
                match x {
                    crate::enums::auth::ExportedAuthorization::Authorization(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LoggedOut {
            pub future_auth_token: Option<Vec<u8>>,
        }
        impl crate::Identifiable for LoggedOut {
            const CONSTRUCTOR_ID: u32 = 3282207583;
        }
        impl crate::Serializable for LoggedOut {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.future_auth_token.is_some() {
                        1
                    } else {
                        0
                    })
                .serialize(buf);
                if let Some(ref x) = self.future_auth_token {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for LoggedOut {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let future_auth_token = if (flags & 1) != 0 {
                    Some(Vec::<u8>::deserialize(buf)?)
                } else {
                    None
                };
                Ok(LoggedOut { future_auth_token })
            }
        }
        impl From<crate::enums::auth::LoggedOut> for LoggedOut {
            fn from(x: crate::enums::auth::LoggedOut) -> Self {
                match x {
                    crate::enums::auth::LoggedOut::Out(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LoginToken {
            pub expires: i32,
            pub token: Vec<u8>,
        }
        impl crate::Identifiable for LoginToken {
            const CONSTRUCTOR_ID: u32 = 1654593920;
        }
        impl crate::Serializable for LoginToken {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.expires.serialize(buf);
                self.token.serialize(buf);
            }
        }
        impl crate::Deserializable for LoginToken {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let expires = i32::deserialize(buf)?;
                let token = Vec::<u8>::deserialize(buf)?;
                Ok(LoginToken { expires, token })
            }
        }
        impl TryFrom<crate::enums::auth::LoginToken> for LoginToken {
            type Error = ();
            fn try_from(x: crate::enums::auth::LoginToken) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::LoginToken::Token(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LoginTokenMigrateTo {
            pub dc_id: i32,
            pub token: Vec<u8>,
        }
        impl crate::Identifiable for LoginTokenMigrateTo {
            const CONSTRUCTOR_ID: u32 = 110008598;
        }
        impl crate::Serializable for LoginTokenMigrateTo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.dc_id.serialize(buf);
                self.token.serialize(buf);
            }
        }
        impl crate::Deserializable for LoginTokenMigrateTo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let dc_id = i32::deserialize(buf)?;
                let token = Vec::<u8>::deserialize(buf)?;
                Ok(LoginTokenMigrateTo { dc_id, token })
            }
        }
        impl TryFrom<crate::enums::auth::LoginToken> for LoginTokenMigrateTo {
            type Error = ();
            fn try_from(x: crate::enums::auth::LoginToken) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::LoginToken::MigrateTo(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LoginTokenSuccess {
            pub authorization: crate::enums::auth::Authorization,
        }
        impl crate::Identifiable for LoginTokenSuccess {
            const CONSTRUCTOR_ID: u32 = 957176926;
        }
        impl crate::Serializable for LoginTokenSuccess {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.authorization.serialize(buf);
            }
        }
        impl crate::Deserializable for LoginTokenSuccess {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let authorization = crate::enums::auth::Authorization::deserialize(buf)?;
                Ok(LoginTokenSuccess { authorization })
            }
        }
        impl TryFrom<crate::enums::auth::LoginToken> for LoginTokenSuccess {
            type Error = ();
            fn try_from(x: crate::enums::auth::LoginToken) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::LoginToken::Success(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PasswordRecovery {
            pub email_pattern: String,
        }
        impl crate::Identifiable for PasswordRecovery {
            const CONSTRUCTOR_ID: u32 = 326715557;
        }
        impl crate::Serializable for PasswordRecovery {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.email_pattern.serialize(buf);
            }
        }
        impl crate::Deserializable for PasswordRecovery {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let email_pattern = String::deserialize(buf)?;
                Ok(PasswordRecovery { email_pattern })
            }
        }
        impl From<crate::enums::auth::PasswordRecovery> for PasswordRecovery {
            fn from(x: crate::enums::auth::PasswordRecovery) -> Self {
                match x {
                    crate::enums::auth::PasswordRecovery::Recovery(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCode {
            pub r#type: crate::enums::auth::SentCodeType,
            pub phone_code_hash: String,
            pub next_type: Option<crate::enums::auth::CodeType>,
            pub timeout: Option<i32>,
        }
        impl crate::Identifiable for SentCode {
            const CONSTRUCTOR_ID: u32 = 1577067778;
        }
        impl crate::Serializable for SentCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.next_type.is_some() { 2 } else { 0 }
                    | if self.timeout.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.r#type.serialize(buf);
                self.phone_code_hash.serialize(buf);
                if let Some(ref x) = self.next_type {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.timeout {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for SentCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let r#type = crate::enums::auth::SentCodeType::deserialize(buf)?;
                let phone_code_hash = String::deserialize(buf)?;
                let next_type = if (flags & 2) != 0 {
                    Some(crate::enums::auth::CodeType::deserialize(buf)?)
                } else {
                    None
                };
                let timeout = if (flags & 4) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                Ok(SentCode {
                    r#type,
                    phone_code_hash,
                    next_type,
                    timeout,
                })
            }
        }
        impl From<crate::enums::auth::SentCode> for SentCode {
            fn from(x: crate::enums::auth::SentCode) -> Self {
                match x {
                    crate::enums::auth::SentCode::Code(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCodeTypeApp {
            pub length: i32,
        }
        impl crate::Identifiable for SentCodeTypeApp {
            const CONSTRUCTOR_ID: u32 = 1035688326;
        }
        impl crate::Serializable for SentCodeTypeApp {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.length.serialize(buf);
            }
        }
        impl crate::Deserializable for SentCodeTypeApp {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let length = i32::deserialize(buf)?;
                Ok(SentCodeTypeApp { length })
            }
        }
        impl TryFrom<crate::enums::auth::SentCodeType> for SentCodeTypeApp {
            type Error = ();
            fn try_from(x: crate::enums::auth::SentCodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::SentCodeType::App(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCodeTypeCall {
            pub length: i32,
        }
        impl crate::Identifiable for SentCodeTypeCall {
            const CONSTRUCTOR_ID: u32 = 1398007207;
        }
        impl crate::Serializable for SentCodeTypeCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.length.serialize(buf);
            }
        }
        impl crate::Deserializable for SentCodeTypeCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let length = i32::deserialize(buf)?;
                Ok(SentCodeTypeCall { length })
            }
        }
        impl TryFrom<crate::enums::auth::SentCodeType> for SentCodeTypeCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::SentCodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::SentCodeType::Call(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCodeTypeFlashCall {
            pub pattern: String,
        }
        impl crate::Identifiable for SentCodeTypeFlashCall {
            const CONSTRUCTOR_ID: u32 = 2869151449;
        }
        impl crate::Serializable for SentCodeTypeFlashCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pattern.serialize(buf);
            }
        }
        impl crate::Deserializable for SentCodeTypeFlashCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pattern = String::deserialize(buf)?;
                Ok(SentCodeTypeFlashCall { pattern })
            }
        }
        impl TryFrom<crate::enums::auth::SentCodeType> for SentCodeTypeFlashCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::SentCodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::SentCodeType::FlashCall(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCodeTypeMissedCall {
            pub prefix: String,
            pub length: i32,
        }
        impl crate::Identifiable for SentCodeTypeMissedCall {
            const CONSTRUCTOR_ID: u32 = 2181063812;
        }
        impl crate::Serializable for SentCodeTypeMissedCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.prefix.serialize(buf);
                self.length.serialize(buf);
            }
        }
        impl crate::Deserializable for SentCodeTypeMissedCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let prefix = String::deserialize(buf)?;
                let length = i32::deserialize(buf)?;
                Ok(SentCodeTypeMissedCall { prefix, length })
            }
        }
        impl TryFrom<crate::enums::auth::SentCodeType> for SentCodeTypeMissedCall {
            type Error = ();
            fn try_from(x: crate::enums::auth::SentCodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::SentCodeType::MissedCall(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentCodeTypeSms {
            pub length: i32,
        }
        impl crate::Identifiable for SentCodeTypeSms {
            const CONSTRUCTOR_ID: u32 = 3221273506;
        }
        impl crate::Serializable for SentCodeTypeSms {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.length.serialize(buf);
            }
        }
        impl crate::Deserializable for SentCodeTypeSms {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let length = i32::deserialize(buf)?;
                Ok(SentCodeTypeSms { length })
            }
        }
        impl TryFrom<crate::enums::auth::SentCodeType> for SentCodeTypeSms {
            type Error = ();
            fn try_from(x: crate::enums::auth::SentCodeType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::auth::SentCodeType::Sms(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod channels {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct AdminLogResults {
            pub events: Vec<crate::enums::ChannelAdminLogEvent>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for AdminLogResults {
            const CONSTRUCTOR_ID: u32 = 3985307469;
        }
        impl crate::Serializable for AdminLogResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.events.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for AdminLogResults {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let events = Vec::<crate::enums::ChannelAdminLogEvent>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(AdminLogResults {
                    events,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::channels::AdminLogResults> for AdminLogResults {
            fn from(x: crate::enums::channels::AdminLogResults) -> Self {
                match x {
                    crate::enums::channels::AdminLogResults::Results(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelParticipant {
            pub participant: crate::enums::ChannelParticipant,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChannelParticipant {
            const CONSTRUCTOR_ID: u32 = 3753378583;
        }
        impl crate::Serializable for ChannelParticipant {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.participant.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChannelParticipant {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let participant = crate::enums::ChannelParticipant::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChannelParticipant {
                    participant,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::channels::ChannelParticipant> for ChannelParticipant {
            fn from(x: crate::enums::channels::ChannelParticipant) -> Self {
                match x {
                    crate::enums::channels::ChannelParticipant::Participant(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelParticipants {
            pub count: i32,
            pub participants: Vec<crate::enums::ChannelParticipant>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChannelParticipants {
            const CONSTRUCTOR_ID: u32 = 2595290799;
        }
        impl crate::Serializable for ChannelParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.participants.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChannelParticipants {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let participants = Vec::<crate::enums::ChannelParticipant>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChannelParticipants {
                    count,
                    participants,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::channels::ChannelParticipants> for ChannelParticipants {
            type Error = ();
            fn try_from(
                x: crate::enums::channels::ChannelParticipants,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::channels::ChannelParticipants::Participants(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelParticipantsNotModified {}
        impl crate::Identifiable for ChannelParticipantsNotModified {
            const CONSTRUCTOR_ID: u32 = 4028055529;
        }
        impl crate::Serializable for ChannelParticipantsNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for ChannelParticipantsNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(ChannelParticipantsNotModified {})
            }
        }
        impl TryFrom<crate::enums::channels::ChannelParticipants> for ChannelParticipantsNotModified {
            type Error = ();
            fn try_from(
                x: crate::enums::channels::ChannelParticipants,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::channels::ChannelParticipants::NotModified => {
                        Ok(ChannelParticipantsNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendAsPeers {
            pub peers: Vec<crate::enums::Peer>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for SendAsPeers {
            const CONSTRUCTOR_ID: u32 = 2203504041;
        }
        impl crate::Serializable for SendAsPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.peers.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for SendAsPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let peers = Vec::<crate::enums::Peer>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(SendAsPeers {
                    peers,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::channels::SendAsPeers> for SendAsPeers {
            fn from(x: crate::enums::channels::SendAsPeers) -> Self {
                match x {
                    crate::enums::channels::SendAsPeers::Peers(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod contacts {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct Blocked {
            pub blocked: Vec<crate::enums::PeerBlocked>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Blocked {
            const CONSTRUCTOR_ID: u32 = 182326673;
        }
        impl crate::Serializable for Blocked {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.blocked.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Blocked {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let blocked = Vec::<crate::enums::PeerBlocked>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Blocked {
                    blocked,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::contacts::Blocked> for Blocked {
            type Error = ();
            fn try_from(x: crate::enums::contacts::Blocked) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::Blocked::Blocked(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct BlockedSlice {
            pub count: i32,
            pub blocked: Vec<crate::enums::PeerBlocked>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for BlockedSlice {
            const CONSTRUCTOR_ID: u32 = 3781575060;
        }
        impl crate::Serializable for BlockedSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.blocked.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for BlockedSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let blocked = Vec::<crate::enums::PeerBlocked>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(BlockedSlice {
                    count,
                    blocked,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::contacts::Blocked> for BlockedSlice {
            type Error = ();
            fn try_from(x: crate::enums::contacts::Blocked) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::Blocked::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Contacts {
            pub contacts: Vec<crate::enums::Contact>,
            pub saved_count: i32,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Contacts {
            const CONSTRUCTOR_ID: u32 = 3941105218;
        }
        impl crate::Serializable for Contacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.contacts.serialize(buf);
                self.saved_count.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Contacts {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let contacts = Vec::<crate::enums::Contact>::deserialize(buf)?;
                let saved_count = i32::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Contacts {
                    contacts,
                    saved_count,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::contacts::Contacts> for Contacts {
            type Error = ();
            fn try_from(x: crate::enums::contacts::Contacts) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::Contacts::Contacts(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ContactsNotModified {}
        impl crate::Identifiable for ContactsNotModified {
            const CONSTRUCTOR_ID: u32 = 3075189202;
        }
        impl crate::Serializable for ContactsNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for ContactsNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(ContactsNotModified {})
            }
        }
        impl TryFrom<crate::enums::contacts::Contacts> for ContactsNotModified {
            type Error = ();
            fn try_from(x: crate::enums::contacts::Contacts) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::Contacts::NotModified => Ok(ContactsNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Found {
            pub my_results: Vec<crate::enums::Peer>,
            pub results: Vec<crate::enums::Peer>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Found {
            const CONSTRUCTOR_ID: u32 = 3004386717;
        }
        impl crate::Serializable for Found {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.my_results.serialize(buf);
                self.results.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Found {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let my_results = Vec::<crate::enums::Peer>::deserialize(buf)?;
                let results = Vec::<crate::enums::Peer>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Found {
                    my_results,
                    results,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::contacts::Found> for Found {
            fn from(x: crate::enums::contacts::Found) -> Self {
                match x {
                    crate::enums::contacts::Found::Found(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportedContacts {
            pub imported: Vec<crate::enums::ImportedContact>,
            pub popular_invites: Vec<crate::enums::PopularContact>,
            pub retry_contacts: Vec<i64>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ImportedContacts {
            const CONSTRUCTOR_ID: u32 = 2010127419;
        }
        impl crate::Serializable for ImportedContacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.imported.serialize(buf);
                self.popular_invites.serialize(buf);
                self.retry_contacts.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ImportedContacts {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let imported = Vec::<crate::enums::ImportedContact>::deserialize(buf)?;
                let popular_invites = Vec::<crate::enums::PopularContact>::deserialize(buf)?;
                let retry_contacts = Vec::<i64>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ImportedContacts {
                    imported,
                    popular_invites,
                    retry_contacts,
                    users,
                })
            }
        }
        impl From<crate::enums::contacts::ImportedContacts> for ImportedContacts {
            fn from(x: crate::enums::contacts::ImportedContacts) -> Self {
                match x {
                    crate::enums::contacts::ImportedContacts::Contacts(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResolvedPeer {
            pub peer: crate::enums::Peer,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ResolvedPeer {
            const CONSTRUCTOR_ID: u32 = 2131196633;
        }
        impl crate::Serializable for ResolvedPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.peer.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ResolvedPeer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let peer = crate::enums::Peer::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ResolvedPeer { peer, chats, users })
            }
        }
        impl From<crate::enums::contacts::ResolvedPeer> for ResolvedPeer {
            fn from(x: crate::enums::contacts::ResolvedPeer) -> Self {
                match x {
                    crate::enums::contacts::ResolvedPeer::Peer(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TopPeers {
            pub categories: Vec<crate::enums::TopPeerCategoryPeers>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for TopPeers {
            const CONSTRUCTOR_ID: u32 = 1891070632;
        }
        impl crate::Serializable for TopPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.categories.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for TopPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let categories = Vec::<crate::enums::TopPeerCategoryPeers>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(TopPeers {
                    categories,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::contacts::TopPeers> for TopPeers {
            type Error = ();
            fn try_from(x: crate::enums::contacts::TopPeers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::TopPeers::Peers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TopPeersDisabled {}
        impl crate::Identifiable for TopPeersDisabled {
            const CONSTRUCTOR_ID: u32 = 3039597469;
        }
        impl crate::Serializable for TopPeersDisabled {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for TopPeersDisabled {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(TopPeersDisabled {})
            }
        }
        impl TryFrom<crate::enums::contacts::TopPeers> for TopPeersDisabled {
            type Error = ();
            fn try_from(x: crate::enums::contacts::TopPeers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::TopPeers::Disabled => Ok(TopPeersDisabled {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TopPeersNotModified {}
        impl crate::Identifiable for TopPeersNotModified {
            const CONSTRUCTOR_ID: u32 = 3727060725;
        }
        impl crate::Serializable for TopPeersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for TopPeersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(TopPeersNotModified {})
            }
        }
        impl TryFrom<crate::enums::contacts::TopPeers> for TopPeersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::contacts::TopPeers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::contacts::TopPeers::NotModified => Ok(TopPeersNotModified {}),
                    _ => Err(()),
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod help {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct AppUpdate {
            pub can_not_skip: bool,
            pub id: i32,
            pub version: String,
            pub text: String,
            pub entities: Vec<crate::enums::MessageEntity>,
            pub document: Option<crate::enums::Document>,
            pub url: Option<String>,
            pub sticker: Option<crate::enums::Document>,
        }
        impl crate::Identifiable for AppUpdate {
            const CONSTRUCTOR_ID: u32 = 3434860080;
        }
        impl crate::Serializable for AppUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.can_not_skip { 1 } else { 0 }
                    | if self.document.is_some() { 2 } else { 0 }
                    | if self.url.is_some() { 4 } else { 0 }
                    | if self.sticker.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.id.serialize(buf);
                self.version.serialize(buf);
                self.text.serialize(buf);
                self.entities.serialize(buf);
                if let Some(ref x) = self.document {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.url {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.sticker {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for AppUpdate {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let can_not_skip = (flags & 1) != 0;
                let id = i32::deserialize(buf)?;
                let version = String::deserialize(buf)?;
                let text = String::deserialize(buf)?;
                let entities = Vec::<crate::enums::MessageEntity>::deserialize(buf)?;
                let document = if (flags & 2) != 0 {
                    Some(crate::enums::Document::deserialize(buf)?)
                } else {
                    None
                };
                let url = if (flags & 4) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let sticker = if (flags & 8) != 0 {
                    Some(crate::enums::Document::deserialize(buf)?)
                } else {
                    None
                };
                Ok(AppUpdate {
                    can_not_skip,
                    id,
                    version,
                    text,
                    entities,
                    document,
                    url,
                    sticker,
                })
            }
        }
        impl TryFrom<crate::enums::help::AppUpdate> for AppUpdate {
            type Error = ();
            fn try_from(x: crate::enums::help::AppUpdate) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::AppUpdate::Update(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ConfigSimple {
            pub date: i32,
            pub expires: i32,
            pub rules: crate::RawVec<crate::enums::AccessPointRule>,
        }
        impl crate::Identifiable for ConfigSimple {
            const CONSTRUCTOR_ID: u32 = 1515793004;
        }
        impl crate::Serializable for ConfigSimple {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.date.serialize(buf);
                self.expires.serialize(buf);
                self.rules.serialize(buf);
            }
        }
        impl crate::Deserializable for ConfigSimple {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let date = i32::deserialize(buf)?;
                let expires = i32::deserialize(buf)?;
                let rules = crate::RawVec::<crate::enums::AccessPointRule>::deserialize(buf)?;
                Ok(ConfigSimple {
                    date,
                    expires,
                    rules,
                })
            }
        }
        impl From<crate::enums::help::ConfigSimple> for ConfigSimple {
            fn from(x: crate::enums::help::ConfigSimple) -> Self {
                match x {
                    crate::enums::help::ConfigSimple::Simple(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CountriesList {
            pub countries: Vec<crate::enums::help::Country>,
            pub hash: i32,
        }
        impl crate::Identifiable for CountriesList {
            const CONSTRUCTOR_ID: u32 = 2278585758;
        }
        impl crate::Serializable for CountriesList {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.countries.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::Deserializable for CountriesList {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let countries = Vec::<crate::enums::help::Country>::deserialize(buf)?;
                let hash = i32::deserialize(buf)?;
                Ok(CountriesList { countries, hash })
            }
        }
        impl TryFrom<crate::enums::help::CountriesList> for CountriesList {
            type Error = ();
            fn try_from(x: crate::enums::help::CountriesList) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::CountriesList::List(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CountriesListNotModified {}
        impl crate::Identifiable for CountriesListNotModified {
            const CONSTRUCTOR_ID: u32 = 2479628082;
        }
        impl crate::Serializable for CountriesListNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for CountriesListNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(CountriesListNotModified {})
            }
        }
        impl TryFrom<crate::enums::help::CountriesList> for CountriesListNotModified {
            type Error = ();
            fn try_from(x: crate::enums::help::CountriesList) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::CountriesList::NotModified => {
                        Ok(CountriesListNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Country {
            pub hidden: bool,
            pub iso2: String,
            pub default_name: String,
            pub name: Option<String>,
            pub country_codes: Vec<crate::enums::help::CountryCode>,
        }
        impl crate::Identifiable for Country {
            const CONSTRUCTOR_ID: u32 = 3280440867;
        }
        impl crate::Serializable for Country {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32 | if self.hidden { 1 } else { 0 } | if self.name.is_some() { 2 } else { 0 })
                    .serialize(buf);
                self.iso2.serialize(buf);
                self.default_name.serialize(buf);
                if let Some(ref x) = self.name {
                    x.serialize(buf);
                }
                self.country_codes.serialize(buf);
            }
        }
        impl crate::Deserializable for Country {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let hidden = (flags & 1) != 0;
                let iso2 = String::deserialize(buf)?;
                let default_name = String::deserialize(buf)?;
                let name = if (flags & 2) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let country_codes = Vec::<crate::enums::help::CountryCode>::deserialize(buf)?;
                Ok(Country {
                    hidden,
                    iso2,
                    default_name,
                    name,
                    country_codes,
                })
            }
        }
        impl From<crate::enums::help::Country> for Country {
            fn from(x: crate::enums::help::Country) -> Self {
                match x {
                    crate::enums::help::Country::Country(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CountryCode {
            pub country_code: String,
            pub prefixes: Option<Vec<String>>,
            pub patterns: Option<Vec<String>>,
        }
        impl crate::Identifiable for CountryCode {
            const CONSTRUCTOR_ID: u32 = 1107543535;
        }
        impl crate::Serializable for CountryCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.prefixes.is_some() { 1 } else { 0 }
                    | if self.patterns.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.country_code.serialize(buf);
                if let Some(ref x) = self.prefixes {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.patterns {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for CountryCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let country_code = String::deserialize(buf)?;
                let prefixes = if (flags & 1) != 0 {
                    Some(Vec::<String>::deserialize(buf)?)
                } else {
                    None
                };
                let patterns = if (flags & 2) != 0 {
                    Some(Vec::<String>::deserialize(buf)?)
                } else {
                    None
                };
                Ok(CountryCode {
                    country_code,
                    prefixes,
                    patterns,
                })
            }
        }
        impl From<crate::enums::help::CountryCode> for CountryCode {
            fn from(x: crate::enums::help::CountryCode) -> Self {
                match x {
                    crate::enums::help::CountryCode::Code(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeepLinkInfo {
            pub update_app: bool,
            pub message: String,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
        }
        impl crate::Identifiable for DeepLinkInfo {
            const CONSTRUCTOR_ID: u32 = 1783556146;
        }
        impl crate::Serializable for DeepLinkInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.update_app { 1 } else { 0 }
                    | if self.entities.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.message.serialize(buf);
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for DeepLinkInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let update_app = (flags & 1) != 0;
                let message = String::deserialize(buf)?;
                let entities = if (flags & 2) != 0 {
                    Some(Vec::<crate::enums::MessageEntity>::deserialize(buf)?)
                } else {
                    None
                };
                Ok(DeepLinkInfo {
                    update_app,
                    message,
                    entities,
                })
            }
        }
        impl TryFrom<crate::enums::help::DeepLinkInfo> for DeepLinkInfo {
            type Error = ();
            fn try_from(x: crate::enums::help::DeepLinkInfo) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::DeepLinkInfo::Info(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeepLinkInfoEmpty {}
        impl crate::Identifiable for DeepLinkInfoEmpty {
            const CONSTRUCTOR_ID: u32 = 1722786150;
        }
        impl crate::Serializable for DeepLinkInfoEmpty {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for DeepLinkInfoEmpty {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(DeepLinkInfoEmpty {})
            }
        }
        impl TryFrom<crate::enums::help::DeepLinkInfo> for DeepLinkInfoEmpty {
            type Error = ();
            fn try_from(x: crate::enums::help::DeepLinkInfo) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::DeepLinkInfo::Empty => Ok(DeepLinkInfoEmpty {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InviteText {
            pub message: String,
        }
        impl crate::Identifiable for InviteText {
            const CONSTRUCTOR_ID: u32 = 415997816;
        }
        impl crate::Serializable for InviteText {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.message.serialize(buf);
            }
        }
        impl crate::Deserializable for InviteText {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let message = String::deserialize(buf)?;
                Ok(InviteText { message })
            }
        }
        impl From<crate::enums::help::InviteText> for InviteText {
            fn from(x: crate::enums::help::InviteText) -> Self {
                match x {
                    crate::enums::help::InviteText::Text(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct NoAppUpdate {}
        impl crate::Identifiable for NoAppUpdate {
            const CONSTRUCTOR_ID: u32 = 3294258486;
        }
        impl crate::Serializable for NoAppUpdate {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for NoAppUpdate {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(NoAppUpdate {})
            }
        }
        impl TryFrom<crate::enums::help::AppUpdate> for NoAppUpdate {
            type Error = ();
            fn try_from(x: crate::enums::help::AppUpdate) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::AppUpdate::NoAppUpdate => Ok(NoAppUpdate {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PassportConfig {
            pub hash: i32,
            pub countries_langs: crate::enums::DataJson,
        }
        impl crate::Identifiable for PassportConfig {
            const CONSTRUCTOR_ID: u32 = 2694370991;
        }
        impl crate::Serializable for PassportConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.countries_langs.serialize(buf);
            }
        }
        impl crate::Deserializable for PassportConfig {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i32::deserialize(buf)?;
                let countries_langs = crate::enums::DataJson::deserialize(buf)?;
                Ok(PassportConfig {
                    hash,
                    countries_langs,
                })
            }
        }
        impl TryFrom<crate::enums::help::PassportConfig> for PassportConfig {
            type Error = ();
            fn try_from(x: crate::enums::help::PassportConfig) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::PassportConfig::Config(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PassportConfigNotModified {}
        impl crate::Identifiable for PassportConfigNotModified {
            const CONSTRUCTOR_ID: u32 = 3216634967;
        }
        impl crate::Serializable for PassportConfigNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for PassportConfigNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(PassportConfigNotModified {})
            }
        }
        impl TryFrom<crate::enums::help::PassportConfig> for PassportConfigNotModified {
            type Error = ();
            fn try_from(x: crate::enums::help::PassportConfig) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::PassportConfig::NotModified => {
                        Ok(PassportConfigNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PromoData {
            pub proxy: bool,
            pub expires: i32,
            pub peer: crate::enums::Peer,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
            pub psa_type: Option<String>,
            pub psa_message: Option<String>,
        }
        impl crate::Identifiable for PromoData {
            const CONSTRUCTOR_ID: u32 = 2352576831;
        }
        impl crate::Serializable for PromoData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.proxy { 1 } else { 0 }
                    | if self.psa_type.is_some() { 2 } else { 0 }
                    | if self.psa_message.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.expires.serialize(buf);
                self.peer.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
                if let Some(ref x) = self.psa_type {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.psa_message {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for PromoData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let proxy = (flags & 1) != 0;
                let expires = i32::deserialize(buf)?;
                let peer = crate::enums::Peer::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let psa_type = if (flags & 2) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let psa_message = if (flags & 4) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                Ok(PromoData {
                    proxy,
                    expires,
                    peer,
                    chats,
                    users,
                    psa_type,
                    psa_message,
                })
            }
        }
        impl TryFrom<crate::enums::help::PromoData> for PromoData {
            type Error = ();
            fn try_from(x: crate::enums::help::PromoData) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::PromoData::Data(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PromoDataEmpty {
            pub expires: i32,
        }
        impl crate::Identifiable for PromoDataEmpty {
            const CONSTRUCTOR_ID: u32 = 2566302837;
        }
        impl crate::Serializable for PromoDataEmpty {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.expires.serialize(buf);
            }
        }
        impl crate::Deserializable for PromoDataEmpty {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let expires = i32::deserialize(buf)?;
                Ok(PromoDataEmpty { expires })
            }
        }
        impl TryFrom<crate::enums::help::PromoData> for PromoDataEmpty {
            type Error = ();
            fn try_from(x: crate::enums::help::PromoData) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::PromoData::Empty(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RecentMeUrls {
            pub urls: Vec<crate::enums::RecentMeUrl>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for RecentMeUrls {
            const CONSTRUCTOR_ID: u32 = 235081943;
        }
        impl crate::Serializable for RecentMeUrls {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.urls.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for RecentMeUrls {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let urls = Vec::<crate::enums::RecentMeUrl>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(RecentMeUrls { urls, chats, users })
            }
        }
        impl From<crate::enums::help::RecentMeUrls> for RecentMeUrls {
            fn from(x: crate::enums::help::RecentMeUrls) -> Self {
                match x {
                    crate::enums::help::RecentMeUrls::Urls(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Support {
            pub phone_number: String,
            pub user: crate::enums::User,
        }
        impl crate::Identifiable for Support {
            const CONSTRUCTOR_ID: u32 = 398898678;
        }
        impl crate::Serializable for Support {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.phone_number.serialize(buf);
                self.user.serialize(buf);
            }
        }
        impl crate::Deserializable for Support {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let phone_number = String::deserialize(buf)?;
                let user = crate::enums::User::deserialize(buf)?;
                Ok(Support { phone_number, user })
            }
        }
        impl From<crate::enums::help::Support> for Support {
            fn from(x: crate::enums::help::Support) -> Self {
                match x {
                    crate::enums::help::Support::Support(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SupportName {
            pub name: String,
        }
        impl crate::Identifiable for SupportName {
            const CONSTRUCTOR_ID: u32 = 2349199817;
        }
        impl crate::Serializable for SupportName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.name.serialize(buf);
            }
        }
        impl crate::Deserializable for SupportName {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let name = String::deserialize(buf)?;
                Ok(SupportName { name })
            }
        }
        impl From<crate::enums::help::SupportName> for SupportName {
            fn from(x: crate::enums::help::SupportName) -> Self {
                match x {
                    crate::enums::help::SupportName::Name(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TermsOfService {
            pub popup: bool,
            pub id: crate::enums::DataJson,
            pub text: String,
            pub entities: Vec<crate::enums::MessageEntity>,
            pub min_age_confirm: Option<i32>,
        }
        impl crate::Identifiable for TermsOfService {
            const CONSTRUCTOR_ID: u32 = 2013922064;
        }
        impl crate::Serializable for TermsOfService {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.popup { 1 } else { 0 }
                    | if self.min_age_confirm.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.id.serialize(buf);
                self.text.serialize(buf);
                self.entities.serialize(buf);
                if let Some(ref x) = self.min_age_confirm {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for TermsOfService {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let popup = (flags & 1) != 0;
                let id = crate::enums::DataJson::deserialize(buf)?;
                let text = String::deserialize(buf)?;
                let entities = Vec::<crate::enums::MessageEntity>::deserialize(buf)?;
                let min_age_confirm = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                Ok(TermsOfService {
                    popup,
                    id,
                    text,
                    entities,
                    min_age_confirm,
                })
            }
        }
        impl From<crate::enums::help::TermsOfService> for TermsOfService {
            fn from(x: crate::enums::help::TermsOfService) -> Self {
                match x {
                    crate::enums::help::TermsOfService::Service(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TermsOfServiceUpdate {
            pub expires: i32,
            pub terms_of_service: crate::enums::help::TermsOfService,
        }
        impl crate::Identifiable for TermsOfServiceUpdate {
            const CONSTRUCTOR_ID: u32 = 686618977;
        }
        impl crate::Serializable for TermsOfServiceUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.expires.serialize(buf);
                self.terms_of_service.serialize(buf);
            }
        }
        impl crate::Deserializable for TermsOfServiceUpdate {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let expires = i32::deserialize(buf)?;
                let terms_of_service = crate::enums::help::TermsOfService::deserialize(buf)?;
                Ok(TermsOfServiceUpdate {
                    expires,
                    terms_of_service,
                })
            }
        }
        impl TryFrom<crate::enums::help::TermsOfServiceUpdate> for TermsOfServiceUpdate {
            type Error = ();
            fn try_from(x: crate::enums::help::TermsOfServiceUpdate) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::TermsOfServiceUpdate::Update(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TermsOfServiceUpdateEmpty {
            pub expires: i32,
        }
        impl crate::Identifiable for TermsOfServiceUpdateEmpty {
            const CONSTRUCTOR_ID: u32 = 3811614591;
        }
        impl crate::Serializable for TermsOfServiceUpdateEmpty {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.expires.serialize(buf);
            }
        }
        impl crate::Deserializable for TermsOfServiceUpdateEmpty {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let expires = i32::deserialize(buf)?;
                Ok(TermsOfServiceUpdateEmpty { expires })
            }
        }
        impl TryFrom<crate::enums::help::TermsOfServiceUpdate> for TermsOfServiceUpdateEmpty {
            type Error = ();
            fn try_from(x: crate::enums::help::TermsOfServiceUpdate) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::TermsOfServiceUpdate::Empty(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UserInfo {
            pub message: String,
            pub entities: Vec<crate::enums::MessageEntity>,
            pub author: String,
            pub date: i32,
        }
        impl crate::Identifiable for UserInfo {
            const CONSTRUCTOR_ID: u32 = 32192344;
        }
        impl crate::Serializable for UserInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.message.serialize(buf);
                self.entities.serialize(buf);
                self.author.serialize(buf);
                self.date.serialize(buf);
            }
        }
        impl crate::Deserializable for UserInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let message = String::deserialize(buf)?;
                let entities = Vec::<crate::enums::MessageEntity>::deserialize(buf)?;
                let author = String::deserialize(buf)?;
                let date = i32::deserialize(buf)?;
                Ok(UserInfo {
                    message,
                    entities,
                    author,
                    date,
                })
            }
        }
        impl TryFrom<crate::enums::help::UserInfo> for UserInfo {
            type Error = ();
            fn try_from(x: crate::enums::help::UserInfo) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::UserInfo::Info(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UserInfoEmpty {}
        impl crate::Identifiable for UserInfoEmpty {
            const CONSTRUCTOR_ID: u32 = 4088278765;
        }
        impl crate::Serializable for UserInfoEmpty {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for UserInfoEmpty {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(UserInfoEmpty {})
            }
        }
        impl TryFrom<crate::enums::help::UserInfo> for UserInfoEmpty {
            type Error = ();
            fn try_from(x: crate::enums::help::UserInfo) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::help::UserInfo::Empty => Ok(UserInfoEmpty {}),
                    _ => Err(()),
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod messages {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct AffectedFoundMessages {
            pub pts: i32,
            pub pts_count: i32,
            pub offset: i32,
            pub messages: Vec<i32>,
        }
        impl crate::Identifiable for AffectedFoundMessages {
            const CONSTRUCTOR_ID: u32 = 4019011180;
        }
        impl crate::Serializable for AffectedFoundMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pts.serialize(buf);
                self.pts_count.serialize(buf);
                self.offset.serialize(buf);
                self.messages.serialize(buf);
            }
        }
        impl crate::Deserializable for AffectedFoundMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pts = i32::deserialize(buf)?;
                let pts_count = i32::deserialize(buf)?;
                let offset = i32::deserialize(buf)?;
                let messages = Vec::<i32>::deserialize(buf)?;
                Ok(AffectedFoundMessages {
                    pts,
                    pts_count,
                    offset,
                    messages,
                })
            }
        }
        impl From<crate::enums::messages::AffectedFoundMessages> for AffectedFoundMessages {
            fn from(x: crate::enums::messages::AffectedFoundMessages) -> Self {
                match x {
                    crate::enums::messages::AffectedFoundMessages::Messages(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AffectedHistory {
            pub pts: i32,
            pub pts_count: i32,
            pub offset: i32,
        }
        impl crate::Identifiable for AffectedHistory {
            const CONSTRUCTOR_ID: u32 = 3025955281;
        }
        impl crate::Serializable for AffectedHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pts.serialize(buf);
                self.pts_count.serialize(buf);
                self.offset.serialize(buf);
            }
        }
        impl crate::Deserializable for AffectedHistory {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pts = i32::deserialize(buf)?;
                let pts_count = i32::deserialize(buf)?;
                let offset = i32::deserialize(buf)?;
                Ok(AffectedHistory {
                    pts,
                    pts_count,
                    offset,
                })
            }
        }
        impl From<crate::enums::messages::AffectedHistory> for AffectedHistory {
            fn from(x: crate::enums::messages::AffectedHistory) -> Self {
                match x {
                    crate::enums::messages::AffectedHistory::History(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AffectedMessages {
            pub pts: i32,
            pub pts_count: i32,
        }
        impl crate::Identifiable for AffectedMessages {
            const CONSTRUCTOR_ID: u32 = 2228326789;
        }
        impl crate::Serializable for AffectedMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pts.serialize(buf);
                self.pts_count.serialize(buf);
            }
        }
        impl crate::Deserializable for AffectedMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pts = i32::deserialize(buf)?;
                let pts_count = i32::deserialize(buf)?;
                Ok(AffectedMessages { pts, pts_count })
            }
        }
        impl From<crate::enums::messages::AffectedMessages> for AffectedMessages {
            fn from(x: crate::enums::messages::AffectedMessages) -> Self {
                match x {
                    crate::enums::messages::AffectedMessages::Messages(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AllStickers {
            pub hash: i64,
            pub sets: Vec<crate::enums::StickerSet>,
        }
        impl crate::Identifiable for AllStickers {
            const CONSTRUCTOR_ID: u32 = 3451637435;
        }
        impl crate::Serializable for AllStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.sets.serialize(buf);
            }
        }
        impl crate::Deserializable for AllStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let sets = Vec::<crate::enums::StickerSet>::deserialize(buf)?;
                Ok(AllStickers { hash, sets })
            }
        }
        impl TryFrom<crate::enums::messages::AllStickers> for AllStickers {
            type Error = ();
            fn try_from(x: crate::enums::messages::AllStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::AllStickers::Stickers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AllStickersNotModified {}
        impl crate::Identifiable for AllStickersNotModified {
            const CONSTRUCTOR_ID: u32 = 3898999491;
        }
        impl crate::Serializable for AllStickersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for AllStickersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(AllStickersNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::AllStickers> for AllStickersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::AllStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::AllStickers::NotModified => {
                        Ok(AllStickersNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ArchivedStickers {
            pub count: i32,
            pub sets: Vec<crate::enums::StickerSetCovered>,
        }
        impl crate::Identifiable for ArchivedStickers {
            const CONSTRUCTOR_ID: u32 = 1338747336;
        }
        impl crate::Serializable for ArchivedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.sets.serialize(buf);
            }
        }
        impl crate::Deserializable for ArchivedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let sets = Vec::<crate::enums::StickerSetCovered>::deserialize(buf)?;
                Ok(ArchivedStickers { count, sets })
            }
        }
        impl From<crate::enums::messages::ArchivedStickers> for ArchivedStickers {
            fn from(x: crate::enums::messages::ArchivedStickers) -> Self {
                match x {
                    crate::enums::messages::ArchivedStickers::Stickers(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct BotCallbackAnswer {
            pub alert: bool,
            pub has_url: bool,
            pub native_ui: bool,
            pub message: Option<String>,
            pub url: Option<String>,
            pub cache_time: i32,
        }
        impl crate::Identifiable for BotCallbackAnswer {
            const CONSTRUCTOR_ID: u32 = 911761060;
        }
        impl crate::Serializable for BotCallbackAnswer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.alert { 2 } else { 0 }
                    | if self.has_url { 8 } else { 0 }
                    | if self.native_ui { 16 } else { 0 }
                    | if self.message.is_some() { 1 } else { 0 }
                    | if self.url.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.message {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.url {
                    x.serialize(buf);
                }
                self.cache_time.serialize(buf);
            }
        }
        impl crate::Deserializable for BotCallbackAnswer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let alert = (flags & 2) != 0;
                let has_url = (flags & 8) != 0;
                let native_ui = (flags & 16) != 0;
                let message = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let url = if (flags & 4) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let cache_time = i32::deserialize(buf)?;
                Ok(BotCallbackAnswer {
                    alert,
                    has_url,
                    native_ui,
                    message,
                    url,
                    cache_time,
                })
            }
        }
        impl From<crate::enums::messages::BotCallbackAnswer> for BotCallbackAnswer {
            fn from(x: crate::enums::messages::BotCallbackAnswer) -> Self {
                match x {
                    crate::enums::messages::BotCallbackAnswer::Answer(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct BotResults {
            pub gallery: bool,
            pub query_id: i64,
            pub next_offset: Option<String>,
            pub switch_pm: Option<crate::enums::InlineBotSwitchPm>,
            pub results: Vec<crate::enums::BotInlineResult>,
            pub cache_time: i32,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for BotResults {
            const CONSTRUCTOR_ID: u32 = 2491197512;
        }
        impl crate::Serializable for BotResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.gallery { 1 } else { 0 }
                    | if self.next_offset.is_some() { 2 } else { 0 }
                    | if self.switch_pm.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.query_id.serialize(buf);
                if let Some(ref x) = self.next_offset {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.switch_pm {
                    x.serialize(buf);
                }
                self.results.serialize(buf);
                self.cache_time.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for BotResults {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let gallery = (flags & 1) != 0;
                let query_id = i64::deserialize(buf)?;
                let next_offset = if (flags & 2) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let switch_pm = if (flags & 4) != 0 {
                    Some(crate::enums::InlineBotSwitchPm::deserialize(buf)?)
                } else {
                    None
                };
                let results = Vec::<crate::enums::BotInlineResult>::deserialize(buf)?;
                let cache_time = i32::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(BotResults {
                    gallery,
                    query_id,
                    next_offset,
                    switch_pm,
                    results,
                    cache_time,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::BotResults> for BotResults {
            fn from(x: crate::enums::messages::BotResults) -> Self {
                match x {
                    crate::enums::messages::BotResults::Results(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelMessages {
            pub inexact: bool,
            pub pts: i32,
            pub count: i32,
            pub offset_id_offset: Option<i32>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChannelMessages {
            const CONSTRUCTOR_ID: u32 = 1682413576;
        }
        impl crate::Serializable for ChannelMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.inexact { 2 } else { 0 }
                    | if self.offset_id_offset.is_some() {
                        4
                    } else {
                        0
                    })
                .serialize(buf);
                self.pts.serialize(buf);
                self.count.serialize(buf);
                if let Some(ref x) = self.offset_id_offset {
                    x.serialize(buf);
                }
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChannelMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let inexact = (flags & 2) != 0;
                let pts = i32::deserialize(buf)?;
                let count = i32::deserialize(buf)?;
                let offset_id_offset = if (flags & 4) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChannelMessages {
                    inexact,
                    pts,
                    count,
                    offset_id_offset,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::Messages> for ChannelMessages {
            type Error = ();
            fn try_from(x: crate::enums::messages::Messages) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Messages::ChannelMessages(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChatAdminsWithInvites {
            pub admins: Vec<crate::enums::ChatAdminWithInvites>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChatAdminsWithInvites {
            const CONSTRUCTOR_ID: u32 = 3063640791;
        }
        impl crate::Serializable for ChatAdminsWithInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.admins.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChatAdminsWithInvites {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let admins = Vec::<crate::enums::ChatAdminWithInvites>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChatAdminsWithInvites { admins, users })
            }
        }
        impl From<crate::enums::messages::ChatAdminsWithInvites> for ChatAdminsWithInvites {
            fn from(x: crate::enums::messages::ChatAdminsWithInvites) -> Self {
                match x {
                    crate::enums::messages::ChatAdminsWithInvites::Invites(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChatFull {
            pub full_chat: crate::enums::ChatFull,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChatFull {
            const CONSTRUCTOR_ID: u32 = 3856126364;
        }
        impl crate::Serializable for ChatFull {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.full_chat.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChatFull {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let full_chat = crate::enums::ChatFull::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChatFull {
                    full_chat,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::ChatFull> for ChatFull {
            fn from(x: crate::enums::messages::ChatFull) -> Self {
                match x {
                    crate::enums::messages::ChatFull::Full(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChatInviteImporters {
            pub count: i32,
            pub importers: Vec<crate::enums::ChatInviteImporter>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChatInviteImporters {
            const CONSTRUCTOR_ID: u32 = 2176233482;
        }
        impl crate::Serializable for ChatInviteImporters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.importers.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChatInviteImporters {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let importers = Vec::<crate::enums::ChatInviteImporter>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChatInviteImporters {
                    count,
                    importers,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::ChatInviteImporters> for ChatInviteImporters {
            fn from(x: crate::enums::messages::ChatInviteImporters) -> Self {
                match x {
                    crate::enums::messages::ChatInviteImporters::Importers(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Chats {
            pub chats: Vec<crate::enums::Chat>,
        }
        impl crate::Identifiable for Chats {
            const CONSTRUCTOR_ID: u32 = 1694474197;
        }
        impl crate::Serializable for Chats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.chats.serialize(buf);
            }
        }
        impl crate::Deserializable for Chats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                Ok(Chats { chats })
            }
        }
        impl TryFrom<crate::enums::messages::Chats> for Chats {
            type Error = ();
            fn try_from(x: crate::enums::messages::Chats) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Chats::Chats(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChatsSlice {
            pub count: i32,
            pub chats: Vec<crate::enums::Chat>,
        }
        impl crate::Identifiable for ChatsSlice {
            const CONSTRUCTOR_ID: u32 = 2631405892;
        }
        impl crate::Serializable for ChatsSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.chats.serialize(buf);
            }
        }
        impl crate::Deserializable for ChatsSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                Ok(ChatsSlice { count, chats })
            }
        }
        impl TryFrom<crate::enums::messages::Chats> for ChatsSlice {
            type Error = ();
            fn try_from(x: crate::enums::messages::Chats) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Chats::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckedHistoryImportPeer {
            pub confirm_text: String,
        }
        impl crate::Identifiable for CheckedHistoryImportPeer {
            const CONSTRUCTOR_ID: u32 = 2723014423;
        }
        impl crate::Serializable for CheckedHistoryImportPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.confirm_text.serialize(buf);
            }
        }
        impl crate::Deserializable for CheckedHistoryImportPeer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let confirm_text = String::deserialize(buf)?;
                Ok(CheckedHistoryImportPeer { confirm_text })
            }
        }
        impl From<crate::enums::messages::CheckedHistoryImportPeer> for CheckedHistoryImportPeer {
            fn from(x: crate::enums::messages::CheckedHistoryImportPeer) -> Self {
                match x {
                    crate::enums::messages::CheckedHistoryImportPeer::Peer(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DhConfig {
            pub g: i32,
            pub p: Vec<u8>,
            pub version: i32,
            pub random: Vec<u8>,
        }
        impl crate::Identifiable for DhConfig {
            const CONSTRUCTOR_ID: u32 = 740433629;
        }
        impl crate::Serializable for DhConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.g.serialize(buf);
                self.p.serialize(buf);
                self.version.serialize(buf);
                self.random.serialize(buf);
            }
        }
        impl crate::Deserializable for DhConfig {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let g = i32::deserialize(buf)?;
                let p = Vec::<u8>::deserialize(buf)?;
                let version = i32::deserialize(buf)?;
                let random = Vec::<u8>::deserialize(buf)?;
                Ok(DhConfig {
                    g,
                    p,
                    version,
                    random,
                })
            }
        }
        impl TryFrom<crate::enums::messages::DhConfig> for DhConfig {
            type Error = ();
            fn try_from(x: crate::enums::messages::DhConfig) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::DhConfig::Config(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DhConfigNotModified {
            pub random: Vec<u8>,
        }
        impl crate::Identifiable for DhConfigNotModified {
            const CONSTRUCTOR_ID: u32 = 3236054581;
        }
        impl crate::Serializable for DhConfigNotModified {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.random.serialize(buf);
            }
        }
        impl crate::Deserializable for DhConfigNotModified {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let random = Vec::<u8>::deserialize(buf)?;
                Ok(DhConfigNotModified { random })
            }
        }
        impl TryFrom<crate::enums::messages::DhConfig> for DhConfigNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::DhConfig) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::DhConfig::NotModified(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Dialogs {
            pub dialogs: Vec<crate::enums::Dialog>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Dialogs {
            const CONSTRUCTOR_ID: u32 = 364538944;
        }
        impl crate::Serializable for Dialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.dialogs.serialize(buf);
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Dialogs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let dialogs = Vec::<crate::enums::Dialog>::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Dialogs {
                    dialogs,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::Dialogs> for Dialogs {
            type Error = ();
            fn try_from(x: crate::enums::messages::Dialogs) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Dialogs::Dialogs(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DialogsNotModified {
            pub count: i32,
        }
        impl crate::Identifiable for DialogsNotModified {
            const CONSTRUCTOR_ID: u32 = 4041467286;
        }
        impl crate::Serializable for DialogsNotModified {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
            }
        }
        impl crate::Deserializable for DialogsNotModified {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                Ok(DialogsNotModified { count })
            }
        }
        impl TryFrom<crate::enums::messages::Dialogs> for DialogsNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::Dialogs) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Dialogs::NotModified(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DialogsSlice {
            pub count: i32,
            pub dialogs: Vec<crate::enums::Dialog>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for DialogsSlice {
            const CONSTRUCTOR_ID: u32 = 1910543603;
        }
        impl crate::Serializable for DialogsSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.dialogs.serialize(buf);
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for DialogsSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let dialogs = Vec::<crate::enums::Dialog>::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(DialogsSlice {
                    count,
                    dialogs,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::Dialogs> for DialogsSlice {
            type Error = ();
            fn try_from(x: crate::enums::messages::Dialogs) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Dialogs::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DiscussionMessage {
            pub messages: Vec<crate::enums::Message>,
            pub max_id: Option<i32>,
            pub read_inbox_max_id: Option<i32>,
            pub read_outbox_max_id: Option<i32>,
            pub unread_count: i32,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for DiscussionMessage {
            const CONSTRUCTOR_ID: u32 = 2788431746;
        }
        impl crate::Serializable for DiscussionMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.max_id.is_some() { 1 } else { 0 }
                    | if self.read_inbox_max_id.is_some() {
                        2
                    } else {
                        0
                    }
                    | if self.read_outbox_max_id.is_some() {
                        4
                    } else {
                        0
                    })
                .serialize(buf);
                self.messages.serialize(buf);
                if let Some(ref x) = self.max_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.read_inbox_max_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.read_outbox_max_id {
                    x.serialize(buf);
                }
                self.unread_count.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for DiscussionMessage {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let max_id = if (flags & 1) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let read_inbox_max_id = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let read_outbox_max_id = if (flags & 4) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let unread_count = i32::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(DiscussionMessage {
                    messages,
                    max_id,
                    read_inbox_max_id,
                    read_outbox_max_id,
                    unread_count,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::DiscussionMessage> for DiscussionMessage {
            fn from(x: crate::enums::messages::DiscussionMessage) -> Self {
                match x {
                    crate::enums::messages::DiscussionMessage::Message(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportedChatInvite {
            pub invite: crate::enums::ExportedChatInvite,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ExportedChatInvite {
            const CONSTRUCTOR_ID: u32 = 410107472;
        }
        impl crate::Serializable for ExportedChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.invite.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ExportedChatInvite {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ExportedChatInvite { invite, users })
            }
        }
        impl TryFrom<crate::enums::messages::ExportedChatInvite> for ExportedChatInvite {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::ExportedChatInvite,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::ExportedChatInvite::Invite(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportedChatInviteReplaced {
            pub invite: crate::enums::ExportedChatInvite,
            pub new_invite: crate::enums::ExportedChatInvite,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ExportedChatInviteReplaced {
            const CONSTRUCTOR_ID: u32 = 572915951;
        }
        impl crate::Serializable for ExportedChatInviteReplaced {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.invite.serialize(buf);
                self.new_invite.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ExportedChatInviteReplaced {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
                let new_invite = crate::enums::ExportedChatInvite::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ExportedChatInviteReplaced {
                    invite,
                    new_invite,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::ExportedChatInvite> for ExportedChatInviteReplaced {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::ExportedChatInvite,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::ExportedChatInvite::Replaced(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportedChatInvites {
            pub count: i32,
            pub invites: Vec<crate::enums::ExportedChatInvite>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ExportedChatInvites {
            const CONSTRUCTOR_ID: u32 = 3183881676;
        }
        impl crate::Serializable for ExportedChatInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.invites.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ExportedChatInvites {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let invites = Vec::<crate::enums::ExportedChatInvite>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ExportedChatInvites {
                    count,
                    invites,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::ExportedChatInvites> for ExportedChatInvites {
            fn from(x: crate::enums::messages::ExportedChatInvites) -> Self {
                match x {
                    crate::enums::messages::ExportedChatInvites::Invites(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FavedStickers {
            pub hash: i64,
            pub packs: Vec<crate::enums::StickerPack>,
            pub stickers: Vec<crate::enums::Document>,
        }
        impl crate::Identifiable for FavedStickers {
            const CONSTRUCTOR_ID: u32 = 750063767;
        }
        impl crate::Serializable for FavedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.packs.serialize(buf);
                self.stickers.serialize(buf);
            }
        }
        impl crate::Deserializable for FavedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let packs = Vec::<crate::enums::StickerPack>::deserialize(buf)?;
                let stickers = Vec::<crate::enums::Document>::deserialize(buf)?;
                Ok(FavedStickers {
                    hash,
                    packs,
                    stickers,
                })
            }
        }
        impl TryFrom<crate::enums::messages::FavedStickers> for FavedStickers {
            type Error = ();
            fn try_from(x: crate::enums::messages::FavedStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FavedStickers::Stickers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FavedStickersNotModified {}
        impl crate::Identifiable for FavedStickersNotModified {
            const CONSTRUCTOR_ID: u32 = 2660214483;
        }
        impl crate::Serializable for FavedStickersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FavedStickersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FavedStickersNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::FavedStickers> for FavedStickersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::FavedStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FavedStickers::NotModified => {
                        Ok(FavedStickersNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FeaturedStickers {
            pub hash: i64,
            pub count: i32,
            pub sets: Vec<crate::enums::StickerSetCovered>,
            pub unread: Vec<i64>,
        }
        impl crate::Identifiable for FeaturedStickers {
            const CONSTRUCTOR_ID: u32 = 2227184400;
        }
        impl crate::Serializable for FeaturedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.count.serialize(buf);
                self.sets.serialize(buf);
                self.unread.serialize(buf);
            }
        }
        impl crate::Deserializable for FeaturedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let count = i32::deserialize(buf)?;
                let sets = Vec::<crate::enums::StickerSetCovered>::deserialize(buf)?;
                let unread = Vec::<i64>::deserialize(buf)?;
                Ok(FeaturedStickers {
                    hash,
                    count,
                    sets,
                    unread,
                })
            }
        }
        impl TryFrom<crate::enums::messages::FeaturedStickers> for FeaturedStickers {
            type Error = ();
            fn try_from(x: crate::enums::messages::FeaturedStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FeaturedStickers::Stickers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FeaturedStickersNotModified {
            pub count: i32,
        }
        impl crate::Identifiable for FeaturedStickersNotModified {
            const CONSTRUCTOR_ID: u32 = 3336309862;
        }
        impl crate::Serializable for FeaturedStickersNotModified {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
            }
        }
        impl crate::Deserializable for FeaturedStickersNotModified {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                Ok(FeaturedStickersNotModified { count })
            }
        }
        impl TryFrom<crate::enums::messages::FeaturedStickers> for FeaturedStickersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::FeaturedStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FeaturedStickers::NotModified(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FoundStickerSets {
            pub hash: i64,
            pub sets: Vec<crate::enums::StickerSetCovered>,
        }
        impl crate::Identifiable for FoundStickerSets {
            const CONSTRUCTOR_ID: u32 = 2331024850;
        }
        impl crate::Serializable for FoundStickerSets {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.sets.serialize(buf);
            }
        }
        impl crate::Deserializable for FoundStickerSets {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let sets = Vec::<crate::enums::StickerSetCovered>::deserialize(buf)?;
                Ok(FoundStickerSets { hash, sets })
            }
        }
        impl TryFrom<crate::enums::messages::FoundStickerSets> for FoundStickerSets {
            type Error = ();
            fn try_from(x: crate::enums::messages::FoundStickerSets) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FoundStickerSets::Sets(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FoundStickerSetsNotModified {}
        impl crate::Identifiable for FoundStickerSetsNotModified {
            const CONSTRUCTOR_ID: u32 = 223655517;
        }
        impl crate::Serializable for FoundStickerSetsNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FoundStickerSetsNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FoundStickerSetsNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::FoundStickerSets> for FoundStickerSetsNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::FoundStickerSets) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::FoundStickerSets::NotModified => {
                        Ok(FoundStickerSetsNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HighScores {
            pub scores: Vec<crate::enums::HighScore>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for HighScores {
            const CONSTRUCTOR_ID: u32 = 2587622809;
        }
        impl crate::Serializable for HighScores {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.scores.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for HighScores {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let scores = Vec::<crate::enums::HighScore>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(HighScores { scores, users })
            }
        }
        impl From<crate::enums::messages::HighScores> for HighScores {
            fn from(x: crate::enums::messages::HighScores) -> Self {
                match x {
                    crate::enums::messages::HighScores::Scores(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HistoryImport {
            pub id: i64,
        }
        impl crate::Identifiable for HistoryImport {
            const CONSTRUCTOR_ID: u32 = 375566091;
        }
        impl crate::Serializable for HistoryImport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.id.serialize(buf);
            }
        }
        impl crate::Deserializable for HistoryImport {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let id = i64::deserialize(buf)?;
                Ok(HistoryImport { id })
            }
        }
        impl From<crate::enums::messages::HistoryImport> for HistoryImport {
            fn from(x: crate::enums::messages::HistoryImport) -> Self {
                match x {
                    crate::enums::messages::HistoryImport::Import(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HistoryImportParsed {
            pub pm: bool,
            pub group: bool,
            pub title: Option<String>,
        }
        impl crate::Identifiable for HistoryImportParsed {
            const CONSTRUCTOR_ID: u32 = 1578088377;
        }
        impl crate::Serializable for HistoryImportParsed {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.pm { 1 } else { 0 }
                    | if self.group { 2 } else { 0 }
                    | if self.title.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for HistoryImportParsed {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let pm = (flags & 1) != 0;
                let group = (flags & 2) != 0;
                let title = if (flags & 4) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                Ok(HistoryImportParsed { pm, group, title })
            }
        }
        impl From<crate::enums::messages::HistoryImportParsed> for HistoryImportParsed {
            fn from(x: crate::enums::messages::HistoryImportParsed) -> Self {
                match x {
                    crate::enums::messages::HistoryImportParsed::Parsed(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InactiveChats {
            pub dates: Vec<i32>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for InactiveChats {
            const CONSTRUCTOR_ID: u32 = 2837970629;
        }
        impl crate::Serializable for InactiveChats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.dates.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for InactiveChats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let dates = Vec::<i32>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(InactiveChats {
                    dates,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::InactiveChats> for InactiveChats {
            fn from(x: crate::enums::messages::InactiveChats) -> Self {
                match x {
                    crate::enums::messages::InactiveChats::Chats(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MessageEditData {
            pub caption: bool,
        }
        impl crate::Identifiable for MessageEditData {
            const CONSTRUCTOR_ID: u32 = 649453030;
        }
        impl crate::Serializable for MessageEditData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32 | if self.caption { 1 } else { 0 }).serialize(buf);
            }
        }
        impl crate::Deserializable for MessageEditData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let caption = (flags & 1) != 0;
                Ok(MessageEditData { caption })
            }
        }
        impl From<crate::enums::messages::MessageEditData> for MessageEditData {
            fn from(x: crate::enums::messages::MessageEditData) -> Self {
                match x {
                    crate::enums::messages::MessageEditData::Data(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MessageViews {
            pub views: Vec<crate::enums::MessageViews>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for MessageViews {
            const CONSTRUCTOR_ID: u32 = 3066361155;
        }
        impl crate::Serializable for MessageViews {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.views.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for MessageViews {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let views = Vec::<crate::enums::MessageViews>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(MessageViews {
                    views,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::MessageViews> for MessageViews {
            fn from(x: crate::enums::messages::MessageViews) -> Self {
                match x {
                    crate::enums::messages::MessageViews::Views(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Messages {
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Messages {
            const CONSTRUCTOR_ID: u32 = 2356252295;
        }
        impl crate::Serializable for Messages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Messages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Messages {
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::Messages> for Messages {
            type Error = ();
            fn try_from(x: crate::enums::messages::Messages) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Messages::Messages(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MessagesNotModified {
            pub count: i32,
        }
        impl crate::Identifiable for MessagesNotModified {
            const CONSTRUCTOR_ID: u32 = 1951620897;
        }
        impl crate::Serializable for MessagesNotModified {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
            }
        }
        impl crate::Deserializable for MessagesNotModified {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                Ok(MessagesNotModified { count })
            }
        }
        impl TryFrom<crate::enums::messages::Messages> for MessagesNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::Messages) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Messages::NotModified(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MessagesSlice {
            pub inexact: bool,
            pub count: i32,
            pub next_rate: Option<i32>,
            pub offset_id_offset: Option<i32>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for MessagesSlice {
            const CONSTRUCTOR_ID: u32 = 978610270;
        }
        impl crate::Serializable for MessagesSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.inexact { 2 } else { 0 }
                    | if self.next_rate.is_some() { 1 } else { 0 }
                    | if self.offset_id_offset.is_some() {
                        4
                    } else {
                        0
                    })
                .serialize(buf);
                self.count.serialize(buf);
                if let Some(ref x) = self.next_rate {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.offset_id_offset {
                    x.serialize(buf);
                }
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for MessagesSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let inexact = (flags & 2) != 0;
                let count = i32::deserialize(buf)?;
                let next_rate = if (flags & 1) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let offset_id_offset = if (flags & 4) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(MessagesSlice {
                    inexact,
                    count,
                    next_rate,
                    offset_id_offset,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::messages::Messages> for MessagesSlice {
            type Error = ();
            fn try_from(x: crate::enums::messages::Messages) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Messages::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PeerDialogs {
            pub dialogs: Vec<crate::enums::Dialog>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
            pub state: crate::enums::updates::State,
        }
        impl crate::Identifiable for PeerDialogs {
            const CONSTRUCTOR_ID: u32 = 863093588;
        }
        impl crate::Serializable for PeerDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.dialogs.serialize(buf);
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
                self.state.serialize(buf);
            }
        }
        impl crate::Deserializable for PeerDialogs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let dialogs = Vec::<crate::enums::Dialog>::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let state = crate::enums::updates::State::deserialize(buf)?;
                Ok(PeerDialogs {
                    dialogs,
                    messages,
                    chats,
                    users,
                    state,
                })
            }
        }
        impl From<crate::enums::messages::PeerDialogs> for PeerDialogs {
            fn from(x: crate::enums::messages::PeerDialogs) -> Self {
                match x {
                    crate::enums::messages::PeerDialogs::Dialogs(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PeerSettings {
            pub settings: crate::enums::PeerSettings,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PeerSettings {
            const CONSTRUCTOR_ID: u32 = 1753266509;
        }
        impl crate::Serializable for PeerSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.settings.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PeerSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let settings = crate::enums::PeerSettings::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PeerSettings {
                    settings,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::PeerSettings> for PeerSettings {
            fn from(x: crate::enums::messages::PeerSettings) -> Self {
                match x {
                    crate::enums::messages::PeerSettings::Settings(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RecentStickers {
            pub hash: i64,
            pub packs: Vec<crate::enums::StickerPack>,
            pub stickers: Vec<crate::enums::Document>,
            pub dates: Vec<i32>,
        }
        impl crate::Identifiable for RecentStickers {
            const CONSTRUCTOR_ID: u32 = 2295561302;
        }
        impl crate::Serializable for RecentStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.packs.serialize(buf);
                self.stickers.serialize(buf);
                self.dates.serialize(buf);
            }
        }
        impl crate::Deserializable for RecentStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let packs = Vec::<crate::enums::StickerPack>::deserialize(buf)?;
                let stickers = Vec::<crate::enums::Document>::deserialize(buf)?;
                let dates = Vec::<i32>::deserialize(buf)?;
                Ok(RecentStickers {
                    hash,
                    packs,
                    stickers,
                    dates,
                })
            }
        }
        impl TryFrom<crate::enums::messages::RecentStickers> for RecentStickers {
            type Error = ();
            fn try_from(x: crate::enums::messages::RecentStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::RecentStickers::Stickers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RecentStickersNotModified {}
        impl crate::Identifiable for RecentStickersNotModified {
            const CONSTRUCTOR_ID: u32 = 186120336;
        }
        impl crate::Serializable for RecentStickersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for RecentStickersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(RecentStickersNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::RecentStickers> for RecentStickersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::RecentStickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::RecentStickers::NotModified => {
                        Ok(RecentStickersNotModified {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SavedGifs {
            pub hash: i64,
            pub gifs: Vec<crate::enums::Document>,
        }
        impl crate::Identifiable for SavedGifs {
            const CONSTRUCTOR_ID: u32 = 2225089037;
        }
        impl crate::Serializable for SavedGifs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.gifs.serialize(buf);
            }
        }
        impl crate::Deserializable for SavedGifs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let gifs = Vec::<crate::enums::Document>::deserialize(buf)?;
                Ok(SavedGifs { hash, gifs })
            }
        }
        impl TryFrom<crate::enums::messages::SavedGifs> for SavedGifs {
            type Error = ();
            fn try_from(x: crate::enums::messages::SavedGifs) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::SavedGifs::Gifs(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SavedGifsNotModified {}
        impl crate::Identifiable for SavedGifsNotModified {
            const CONSTRUCTOR_ID: u32 = 3892468898;
        }
        impl crate::Serializable for SavedGifsNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for SavedGifsNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(SavedGifsNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::SavedGifs> for SavedGifsNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::SavedGifs) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::SavedGifs::NotModified => Ok(SavedGifsNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SearchCounter {
            pub inexact: bool,
            pub filter: crate::enums::MessagesFilter,
            pub count: i32,
        }
        impl crate::Identifiable for SearchCounter {
            const CONSTRUCTOR_ID: u32 = 3896830975;
        }
        impl crate::Serializable for SearchCounter {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32 | if self.inexact { 2 } else { 0 }).serialize(buf);
                self.filter.serialize(buf);
                self.count.serialize(buf);
            }
        }
        impl crate::Deserializable for SearchCounter {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let inexact = (flags & 2) != 0;
                let filter = crate::enums::MessagesFilter::deserialize(buf)?;
                let count = i32::deserialize(buf)?;
                Ok(SearchCounter {
                    inexact,
                    filter,
                    count,
                })
            }
        }
        impl From<crate::enums::messages::SearchCounter> for SearchCounter {
            fn from(x: crate::enums::messages::SearchCounter) -> Self {
                match x {
                    crate::enums::messages::SearchCounter::Counter(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SearchResultsCalendar {
            pub inexact: bool,
            pub count: i32,
            pub min_date: i32,
            pub min_msg_id: i32,
            pub offset_id_offset: Option<i32>,
            pub periods: Vec<crate::enums::SearchResultsCalendarPeriod>,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for SearchResultsCalendar {
            const CONSTRUCTOR_ID: u32 = 343859772;
        }
        impl crate::Serializable for SearchResultsCalendar {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.inexact { 1 } else { 0 }
                    | if self.offset_id_offset.is_some() {
                        2
                    } else {
                        0
                    })
                .serialize(buf);
                self.count.serialize(buf);
                self.min_date.serialize(buf);
                self.min_msg_id.serialize(buf);
                if let Some(ref x) = self.offset_id_offset {
                    x.serialize(buf);
                }
                self.periods.serialize(buf);
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for SearchResultsCalendar {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let inexact = (flags & 1) != 0;
                let count = i32::deserialize(buf)?;
                let min_date = i32::deserialize(buf)?;
                let min_msg_id = i32::deserialize(buf)?;
                let offset_id_offset = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let periods = Vec::<crate::enums::SearchResultsCalendarPeriod>::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(SearchResultsCalendar {
                    inexact,
                    count,
                    min_date,
                    min_msg_id,
                    offset_id_offset,
                    periods,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::SearchResultsCalendar> for SearchResultsCalendar {
            fn from(x: crate::enums::messages::SearchResultsCalendar) -> Self {
                match x {
                    crate::enums::messages::SearchResultsCalendar::Calendar(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SearchResultsPositions {
            pub count: i32,
            pub positions: Vec<crate::enums::SearchResultsPosition>,
        }
        impl crate::Identifiable for SearchResultsPositions {
            const CONSTRUCTOR_ID: u32 = 1404185519;
        }
        impl crate::Serializable for SearchResultsPositions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.positions.serialize(buf);
            }
        }
        impl crate::Deserializable for SearchResultsPositions {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let positions = Vec::<crate::enums::SearchResultsPosition>::deserialize(buf)?;
                Ok(SearchResultsPositions { count, positions })
            }
        }
        impl From<crate::enums::messages::SearchResultsPositions> for SearchResultsPositions {
            fn from(x: crate::enums::messages::SearchResultsPositions) -> Self {
                match x {
                    crate::enums::messages::SearchResultsPositions::Positions(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentEncryptedFile {
            pub date: i32,
            pub file: crate::enums::EncryptedFile,
        }
        impl crate::Identifiable for SentEncryptedFile {
            const CONSTRUCTOR_ID: u32 = 2492727090;
        }
        impl crate::Serializable for SentEncryptedFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.date.serialize(buf);
                self.file.serialize(buf);
            }
        }
        impl crate::Deserializable for SentEncryptedFile {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let date = i32::deserialize(buf)?;
                let file = crate::enums::EncryptedFile::deserialize(buf)?;
                Ok(SentEncryptedFile { date, file })
            }
        }
        impl TryFrom<crate::enums::messages::SentEncryptedMessage> for SentEncryptedFile {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::SentEncryptedMessage,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::SentEncryptedMessage::SentEncryptedFile(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SentEncryptedMessage {
            pub date: i32,
        }
        impl crate::Identifiable for SentEncryptedMessage {
            const CONSTRUCTOR_ID: u32 = 1443858741;
        }
        impl crate::Serializable for SentEncryptedMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.date.serialize(buf);
            }
        }
        impl crate::Deserializable for SentEncryptedMessage {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let date = i32::deserialize(buf)?;
                Ok(SentEncryptedMessage { date })
            }
        }
        impl TryFrom<crate::enums::messages::SentEncryptedMessage> for SentEncryptedMessage {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::SentEncryptedMessage,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::SentEncryptedMessage::Message(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SponsoredMessages {
            pub messages: Vec<crate::enums::SponsoredMessage>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for SponsoredMessages {
            const CONSTRUCTOR_ID: u32 = 1705297877;
        }
        impl crate::Serializable for SponsoredMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for SponsoredMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let messages = Vec::<crate::enums::SponsoredMessage>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(SponsoredMessages {
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::messages::SponsoredMessages> for SponsoredMessages {
            fn from(x: crate::enums::messages::SponsoredMessages) -> Self {
                match x {
                    crate::enums::messages::SponsoredMessages::Messages(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StickerSet {
            pub set: crate::enums::StickerSet,
            pub packs: Vec<crate::enums::StickerPack>,
            pub documents: Vec<crate::enums::Document>,
        }
        impl crate::Identifiable for StickerSet {
            const CONSTRUCTOR_ID: u32 = 3054118054;
        }
        impl crate::Serializable for StickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.set.serialize(buf);
                self.packs.serialize(buf);
                self.documents.serialize(buf);
            }
        }
        impl crate::Deserializable for StickerSet {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let set = crate::enums::StickerSet::deserialize(buf)?;
                let packs = Vec::<crate::enums::StickerPack>::deserialize(buf)?;
                let documents = Vec::<crate::enums::Document>::deserialize(buf)?;
                Ok(StickerSet {
                    set,
                    packs,
                    documents,
                })
            }
        }
        impl TryFrom<crate::enums::messages::StickerSet> for StickerSet {
            type Error = ();
            fn try_from(x: crate::enums::messages::StickerSet) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::StickerSet::Set(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StickerSetInstallResultArchive {
            pub sets: Vec<crate::enums::StickerSetCovered>,
        }
        impl crate::Identifiable for StickerSetInstallResultArchive {
            const CONSTRUCTOR_ID: u32 = 904138920;
        }
        impl crate::Serializable for StickerSetInstallResultArchive {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.sets.serialize(buf);
            }
        }
        impl crate::Deserializable for StickerSetInstallResultArchive {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let sets = Vec::<crate::enums::StickerSetCovered>::deserialize(buf)?;
                Ok(StickerSetInstallResultArchive { sets })
            }
        }
        impl TryFrom<crate::enums::messages::StickerSetInstallResult> for StickerSetInstallResultArchive {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::StickerSetInstallResult,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::StickerSetInstallResult::Archive(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StickerSetInstallResultSuccess {}
        impl crate::Identifiable for StickerSetInstallResultSuccess {
            const CONSTRUCTOR_ID: u32 = 946083368;
        }
        impl crate::Serializable for StickerSetInstallResultSuccess {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for StickerSetInstallResultSuccess {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(StickerSetInstallResultSuccess {})
            }
        }
        impl TryFrom<crate::enums::messages::StickerSetInstallResult> for StickerSetInstallResultSuccess {
            type Error = ();
            fn try_from(
                x: crate::enums::messages::StickerSetInstallResult,
            ) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::StickerSetInstallResult::Success => {
                        Ok(StickerSetInstallResultSuccess {})
                    }
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StickerSetNotModified {}
        impl crate::Identifiable for StickerSetNotModified {
            const CONSTRUCTOR_ID: u32 = 3556320491;
        }
        impl crate::Serializable for StickerSetNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for StickerSetNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(StickerSetNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::StickerSet> for StickerSetNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::StickerSet) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::StickerSet::NotModified => Ok(StickerSetNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Stickers {
            pub hash: i64,
            pub stickers: Vec<crate::enums::Document>,
        }
        impl crate::Identifiable for Stickers {
            const CONSTRUCTOR_ID: u32 = 816245886;
        }
        impl crate::Serializable for Stickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.hash.serialize(buf);
                self.stickers.serialize(buf);
            }
        }
        impl crate::Deserializable for Stickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let hash = i64::deserialize(buf)?;
                let stickers = Vec::<crate::enums::Document>::deserialize(buf)?;
                Ok(Stickers { hash, stickers })
            }
        }
        impl TryFrom<crate::enums::messages::Stickers> for Stickers {
            type Error = ();
            fn try_from(x: crate::enums::messages::Stickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Stickers::Stickers(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StickersNotModified {}
        impl crate::Identifiable for StickersNotModified {
            const CONSTRUCTOR_ID: u32 = 4050950690;
        }
        impl crate::Serializable for StickersNotModified {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for StickersNotModified {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(StickersNotModified {})
            }
        }
        impl TryFrom<crate::enums::messages::Stickers> for StickersNotModified {
            type Error = ();
            fn try_from(x: crate::enums::messages::Stickers) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::messages::Stickers::NotModified => Ok(StickersNotModified {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct VotesList {
            pub count: i32,
            pub votes: Vec<crate::enums::MessageUserVote>,
            pub users: Vec<crate::enums::User>,
            pub next_offset: Option<String>,
        }
        impl crate::Identifiable for VotesList {
            const CONSTRUCTOR_ID: u32 = 136574537;
        }
        impl crate::Serializable for VotesList {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32 | if self.next_offset.is_some() { 1 } else { 0 }).serialize(buf);
                self.count.serialize(buf);
                self.votes.serialize(buf);
                self.users.serialize(buf);
                if let Some(ref x) = self.next_offset {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for VotesList {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let count = i32::deserialize(buf)?;
                let votes = Vec::<crate::enums::MessageUserVote>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let next_offset = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                Ok(VotesList {
                    count,
                    votes,
                    users,
                    next_offset,
                })
            }
        }
        impl From<crate::enums::messages::VotesList> for VotesList {
            fn from(x: crate::enums::messages::VotesList) -> Self {
                match x {
                    crate::enums::messages::VotesList::List(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod payments {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct BankCardData {
            pub title: String,
            pub open_urls: Vec<crate::enums::BankCardOpenUrl>,
        }
        impl crate::Identifiable for BankCardData {
            const CONSTRUCTOR_ID: u32 = 1042605427;
        }
        impl crate::Serializable for BankCardData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.title.serialize(buf);
                self.open_urls.serialize(buf);
            }
        }
        impl crate::Deserializable for BankCardData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let title = String::deserialize(buf)?;
                let open_urls = Vec::<crate::enums::BankCardOpenUrl>::deserialize(buf)?;
                Ok(BankCardData { title, open_urls })
            }
        }
        impl From<crate::enums::payments::BankCardData> for BankCardData {
            fn from(x: crate::enums::payments::BankCardData) -> Self {
                match x {
                    crate::enums::payments::BankCardData::Data(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PaymentForm {
            pub can_save_credentials: bool,
            pub password_missing: bool,
            pub form_id: i64,
            pub bot_id: i64,
            pub invoice: crate::enums::Invoice,
            pub provider_id: i64,
            pub url: String,
            pub native_provider: Option<String>,
            pub native_params: Option<crate::enums::DataJson>,
            pub saved_info: Option<crate::enums::PaymentRequestedInfo>,
            pub saved_credentials: Option<crate::enums::PaymentSavedCredentials>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PaymentForm {
            const CONSTRUCTOR_ID: u32 = 378828315;
        }
        impl crate::Serializable for PaymentForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.can_save_credentials { 4 } else { 0 }
                    | if self.password_missing { 8 } else { 0 }
                    | if self.native_provider.is_some() {
                        16
                    } else {
                        0
                    }
                    | if self.native_params.is_some() { 16 } else { 0 }
                    | if self.saved_info.is_some() { 1 } else { 0 }
                    | if self.saved_credentials.is_some() {
                        2
                    } else {
                        0
                    })
                .serialize(buf);
                self.form_id.serialize(buf);
                self.bot_id.serialize(buf);
                self.invoice.serialize(buf);
                self.provider_id.serialize(buf);
                self.url.serialize(buf);
                if let Some(ref x) = self.native_provider {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.native_params {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.saved_info {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.saved_credentials {
                    x.serialize(buf);
                }
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PaymentForm {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let can_save_credentials = (flags & 4) != 0;
                let password_missing = (flags & 8) != 0;
                let form_id = i64::deserialize(buf)?;
                let bot_id = i64::deserialize(buf)?;
                let invoice = crate::enums::Invoice::deserialize(buf)?;
                let provider_id = i64::deserialize(buf)?;
                let url = String::deserialize(buf)?;
                let native_provider = if (flags & 16) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let native_params = if (flags & 16) != 0 {
                    Some(crate::enums::DataJson::deserialize(buf)?)
                } else {
                    None
                };
                let saved_info = if (flags & 1) != 0 {
                    Some(crate::enums::PaymentRequestedInfo::deserialize(buf)?)
                } else {
                    None
                };
                let saved_credentials = if (flags & 2) != 0 {
                    Some(crate::enums::PaymentSavedCredentials::deserialize(buf)?)
                } else {
                    None
                };
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PaymentForm {
                    can_save_credentials,
                    password_missing,
                    form_id,
                    bot_id,
                    invoice,
                    provider_id,
                    url,
                    native_provider,
                    native_params,
                    saved_info,
                    saved_credentials,
                    users,
                })
            }
        }
        impl From<crate::enums::payments::PaymentForm> for PaymentForm {
            fn from(x: crate::enums::payments::PaymentForm) -> Self {
                match x {
                    crate::enums::payments::PaymentForm::Form(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PaymentReceipt {
            pub date: i32,
            pub bot_id: i64,
            pub provider_id: i64,
            pub title: String,
            pub description: String,
            pub photo: Option<crate::enums::WebDocument>,
            pub invoice: crate::enums::Invoice,
            pub info: Option<crate::enums::PaymentRequestedInfo>,
            pub shipping: Option<crate::enums::ShippingOption>,
            pub tip_amount: Option<i64>,
            pub currency: String,
            pub total_amount: i64,
            pub credentials_title: String,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PaymentReceipt {
            const CONSTRUCTOR_ID: u32 = 1891958275;
        }
        impl crate::Serializable for PaymentReceipt {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.photo.is_some() { 4 } else { 0 }
                    | if self.info.is_some() { 1 } else { 0 }
                    | if self.shipping.is_some() { 2 } else { 0 }
                    | if self.tip_amount.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.date.serialize(buf);
                self.bot_id.serialize(buf);
                self.provider_id.serialize(buf);
                self.title.serialize(buf);
                self.description.serialize(buf);
                if let Some(ref x) = self.photo {
                    x.serialize(buf);
                }
                self.invoice.serialize(buf);
                if let Some(ref x) = self.info {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.shipping {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.tip_amount {
                    x.serialize(buf);
                }
                self.currency.serialize(buf);
                self.total_amount.serialize(buf);
                self.credentials_title.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PaymentReceipt {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let date = i32::deserialize(buf)?;
                let bot_id = i64::deserialize(buf)?;
                let provider_id = i64::deserialize(buf)?;
                let title = String::deserialize(buf)?;
                let description = String::deserialize(buf)?;
                let photo = if (flags & 4) != 0 {
                    Some(crate::enums::WebDocument::deserialize(buf)?)
                } else {
                    None
                };
                let invoice = crate::enums::Invoice::deserialize(buf)?;
                let info = if (flags & 1) != 0 {
                    Some(crate::enums::PaymentRequestedInfo::deserialize(buf)?)
                } else {
                    None
                };
                let shipping = if (flags & 2) != 0 {
                    Some(crate::enums::ShippingOption::deserialize(buf)?)
                } else {
                    None
                };
                let tip_amount = if (flags & 8) != 0 {
                    Some(i64::deserialize(buf)?)
                } else {
                    None
                };
                let currency = String::deserialize(buf)?;
                let total_amount = i64::deserialize(buf)?;
                let credentials_title = String::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PaymentReceipt {
                    date,
                    bot_id,
                    provider_id,
                    title,
                    description,
                    photo,
                    invoice,
                    info,
                    shipping,
                    tip_amount,
                    currency,
                    total_amount,
                    credentials_title,
                    users,
                })
            }
        }
        impl From<crate::enums::payments::PaymentReceipt> for PaymentReceipt {
            fn from(x: crate::enums::payments::PaymentReceipt) -> Self {
                match x {
                    crate::enums::payments::PaymentReceipt::Receipt(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PaymentResult {
            pub updates: crate::enums::Updates,
        }
        impl crate::Identifiable for PaymentResult {
            const CONSTRUCTOR_ID: u32 = 1314881805;
        }
        impl crate::Serializable for PaymentResult {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.updates.serialize(buf);
            }
        }
        impl crate::Deserializable for PaymentResult {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let updates = crate::enums::Updates::deserialize(buf)?;
                Ok(PaymentResult { updates })
            }
        }
        impl TryFrom<crate::enums::payments::PaymentResult> for PaymentResult {
            type Error = ();
            fn try_from(x: crate::enums::payments::PaymentResult) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::payments::PaymentResult::Result(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PaymentVerificationNeeded {
            pub url: String,
        }
        impl crate::Identifiable for PaymentVerificationNeeded {
            const CONSTRUCTOR_ID: u32 = 3628142905;
        }
        impl crate::Serializable for PaymentVerificationNeeded {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.url.serialize(buf);
            }
        }
        impl crate::Deserializable for PaymentVerificationNeeded {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let url = String::deserialize(buf)?;
                Ok(PaymentVerificationNeeded { url })
            }
        }
        impl TryFrom<crate::enums::payments::PaymentResult> for PaymentVerificationNeeded {
            type Error = ();
            fn try_from(x: crate::enums::payments::PaymentResult) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::payments::PaymentResult::PaymentVerificationNeeded(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SavedInfo {
            pub has_saved_credentials: bool,
            pub saved_info: Option<crate::enums::PaymentRequestedInfo>,
        }
        impl crate::Identifiable for SavedInfo {
            const CONSTRUCTOR_ID: u32 = 4220511292;
        }
        impl crate::Serializable for SavedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.has_saved_credentials { 2 } else { 0 }
                    | if self.saved_info.is_some() { 1 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.saved_info {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for SavedInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let has_saved_credentials = (flags & 2) != 0;
                let saved_info = if (flags & 1) != 0 {
                    Some(crate::enums::PaymentRequestedInfo::deserialize(buf)?)
                } else {
                    None
                };
                Ok(SavedInfo {
                    has_saved_credentials,
                    saved_info,
                })
            }
        }
        impl From<crate::enums::payments::SavedInfo> for SavedInfo {
            fn from(x: crate::enums::payments::SavedInfo) -> Self {
                match x {
                    crate::enums::payments::SavedInfo::Info(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ValidatedRequestedInfo {
            pub id: Option<String>,
            pub shipping_options: Option<Vec<crate::enums::ShippingOption>>,
        }
        impl crate::Identifiable for ValidatedRequestedInfo {
            const CONSTRUCTOR_ID: u32 = 3510966403;
        }
        impl crate::Serializable for ValidatedRequestedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.id.is_some() { 1 } else { 0 }
                    | if self.shipping_options.is_some() {
                        2
                    } else {
                        0
                    })
                .serialize(buf);
                if let Some(ref x) = self.id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.shipping_options {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for ValidatedRequestedInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let id = if (flags & 1) != 0 {
                    Some(String::deserialize(buf)?)
                } else {
                    None
                };
                let shipping_options = if (flags & 2) != 0 {
                    Some(Vec::<crate::enums::ShippingOption>::deserialize(buf)?)
                } else {
                    None
                };
                Ok(ValidatedRequestedInfo {
                    id,
                    shipping_options,
                })
            }
        }
        impl From<crate::enums::payments::ValidatedRequestedInfo> for ValidatedRequestedInfo {
            fn from(x: crate::enums::payments::ValidatedRequestedInfo) -> Self {
                match x {
                    crate::enums::payments::ValidatedRequestedInfo::Info(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod phone {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportedGroupCallInvite {
            pub link: String,
        }
        impl crate::Identifiable for ExportedGroupCallInvite {
            const CONSTRUCTOR_ID: u32 = 541839704;
        }
        impl crate::Serializable for ExportedGroupCallInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.link.serialize(buf);
            }
        }
        impl crate::Deserializable for ExportedGroupCallInvite {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let link = String::deserialize(buf)?;
                Ok(ExportedGroupCallInvite { link })
            }
        }
        impl From<crate::enums::phone::ExportedGroupCallInvite> for ExportedGroupCallInvite {
            fn from(x: crate::enums::phone::ExportedGroupCallInvite) -> Self {
                match x {
                    crate::enums::phone::ExportedGroupCallInvite::Invite(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GroupCall {
            pub call: crate::enums::GroupCall,
            pub participants: Vec<crate::enums::GroupCallParticipant>,
            pub participants_next_offset: String,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for GroupCall {
            const CONSTRUCTOR_ID: u32 = 2658302637;
        }
        impl crate::Serializable for GroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.call.serialize(buf);
                self.participants.serialize(buf);
                self.participants_next_offset.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for GroupCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let call = crate::enums::GroupCall::deserialize(buf)?;
                let participants = Vec::<crate::enums::GroupCallParticipant>::deserialize(buf)?;
                let participants_next_offset = String::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(GroupCall {
                    call,
                    participants,
                    participants_next_offset,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::phone::GroupCall> for GroupCall {
            fn from(x: crate::enums::phone::GroupCall) -> Self {
                match x {
                    crate::enums::phone::GroupCall::Call(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GroupParticipants {
            pub count: i32,
            pub participants: Vec<crate::enums::GroupCallParticipant>,
            pub next_offset: String,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
            pub version: i32,
        }
        impl crate::Identifiable for GroupParticipants {
            const CONSTRUCTOR_ID: u32 = 4101460406;
        }
        impl crate::Serializable for GroupParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.participants.serialize(buf);
                self.next_offset.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
                self.version.serialize(buf);
            }
        }
        impl crate::Deserializable for GroupParticipants {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let participants = Vec::<crate::enums::GroupCallParticipant>::deserialize(buf)?;
                let next_offset = String::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let version = i32::deserialize(buf)?;
                Ok(GroupParticipants {
                    count,
                    participants,
                    next_offset,
                    chats,
                    users,
                    version,
                })
            }
        }
        impl From<crate::enums::phone::GroupParticipants> for GroupParticipants {
            fn from(x: crate::enums::phone::GroupParticipants) -> Self {
                match x {
                    crate::enums::phone::GroupParticipants::Participants(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct JoinAsPeers {
            pub peers: Vec<crate::enums::Peer>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for JoinAsPeers {
            const CONSTRUCTOR_ID: u32 = 2951045695;
        }
        impl crate::Serializable for JoinAsPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.peers.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for JoinAsPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let peers = Vec::<crate::enums::Peer>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(JoinAsPeers {
                    peers,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::phone::JoinAsPeers> for JoinAsPeers {
            fn from(x: crate::enums::phone::JoinAsPeers) -> Self {
                match x {
                    crate::enums::phone::JoinAsPeers::Peers(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PhoneCall {
            pub phone_call: crate::enums::PhoneCall,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PhoneCall {
            const CONSTRUCTOR_ID: u32 = 3968000320;
        }
        impl crate::Serializable for PhoneCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.phone_call.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PhoneCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let phone_call = crate::enums::PhoneCall::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PhoneCall { phone_call, users })
            }
        }
        impl From<crate::enums::phone::PhoneCall> for PhoneCall {
            fn from(x: crate::enums::phone::PhoneCall) -> Self {
                match x {
                    crate::enums::phone::PhoneCall::Call(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod photos {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct Photo {
            pub photo: crate::enums::Photo,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Photo {
            const CONSTRUCTOR_ID: u32 = 539045032;
        }
        impl crate::Serializable for Photo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.photo.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Photo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let photo = crate::enums::Photo::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Photo { photo, users })
            }
        }
        impl From<crate::enums::photos::Photo> for Photo {
            fn from(x: crate::enums::photos::Photo) -> Self {
                match x {
                    crate::enums::photos::Photo::Photo(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Photos {
            pub photos: Vec<crate::enums::Photo>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for Photos {
            const CONSTRUCTOR_ID: u32 = 2378853029;
        }
        impl crate::Serializable for Photos {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.photos.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for Photos {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let photos = Vec::<crate::enums::Photo>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(Photos { photos, users })
            }
        }
        impl TryFrom<crate::enums::photos::Photos> for Photos {
            type Error = ();
            fn try_from(x: crate::enums::photos::Photos) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::photos::Photos::Photos(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PhotosSlice {
            pub count: i32,
            pub photos: Vec<crate::enums::Photo>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for PhotosSlice {
            const CONSTRUCTOR_ID: u32 = 352657236;
        }
        impl crate::Serializable for PhotosSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.count.serialize(buf);
                self.photos.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for PhotosSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let count = i32::deserialize(buf)?;
                let photos = Vec::<crate::enums::Photo>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(PhotosSlice {
                    count,
                    photos,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::photos::Photos> for PhotosSlice {
            type Error = ();
            fn try_from(x: crate::enums::photos::Photos) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::photos::Photos::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod stats {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct BroadcastStats {
            pub period: crate::enums::StatsDateRangeDays,
            pub followers: crate::enums::StatsAbsValueAndPrev,
            pub views_per_post: crate::enums::StatsAbsValueAndPrev,
            pub shares_per_post: crate::enums::StatsAbsValueAndPrev,
            pub enabled_notifications: crate::enums::StatsPercentValue,
            pub growth_graph: crate::enums::StatsGraph,
            pub followers_graph: crate::enums::StatsGraph,
            pub mute_graph: crate::enums::StatsGraph,
            pub top_hours_graph: crate::enums::StatsGraph,
            pub interactions_graph: crate::enums::StatsGraph,
            pub iv_interactions_graph: crate::enums::StatsGraph,
            pub views_by_source_graph: crate::enums::StatsGraph,
            pub new_followers_by_source_graph: crate::enums::StatsGraph,
            pub languages_graph: crate::enums::StatsGraph,
            pub recent_message_interactions: Vec<crate::enums::MessageInteractionCounters>,
        }
        impl crate::Identifiable for BroadcastStats {
            const CONSTRUCTOR_ID: u32 = 3187114900;
        }
        impl crate::Serializable for BroadcastStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.period.serialize(buf);
                self.followers.serialize(buf);
                self.views_per_post.serialize(buf);
                self.shares_per_post.serialize(buf);
                self.enabled_notifications.serialize(buf);
                self.growth_graph.serialize(buf);
                self.followers_graph.serialize(buf);
                self.mute_graph.serialize(buf);
                self.top_hours_graph.serialize(buf);
                self.interactions_graph.serialize(buf);
                self.iv_interactions_graph.serialize(buf);
                self.views_by_source_graph.serialize(buf);
                self.new_followers_by_source_graph.serialize(buf);
                self.languages_graph.serialize(buf);
                self.recent_message_interactions.serialize(buf);
            }
        }
        impl crate::Deserializable for BroadcastStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let period = crate::enums::StatsDateRangeDays::deserialize(buf)?;
                let followers = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let views_per_post = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let shares_per_post = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let enabled_notifications = crate::enums::StatsPercentValue::deserialize(buf)?;
                let growth_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let followers_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let mute_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let top_hours_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let interactions_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let iv_interactions_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let views_by_source_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let new_followers_by_source_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let languages_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let recent_message_interactions =
                    Vec::<crate::enums::MessageInteractionCounters>::deserialize(buf)?;
                Ok(BroadcastStats {
                    period,
                    followers,
                    views_per_post,
                    shares_per_post,
                    enabled_notifications,
                    growth_graph,
                    followers_graph,
                    mute_graph,
                    top_hours_graph,
                    interactions_graph,
                    iv_interactions_graph,
                    views_by_source_graph,
                    new_followers_by_source_graph,
                    languages_graph,
                    recent_message_interactions,
                })
            }
        }
        impl From<crate::enums::stats::BroadcastStats> for BroadcastStats {
            fn from(x: crate::enums::stats::BroadcastStats) -> Self {
                match x {
                    crate::enums::stats::BroadcastStats::Stats(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MegagroupStats {
            pub period: crate::enums::StatsDateRangeDays,
            pub members: crate::enums::StatsAbsValueAndPrev,
            pub messages: crate::enums::StatsAbsValueAndPrev,
            pub viewers: crate::enums::StatsAbsValueAndPrev,
            pub posters: crate::enums::StatsAbsValueAndPrev,
            pub growth_graph: crate::enums::StatsGraph,
            pub members_graph: crate::enums::StatsGraph,
            pub new_members_by_source_graph: crate::enums::StatsGraph,
            pub languages_graph: crate::enums::StatsGraph,
            pub messages_graph: crate::enums::StatsGraph,
            pub actions_graph: crate::enums::StatsGraph,
            pub top_hours_graph: crate::enums::StatsGraph,
            pub weekdays_graph: crate::enums::StatsGraph,
            pub top_posters: Vec<crate::enums::StatsGroupTopPoster>,
            pub top_admins: Vec<crate::enums::StatsGroupTopAdmin>,
            pub top_inviters: Vec<crate::enums::StatsGroupTopInviter>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for MegagroupStats {
            const CONSTRUCTOR_ID: u32 = 4018141462;
        }
        impl crate::Serializable for MegagroupStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.period.serialize(buf);
                self.members.serialize(buf);
                self.messages.serialize(buf);
                self.viewers.serialize(buf);
                self.posters.serialize(buf);
                self.growth_graph.serialize(buf);
                self.members_graph.serialize(buf);
                self.new_members_by_source_graph.serialize(buf);
                self.languages_graph.serialize(buf);
                self.messages_graph.serialize(buf);
                self.actions_graph.serialize(buf);
                self.top_hours_graph.serialize(buf);
                self.weekdays_graph.serialize(buf);
                self.top_posters.serialize(buf);
                self.top_admins.serialize(buf);
                self.top_inviters.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for MegagroupStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let period = crate::enums::StatsDateRangeDays::deserialize(buf)?;
                let members = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let messages = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let viewers = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let posters = crate::enums::StatsAbsValueAndPrev::deserialize(buf)?;
                let growth_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let members_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let new_members_by_source_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let languages_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let messages_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let actions_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let top_hours_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let weekdays_graph = crate::enums::StatsGraph::deserialize(buf)?;
                let top_posters = Vec::<crate::enums::StatsGroupTopPoster>::deserialize(buf)?;
                let top_admins = Vec::<crate::enums::StatsGroupTopAdmin>::deserialize(buf)?;
                let top_inviters = Vec::<crate::enums::StatsGroupTopInviter>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(MegagroupStats {
                    period,
                    members,
                    messages,
                    viewers,
                    posters,
                    growth_graph,
                    members_graph,
                    new_members_by_source_graph,
                    languages_graph,
                    messages_graph,
                    actions_graph,
                    top_hours_graph,
                    weekdays_graph,
                    top_posters,
                    top_admins,
                    top_inviters,
                    users,
                })
            }
        }
        impl From<crate::enums::stats::MegagroupStats> for MegagroupStats {
            fn from(x: crate::enums::stats::MegagroupStats) -> Self {
                match x {
                    crate::enums::stats::MegagroupStats::Stats(x) => x,
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MessageStats {
            pub views_graph: crate::enums::StatsGraph,
        }
        impl crate::Identifiable for MessageStats {
            const CONSTRUCTOR_ID: u32 = 2308567701;
        }
        impl crate::Serializable for MessageStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.views_graph.serialize(buf);
            }
        }
        impl crate::Deserializable for MessageStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let views_graph = crate::enums::StatsGraph::deserialize(buf)?;
                Ok(MessageStats { views_graph })
            }
        }
        impl From<crate::enums::stats::MessageStats> for MessageStats {
            fn from(x: crate::enums::stats::MessageStats) -> Self {
                match x {
                    crate::enums::stats::MessageStats::Stats(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod stickers {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct SuggestedShortName {
            pub short_name: String,
        }
        impl crate::Identifiable for SuggestedShortName {
            const CONSTRUCTOR_ID: u32 = 2248056895;
        }
        impl crate::Serializable for SuggestedShortName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.short_name.serialize(buf);
            }
        }
        impl crate::Deserializable for SuggestedShortName {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let short_name = String::deserialize(buf)?;
                Ok(SuggestedShortName { short_name })
            }
        }
        impl From<crate::enums::stickers::SuggestedShortName> for SuggestedShortName {
            fn from(x: crate::enums::stickers::SuggestedShortName) -> Self {
                match x {
                    crate::enums::stickers::SuggestedShortName::Name(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod storage {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileGif {}
        impl crate::Identifiable for FileGif {
            const CONSTRUCTOR_ID: u32 = 3403786975;
        }
        impl crate::Serializable for FileGif {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileGif {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileGif {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileGif {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileGif => Ok(FileGif {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileJpeg {}
        impl crate::Identifiable for FileJpeg {
            const CONSTRUCTOR_ID: u32 = 8322574;
        }
        impl crate::Serializable for FileJpeg {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileJpeg {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileJpeg {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileJpeg {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileJpeg => Ok(FileJpeg {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileMov {}
        impl crate::Identifiable for FileMov {
            const CONSTRUCTOR_ID: u32 = 1258941372;
        }
        impl crate::Serializable for FileMov {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileMov {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileMov {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileMov {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileMov => Ok(FileMov {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileMp3 {}
        impl crate::Identifiable for FileMp3 {
            const CONSTRUCTOR_ID: u32 = 1384777335;
        }
        impl crate::Serializable for FileMp3 {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileMp3 {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileMp3 {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileMp3 {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileMp3 => Ok(FileMp3 {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileMp4 {}
        impl crate::Identifiable for FileMp4 {
            const CONSTRUCTOR_ID: u32 = 3016663268;
        }
        impl crate::Serializable for FileMp4 {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileMp4 {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileMp4 {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileMp4 {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileMp4 => Ok(FileMp4 {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FilePartial {}
        impl crate::Identifiable for FilePartial {
            const CONSTRUCTOR_ID: u32 = 1086091090;
        }
        impl crate::Serializable for FilePartial {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FilePartial {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FilePartial {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FilePartial {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FilePartial => Ok(FilePartial {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FilePdf {}
        impl crate::Identifiable for FilePdf {
            const CONSTRUCTOR_ID: u32 = 2921222285;
        }
        impl crate::Serializable for FilePdf {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FilePdf {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FilePdf {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FilePdf {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FilePdf => Ok(FilePdf {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FilePng {}
        impl crate::Identifiable for FilePng {
            const CONSTRUCTOR_ID: u32 = 172975040;
        }
        impl crate::Serializable for FilePng {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FilePng {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FilePng {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FilePng {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FilePng => Ok(FilePng {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileUnknown {}
        impl crate::Identifiable for FileUnknown {
            const CONSTRUCTOR_ID: u32 = 2861972229;
        }
        impl crate::Serializable for FileUnknown {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileUnknown {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileUnknown {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileUnknown {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileUnknown => Ok(FileUnknown {}),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileWebp {}
        impl crate::Identifiable for FileWebp {
            const CONSTRUCTOR_ID: u32 = 276907596;
        }
        impl crate::Serializable for FileWebp {
            fn serialize(&self, _buf: crate::serialize::Buffer) {}
        }
        impl crate::Deserializable for FileWebp {
            fn deserialize(_buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                Ok(FileWebp {})
            }
        }
        impl TryFrom<crate::enums::storage::FileType> for FileWebp {
            type Error = ();
            fn try_from(x: crate::enums::storage::FileType) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::storage::FileType::FileWebp => Ok(FileWebp {}),
                    _ => Err(()),
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod updates {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelDifference {
            pub r#final: bool,
            pub pts: i32,
            pub timeout: Option<i32>,
            pub new_messages: Vec<crate::enums::Message>,
            pub other_updates: Vec<crate::enums::Update>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChannelDifference {
            const CONSTRUCTOR_ID: u32 = 543450958;
        }
        impl crate::Serializable for ChannelDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.r#final { 1 } else { 0 }
                    | if self.timeout.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.pts.serialize(buf);
                if let Some(ref x) = self.timeout {
                    x.serialize(buf);
                }
                self.new_messages.serialize(buf);
                self.other_updates.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChannelDifference {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let r#final = (flags & 1) != 0;
                let pts = i32::deserialize(buf)?;
                let timeout = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let new_messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let other_updates = Vec::<crate::enums::Update>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChannelDifference {
                    r#final,
                    pts,
                    timeout,
                    new_messages,
                    other_updates,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::updates::ChannelDifference> for ChannelDifference {
            type Error = ();
            fn try_from(x: crate::enums::updates::ChannelDifference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::ChannelDifference::Difference(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelDifferenceEmpty {
            pub r#final: bool,
            pub pts: i32,
            pub timeout: Option<i32>,
        }
        impl crate::Identifiable for ChannelDifferenceEmpty {
            const CONSTRUCTOR_ID: u32 = 1041346555;
        }
        impl crate::Serializable for ChannelDifferenceEmpty {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.r#final { 1 } else { 0 }
                    | if self.timeout.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.pts.serialize(buf);
                if let Some(ref x) = self.timeout {
                    x.serialize(buf);
                }
            }
        }
        impl crate::Deserializable for ChannelDifferenceEmpty {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let r#final = (flags & 1) != 0;
                let pts = i32::deserialize(buf)?;
                let timeout = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                Ok(ChannelDifferenceEmpty {
                    r#final,
                    pts,
                    timeout,
                })
            }
        }
        impl TryFrom<crate::enums::updates::ChannelDifference> for ChannelDifferenceEmpty {
            type Error = ();
            fn try_from(x: crate::enums::updates::ChannelDifference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::ChannelDifference::Empty(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChannelDifferenceTooLong {
            pub r#final: bool,
            pub timeout: Option<i32>,
            pub dialog: crate::enums::Dialog,
            pub messages: Vec<crate::enums::Message>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for ChannelDifferenceTooLong {
            const CONSTRUCTOR_ID: u32 = 2763835134;
        }
        impl crate::Serializable for ChannelDifferenceTooLong {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                (0u32
                    | if self.r#final { 1 } else { 0 }
                    | if self.timeout.is_some() { 2 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.timeout {
                    x.serialize(buf);
                }
                self.dialog.serialize(buf);
                self.messages.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for ChannelDifferenceTooLong {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let flags = u32::deserialize(buf)?;
                let r#final = (flags & 1) != 0;
                let timeout = if (flags & 2) != 0 {
                    Some(i32::deserialize(buf)?)
                } else {
                    None
                };
                let dialog = crate::enums::Dialog::deserialize(buf)?;
                let messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(ChannelDifferenceTooLong {
                    r#final,
                    timeout,
                    dialog,
                    messages,
                    chats,
                    users,
                })
            }
        }
        impl TryFrom<crate::enums::updates::ChannelDifference> for ChannelDifferenceTooLong {
            type Error = ();
            fn try_from(x: crate::enums::updates::ChannelDifference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::ChannelDifference::TooLong(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Difference {
            pub new_messages: Vec<crate::enums::Message>,
            pub new_encrypted_messages: Vec<crate::enums::EncryptedMessage>,
            pub other_updates: Vec<crate::enums::Update>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
            pub state: crate::enums::updates::State,
        }
        impl crate::Identifiable for Difference {
            const CONSTRUCTOR_ID: u32 = 16030880;
        }
        impl crate::Serializable for Difference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.new_messages.serialize(buf);
                self.new_encrypted_messages.serialize(buf);
                self.other_updates.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
                self.state.serialize(buf);
            }
        }
        impl crate::Deserializable for Difference {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let new_messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let new_encrypted_messages =
                    Vec::<crate::enums::EncryptedMessage>::deserialize(buf)?;
                let other_updates = Vec::<crate::enums::Update>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let state = crate::enums::updates::State::deserialize(buf)?;
                Ok(Difference {
                    new_messages,
                    new_encrypted_messages,
                    other_updates,
                    chats,
                    users,
                    state,
                })
            }
        }
        impl TryFrom<crate::enums::updates::Difference> for Difference {
            type Error = ();
            fn try_from(x: crate::enums::updates::Difference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::Difference::Difference(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DifferenceEmpty {
            pub date: i32,
            pub seq: i32,
        }
        impl crate::Identifiable for DifferenceEmpty {
            const CONSTRUCTOR_ID: u32 = 1567990072;
        }
        impl crate::Serializable for DifferenceEmpty {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.date.serialize(buf);
                self.seq.serialize(buf);
            }
        }
        impl crate::Deserializable for DifferenceEmpty {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let date = i32::deserialize(buf)?;
                let seq = i32::deserialize(buf)?;
                Ok(DifferenceEmpty { date, seq })
            }
        }
        impl TryFrom<crate::enums::updates::Difference> for DifferenceEmpty {
            type Error = ();
            fn try_from(x: crate::enums::updates::Difference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::Difference::Empty(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DifferenceSlice {
            pub new_messages: Vec<crate::enums::Message>,
            pub new_encrypted_messages: Vec<crate::enums::EncryptedMessage>,
            pub other_updates: Vec<crate::enums::Update>,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
            pub intermediate_state: crate::enums::updates::State,
        }
        impl crate::Identifiable for DifferenceSlice {
            const CONSTRUCTOR_ID: u32 = 2835028353;
        }
        impl crate::Serializable for DifferenceSlice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.new_messages.serialize(buf);
                self.new_encrypted_messages.serialize(buf);
                self.other_updates.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
                self.intermediate_state.serialize(buf);
            }
        }
        impl crate::Deserializable for DifferenceSlice {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let new_messages = Vec::<crate::enums::Message>::deserialize(buf)?;
                let new_encrypted_messages =
                    Vec::<crate::enums::EncryptedMessage>::deserialize(buf)?;
                let other_updates = Vec::<crate::enums::Update>::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                let intermediate_state = crate::enums::updates::State::deserialize(buf)?;
                Ok(DifferenceSlice {
                    new_messages,
                    new_encrypted_messages,
                    other_updates,
                    chats,
                    users,
                    intermediate_state,
                })
            }
        }
        impl TryFrom<crate::enums::updates::Difference> for DifferenceSlice {
            type Error = ();
            fn try_from(x: crate::enums::updates::Difference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::Difference::Slice(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DifferenceTooLong {
            pub pts: i32,
        }
        impl crate::Identifiable for DifferenceTooLong {
            const CONSTRUCTOR_ID: u32 = 1258196845;
        }
        impl crate::Serializable for DifferenceTooLong {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pts.serialize(buf);
            }
        }
        impl crate::Deserializable for DifferenceTooLong {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pts = i32::deserialize(buf)?;
                Ok(DifferenceTooLong { pts })
            }
        }
        impl TryFrom<crate::enums::updates::Difference> for DifferenceTooLong {
            type Error = ();
            fn try_from(x: crate::enums::updates::Difference) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::updates::Difference::TooLong(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct State {
            pub pts: i32,
            pub qts: i32,
            pub date: i32,
            pub seq: i32,
            pub unread_count: i32,
        }
        impl crate::Identifiable for State {
            const CONSTRUCTOR_ID: u32 = 2775329342;
        }
        impl crate::Serializable for State {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.pts.serialize(buf);
                self.qts.serialize(buf);
                self.date.serialize(buf);
                self.seq.serialize(buf);
                self.unread_count.serialize(buf);
            }
        }
        impl crate::Deserializable for State {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let pts = i32::deserialize(buf)?;
                let qts = i32::deserialize(buf)?;
                let date = i32::deserialize(buf)?;
                let seq = i32::deserialize(buf)?;
                let unread_count = i32::deserialize(buf)?;
                Ok(State {
                    pts,
                    qts,
                    date,
                    seq,
                    unread_count,
                })
            }
        }
        impl From<crate::enums::updates::State> for State {
            fn from(x: crate::enums::updates::State) -> Self {
                match x {
                    crate::enums::updates::State::State(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod upload {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct CdnFile {
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for CdnFile {
            const CONSTRUCTOR_ID: u32 = 2845821519;
        }
        impl crate::Serializable for CdnFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.bytes.serialize(buf);
            }
        }
        impl crate::Deserializable for CdnFile {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let bytes = Vec::<u8>::deserialize(buf)?;
                Ok(CdnFile { bytes })
            }
        }
        impl TryFrom<crate::enums::upload::CdnFile> for CdnFile {
            type Error = ();
            fn try_from(x: crate::enums::upload::CdnFile) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::upload::CdnFile::File(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CdnFileReuploadNeeded {
            pub request_token: Vec<u8>,
        }
        impl crate::Identifiable for CdnFileReuploadNeeded {
            const CONSTRUCTOR_ID: u32 = 4004045934;
        }
        impl crate::Serializable for CdnFileReuploadNeeded {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.request_token.serialize(buf);
            }
        }
        impl crate::Deserializable for CdnFileReuploadNeeded {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let request_token = Vec::<u8>::deserialize(buf)?;
                Ok(CdnFileReuploadNeeded { request_token })
            }
        }
        impl TryFrom<crate::enums::upload::CdnFile> for CdnFileReuploadNeeded {
            type Error = ();
            fn try_from(x: crate::enums::upload::CdnFile) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::upload::CdnFile::ReuploadNeeded(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct File {
            pub r#type: crate::enums::storage::FileType,
            pub mtime: i32,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for File {
            const CONSTRUCTOR_ID: u32 = 157948117;
        }
        impl crate::Serializable for File {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.r#type.serialize(buf);
                self.mtime.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::Deserializable for File {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let r#type = crate::enums::storage::FileType::deserialize(buf)?;
                let mtime = i32::deserialize(buf)?;
                let bytes = Vec::<u8>::deserialize(buf)?;
                Ok(File {
                    r#type,
                    mtime,
                    bytes,
                })
            }
        }
        impl TryFrom<crate::enums::upload::File> for File {
            type Error = ();
            fn try_from(x: crate::enums::upload::File) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::upload::File::File(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FileCdnRedirect {
            pub dc_id: i32,
            pub file_token: Vec<u8>,
            pub encryption_key: Vec<u8>,
            pub encryption_iv: Vec<u8>,
            pub file_hashes: Vec<crate::enums::FileHash>,
        }
        impl crate::Identifiable for FileCdnRedirect {
            const CONSTRUCTOR_ID: u32 = 4052539972;
        }
        impl crate::Serializable for FileCdnRedirect {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.dc_id.serialize(buf);
                self.file_token.serialize(buf);
                self.encryption_key.serialize(buf);
                self.encryption_iv.serialize(buf);
                self.file_hashes.serialize(buf);
            }
        }
        impl crate::Deserializable for FileCdnRedirect {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let dc_id = i32::deserialize(buf)?;
                let file_token = Vec::<u8>::deserialize(buf)?;
                let encryption_key = Vec::<u8>::deserialize(buf)?;
                let encryption_iv = Vec::<u8>::deserialize(buf)?;
                let file_hashes = Vec::<crate::enums::FileHash>::deserialize(buf)?;
                Ok(FileCdnRedirect {
                    dc_id,
                    file_token,
                    encryption_key,
                    encryption_iv,
                    file_hashes,
                })
            }
        }
        impl TryFrom<crate::enums::upload::File> for FileCdnRedirect {
            type Error = ();
            fn try_from(x: crate::enums::upload::File) -> Result<Self, Self::Error> {
                match x {
                    crate::enums::upload::File::CdnRedirect(x) => Ok(x),
                    _ => Err(()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct WebFile {
            pub size: i32,
            pub mime_type: String,
            pub file_type: crate::enums::storage::FileType,
            pub mtime: i32,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for WebFile {
            const CONSTRUCTOR_ID: u32 = 568808380;
        }
        impl crate::Serializable for WebFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.size.serialize(buf);
                self.mime_type.serialize(buf);
                self.file_type.serialize(buf);
                self.mtime.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::Deserializable for WebFile {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let size = i32::deserialize(buf)?;
                let mime_type = String::deserialize(buf)?;
                let file_type = crate::enums::storage::FileType::deserialize(buf)?;
                let mtime = i32::deserialize(buf)?;
                let bytes = Vec::<u8>::deserialize(buf)?;
                Ok(WebFile {
                    size,
                    mime_type,
                    file_type,
                    mtime,
                    bytes,
                })
            }
        }
        impl From<crate::enums::upload::WebFile> for WebFile {
            fn from(x: crate::enums::upload::WebFile) -> Self {
                match x {
                    crate::enums::upload::WebFile::File(x) => x,
                }
            }
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod users {
        #[allow(unused_imports)]
        use std::convert::TryFrom;
        #[derive(Debug, Clone, PartialEq)]
        pub struct UserFull {
            pub full_user: crate::enums::UserFull,
            pub chats: Vec<crate::enums::Chat>,
            pub users: Vec<crate::enums::User>,
        }
        impl crate::Identifiable for UserFull {
            const CONSTRUCTOR_ID: u32 = 997004590;
        }
        impl crate::Serializable for UserFull {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                self.full_user.serialize(buf);
                self.chats.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::Deserializable for UserFull {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                let full_user = crate::enums::UserFull::deserialize(buf)?;
                let chats = Vec::<crate::enums::Chat>::deserialize(buf)?;
                let users = Vec::<crate::enums::User>::deserialize(buf)?;
                Ok(UserFull {
                    full_user,
                    chats,
                    users,
                })
            }
        }
        impl From<crate::enums::users::UserFull> for UserFull {
            fn from(x: crate::enums::users::UserFull) -> Self {
                match x {
                    crate::enums::users::UserFull::Full(x) => x,
                }
            }
        }
    }
}
/// This module contains all of the functions, each
/// represented by a `struct`. All of them implement
/// [`Identifiable`] and [`Serializable`].
///
/// To find out the type that Telegram will return upon
/// invoking one of these requests, check out the associated
/// type in the corresponding [`RemoteCall`] trait impl.
///
/// [`Identifiable`]: ../trait.Identifiable.html
/// [`Serializable`]: ../trait.Serializable.html
/// [`RemoteCall`]: trait.RemoteCall.html
#[allow(
    clippy::cognitive_complexity,
    clippy::identity_op,
    clippy::unreadable_literal
)]
pub mod functions {

    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroyAuthKey {}
    impl crate::Identifiable for DestroyAuthKey {
        const CONSTRUCTOR_ID: u32 = 3510849888;
    }
    impl crate::Serializable for DestroyAuthKey {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
        }
    }
    impl crate::RemoteCall for DestroyAuthKey {
        type Return = crate::enums::DestroyAuthKeyRes;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct DestroySession {
        pub session_id: i64,
    }
    impl crate::Identifiable for DestroySession {
        const CONSTRUCTOR_ID: u32 = 3880853798;
    }
    impl crate::Serializable for DestroySession {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.session_id.serialize(buf);
        }
    }
    impl crate::RemoteCall for DestroySession {
        type Return = crate::enums::DestroySessionRes;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetFutureSalts {
        pub num: i32,
    }
    impl crate::Identifiable for GetFutureSalts {
        const CONSTRUCTOR_ID: u32 = 3105996036;
    }
    impl crate::Serializable for GetFutureSalts {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.num.serialize(buf);
        }
    }
    impl crate::RemoteCall for GetFutureSalts {
        type Return = crate::enums::FutureSalts;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InitConnection<X: crate::RemoteCall> {
        pub api_id: i32,
        pub device_model: String,
        pub system_version: String,
        pub app_version: String,
        pub system_lang_code: String,
        pub lang_pack: String,
        pub lang_code: String,
        pub proxy: Option<crate::enums::InputClientProxy>,
        pub params: Option<crate::enums::Jsonvalue>,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InitConnection<X> {
        const CONSTRUCTOR_ID: u32 = 3251461801;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InitConnection<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            (0u32
                | if self.proxy.is_some() { 1 } else { 0 }
                | if self.params.is_some() { 2 } else { 0 })
            .serialize(buf);
            self.api_id.serialize(buf);
            self.device_model.serialize(buf);
            self.system_version.serialize(buf);
            self.app_version.serialize(buf);
            self.system_lang_code.serialize(buf);
            self.lang_pack.serialize(buf);
            self.lang_code.serialize(buf);
            if let Some(ref x) = self.proxy {
                x.serialize(buf);
            }
            if let Some(ref x) = self.params {
                x.serialize(buf);
            }
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InitConnection<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeAfterMsg<X: crate::RemoteCall> {
        pub msg_id: i64,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeAfterMsg<X> {
        const CONSTRUCTOR_ID: u32 = 3416209197;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeAfterMsg<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.msg_id.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeAfterMsg<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeAfterMsgs<X: crate::RemoteCall> {
        pub msg_ids: Vec<i64>,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeAfterMsgs<X> {
        const CONSTRUCTOR_ID: u32 = 1036301552;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeAfterMsgs<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.msg_ids.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeAfterMsgs<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeWithLayer<X: crate::RemoteCall> {
        pub layer: i32,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeWithLayer<X> {
        const CONSTRUCTOR_ID: u32 = 3667594509;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeWithLayer<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.layer.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeWithLayer<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeWithMessagesRange<X: crate::RemoteCall> {
        pub range: crate::enums::MessageRange,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeWithMessagesRange<X> {
        const CONSTRUCTOR_ID: u32 = 911373810;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeWithMessagesRange<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.range.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeWithMessagesRange<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeWithTakeout<X: crate::RemoteCall> {
        pub takeout_id: i64,
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeWithTakeout<X> {
        const CONSTRUCTOR_ID: u32 = 2896821550;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeWithTakeout<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.takeout_id.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeWithTakeout<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct InvokeWithoutUpdates<X: crate::RemoteCall> {
        pub query: X,
    }
    impl<X: crate::RemoteCall> crate::Identifiable for InvokeWithoutUpdates<X> {
        const CONSTRUCTOR_ID: u32 = 3214170551;
    }
    impl<X: crate::RemoteCall> crate::Serializable for InvokeWithoutUpdates<X> {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.query.serialize(buf);
        }
    }
    impl<X: crate::RemoteCall> crate::RemoteCall for InvokeWithoutUpdates<X> {
        type Return = X::Return;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Ping {
        pub ping_id: i64,
    }
    impl crate::Identifiable for Ping {
        const CONSTRUCTOR_ID: u32 = 2059302892;
    }
    impl crate::Serializable for Ping {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.ping_id.serialize(buf);
        }
    }
    impl crate::RemoteCall for Ping {
        type Return = crate::enums::Pong;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct PingDelayDisconnect {
        pub ping_id: i64,
        pub disconnect_delay: i32,
    }
    impl crate::Identifiable for PingDelayDisconnect {
        const CONSTRUCTOR_ID: u32 = 4081220492;
    }
    impl crate::Serializable for PingDelayDisconnect {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.ping_id.serialize(buf);
            self.disconnect_delay.serialize(buf);
        }
    }
    impl crate::RemoteCall for PingDelayDisconnect {
        type Return = crate::enums::Pong;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReqDhParams {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub p: Vec<u8>,
        pub q: Vec<u8>,
        pub public_key_fingerprint: i64,
        pub encrypted_data: Vec<u8>,
    }
    impl crate::Identifiable for ReqDhParams {
        const CONSTRUCTOR_ID: u32 = 3608339646;
    }
    impl crate::Serializable for ReqDhParams {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.p.serialize(buf);
            self.q.serialize(buf);
            self.public_key_fingerprint.serialize(buf);
            self.encrypted_data.serialize(buf);
        }
    }
    impl crate::RemoteCall for ReqDhParams {
        type Return = crate::enums::ServerDhParams;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReqPq {
        pub nonce: [u8; 16],
    }
    impl crate::Identifiable for ReqPq {
        const CONSTRUCTOR_ID: u32 = 1615239032;
    }
    impl crate::Serializable for ReqPq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.nonce.serialize(buf);
        }
    }
    impl crate::RemoteCall for ReqPq {
        type Return = crate::enums::ResPq;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReqPqMulti {
        pub nonce: [u8; 16],
    }
    impl crate::Identifiable for ReqPqMulti {
        const CONSTRUCTOR_ID: u32 = 3195965169;
    }
    impl crate::Serializable for ReqPqMulti {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.nonce.serialize(buf);
        }
    }
    impl crate::RemoteCall for ReqPqMulti {
        type Return = crate::enums::ResPq;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RpcDropAnswer {
        pub req_msg_id: i64,
    }
    impl crate::Identifiable for RpcDropAnswer {
        const CONSTRUCTOR_ID: u32 = 1491380032;
    }
    impl crate::Serializable for RpcDropAnswer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.req_msg_id.serialize(buf);
        }
    }
    impl crate::RemoteCall for RpcDropAnswer {
        type Return = crate::enums::RpcDropAnswer;
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetClientDhParams {
        pub nonce: [u8; 16],
        pub server_nonce: [u8; 16],
        pub encrypted_data: Vec<u8>,
    }
    impl crate::Identifiable for SetClientDhParams {
        const CONSTRUCTOR_ID: u32 = 4110704415;
    }
    impl crate::Serializable for SetClientDhParams {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            Self::CONSTRUCTOR_ID.serialize(buf);
            self.nonce.serialize(buf);
            self.server_nonce.serialize(buf);
            self.encrypted_data.serialize(buf);
        }
    }
    impl crate::RemoteCall for SetClientDhParams {
        type Return = crate::enums::SetClientDhParamsAnswer;
    }
    #[allow(clippy::unreadable_literal)]
    pub mod account {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptAuthorization {
            pub bot_id: i64,
            pub scope: String,
            pub public_key: String,
            pub value_hashes: Vec<crate::enums::SecureValueHash>,
            pub credentials: crate::enums::SecureCredentialsEncrypted,
        }
        impl crate::Identifiable for AcceptAuthorization {
            const CONSTRUCTOR_ID: u32 = 4092415091;
        }
        impl crate::Serializable for AcceptAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.bot_id.serialize(buf);
                self.scope.serialize(buf);
                self.public_key.serialize(buf);
                self.value_hashes.serialize(buf);
                self.credentials.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptAuthorization {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CancelPasswordEmail {}
        impl crate::Identifiable for CancelPasswordEmail {
            const CONSTRUCTOR_ID: u32 = 3251361206;
        }
        impl crate::Serializable for CancelPasswordEmail {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for CancelPasswordEmail {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChangeAuthorizationSettings {
            pub hash: i64,
            pub encrypted_requests_disabled: Option<bool>,
            pub call_requests_disabled: Option<bool>,
        }
        impl crate::Identifiable for ChangeAuthorizationSettings {
            const CONSTRUCTOR_ID: u32 = 1089766498;
        }
        impl crate::Serializable for ChangeAuthorizationSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.encrypted_requests_disabled.is_some() {
                        1
                    } else {
                        0
                    }
                    | if self.call_requests_disabled.is_some() {
                        2
                    } else {
                        0
                    })
                .serialize(buf);
                self.hash.serialize(buf);
                if let Some(ref x) = self.encrypted_requests_disabled {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.call_requests_disabled {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for ChangeAuthorizationSettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChangePhone {
            pub phone_number: String,
            pub phone_code_hash: String,
            pub phone_code: String,
        }
        impl crate::Identifiable for ChangePhone {
            const CONSTRUCTOR_ID: u32 = 1891839707;
        }
        impl crate::Serializable for ChangePhone {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
                self.phone_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for ChangePhone {
            type Return = crate::enums::User;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckUsername {
            pub username: String,
        }
        impl crate::Identifiable for CheckUsername {
            const CONSTRUCTOR_ID: u32 = 655677548;
        }
        impl crate::Serializable for CheckUsername {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.username.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckUsername {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ConfirmPasswordEmail {
            pub code: String,
        }
        impl crate::Identifiable for ConfirmPasswordEmail {
            const CONSTRUCTOR_ID: u32 = 2413762848;
        }
        impl crate::Serializable for ConfirmPasswordEmail {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.code.serialize(buf);
            }
        }
        impl crate::RemoteCall for ConfirmPasswordEmail {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ConfirmPhone {
            pub phone_code_hash: String,
            pub phone_code: String,
        }
        impl crate::Identifiable for ConfirmPhone {
            const CONSTRUCTOR_ID: u32 = 1596029123;
        }
        impl crate::Serializable for ConfirmPhone {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_code_hash.serialize(buf);
                self.phone_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for ConfirmPhone {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CreateTheme {
            pub slug: String,
            pub title: String,
            pub document: Option<crate::enums::InputDocument>,
            pub settings: Option<Vec<crate::enums::InputThemeSettings>>,
        }
        impl crate::Identifiable for CreateTheme {
            const CONSTRUCTOR_ID: u32 = 1697530880;
        }
        impl crate::Serializable for CreateTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.document.is_some() { 4 } else { 0 }
                    | if self.settings.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.slug.serialize(buf);
                self.title.serialize(buf);
                if let Some(ref x) = self.document {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.settings {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for CreateTheme {
            type Return = crate::enums::Theme;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeclinePasswordReset {}
        impl crate::Identifiable for DeclinePasswordReset {
            const CONSTRUCTOR_ID: u32 = 1284770294;
        }
        impl crate::Serializable for DeclinePasswordReset {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeclinePasswordReset {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteAccount {
            pub reason: String,
        }
        impl crate::Identifiable for DeleteAccount {
            const CONSTRUCTOR_ID: u32 = 1099779595;
        }
        impl crate::Serializable for DeleteAccount {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.reason.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteAccount {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteSecureValue {
            pub types: Vec<crate::enums::SecureValueType>,
        }
        impl crate::Identifiable for DeleteSecureValue {
            const CONSTRUCTOR_ID: u32 = 3095444555;
        }
        impl crate::Serializable for DeleteSecureValue {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.types.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteSecureValue {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FinishTakeoutSession {
            pub success: bool,
        }
        impl crate::Identifiable for FinishTakeoutSession {
            const CONSTRUCTOR_ID: u32 = 489050862;
        }
        impl crate::Serializable for FinishTakeoutSession {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.success { 1 } else { 0 }).serialize(buf);
            }
        }
        impl crate::RemoteCall for FinishTakeoutSession {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAccountTtl {}
        impl crate::Identifiable for GetAccountTtl {
            const CONSTRUCTOR_ID: u32 = 150761757;
        }
        impl crate::Serializable for GetAccountTtl {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAccountTtl {
            type Return = crate::enums::AccountDaysTtl;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAllSecureValues {}
        impl crate::Identifiable for GetAllSecureValues {
            const CONSTRUCTOR_ID: u32 = 2995305597;
        }
        impl crate::Serializable for GetAllSecureValues {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAllSecureValues {
            type Return = Vec<crate::enums::SecureValue>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAuthorizationForm {
            pub bot_id: i64,
            pub scope: String,
            pub public_key: String,
        }
        impl crate::Identifiable for GetAuthorizationForm {
            const CONSTRUCTOR_ID: u32 = 2838059386;
        }
        impl crate::Serializable for GetAuthorizationForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.bot_id.serialize(buf);
                self.scope.serialize(buf);
                self.public_key.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAuthorizationForm {
            type Return = crate::enums::account::AuthorizationForm;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAuthorizations {}
        impl crate::Identifiable for GetAuthorizations {
            const CONSTRUCTOR_ID: u32 = 3810574680;
        }
        impl crate::Serializable for GetAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAuthorizations {
            type Return = crate::enums::account::Authorizations;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAutoDownloadSettings {}
        impl crate::Identifiable for GetAutoDownloadSettings {
            const CONSTRUCTOR_ID: u32 = 1457130303;
        }
        impl crate::Serializable for GetAutoDownloadSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAutoDownloadSettings {
            type Return = crate::enums::account::AutoDownloadSettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetChatThemes {
            pub hash: i64,
        }
        impl crate::Identifiable for GetChatThemes {
            const CONSTRUCTOR_ID: u32 = 3594051209;
        }
        impl crate::Serializable for GetChatThemes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetChatThemes {
            type Return = crate::enums::account::Themes;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetContactSignUpNotification {}
        impl crate::Identifiable for GetContactSignUpNotification {
            const CONSTRUCTOR_ID: u32 = 2668087080;
        }
        impl crate::Serializable for GetContactSignUpNotification {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetContactSignUpNotification {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetContentSettings {}
        impl crate::Identifiable for GetContentSettings {
            const CONSTRUCTOR_ID: u32 = 2342210990;
        }
        impl crate::Serializable for GetContentSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetContentSettings {
            type Return = crate::enums::account::ContentSettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGlobalPrivacySettings {}
        impl crate::Identifiable for GetGlobalPrivacySettings {
            const CONSTRUCTOR_ID: u32 = 3945483510;
        }
        impl crate::Serializable for GetGlobalPrivacySettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGlobalPrivacySettings {
            type Return = crate::enums::GlobalPrivacySettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMultiWallPapers {
            pub wallpapers: Vec<crate::enums::InputWallPaper>,
        }
        impl crate::Identifiable for GetMultiWallPapers {
            const CONSTRUCTOR_ID: u32 = 1705865692;
        }
        impl crate::Serializable for GetMultiWallPapers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.wallpapers.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMultiWallPapers {
            type Return = Vec<crate::enums::WallPaper>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetNotifyExceptions {
            pub compare_sound: bool,
            pub peer: Option<crate::enums::InputNotifyPeer>,
        }
        impl crate::Identifiable for GetNotifyExceptions {
            const CONSTRUCTOR_ID: u32 = 1398240377;
        }
        impl crate::Serializable for GetNotifyExceptions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.compare_sound { 2 } else { 0 }
                    | if self.peer.is_some() { 1 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.peer {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for GetNotifyExceptions {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetNotifySettings {
            pub peer: crate::enums::InputNotifyPeer,
        }
        impl crate::Identifiable for GetNotifySettings {
            const CONSTRUCTOR_ID: u32 = 313765169;
        }
        impl crate::Serializable for GetNotifySettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetNotifySettings {
            type Return = crate::enums::PeerNotifySettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPassword {}
        impl crate::Identifiable for GetPassword {
            const CONSTRUCTOR_ID: u32 = 1418342645;
        }
        impl crate::Serializable for GetPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPassword {
            type Return = crate::enums::account::Password;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPasswordSettings {
            pub password: crate::enums::InputCheckPasswordSrp,
        }
        impl crate::Identifiable for GetPasswordSettings {
            const CONSTRUCTOR_ID: u32 = 2631199481;
        }
        impl crate::Serializable for GetPasswordSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.password.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPasswordSettings {
            type Return = crate::enums::account::PasswordSettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPrivacy {
            pub key: crate::enums::InputPrivacyKey,
        }
        impl crate::Identifiable for GetPrivacy {
            const CONSTRUCTOR_ID: u32 = 3671837008;
        }
        impl crate::Serializable for GetPrivacy {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.key.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPrivacy {
            type Return = crate::enums::account::PrivacyRules;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSecureValue {
            pub types: Vec<crate::enums::SecureValueType>,
        }
        impl crate::Identifiable for GetSecureValue {
            const CONSTRUCTOR_ID: u32 = 1936088002;
        }
        impl crate::Serializable for GetSecureValue {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.types.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSecureValue {
            type Return = Vec<crate::enums::SecureValue>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetTheme {
            pub format: String,
            pub theme: crate::enums::InputTheme,
            pub document_id: i64,
        }
        impl crate::Identifiable for GetTheme {
            const CONSTRUCTOR_ID: u32 = 2375906347;
        }
        impl crate::Serializable for GetTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.format.serialize(buf);
                self.theme.serialize(buf);
                self.document_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetTheme {
            type Return = crate::enums::Theme;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetThemes {
            pub format: String,
            pub hash: i64,
        }
        impl crate::Identifiable for GetThemes {
            const CONSTRUCTOR_ID: u32 = 1913054296;
        }
        impl crate::Serializable for GetThemes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.format.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetThemes {
            type Return = crate::enums::account::Themes;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetTmpPassword {
            pub password: crate::enums::InputCheckPasswordSrp,
            pub period: i32,
        }
        impl crate::Identifiable for GetTmpPassword {
            const CONSTRUCTOR_ID: u32 = 1151208273;
        }
        impl crate::Serializable for GetTmpPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.password.serialize(buf);
                self.period.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetTmpPassword {
            type Return = crate::enums::account::TmpPassword;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWallPaper {
            pub wallpaper: crate::enums::InputWallPaper,
        }
        impl crate::Identifiable for GetWallPaper {
            const CONSTRUCTOR_ID: u32 = 4237155306;
        }
        impl crate::Serializable for GetWallPaper {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.wallpaper.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetWallPaper {
            type Return = crate::enums::WallPaper;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWallPapers {
            pub hash: i64,
        }
        impl crate::Identifiable for GetWallPapers {
            const CONSTRUCTOR_ID: u32 = 127302966;
        }
        impl crate::Serializable for GetWallPapers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetWallPapers {
            type Return = crate::enums::account::WallPapers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWebAuthorizations {}
        impl crate::Identifiable for GetWebAuthorizations {
            const CONSTRUCTOR_ID: u32 = 405695855;
        }
        impl crate::Serializable for GetWebAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetWebAuthorizations {
            type Return = crate::enums::account::WebAuthorizations;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InitTakeoutSession {
            pub contacts: bool,
            pub message_users: bool,
            pub message_chats: bool,
            pub message_megagroups: bool,
            pub message_channels: bool,
            pub files: bool,
            pub file_max_size: Option<i32>,
        }
        impl crate::Identifiable for InitTakeoutSession {
            const CONSTRUCTOR_ID: u32 = 4032514052;
        }
        impl crate::Serializable for InitTakeoutSession {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.contacts { 1 } else { 0 }
                    | if self.message_users { 2 } else { 0 }
                    | if self.message_chats { 4 } else { 0 }
                    | if self.message_megagroups { 8 } else { 0 }
                    | if self.message_channels { 16 } else { 0 }
                    | if self.files { 32 } else { 0 }
                    | if self.file_max_size.is_some() { 32 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.file_max_size {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for InitTakeoutSession {
            type Return = crate::enums::account::Takeout;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InstallTheme {
            pub dark: bool,
            pub theme: Option<crate::enums::InputTheme>,
            pub format: Option<String>,
            pub base_theme: Option<crate::enums::BaseTheme>,
        }
        impl crate::Identifiable for InstallTheme {
            const CONSTRUCTOR_ID: u32 = 3341269819;
        }
        impl crate::Serializable for InstallTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.dark { 1 } else { 0 }
                    | if self.theme.is_some() { 2 } else { 0 }
                    | if self.format.is_some() { 4 } else { 0 }
                    | if self.base_theme.is_some() { 8 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.theme {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.format {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.base_theme {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for InstallTheme {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InstallWallPaper {
            pub wallpaper: crate::enums::InputWallPaper,
            pub settings: crate::enums::WallPaperSettings,
        }
        impl crate::Identifiable for InstallWallPaper {
            const CONSTRUCTOR_ID: u32 = 4276967273;
        }
        impl crate::Serializable for InstallWallPaper {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.wallpaper.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for InstallWallPaper {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RegisterDevice {
            pub no_muted: bool,
            pub token_type: i32,
            pub token: String,
            pub app_sandbox: bool,
            pub secret: Vec<u8>,
            pub other_uids: Vec<i64>,
        }
        impl crate::Identifiable for RegisterDevice {
            const CONSTRUCTOR_ID: u32 = 3968205178;
        }
        impl crate::Serializable for RegisterDevice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.no_muted { 1 } else { 0 }).serialize(buf);
                self.token_type.serialize(buf);
                self.token.serialize(buf);
                self.app_sandbox.serialize(buf);
                self.secret.serialize(buf);
                self.other_uids.serialize(buf);
            }
        }
        impl crate::RemoteCall for RegisterDevice {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReportPeer {
            pub peer: crate::enums::InputPeer,
            pub reason: crate::enums::ReportReason,
            pub message: String,
        }
        impl crate::Identifiable for ReportPeer {
            const CONSTRUCTOR_ID: u32 = 3317316998;
        }
        impl crate::Serializable for ReportPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.reason.serialize(buf);
                self.message.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReportPeer {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReportProfilePhoto {
            pub peer: crate::enums::InputPeer,
            pub photo_id: crate::enums::InputPhoto,
            pub reason: crate::enums::ReportReason,
            pub message: String,
        }
        impl crate::Identifiable for ReportProfilePhoto {
            const CONSTRUCTOR_ID: u32 = 4203529973;
        }
        impl crate::Serializable for ReportProfilePhoto {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.photo_id.serialize(buf);
                self.reason.serialize(buf);
                self.message.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReportProfilePhoto {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResendPasswordEmail {}
        impl crate::Identifiable for ResendPasswordEmail {
            const CONSTRUCTOR_ID: u32 = 2055154197;
        }
        impl crate::Serializable for ResendPasswordEmail {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResendPasswordEmail {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetAuthorization {
            pub hash: i64,
        }
        impl crate::Identifiable for ResetAuthorization {
            const CONSTRUCTOR_ID: u32 = 3749180348;
        }
        impl crate::Serializable for ResetAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetAuthorization {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetNotifySettings {}
        impl crate::Identifiable for ResetNotifySettings {
            const CONSTRUCTOR_ID: u32 = 3682473799;
        }
        impl crate::Serializable for ResetNotifySettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetNotifySettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetPassword {}
        impl crate::Identifiable for ResetPassword {
            const CONSTRUCTOR_ID: u32 = 2466827803;
        }
        impl crate::Serializable for ResetPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetPassword {
            type Return = crate::enums::account::ResetPasswordResult;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetWallPapers {}
        impl crate::Identifiable for ResetWallPapers {
            const CONSTRUCTOR_ID: u32 = 3141244932;
        }
        impl crate::Serializable for ResetWallPapers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetWallPapers {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetWebAuthorization {
            pub hash: i64,
        }
        impl crate::Identifiable for ResetWebAuthorization {
            const CONSTRUCTOR_ID: u32 = 755087855;
        }
        impl crate::Serializable for ResetWebAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetWebAuthorization {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetWebAuthorizations {}
        impl crate::Identifiable for ResetWebAuthorizations {
            const CONSTRUCTOR_ID: u32 = 1747789204;
        }
        impl crate::Serializable for ResetWebAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetWebAuthorizations {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveAutoDownloadSettings {
            pub low: bool,
            pub high: bool,
            pub settings: crate::enums::AutoDownloadSettings,
        }
        impl crate::Identifiable for SaveAutoDownloadSettings {
            const CONSTRUCTOR_ID: u32 = 1995661875;
        }
        impl crate::Serializable for SaveAutoDownloadSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.low { 1 } else { 0 } | if self.high { 2 } else { 0 })
                    .serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveAutoDownloadSettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveSecureValue {
            pub value: crate::enums::InputSecureValue,
            pub secure_secret_id: i64,
        }
        impl crate::Identifiable for SaveSecureValue {
            const CONSTRUCTOR_ID: u32 = 2308956957;
        }
        impl crate::Serializable for SaveSecureValue {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.value.serialize(buf);
                self.secure_secret_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveSecureValue {
            type Return = crate::enums::SecureValue;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveTheme {
            pub theme: crate::enums::InputTheme,
            pub unsave: bool,
        }
        impl crate::Identifiable for SaveTheme {
            const CONSTRUCTOR_ID: u32 = 4065792108;
        }
        impl crate::Serializable for SaveTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.theme.serialize(buf);
                self.unsave.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveTheme {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveWallPaper {
            pub wallpaper: crate::enums::InputWallPaper,
            pub unsave: bool,
            pub settings: crate::enums::WallPaperSettings,
        }
        impl crate::Identifiable for SaveWallPaper {
            const CONSTRUCTOR_ID: u32 = 1817860919;
        }
        impl crate::Serializable for SaveWallPaper {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.wallpaper.serialize(buf);
                self.unsave.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveWallPaper {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendChangePhoneCode {
            pub phone_number: String,
            pub settings: crate::enums::CodeSettings,
        }
        impl crate::Identifiable for SendChangePhoneCode {
            const CONSTRUCTOR_ID: u32 = 2186758885;
        }
        impl crate::Serializable for SendChangePhoneCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendChangePhoneCode {
            type Return = crate::enums::auth::SentCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendConfirmPhoneCode {
            pub hash: String,
            pub settings: crate::enums::CodeSettings,
        }
        impl crate::Identifiable for SendConfirmPhoneCode {
            const CONSTRUCTOR_ID: u32 = 457157256;
        }
        impl crate::Serializable for SendConfirmPhoneCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendConfirmPhoneCode {
            type Return = crate::enums::auth::SentCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendVerifyEmailCode {
            pub email: String,
        }
        impl crate::Identifiable for SendVerifyEmailCode {
            const CONSTRUCTOR_ID: u32 = 1880182943;
        }
        impl crate::Serializable for SendVerifyEmailCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.email.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendVerifyEmailCode {
            type Return = crate::enums::account::SentEmailCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendVerifyPhoneCode {
            pub phone_number: String,
            pub settings: crate::enums::CodeSettings,
        }
        impl crate::Identifiable for SendVerifyPhoneCode {
            const CONSTRUCTOR_ID: u32 = 2778945273;
        }
        impl crate::Serializable for SendVerifyPhoneCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendVerifyPhoneCode {
            type Return = crate::enums::auth::SentCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetAccountTtl {
            pub ttl: crate::enums::AccountDaysTtl,
        }
        impl crate::Identifiable for SetAccountTtl {
            const CONSTRUCTOR_ID: u32 = 608323678;
        }
        impl crate::Serializable for SetAccountTtl {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.ttl.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetAccountTtl {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetAuthorizationTtl {
            pub authorization_ttl_days: i32,
        }
        impl crate::Identifiable for SetAuthorizationTtl {
            const CONSTRUCTOR_ID: u32 = 3213466272;
        }
        impl crate::Serializable for SetAuthorizationTtl {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.authorization_ttl_days.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetAuthorizationTtl {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetContactSignUpNotification {
            pub silent: bool,
        }
        impl crate::Identifiable for SetContactSignUpNotification {
            const CONSTRUCTOR_ID: u32 = 3488890721;
        }
        impl crate::Serializable for SetContactSignUpNotification {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.silent.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetContactSignUpNotification {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetContentSettings {
            pub sensitive_enabled: bool,
        }
        impl crate::Identifiable for SetContentSettings {
            const CONSTRUCTOR_ID: u32 = 3044323691;
        }
        impl crate::Serializable for SetContentSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.sensitive_enabled { 1 } else { 0 }).serialize(buf);
            }
        }
        impl crate::RemoteCall for SetContentSettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetGlobalPrivacySettings {
            pub settings: crate::enums::GlobalPrivacySettings,
        }
        impl crate::Identifiable for SetGlobalPrivacySettings {
            const CONSTRUCTOR_ID: u32 = 517647042;
        }
        impl crate::Serializable for SetGlobalPrivacySettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetGlobalPrivacySettings {
            type Return = crate::enums::GlobalPrivacySettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetPrivacy {
            pub key: crate::enums::InputPrivacyKey,
            pub rules: Vec<crate::enums::InputPrivacyRule>,
        }
        impl crate::Identifiable for SetPrivacy {
            const CONSTRUCTOR_ID: u32 = 3388480744;
        }
        impl crate::Serializable for SetPrivacy {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.key.serialize(buf);
                self.rules.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetPrivacy {
            type Return = crate::enums::account::PrivacyRules;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UnregisterDevice {
            pub token_type: i32,
            pub token: String,
            pub other_uids: Vec<i64>,
        }
        impl crate::Identifiable for UnregisterDevice {
            const CONSTRUCTOR_ID: u32 = 1779249670;
        }
        impl crate::Serializable for UnregisterDevice {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.token_type.serialize(buf);
                self.token.serialize(buf);
                self.other_uids.serialize(buf);
            }
        }
        impl crate::RemoteCall for UnregisterDevice {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateDeviceLocked {
            pub period: i32,
        }
        impl crate::Identifiable for UpdateDeviceLocked {
            const CONSTRUCTOR_ID: u32 = 954152242;
        }
        impl crate::Serializable for UpdateDeviceLocked {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.period.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateDeviceLocked {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateNotifySettings {
            pub peer: crate::enums::InputNotifyPeer,
            pub settings: crate::enums::InputPeerNotifySettings,
        }
        impl crate::Identifiable for UpdateNotifySettings {
            const CONSTRUCTOR_ID: u32 = 2227067795;
        }
        impl crate::Serializable for UpdateNotifySettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateNotifySettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdatePasswordSettings {
            pub password: crate::enums::InputCheckPasswordSrp,
            pub new_settings: crate::enums::account::PasswordInputSettings,
        }
        impl crate::Identifiable for UpdatePasswordSettings {
            const CONSTRUCTOR_ID: u32 = 2778402863;
        }
        impl crate::Serializable for UpdatePasswordSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.password.serialize(buf);
                self.new_settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdatePasswordSettings {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateProfile {
            pub first_name: Option<String>,
            pub last_name: Option<String>,
            pub about: Option<String>,
        }
        impl crate::Identifiable for UpdateProfile {
            const CONSTRUCTOR_ID: u32 = 2018596725;
        }
        impl crate::Serializable for UpdateProfile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.first_name.is_some() { 1 } else { 0 }
                    | if self.last_name.is_some() { 2 } else { 0 }
                    | if self.about.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.first_name {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.last_name {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.about {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for UpdateProfile {
            type Return = crate::enums::User;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateStatus {
            pub offline: bool,
        }
        impl crate::Identifiable for UpdateStatus {
            const CONSTRUCTOR_ID: u32 = 1713919532;
        }
        impl crate::Serializable for UpdateStatus {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.offline.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateStatus {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateTheme {
            pub format: String,
            pub theme: crate::enums::InputTheme,
            pub slug: Option<String>,
            pub title: Option<String>,
            pub document: Option<crate::enums::InputDocument>,
            pub settings: Option<Vec<crate::enums::InputThemeSettings>>,
        }
        impl crate::Identifiable for UpdateTheme {
            const CONSTRUCTOR_ID: u32 = 737414348;
        }
        impl crate::Serializable for UpdateTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.slug.is_some() { 1 } else { 0 }
                    | if self.title.is_some() { 2 } else { 0 }
                    | if self.document.is_some() { 4 } else { 0 }
                    | if self.settings.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.format.serialize(buf);
                self.theme.serialize(buf);
                if let Some(ref x) = self.slug {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.document {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.settings {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for UpdateTheme {
            type Return = crate::enums::Theme;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateUsername {
            pub username: String,
        }
        impl crate::Identifiable for UpdateUsername {
            const CONSTRUCTOR_ID: u32 = 1040964988;
        }
        impl crate::Serializable for UpdateUsername {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.username.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateUsername {
            type Return = crate::enums::User;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadTheme {
            pub file: crate::enums::InputFile,
            pub thumb: Option<crate::enums::InputFile>,
            pub file_name: String,
            pub mime_type: String,
        }
        impl crate::Identifiable for UploadTheme {
            const CONSTRUCTOR_ID: u32 = 473805619;
        }
        impl crate::Serializable for UploadTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.thumb.is_some() { 1 } else { 0 }).serialize(buf);
                self.file.serialize(buf);
                if let Some(ref x) = self.thumb {
                    x.serialize(buf);
                }
                self.file_name.serialize(buf);
                self.mime_type.serialize(buf);
            }
        }
        impl crate::RemoteCall for UploadTheme {
            type Return = crate::enums::Document;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadWallPaper {
            pub file: crate::enums::InputFile,
            pub mime_type: String,
            pub settings: crate::enums::WallPaperSettings,
        }
        impl crate::Identifiable for UploadWallPaper {
            const CONSTRUCTOR_ID: u32 = 3716494945;
        }
        impl crate::Serializable for UploadWallPaper {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file.serialize(buf);
                self.mime_type.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for UploadWallPaper {
            type Return = crate::enums::WallPaper;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct VerifyEmail {
            pub email: String,
            pub code: String,
        }
        impl crate::Identifiable for VerifyEmail {
            const CONSTRUCTOR_ID: u32 = 3971627483;
        }
        impl crate::Serializable for VerifyEmail {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.email.serialize(buf);
                self.code.serialize(buf);
            }
        }
        impl crate::RemoteCall for VerifyEmail {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct VerifyPhone {
            pub phone_number: String,
            pub phone_code_hash: String,
            pub phone_code: String,
        }
        impl crate::Identifiable for VerifyPhone {
            const CONSTRUCTOR_ID: u32 = 1305716726;
        }
        impl crate::Serializable for VerifyPhone {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
                self.phone_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for VerifyPhone {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod auth {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptLoginToken {
            pub token: Vec<u8>,
        }
        impl crate::Identifiable for AcceptLoginToken {
            const CONSTRUCTOR_ID: u32 = 3902057805;
        }
        impl crate::Serializable for AcceptLoginToken {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.token.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptLoginToken {
            type Return = crate::enums::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct BindTempAuthKey {
            pub perm_auth_key_id: i64,
            pub nonce: i64,
            pub expires_at: i32,
            pub encrypted_message: Vec<u8>,
        }
        impl crate::Identifiable for BindTempAuthKey {
            const CONSTRUCTOR_ID: u32 = 3453233669;
        }
        impl crate::Serializable for BindTempAuthKey {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.perm_auth_key_id.serialize(buf);
                self.nonce.serialize(buf);
                self.expires_at.serialize(buf);
                self.encrypted_message.serialize(buf);
            }
        }
        impl crate::RemoteCall for BindTempAuthKey {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CancelCode {
            pub phone_number: String,
            pub phone_code_hash: String,
        }
        impl crate::Identifiable for CancelCode {
            const CONSTRUCTOR_ID: u32 = 520357240;
        }
        impl crate::Serializable for CancelCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for CancelCode {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckPassword {
            pub password: crate::enums::InputCheckPasswordSrp,
        }
        impl crate::Identifiable for CheckPassword {
            const CONSTRUCTOR_ID: u32 = 3515567382;
        }
        impl crate::Serializable for CheckPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.password.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckPassword {
            type Return = crate::enums::auth::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckRecoveryPassword {
            pub code: String,
        }
        impl crate::Identifiable for CheckRecoveryPassword {
            const CONSTRUCTOR_ID: u32 = 221691769;
        }
        impl crate::Serializable for CheckRecoveryPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.code.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckRecoveryPassword {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DropTempAuthKeys {
            pub except_auth_keys: Vec<i64>,
        }
        impl crate::Identifiable for DropTempAuthKeys {
            const CONSTRUCTOR_ID: u32 = 2387124616;
        }
        impl crate::Serializable for DropTempAuthKeys {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.except_auth_keys.serialize(buf);
            }
        }
        impl crate::RemoteCall for DropTempAuthKeys {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportAuthorization {
            pub dc_id: i32,
        }
        impl crate::Identifiable for ExportAuthorization {
            const CONSTRUCTOR_ID: u32 = 3854565325;
        }
        impl crate::Serializable for ExportAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.dc_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ExportAuthorization {
            type Return = crate::enums::auth::ExportedAuthorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportLoginToken {
            pub api_id: i32,
            pub api_hash: String,
            pub except_ids: Vec<i64>,
        }
        impl crate::Identifiable for ExportLoginToken {
            const CONSTRUCTOR_ID: u32 = 3084944894;
        }
        impl crate::Serializable for ExportLoginToken {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.api_id.serialize(buf);
                self.api_hash.serialize(buf);
                self.except_ids.serialize(buf);
            }
        }
        impl crate::RemoteCall for ExportLoginToken {
            type Return = crate::enums::auth::LoginToken;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportAuthorization {
            pub id: i64,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for ImportAuthorization {
            const CONSTRUCTOR_ID: u32 = 2776268205;
        }
        impl crate::Serializable for ImportAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::RemoteCall for ImportAuthorization {
            type Return = crate::enums::auth::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportBotAuthorization {
            pub flags: i32,
            pub api_id: i32,
            pub api_hash: String,
            pub bot_auth_token: String,
        }
        impl crate::Identifiable for ImportBotAuthorization {
            const CONSTRUCTOR_ID: u32 = 1738800940;
        }
        impl crate::Serializable for ImportBotAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.flags.serialize(buf);
                self.api_id.serialize(buf);
                self.api_hash.serialize(buf);
                self.bot_auth_token.serialize(buf);
            }
        }
        impl crate::RemoteCall for ImportBotAuthorization {
            type Return = crate::enums::auth::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportLoginToken {
            pub token: Vec<u8>,
        }
        impl crate::Identifiable for ImportLoginToken {
            const CONSTRUCTOR_ID: u32 = 2511101156;
        }
        impl crate::Serializable for ImportLoginToken {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.token.serialize(buf);
            }
        }
        impl crate::RemoteCall for ImportLoginToken {
            type Return = crate::enums::auth::LoginToken;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LogOut {}
        impl crate::Identifiable for LogOut {
            const CONSTRUCTOR_ID: u32 = 1047706137;
        }
        impl crate::Serializable for LogOut {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for LogOut {
            type Return = crate::enums::auth::LoggedOut;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RecoverPassword {
            pub code: String,
            pub new_settings: Option<crate::enums::account::PasswordInputSettings>,
        }
        impl crate::Identifiable for RecoverPassword {
            const CONSTRUCTOR_ID: u32 = 923364464;
        }
        impl crate::Serializable for RecoverPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.new_settings.is_some() { 1 } else { 0 }).serialize(buf);
                self.code.serialize(buf);
                if let Some(ref x) = self.new_settings {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for RecoverPassword {
            type Return = crate::enums::auth::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RequestPasswordRecovery {}
        impl crate::Identifiable for RequestPasswordRecovery {
            const CONSTRUCTOR_ID: u32 = 3633822822;
        }
        impl crate::Serializable for RequestPasswordRecovery {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for RequestPasswordRecovery {
            type Return = crate::enums::auth::PasswordRecovery;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResendCode {
            pub phone_number: String,
            pub phone_code_hash: String,
        }
        impl crate::Identifiable for ResendCode {
            const CONSTRUCTOR_ID: u32 = 1056025023;
        }
        impl crate::Serializable for ResendCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResendCode {
            type Return = crate::enums::auth::SentCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetAuthorizations {}
        impl crate::Identifiable for ResetAuthorizations {
            const CONSTRUCTOR_ID: u32 = 2678787354;
        }
        impl crate::Serializable for ResetAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetAuthorizations {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendCode {
            pub phone_number: String,
            pub api_id: i32,
            pub api_hash: String,
            pub settings: crate::enums::CodeSettings,
        }
        impl crate::Identifiable for SendCode {
            const CONSTRUCTOR_ID: u32 = 2792825935;
        }
        impl crate::Serializable for SendCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.api_id.serialize(buf);
                self.api_hash.serialize(buf);
                self.settings.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendCode {
            type Return = crate::enums::auth::SentCode;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SignIn {
            pub phone_number: String,
            pub phone_code_hash: String,
            pub phone_code: String,
        }
        impl crate::Identifiable for SignIn {
            const CONSTRUCTOR_ID: u32 = 3168081281;
        }
        impl crate::Serializable for SignIn {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
                self.phone_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for SignIn {
            type Return = crate::enums::auth::Authorization;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SignUp {
            pub phone_number: String,
            pub phone_code_hash: String,
            pub first_name: String,
            pub last_name: String,
        }
        impl crate::Identifiable for SignUp {
            const CONSTRUCTOR_ID: u32 = 2163139623;
        }
        impl crate::Serializable for SignUp {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phone_number.serialize(buf);
                self.phone_code_hash.serialize(buf);
                self.first_name.serialize(buf);
                self.last_name.serialize(buf);
            }
        }
        impl crate::RemoteCall for SignUp {
            type Return = crate::enums::auth::Authorization;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod bots {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AnswerWebhookJsonquery {
            pub query_id: i64,
            pub data: crate::enums::DataJson,
        }
        impl crate::Identifiable for AnswerWebhookJsonquery {
            const CONSTRUCTOR_ID: u32 = 3860938573;
        }
        impl crate::Serializable for AnswerWebhookJsonquery {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.query_id.serialize(buf);
                self.data.serialize(buf);
            }
        }
        impl crate::RemoteCall for AnswerWebhookJsonquery {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetBotCommands {
            pub scope: crate::enums::BotCommandScope,
            pub lang_code: String,
        }
        impl crate::Identifiable for GetBotCommands {
            const CONSTRUCTOR_ID: u32 = 3813412310;
        }
        impl crate::Serializable for GetBotCommands {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.scope.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetBotCommands {
            type Return = Vec<crate::enums::BotCommand>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetBotCommands {
            pub scope: crate::enums::BotCommandScope,
            pub lang_code: String,
        }
        impl crate::Identifiable for ResetBotCommands {
            const CONSTRUCTOR_ID: u32 = 1032708345;
        }
        impl crate::Serializable for ResetBotCommands {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.scope.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetBotCommands {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendCustomRequest {
            pub custom_method: String,
            pub params: crate::enums::DataJson,
        }
        impl crate::Identifiable for SendCustomRequest {
            const CONSTRUCTOR_ID: u32 = 2854709741;
        }
        impl crate::Serializable for SendCustomRequest {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.custom_method.serialize(buf);
                self.params.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendCustomRequest {
            type Return = crate::enums::DataJson;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetBotCommands {
            pub scope: crate::enums::BotCommandScope,
            pub lang_code: String,
            pub commands: Vec<crate::enums::BotCommand>,
        }
        impl crate::Identifiable for SetBotCommands {
            const CONSTRUCTOR_ID: u32 = 85399130;
        }
        impl crate::Serializable for SetBotCommands {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.scope.serialize(buf);
                self.lang_code.serialize(buf);
                self.commands.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetBotCommands {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod channels {
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckUsername {
            pub channel: crate::enums::InputChannel,
            pub username: String,
        }
        impl crate::Identifiable for CheckUsername {
            const CONSTRUCTOR_ID: u32 = 283557164;
        }
        impl crate::Serializable for CheckUsername {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.username.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckUsername {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ConvertToGigagroup {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for ConvertToGigagroup {
            const CONSTRUCTOR_ID: u32 = 187239529;
        }
        impl crate::Serializable for ConvertToGigagroup {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for ConvertToGigagroup {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CreateChannel {
            pub broadcast: bool,
            pub megagroup: bool,
            pub for_import: bool,
            pub title: String,
            pub about: String,
            pub geo_point: Option<crate::enums::InputGeoPoint>,
            pub address: Option<String>,
        }
        impl crate::Identifiable for CreateChannel {
            const CONSTRUCTOR_ID: u32 = 1029681423;
        }
        impl crate::Serializable for CreateChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.broadcast { 1 } else { 0 }
                    | if self.megagroup { 2 } else { 0 }
                    | if self.for_import { 8 } else { 0 }
                    | if self.geo_point.is_some() { 4 } else { 0 }
                    | if self.address.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.title.serialize(buf);
                self.about.serialize(buf);
                if let Some(ref x) = self.geo_point {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.address {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for CreateChannel {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteChannel {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for DeleteChannel {
            const CONSTRUCTOR_ID: u32 = 3222347747;
        }
        impl crate::Serializable for DeleteChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteChannel {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteHistory {
            pub channel: crate::enums::InputChannel,
            pub max_id: i32,
        }
        impl crate::Identifiable for DeleteHistory {
            const CONSTRUCTOR_ID: u32 = 2939592002;
        }
        impl crate::Serializable for DeleteHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.max_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteHistory {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteMessages {
            pub channel: crate::enums::InputChannel,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for DeleteMessages {
            const CONSTRUCTOR_ID: u32 = 2227305806;
        }
        impl crate::Serializable for DeleteMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteMessages {
            type Return = crate::enums::messages::AffectedMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteParticipantHistory {
            pub channel: crate::enums::InputChannel,
            pub participant: crate::enums::InputPeer,
        }
        impl crate::Identifiable for DeleteParticipantHistory {
            const CONSTRUCTOR_ID: u32 = 913655003;
        }
        impl crate::Serializable for DeleteParticipantHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.participant.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteParticipantHistory {
            type Return = crate::enums::messages::AffectedHistory;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditAdmin {
            pub channel: crate::enums::InputChannel,
            pub user_id: crate::enums::InputUser,
            pub admin_rights: crate::enums::ChatAdminRights,
            pub rank: String,
        }
        impl crate::Identifiable for EditAdmin {
            const CONSTRUCTOR_ID: u32 = 3543959810;
        }
        impl crate::Serializable for EditAdmin {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.user_id.serialize(buf);
                self.admin_rights.serialize(buf);
                self.rank.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditAdmin {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditBanned {
            pub channel: crate::enums::InputChannel,
            pub participant: crate::enums::InputPeer,
            pub banned_rights: crate::enums::ChatBannedRights,
        }
        impl crate::Identifiable for EditBanned {
            const CONSTRUCTOR_ID: u32 = 2531708289;
        }
        impl crate::Serializable for EditBanned {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.participant.serialize(buf);
                self.banned_rights.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditBanned {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditCreator {
            pub channel: crate::enums::InputChannel,
            pub user_id: crate::enums::InputUser,
            pub password: crate::enums::InputCheckPasswordSrp,
        }
        impl crate::Identifiable for EditCreator {
            const CONSTRUCTOR_ID: u32 = 2402864415;
        }
        impl crate::Serializable for EditCreator {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.user_id.serialize(buf);
                self.password.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditCreator {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditLocation {
            pub channel: crate::enums::InputChannel,
            pub geo_point: crate::enums::InputGeoPoint,
            pub address: String,
        }
        impl crate::Identifiable for EditLocation {
            const CONSTRUCTOR_ID: u32 = 1491484525;
        }
        impl crate::Serializable for EditLocation {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.geo_point.serialize(buf);
                self.address.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditLocation {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditPhoto {
            pub channel: crate::enums::InputChannel,
            pub photo: crate::enums::InputChatPhoto,
        }
        impl crate::Identifiable for EditPhoto {
            const CONSTRUCTOR_ID: u32 = 4046346185;
        }
        impl crate::Serializable for EditPhoto {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.photo.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditPhoto {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditTitle {
            pub channel: crate::enums::InputChannel,
            pub title: String,
        }
        impl crate::Identifiable for EditTitle {
            const CONSTRUCTOR_ID: u32 = 1450044624;
        }
        impl crate::Serializable for EditTitle {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.title.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditTitle {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportMessageLink {
            pub grouped: bool,
            pub thread: bool,
            pub channel: crate::enums::InputChannel,
            pub id: i32,
        }
        impl crate::Identifiable for ExportMessageLink {
            const CONSTRUCTOR_ID: u32 = 3862932971;
        }
        impl crate::Serializable for ExportMessageLink {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.grouped { 1 } else { 0 } | if self.thread { 2 } else { 0 })
                    .serialize(buf);
                self.channel.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ExportMessageLink {
            type Return = crate::enums::ExportedMessageLink;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAdminLog {
            pub channel: crate::enums::InputChannel,
            pub q: String,
            pub events_filter: Option<crate::enums::ChannelAdminLogEventsFilter>,
            pub admins: Option<Vec<crate::enums::InputUser>>,
            pub max_id: i64,
            pub min_id: i64,
            pub limit: i32,
        }
        impl crate::Identifiable for GetAdminLog {
            const CONSTRUCTOR_ID: u32 = 870184064;
        }
        impl crate::Serializable for GetAdminLog {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.events_filter.is_some() { 1 } else { 0 }
                    | if self.admins.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.channel.serialize(buf);
                self.q.serialize(buf);
                if let Some(ref x) = self.events_filter {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.admins {
                    x.serialize(buf);
                }
                self.max_id.serialize(buf);
                self.min_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAdminLog {
            type Return = crate::enums::channels::AdminLogResults;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAdminedPublicChannels {
            pub by_location: bool,
            pub check_limit: bool,
        }
        impl crate::Identifiable for GetAdminedPublicChannels {
            const CONSTRUCTOR_ID: u32 = 4172297903;
        }
        impl crate::Serializable for GetAdminedPublicChannels {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.by_location { 1 } else { 0 }
                    | if self.check_limit { 2 } else { 0 })
                .serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAdminedPublicChannels {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetChannels {
            pub id: Vec<crate::enums::InputChannel>,
        }
        impl crate::Identifiable for GetChannels {
            const CONSTRUCTOR_ID: u32 = 176122811;
        }
        impl crate::Serializable for GetChannels {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetChannels {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFullChannel {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for GetFullChannel {
            const CONSTRUCTOR_ID: u32 = 141781513;
        }
        impl crate::Serializable for GetFullChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFullChannel {
            type Return = crate::enums::messages::ChatFull;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGroupsForDiscussion {}
        impl crate::Identifiable for GetGroupsForDiscussion {
            const CONSTRUCTOR_ID: u32 = 4124758904;
        }
        impl crate::Serializable for GetGroupsForDiscussion {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGroupsForDiscussion {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetInactiveChannels {}
        impl crate::Identifiable for GetInactiveChannels {
            const CONSTRUCTOR_ID: u32 = 300429806;
        }
        impl crate::Serializable for GetInactiveChannels {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetInactiveChannels {
            type Return = crate::enums::messages::InactiveChats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetLeftChannels {
            pub offset: i32,
        }
        impl crate::Identifiable for GetLeftChannels {
            const CONSTRUCTOR_ID: u32 = 2202135744;
        }
        impl crate::Serializable for GetLeftChannels {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.offset.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetLeftChannels {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessages {
            pub channel: crate::enums::InputChannel,
            pub id: Vec<crate::enums::InputMessage>,
        }
        impl crate::Identifiable for GetMessages {
            const CONSTRUCTOR_ID: u32 = 2911672867;
        }
        impl crate::Serializable for GetMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessages {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetParticipant {
            pub channel: crate::enums::InputChannel,
            pub participant: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetParticipant {
            const CONSTRUCTOR_ID: u32 = 2695589062;
        }
        impl crate::Serializable for GetParticipant {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.participant.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetParticipant {
            type Return = crate::enums::channels::ChannelParticipant;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetParticipants {
            pub channel: crate::enums::InputChannel,
            pub filter: crate::enums::ChannelParticipantsFilter,
            pub offset: i32,
            pub limit: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetParticipants {
            const CONSTRUCTOR_ID: u32 = 2010044880;
        }
        impl crate::Serializable for GetParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.filter.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetParticipants {
            type Return = crate::enums::channels::ChannelParticipants;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSendAs {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetSendAs {
            const CONSTRUCTOR_ID: u32 = 231174382;
        }
        impl crate::Serializable for GetSendAs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSendAs {
            type Return = crate::enums::channels::SendAsPeers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSponsoredMessages {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for GetSponsoredMessages {
            const CONSTRUCTOR_ID: u32 = 3961589695;
        }
        impl crate::Serializable for GetSponsoredMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSponsoredMessages {
            type Return = crate::enums::messages::SponsoredMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InviteToChannel {
            pub channel: crate::enums::InputChannel,
            pub users: Vec<crate::enums::InputUser>,
        }
        impl crate::Identifiable for InviteToChannel {
            const CONSTRUCTOR_ID: u32 = 429865580;
        }
        impl crate::Serializable for InviteToChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::RemoteCall for InviteToChannel {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct JoinChannel {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for JoinChannel {
            const CONSTRUCTOR_ID: u32 = 615851205;
        }
        impl crate::Serializable for JoinChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for JoinChannel {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LeaveChannel {
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for LeaveChannel {
            const CONSTRUCTOR_ID: u32 = 4164332181;
        }
        impl crate::Serializable for LeaveChannel {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for LeaveChannel {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadHistory {
            pub channel: crate::enums::InputChannel,
            pub max_id: i32,
        }
        impl crate::Identifiable for ReadHistory {
            const CONSTRUCTOR_ID: u32 = 3423619383;
        }
        impl crate::Serializable for ReadHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.max_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadHistory {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadMessageContents {
            pub channel: crate::enums::InputChannel,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for ReadMessageContents {
            const CONSTRUCTOR_ID: u32 = 3937786936;
        }
        impl crate::Serializable for ReadMessageContents {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadMessageContents {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReportSpam {
            pub channel: crate::enums::InputChannel,
            pub participant: crate::enums::InputPeer,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for ReportSpam {
            const CONSTRUCTOR_ID: u32 = 4098523925;
        }
        impl crate::Serializable for ReportSpam {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.participant.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReportSpam {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetDiscussionGroup {
            pub broadcast: crate::enums::InputChannel,
            pub group: crate::enums::InputChannel,
        }
        impl crate::Identifiable for SetDiscussionGroup {
            const CONSTRUCTOR_ID: u32 = 1079520178;
        }
        impl crate::Serializable for SetDiscussionGroup {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.broadcast.serialize(buf);
                self.group.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetDiscussionGroup {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetStickers {
            pub channel: crate::enums::InputChannel,
            pub stickerset: crate::enums::InputStickerSet,
        }
        impl crate::Identifiable for SetStickers {
            const CONSTRUCTOR_ID: u32 = 3935085817;
        }
        impl crate::Serializable for SetStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.stickerset.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetStickers {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TogglePreHistoryHidden {
            pub channel: crate::enums::InputChannel,
            pub enabled: bool,
        }
        impl crate::Identifiable for TogglePreHistoryHidden {
            const CONSTRUCTOR_ID: u32 = 3938171212;
        }
        impl crate::Serializable for TogglePreHistoryHidden {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.enabled.serialize(buf);
            }
        }
        impl crate::RemoteCall for TogglePreHistoryHidden {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleSignatures {
            pub channel: crate::enums::InputChannel,
            pub enabled: bool,
        }
        impl crate::Identifiable for ToggleSignatures {
            const CONSTRUCTOR_ID: u32 = 527021574;
        }
        impl crate::Serializable for ToggleSignatures {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.enabled.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleSignatures {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleSlowMode {
            pub channel: crate::enums::InputChannel,
            pub seconds: i32,
        }
        impl crate::Identifiable for ToggleSlowMode {
            const CONSTRUCTOR_ID: u32 = 3990134512;
        }
        impl crate::Serializable for ToggleSlowMode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.seconds.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleSlowMode {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateUsername {
            pub channel: crate::enums::InputChannel,
            pub username: String,
        }
        impl crate::Identifiable for UpdateUsername {
            const CONSTRUCTOR_ID: u32 = 890549214;
        }
        impl crate::Serializable for UpdateUsername {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.username.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateUsername {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ViewSponsoredMessage {
            pub channel: crate::enums::InputChannel,
            pub random_id: Vec<u8>,
        }
        impl crate::Identifiable for ViewSponsoredMessage {
            const CONSTRUCTOR_ID: u32 = 3199130516;
        }
        impl crate::Serializable for ViewSponsoredMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.random_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ViewSponsoredMessage {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod contacts {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptContact {
            pub id: crate::enums::InputUser,
        }
        impl crate::Identifiable for AcceptContact {
            const CONSTRUCTOR_ID: u32 = 4164002319;
        }
        impl crate::Serializable for AcceptContact {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptContact {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AddContact {
            pub add_phone_privacy_exception: bool,
            pub id: crate::enums::InputUser,
            pub first_name: String,
            pub last_name: String,
            pub phone: String,
        }
        impl crate::Identifiable for AddContact {
            const CONSTRUCTOR_ID: u32 = 3908330448;
        }
        impl crate::Serializable for AddContact {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.add_phone_privacy_exception {
                        1
                    } else {
                        0
                    })
                .serialize(buf);
                self.id.serialize(buf);
                self.first_name.serialize(buf);
                self.last_name.serialize(buf);
                self.phone.serialize(buf);
            }
        }
        impl crate::RemoteCall for AddContact {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Block {
            pub id: crate::enums::InputPeer,
        }
        impl crate::Identifiable for Block {
            const CONSTRUCTOR_ID: u32 = 1758204945;
        }
        impl crate::Serializable for Block {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for Block {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct BlockFromReplies {
            pub delete_message: bool,
            pub delete_history: bool,
            pub report_spam: bool,
            pub msg_id: i32,
        }
        impl crate::Identifiable for BlockFromReplies {
            const CONSTRUCTOR_ID: u32 = 698914348;
        }
        impl crate::Serializable for BlockFromReplies {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.delete_message { 1 } else { 0 }
                    | if self.delete_history { 2 } else { 0 }
                    | if self.report_spam { 4 } else { 0 })
                .serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for BlockFromReplies {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteByPhones {
            pub phones: Vec<String>,
        }
        impl crate::Identifiable for DeleteByPhones {
            const CONSTRUCTOR_ID: u32 = 269745566;
        }
        impl crate::Serializable for DeleteByPhones {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.phones.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteByPhones {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteContacts {
            pub id: Vec<crate::enums::InputUser>,
        }
        impl crate::Identifiable for DeleteContacts {
            const CONSTRUCTOR_ID: u32 = 157945344;
        }
        impl crate::Serializable for DeleteContacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteContacts {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetBlocked {
            pub offset: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetBlocked {
            const CONSTRUCTOR_ID: u32 = 4118557967;
        }
        impl crate::Serializable for GetBlocked {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetBlocked {
            type Return = crate::enums::contacts::Blocked;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetContactIds {
            pub hash: i64,
        }
        impl crate::Identifiable for GetContactIds {
            const CONSTRUCTOR_ID: u32 = 2061264541;
        }
        impl crate::Serializable for GetContactIds {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetContactIds {
            type Return = Vec<i32>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetContacts {
            pub hash: i64,
        }
        impl crate::Identifiable for GetContacts {
            const CONSTRUCTOR_ID: u32 = 1574346258;
        }
        impl crate::Serializable for GetContacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetContacts {
            type Return = crate::enums::contacts::Contacts;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetLocated {
            pub background: bool,
            pub geo_point: crate::enums::InputGeoPoint,
            pub self_expires: Option<i32>,
        }
        impl crate::Identifiable for GetLocated {
            const CONSTRUCTOR_ID: u32 = 3544759364;
        }
        impl crate::Serializable for GetLocated {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.background { 2 } else { 0 }
                    | if self.self_expires.is_some() { 1 } else { 0 })
                .serialize(buf);
                self.geo_point.serialize(buf);
                if let Some(ref x) = self.self_expires {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for GetLocated {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSaved {}
        impl crate::Identifiable for GetSaved {
            const CONSTRUCTOR_ID: u32 = 2196890527;
        }
        impl crate::Serializable for GetSaved {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSaved {
            type Return = Vec<crate::enums::SavedContact>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetStatuses {}
        impl crate::Identifiable for GetStatuses {
            const CONSTRUCTOR_ID: u32 = 3299038190;
        }
        impl crate::Serializable for GetStatuses {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetStatuses {
            type Return = Vec<crate::enums::ContactStatus>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetTopPeers {
            pub correspondents: bool,
            pub bots_pm: bool,
            pub bots_inline: bool,
            pub phone_calls: bool,
            pub forward_users: bool,
            pub forward_chats: bool,
            pub groups: bool,
            pub channels: bool,
            pub offset: i32,
            pub limit: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetTopPeers {
            const CONSTRUCTOR_ID: u32 = 2536798390;
        }
        impl crate::Serializable for GetTopPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.correspondents { 1 } else { 0 }
                    | if self.bots_pm { 2 } else { 0 }
                    | if self.bots_inline { 4 } else { 0 }
                    | if self.phone_calls { 8 } else { 0 }
                    | if self.forward_users { 16 } else { 0 }
                    | if self.forward_chats { 32 } else { 0 }
                    | if self.groups { 1024 } else { 0 }
                    | if self.channels { 32768 } else { 0 })
                .serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetTopPeers {
            type Return = crate::enums::contacts::TopPeers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportContacts {
            pub contacts: Vec<crate::enums::InputContact>,
        }
        impl crate::Identifiable for ImportContacts {
            const CONSTRUCTOR_ID: u32 = 746589157;
        }
        impl crate::Serializable for ImportContacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.contacts.serialize(buf);
            }
        }
        impl crate::RemoteCall for ImportContacts {
            type Return = crate::enums::contacts::ImportedContacts;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetSaved {}
        impl crate::Identifiable for ResetSaved {
            const CONSTRUCTOR_ID: u32 = 2274703345;
        }
        impl crate::Serializable for ResetSaved {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetSaved {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResetTopPeerRating {
            pub category: crate::enums::TopPeerCategory,
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for ResetTopPeerRating {
            const CONSTRUCTOR_ID: u32 = 451113900;
        }
        impl crate::Serializable for ResetTopPeerRating {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.category.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResetTopPeerRating {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ResolveUsername {
            pub username: String,
        }
        impl crate::Identifiable for ResolveUsername {
            const CONSTRUCTOR_ID: u32 = 4181511075;
        }
        impl crate::Serializable for ResolveUsername {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.username.serialize(buf);
            }
        }
        impl crate::RemoteCall for ResolveUsername {
            type Return = crate::enums::contacts::ResolvedPeer;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Search {
            pub q: String,
            pub limit: i32,
        }
        impl crate::Identifiable for Search {
            const CONSTRUCTOR_ID: u32 = 301470424;
        }
        impl crate::Serializable for Search {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.q.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for Search {
            type Return = crate::enums::contacts::Found;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleTopPeers {
            pub enabled: bool,
        }
        impl crate::Identifiable for ToggleTopPeers {
            const CONSTRUCTOR_ID: u32 = 2232729050;
        }
        impl crate::Serializable for ToggleTopPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.enabled.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleTopPeers {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Unblock {
            pub id: crate::enums::InputPeer,
        }
        impl crate::Identifiable for Unblock {
            const CONSTRUCTOR_ID: u32 = 3198573904;
        }
        impl crate::Serializable for Unblock {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for Unblock {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod folders {
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteFolder {
            pub folder_id: i32,
        }
        impl crate::Identifiable for DeleteFolder {
            const CONSTRUCTOR_ID: u32 = 472471681;
        }
        impl crate::Serializable for DeleteFolder {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.folder_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteFolder {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditPeerFolders {
            pub folder_peers: Vec<crate::enums::InputFolderPeer>,
        }
        impl crate::Identifiable for EditPeerFolders {
            const CONSTRUCTOR_ID: u32 = 1749536939;
        }
        impl crate::Serializable for EditPeerFolders {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.folder_peers.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditPeerFolders {
            type Return = crate::enums::Updates;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod help {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptTermsOfService {
            pub id: crate::enums::DataJson,
        }
        impl crate::Identifiable for AcceptTermsOfService {
            const CONSTRUCTOR_ID: u32 = 4000511898;
        }
        impl crate::Serializable for AcceptTermsOfService {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptTermsOfService {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DismissSuggestion {
            pub peer: crate::enums::InputPeer,
            pub suggestion: String,
        }
        impl crate::Identifiable for DismissSuggestion {
            const CONSTRUCTOR_ID: u32 = 4111317665;
        }
        impl crate::Serializable for DismissSuggestion {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.suggestion.serialize(buf);
            }
        }
        impl crate::RemoteCall for DismissSuggestion {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditUserInfo {
            pub user_id: crate::enums::InputUser,
            pub message: String,
            pub entities: Vec<crate::enums::MessageEntity>,
        }
        impl crate::Identifiable for EditUserInfo {
            const CONSTRUCTOR_ID: u32 = 1723407216;
        }
        impl crate::Serializable for EditUserInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.user_id.serialize(buf);
                self.message.serialize(buf);
                self.entities.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditUserInfo {
            type Return = crate::enums::help::UserInfo;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAppChangelog {
            pub prev_app_version: String,
        }
        impl crate::Identifiable for GetAppChangelog {
            const CONSTRUCTOR_ID: u32 = 2417028975;
        }
        impl crate::Serializable for GetAppChangelog {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.prev_app_version.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAppChangelog {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAppConfig {}
        impl crate::Identifiable for GetAppConfig {
            const CONSTRUCTOR_ID: u32 = 2559656208;
        }
        impl crate::Serializable for GetAppConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAppConfig {
            type Return = crate::enums::Jsonvalue;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAppUpdate {
            pub source: String,
        }
        impl crate::Identifiable for GetAppUpdate {
            const CONSTRUCTOR_ID: u32 = 1378703997;
        }
        impl crate::Serializable for GetAppUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.source.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAppUpdate {
            type Return = crate::enums::help::AppUpdate;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCdnConfig {}
        impl crate::Identifiable for GetCdnConfig {
            const CONSTRUCTOR_ID: u32 = 1375900482;
        }
        impl crate::Serializable for GetCdnConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCdnConfig {
            type Return = crate::enums::CdnConfig;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetConfig {}
        impl crate::Identifiable for GetConfig {
            const CONSTRUCTOR_ID: u32 = 3304659051;
        }
        impl crate::Serializable for GetConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetConfig {
            type Return = crate::enums::Config;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCountriesList {
            pub lang_code: String,
            pub hash: i32,
        }
        impl crate::Identifiable for GetCountriesList {
            const CONSTRUCTOR_ID: u32 = 1935116200;
        }
        impl crate::Serializable for GetCountriesList {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_code.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCountriesList {
            type Return = crate::enums::help::CountriesList;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDeepLinkInfo {
            pub path: String,
        }
        impl crate::Identifiable for GetDeepLinkInfo {
            const CONSTRUCTOR_ID: u32 = 1072547679;
        }
        impl crate::Serializable for GetDeepLinkInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.path.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDeepLinkInfo {
            type Return = crate::enums::help::DeepLinkInfo;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetInviteText {}
        impl crate::Identifiable for GetInviteText {
            const CONSTRUCTOR_ID: u32 = 1295590211;
        }
        impl crate::Serializable for GetInviteText {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetInviteText {
            type Return = crate::enums::help::InviteText;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetNearestDc {}
        impl crate::Identifiable for GetNearestDc {
            const CONSTRUCTOR_ID: u32 = 531836966;
        }
        impl crate::Serializable for GetNearestDc {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetNearestDc {
            type Return = crate::enums::NearestDc;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPassportConfig {
            pub hash: i32,
        }
        impl crate::Identifiable for GetPassportConfig {
            const CONSTRUCTOR_ID: u32 = 3328290056;
        }
        impl crate::Serializable for GetPassportConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPassportConfig {
            type Return = crate::enums::help::PassportConfig;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPromoData {}
        impl crate::Identifiable for GetPromoData {
            const CONSTRUCTOR_ID: u32 = 3231151137;
        }
        impl crate::Serializable for GetPromoData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPromoData {
            type Return = crate::enums::help::PromoData;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetRecentMeUrls {
            pub referer: String,
        }
        impl crate::Identifiable for GetRecentMeUrls {
            const CONSTRUCTOR_ID: u32 = 1036054804;
        }
        impl crate::Serializable for GetRecentMeUrls {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.referer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetRecentMeUrls {
            type Return = crate::enums::help::RecentMeUrls;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSupport {}
        impl crate::Identifiable for GetSupport {
            const CONSTRUCTOR_ID: u32 = 2631862477;
        }
        impl crate::Serializable for GetSupport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSupport {
            type Return = crate::enums::help::Support;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSupportName {}
        impl crate::Identifiable for GetSupportName {
            const CONSTRUCTOR_ID: u32 = 3546343212;
        }
        impl crate::Serializable for GetSupportName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSupportName {
            type Return = crate::enums::help::SupportName;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetTermsOfServiceUpdate {}
        impl crate::Identifiable for GetTermsOfServiceUpdate {
            const CONSTRUCTOR_ID: u32 = 749019089;
        }
        impl crate::Serializable for GetTermsOfServiceUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetTermsOfServiceUpdate {
            type Return = crate::enums::help::TermsOfServiceUpdate;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetUserInfo {
            pub user_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for GetUserInfo {
            const CONSTRUCTOR_ID: u32 = 59377875;
        }
        impl crate::Serializable for GetUserInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.user_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetUserInfo {
            type Return = crate::enums::help::UserInfo;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HidePromoData {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for HidePromoData {
            const CONSTRUCTOR_ID: u32 = 505748629;
        }
        impl crate::Serializable for HidePromoData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for HidePromoData {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveAppLog {
            pub events: Vec<crate::enums::InputAppEvent>,
        }
        impl crate::Identifiable for SaveAppLog {
            const CONSTRUCTOR_ID: u32 = 1862465352;
        }
        impl crate::Serializable for SaveAppLog {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.events.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveAppLog {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetBotUpdatesStatus {
            pub pending_updates_count: i32,
            pub message: String,
        }
        impl crate::Identifiable for SetBotUpdatesStatus {
            const CONSTRUCTOR_ID: u32 = 3961704397;
        }
        impl crate::Serializable for SetBotUpdatesStatus {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.pending_updates_count.serialize(buf);
                self.message.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetBotUpdatesStatus {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod langpack {
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDifference {
            pub lang_pack: String,
            pub lang_code: String,
            pub from_version: i32,
        }
        impl crate::Identifiable for GetDifference {
            const CONSTRUCTOR_ID: u32 = 3449309861;
        }
        impl crate::Serializable for GetDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_pack.serialize(buf);
                self.lang_code.serialize(buf);
                self.from_version.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDifference {
            type Return = crate::enums::LangPackDifference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetLangPack {
            pub lang_pack: String,
            pub lang_code: String,
        }
        impl crate::Identifiable for GetLangPack {
            const CONSTRUCTOR_ID: u32 = 4075959050;
        }
        impl crate::Serializable for GetLangPack {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_pack.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetLangPack {
            type Return = crate::enums::LangPackDifference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetLanguage {
            pub lang_pack: String,
            pub lang_code: String,
        }
        impl crate::Identifiable for GetLanguage {
            const CONSTRUCTOR_ID: u32 = 1784243458;
        }
        impl crate::Serializable for GetLanguage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_pack.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetLanguage {
            type Return = crate::enums::LangPackLanguage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetLanguages {
            pub lang_pack: String,
        }
        impl crate::Identifiable for GetLanguages {
            const CONSTRUCTOR_ID: u32 = 1120311183;
        }
        impl crate::Serializable for GetLanguages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_pack.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetLanguages {
            type Return = Vec<crate::enums::LangPackLanguage>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetStrings {
            pub lang_pack: String,
            pub lang_code: String,
            pub keys: Vec<String>,
        }
        impl crate::Identifiable for GetStrings {
            const CONSTRUCTOR_ID: u32 = 4025104387;
        }
        impl crate::Serializable for GetStrings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_pack.serialize(buf);
                self.lang_code.serialize(buf);
                self.keys.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetStrings {
            type Return = Vec<crate::enums::LangPackString>;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod messages {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptEncryption {
            pub peer: crate::enums::InputEncryptedChat,
            pub g_b: Vec<u8>,
            pub key_fingerprint: i64,
        }
        impl crate::Identifiable for AcceptEncryption {
            const CONSTRUCTOR_ID: u32 = 1035731989;
        }
        impl crate::Serializable for AcceptEncryption {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.g_b.serialize(buf);
                self.key_fingerprint.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptEncryption {
            type Return = crate::enums::EncryptedChat;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptUrlAuth {
            pub write_allowed: bool,
            pub peer: Option<crate::enums::InputPeer>,
            pub msg_id: Option<i32>,
            pub button_id: Option<i32>,
            pub url: Option<String>,
        }
        impl crate::Identifiable for AcceptUrlAuth {
            const CONSTRUCTOR_ID: u32 = 2972479781;
        }
        impl crate::Serializable for AcceptUrlAuth {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.write_allowed { 1 } else { 0 }
                    | if self.peer.is_some() { 2 } else { 0 }
                    | if self.msg_id.is_some() { 2 } else { 0 }
                    | if self.button_id.is_some() { 2 } else { 0 }
                    | if self.url.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.peer {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.msg_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.button_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.url {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for AcceptUrlAuth {
            type Return = crate::enums::UrlAuthResult;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct AddChatUser {
            pub chat_id: i64,
            pub user_id: crate::enums::InputUser,
            pub fwd_limit: i32,
        }
        impl crate::Identifiable for AddChatUser {
            const CONSTRUCTOR_ID: u32 = 4064760803;
        }
        impl crate::Serializable for AddChatUser {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
                self.user_id.serialize(buf);
                self.fwd_limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for AddChatUser {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckChatInvite {
            pub hash: String,
        }
        impl crate::Identifiable for CheckChatInvite {
            const CONSTRUCTOR_ID: u32 = 1051570619;
        }
        impl crate::Serializable for CheckChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckChatInvite {
            type Return = crate::enums::ChatInvite;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckHistoryImport {
            pub import_head: String,
        }
        impl crate::Identifiable for CheckHistoryImport {
            const CONSTRUCTOR_ID: u32 = 1140726259;
        }
        impl crate::Serializable for CheckHistoryImport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.import_head.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckHistoryImport {
            type Return = crate::enums::messages::HistoryImportParsed;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckHistoryImportPeer {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for CheckHistoryImportPeer {
            const CONSTRUCTOR_ID: u32 = 1573261059;
        }
        impl crate::Serializable for CheckHistoryImportPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckHistoryImportPeer {
            type Return = crate::enums::messages::CheckedHistoryImportPeer;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ClearAllDrafts {}
        impl crate::Identifiable for ClearAllDrafts {
            const CONSTRUCTOR_ID: u32 = 2119757468;
        }
        impl crate::Serializable for ClearAllDrafts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for ClearAllDrafts {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ClearRecentStickers {
            pub attached: bool,
        }
        impl crate::Identifiable for ClearRecentStickers {
            const CONSTRUCTOR_ID: u32 = 2308530221;
        }
        impl crate::Serializable for ClearRecentStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.attached { 1 } else { 0 }).serialize(buf);
            }
        }
        impl crate::RemoteCall for ClearRecentStickers {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CreateChat {
            pub users: Vec<crate::enums::InputUser>,
            pub title: String,
        }
        impl crate::Identifiable for CreateChat {
            const CONSTRUCTOR_ID: u32 = 164303470;
        }
        impl crate::Serializable for CreateChat {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.users.serialize(buf);
                self.title.serialize(buf);
            }
        }
        impl crate::RemoteCall for CreateChat {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteChat {
            pub chat_id: i64,
        }
        impl crate::Identifiable for DeleteChat {
            const CONSTRUCTOR_ID: u32 = 1540419152;
        }
        impl crate::Serializable for DeleteChat {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteChat {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteChatUser {
            pub revoke_history: bool,
            pub chat_id: i64,
            pub user_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for DeleteChatUser {
            const CONSTRUCTOR_ID: u32 = 2719505579;
        }
        impl crate::Serializable for DeleteChatUser {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.revoke_history { 1 } else { 0 }).serialize(buf);
                self.chat_id.serialize(buf);
                self.user_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteChatUser {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteExportedChatInvite {
            pub peer: crate::enums::InputPeer,
            pub link: String,
        }
        impl crate::Identifiable for DeleteExportedChatInvite {
            const CONSTRUCTOR_ID: u32 = 3563365419;
        }
        impl crate::Serializable for DeleteExportedChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.link.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteExportedChatInvite {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteHistory {
            pub just_clear: bool,
            pub revoke: bool,
            pub peer: crate::enums::InputPeer,
            pub max_id: i32,
            pub min_date: Option<i32>,
            pub max_date: Option<i32>,
        }
        impl crate::Identifiable for DeleteHistory {
            const CONSTRUCTOR_ID: u32 = 2962199082;
        }
        impl crate::Serializable for DeleteHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.just_clear { 1 } else { 0 }
                    | if self.revoke { 2 } else { 0 }
                    | if self.min_date.is_some() { 4 } else { 0 }
                    | if self.max_date.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.max_id.serialize(buf);
                if let Some(ref x) = self.min_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.max_date {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for DeleteHistory {
            type Return = crate::enums::messages::AffectedHistory;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteMessages {
            pub revoke: bool,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for DeleteMessages {
            const CONSTRUCTOR_ID: u32 = 3851326930;
        }
        impl crate::Serializable for DeleteMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.revoke { 1 } else { 0 }).serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteMessages {
            type Return = crate::enums::messages::AffectedMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeletePhoneCallHistory {
            pub revoke: bool,
        }
        impl crate::Identifiable for DeletePhoneCallHistory {
            const CONSTRUCTOR_ID: u32 = 4190888969;
        }
        impl crate::Serializable for DeletePhoneCallHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.revoke { 1 } else { 0 }).serialize(buf);
            }
        }
        impl crate::RemoteCall for DeletePhoneCallHistory {
            type Return = crate::enums::messages::AffectedFoundMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteRevokedExportedChatInvites {
            pub peer: crate::enums::InputPeer,
            pub admin_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for DeleteRevokedExportedChatInvites {
            const CONSTRUCTOR_ID: u32 = 1452833749;
        }
        impl crate::Serializable for DeleteRevokedExportedChatInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.admin_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteRevokedExportedChatInvites {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeleteScheduledMessages {
            pub peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for DeleteScheduledMessages {
            const CONSTRUCTOR_ID: u32 = 1504586518;
        }
        impl crate::Serializable for DeleteScheduledMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeleteScheduledMessages {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DiscardEncryption {
            pub delete_history: bool,
            pub chat_id: i32,
        }
        impl crate::Identifiable for DiscardEncryption {
            const CONSTRUCTOR_ID: u32 = 4086541984;
        }
        impl crate::Serializable for DiscardEncryption {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.delete_history { 1 } else { 0 }).serialize(buf);
                self.chat_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DiscardEncryption {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditChatAbout {
            pub peer: crate::enums::InputPeer,
            pub about: String,
        }
        impl crate::Identifiable for EditChatAbout {
            const CONSTRUCTOR_ID: u32 = 3740665751;
        }
        impl crate::Serializable for EditChatAbout {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.about.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditChatAbout {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditChatAdmin {
            pub chat_id: i64,
            pub user_id: crate::enums::InputUser,
            pub is_admin: bool,
        }
        impl crate::Identifiable for EditChatAdmin {
            const CONSTRUCTOR_ID: u32 = 2824589762;
        }
        impl crate::Serializable for EditChatAdmin {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
                self.user_id.serialize(buf);
                self.is_admin.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditChatAdmin {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditChatDefaultBannedRights {
            pub peer: crate::enums::InputPeer,
            pub banned_rights: crate::enums::ChatBannedRights,
        }
        impl crate::Identifiable for EditChatDefaultBannedRights {
            const CONSTRUCTOR_ID: u32 = 2777049921;
        }
        impl crate::Serializable for EditChatDefaultBannedRights {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.banned_rights.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditChatDefaultBannedRights {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditChatPhoto {
            pub chat_id: i64,
            pub photo: crate::enums::InputChatPhoto,
        }
        impl crate::Identifiable for EditChatPhoto {
            const CONSTRUCTOR_ID: u32 = 903730804;
        }
        impl crate::Serializable for EditChatPhoto {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
                self.photo.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditChatPhoto {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditChatTitle {
            pub chat_id: i64,
            pub title: String,
        }
        impl crate::Identifiable for EditChatTitle {
            const CONSTRUCTOR_ID: u32 = 1937260541;
        }
        impl crate::Serializable for EditChatTitle {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
                self.title.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditChatTitle {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditExportedChatInvite {
            pub revoked: bool,
            pub peer: crate::enums::InputPeer,
            pub link: String,
            pub expire_date: Option<i32>,
            pub usage_limit: Option<i32>,
            pub request_needed: Option<bool>,
            pub title: Option<String>,
        }
        impl crate::Identifiable for EditExportedChatInvite {
            const CONSTRUCTOR_ID: u32 = 3184144245;
        }
        impl crate::Serializable for EditExportedChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.revoked { 4 } else { 0 }
                    | if self.expire_date.is_some() { 1 } else { 0 }
                    | if self.usage_limit.is_some() { 2 } else { 0 }
                    | if self.request_needed.is_some() { 8 } else { 0 }
                    | if self.title.is_some() { 16 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.link.serialize(buf);
                if let Some(ref x) = self.expire_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.usage_limit {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.request_needed {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for EditExportedChatInvite {
            type Return = crate::enums::messages::ExportedChatInvite;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditInlineBotMessage {
            pub no_webpage: bool,
            pub id: crate::enums::InputBotInlineMessageId,
            pub message: Option<String>,
            pub media: Option<crate::enums::InputMedia>,
            pub reply_markup: Option<crate::enums::ReplyMarkup>,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
        }
        impl crate::Identifiable for EditInlineBotMessage {
            const CONSTRUCTOR_ID: u32 = 2203418042;
        }
        impl crate::Serializable for EditInlineBotMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.no_webpage { 2 } else { 0 }
                    | if self.message.is_some() { 2048 } else { 0 }
                    | if self.media.is_some() { 16384 } else { 0 }
                    | if self.reply_markup.is_some() { 4 } else { 0 }
                    | if self.entities.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.id.serialize(buf);
                if let Some(ref x) = self.message {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.media {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.reply_markup {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for EditInlineBotMessage {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditMessage {
            pub no_webpage: bool,
            pub peer: crate::enums::InputPeer,
            pub id: i32,
            pub message: Option<String>,
            pub media: Option<crate::enums::InputMedia>,
            pub reply_markup: Option<crate::enums::ReplyMarkup>,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
            pub schedule_date: Option<i32>,
        }
        impl crate::Identifiable for EditMessage {
            const CONSTRUCTOR_ID: u32 = 1224152952;
        }
        impl crate::Serializable for EditMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.no_webpage { 2 } else { 0 }
                    | if self.message.is_some() { 2048 } else { 0 }
                    | if self.media.is_some() { 16384 } else { 0 }
                    | if self.reply_markup.is_some() { 4 } else { 0 }
                    | if self.entities.is_some() { 8 } else { 0 }
                    | if self.schedule_date.is_some() {
                        32768
                    } else {
                        0
                    })
                .serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                if let Some(ref x) = self.message {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.media {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.reply_markup {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for EditMessage {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportChatInvite {
            pub legacy_revoke_permanent: bool,
            pub request_needed: bool,
            pub peer: crate::enums::InputPeer,
            pub expire_date: Option<i32>,
            pub usage_limit: Option<i32>,
            pub title: Option<String>,
        }
        impl crate::Identifiable for ExportChatInvite {
            const CONSTRUCTOR_ID: u32 = 2687296981;
        }
        impl crate::Serializable for ExportChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.legacy_revoke_permanent { 4 } else { 0 }
                    | if self.request_needed { 8 } else { 0 }
                    | if self.expire_date.is_some() { 1 } else { 0 }
                    | if self.usage_limit.is_some() { 2 } else { 0 }
                    | if self.title.is_some() { 16 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.expire_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.usage_limit {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for ExportChatInvite {
            type Return = crate::enums::ExportedChatInvite;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct FaveSticker {
            pub id: crate::enums::InputDocument,
            pub unfave: bool,
        }
        impl crate::Identifiable for FaveSticker {
            const CONSTRUCTOR_ID: u32 = 3120547163;
        }
        impl crate::Serializable for FaveSticker {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
                self.unfave.serialize(buf);
            }
        }
        impl crate::RemoteCall for FaveSticker {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ForwardMessages {
            pub silent: bool,
            pub background: bool,
            pub with_my_score: bool,
            pub drop_author: bool,
            pub drop_media_captions: bool,
            pub from_peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
            pub random_id: Vec<i64>,
            pub to_peer: crate::enums::InputPeer,
            pub schedule_date: Option<i32>,
            pub send_as: Option<crate::enums::InputPeer>,
        }
        impl crate::Identifiable for ForwardMessages {
            const CONSTRUCTOR_ID: u32 = 3425708299;
        }
        impl crate::Serializable for ForwardMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.silent { 32 } else { 0 }
                    | if self.background { 64 } else { 0 }
                    | if self.with_my_score { 256 } else { 0 }
                    | if self.drop_author { 2048 } else { 0 }
                    | if self.drop_media_captions { 4096 } else { 0 }
                    | if self.schedule_date.is_some() {
                        1024
                    } else {
                        0
                    }
                    | if self.send_as.is_some() { 8192 } else { 0 })
                .serialize(buf);
                self.from_peer.serialize(buf);
                self.id.serialize(buf);
                self.random_id.serialize(buf);
                self.to_peer.serialize(buf);
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.send_as {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for ForwardMessages {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAdminsWithInvites {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetAdminsWithInvites {
            const CONSTRUCTOR_ID: u32 = 958457583;
        }
        impl crate::Serializable for GetAdminsWithInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAdminsWithInvites {
            type Return = crate::enums::messages::ChatAdminsWithInvites;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAllChats {
            pub except_ids: Vec<i64>,
        }
        impl crate::Identifiable for GetAllChats {
            const CONSTRUCTOR_ID: u32 = 2271179966;
        }
        impl crate::Serializable for GetAllChats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.except_ids.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAllChats {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAllDrafts {}
        impl crate::Identifiable for GetAllDrafts {
            const CONSTRUCTOR_ID: u32 = 1782549861;
        }
        impl crate::Serializable for GetAllDrafts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAllDrafts {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAllStickers {
            pub hash: i64,
        }
        impl crate::Identifiable for GetAllStickers {
            const CONSTRUCTOR_ID: u32 = 3097534888;
        }
        impl crate::Serializable for GetAllStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAllStickers {
            type Return = crate::enums::messages::AllStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetArchivedStickers {
            pub masks: bool,
            pub offset_id: i64,
            pub limit: i32,
        }
        impl crate::Identifiable for GetArchivedStickers {
            const CONSTRUCTOR_ID: u32 = 1475442322;
        }
        impl crate::Serializable for GetArchivedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.masks { 1 } else { 0 }).serialize(buf);
                self.offset_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetArchivedStickers {
            type Return = crate::enums::messages::ArchivedStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetAttachedStickers {
            pub media: crate::enums::InputStickeredMedia,
        }
        impl crate::Identifiable for GetAttachedStickers {
            const CONSTRUCTOR_ID: u32 = 3428542412;
        }
        impl crate::Serializable for GetAttachedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.media.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetAttachedStickers {
            type Return = Vec<crate::enums::StickerSetCovered>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetBotCallbackAnswer {
            pub game: bool,
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub data: Option<Vec<u8>>,
            pub password: Option<crate::enums::InputCheckPasswordSrp>,
        }
        impl crate::Identifiable for GetBotCallbackAnswer {
            const CONSTRUCTOR_ID: u32 = 2470627847;
        }
        impl crate::Serializable for GetBotCallbackAnswer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.game { 2 } else { 0 }
                    | if self.data.is_some() { 1 } else { 0 }
                    | if self.password.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                if let Some(ref x) = self.data {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.password {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for GetBotCallbackAnswer {
            type Return = crate::enums::messages::BotCallbackAnswer;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetChatInviteImporters {
            pub requested: bool,
            pub peer: crate::enums::InputPeer,
            pub link: Option<String>,
            pub q: Option<String>,
            pub offset_date: i32,
            pub offset_user: crate::enums::InputUser,
            pub limit: i32,
        }
        impl crate::Identifiable for GetChatInviteImporters {
            const CONSTRUCTOR_ID: u32 = 3741637966;
        }
        impl crate::Serializable for GetChatInviteImporters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.requested { 1 } else { 0 }
                    | if self.link.is_some() { 2 } else { 0 }
                    | if self.q.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.link {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.q {
                    x.serialize(buf);
                }
                self.offset_date.serialize(buf);
                self.offset_user.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetChatInviteImporters {
            type Return = crate::enums::messages::ChatInviteImporters;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetChats {
            pub id: Vec<i64>,
        }
        impl crate::Identifiable for GetChats {
            const CONSTRUCTOR_ID: u32 = 1240027791;
        }
        impl crate::Serializable for GetChats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetChats {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCommonChats {
            pub user_id: crate::enums::InputUser,
            pub max_id: i64,
            pub limit: i32,
        }
        impl crate::Identifiable for GetCommonChats {
            const CONSTRUCTOR_ID: u32 = 3826032900;
        }
        impl crate::Serializable for GetCommonChats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.user_id.serialize(buf);
                self.max_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCommonChats {
            type Return = crate::enums::messages::Chats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDhConfig {
            pub version: i32,
            pub random_length: i32,
        }
        impl crate::Identifiable for GetDhConfig {
            const CONSTRUCTOR_ID: u32 = 651135312;
        }
        impl crate::Serializable for GetDhConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.version.serialize(buf);
                self.random_length.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDhConfig {
            type Return = crate::enums::messages::DhConfig;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDialogFilters {}
        impl crate::Identifiable for GetDialogFilters {
            const CONSTRUCTOR_ID: u32 = 4053719405;
        }
        impl crate::Serializable for GetDialogFilters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDialogFilters {
            type Return = Vec<crate::enums::DialogFilter>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDialogUnreadMarks {}
        impl crate::Identifiable for GetDialogUnreadMarks {
            const CONSTRUCTOR_ID: u32 = 585256482;
        }
        impl crate::Serializable for GetDialogUnreadMarks {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDialogUnreadMarks {
            type Return = Vec<crate::enums::DialogPeer>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDialogs {
            pub exclude_pinned: bool,
            pub folder_id: Option<i32>,
            pub offset_date: i32,
            pub offset_id: i32,
            pub offset_peer: crate::enums::InputPeer,
            pub limit: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetDialogs {
            const CONSTRUCTOR_ID: u32 = 2700397391;
        }
        impl crate::Serializable for GetDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.exclude_pinned { 1 } else { 0 }
                    | if self.folder_id.is_some() { 2 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.folder_id {
                    x.serialize(buf);
                }
                self.offset_date.serialize(buf);
                self.offset_id.serialize(buf);
                self.offset_peer.serialize(buf);
                self.limit.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDialogs {
            type Return = crate::enums::messages::Dialogs;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDiscussionMessage {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
        }
        impl crate::Identifiable for GetDiscussionMessage {
            const CONSTRUCTOR_ID: u32 = 1147761405;
        }
        impl crate::Serializable for GetDiscussionMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDiscussionMessage {
            type Return = crate::enums::messages::DiscussionMessage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDocumentByHash {
            pub sha256: Vec<u8>,
            pub size: i32,
            pub mime_type: String,
        }
        impl crate::Identifiable for GetDocumentByHash {
            const CONSTRUCTOR_ID: u32 = 864953444;
        }
        impl crate::Serializable for GetDocumentByHash {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.sha256.serialize(buf);
                self.size.serialize(buf);
                self.mime_type.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDocumentByHash {
            type Return = crate::enums::Document;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetEmojiKeywords {
            pub lang_code: String,
        }
        impl crate::Identifiable for GetEmojiKeywords {
            const CONSTRUCTOR_ID: u32 = 899735650;
        }
        impl crate::Serializable for GetEmojiKeywords {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetEmojiKeywords {
            type Return = crate::enums::EmojiKeywordsDifference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetEmojiKeywordsDifference {
            pub lang_code: String,
            pub from_version: i32,
        }
        impl crate::Identifiable for GetEmojiKeywordsDifference {
            const CONSTRUCTOR_ID: u32 = 352892591;
        }
        impl crate::Serializable for GetEmojiKeywordsDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_code.serialize(buf);
                self.from_version.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetEmojiKeywordsDifference {
            type Return = crate::enums::EmojiKeywordsDifference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetEmojiKeywordsLanguages {
            pub lang_codes: Vec<String>,
        }
        impl crate::Identifiable for GetEmojiKeywordsLanguages {
            const CONSTRUCTOR_ID: u32 = 1318675378;
        }
        impl crate::Serializable for GetEmojiKeywordsLanguages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_codes.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetEmojiKeywordsLanguages {
            type Return = Vec<crate::enums::EmojiLanguage>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetEmojiUrl {
            pub lang_code: String,
        }
        impl crate::Identifiable for GetEmojiUrl {
            const CONSTRUCTOR_ID: u32 = 3585149990;
        }
        impl crate::Serializable for GetEmojiUrl {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.lang_code.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetEmojiUrl {
            type Return = crate::enums::EmojiUrl;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetExportedChatInvite {
            pub peer: crate::enums::InputPeer,
            pub link: String,
        }
        impl crate::Identifiable for GetExportedChatInvite {
            const CONSTRUCTOR_ID: u32 = 1937010524;
        }
        impl crate::Serializable for GetExportedChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.link.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetExportedChatInvite {
            type Return = crate::enums::messages::ExportedChatInvite;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetExportedChatInvites {
            pub revoked: bool,
            pub peer: crate::enums::InputPeer,
            pub admin_id: crate::enums::InputUser,
            pub offset_date: Option<i32>,
            pub offset_link: Option<String>,
            pub limit: i32,
        }
        impl crate::Identifiable for GetExportedChatInvites {
            const CONSTRUCTOR_ID: u32 = 2729812982;
        }
        impl crate::Serializable for GetExportedChatInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.revoked { 8 } else { 0 }
                    | if self.offset_date.is_some() { 4 } else { 0 }
                    | if self.offset_link.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.admin_id.serialize(buf);
                if let Some(ref x) = self.offset_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.offset_link {
                    x.serialize(buf);
                }
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetExportedChatInvites {
            type Return = crate::enums::messages::ExportedChatInvites;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFavedStickers {
            pub hash: i64,
        }
        impl crate::Identifiable for GetFavedStickers {
            const CONSTRUCTOR_ID: u32 = 82946729;
        }
        impl crate::Serializable for GetFavedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFavedStickers {
            type Return = crate::enums::messages::FavedStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFeaturedStickers {
            pub hash: i64,
        }
        impl crate::Identifiable for GetFeaturedStickers {
            const CONSTRUCTOR_ID: u32 = 1685588756;
        }
        impl crate::Serializable for GetFeaturedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFeaturedStickers {
            type Return = crate::enums::messages::FeaturedStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFullChat {
            pub chat_id: i64,
        }
        impl crate::Identifiable for GetFullChat {
            const CONSTRUCTOR_ID: u32 = 2930772788;
        }
        impl crate::Serializable for GetFullChat {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFullChat {
            type Return = crate::enums::messages::ChatFull;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGameHighScores {
            pub peer: crate::enums::InputPeer,
            pub id: i32,
            pub user_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for GetGameHighScores {
            const CONSTRUCTOR_ID: u32 = 3894568093;
        }
        impl crate::Serializable for GetGameHighScores {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                self.user_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGameHighScores {
            type Return = crate::enums::messages::HighScores;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetHistory {
            pub peer: crate::enums::InputPeer,
            pub offset_id: i32,
            pub offset_date: i32,
            pub add_offset: i32,
            pub limit: i32,
            pub max_id: i32,
            pub min_id: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetHistory {
            const CONSTRUCTOR_ID: u32 = 1143203525;
        }
        impl crate::Serializable for GetHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.offset_id.serialize(buf);
                self.offset_date.serialize(buf);
                self.add_offset.serialize(buf);
                self.limit.serialize(buf);
                self.max_id.serialize(buf);
                self.min_id.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetHistory {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetInlineBotResults {
            pub bot: crate::enums::InputUser,
            pub peer: crate::enums::InputPeer,
            pub geo_point: Option<crate::enums::InputGeoPoint>,
            pub query: String,
            pub offset: String,
        }
        impl crate::Identifiable for GetInlineBotResults {
            const CONSTRUCTOR_ID: u32 = 1364105629;
        }
        impl crate::Serializable for GetInlineBotResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.geo_point.is_some() { 1 } else { 0 }).serialize(buf);
                self.bot.serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.geo_point {
                    x.serialize(buf);
                }
                self.query.serialize(buf);
                self.offset.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetInlineBotResults {
            type Return = crate::enums::messages::BotResults;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetInlineGameHighScores {
            pub id: crate::enums::InputBotInlineMessageId,
            pub user_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for GetInlineGameHighScores {
            const CONSTRUCTOR_ID: u32 = 258170395;
        }
        impl crate::Serializable for GetInlineGameHighScores {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
                self.user_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetInlineGameHighScores {
            type Return = crate::enums::messages::HighScores;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMaskStickers {
            pub hash: i64,
        }
        impl crate::Identifiable for GetMaskStickers {
            const CONSTRUCTOR_ID: u32 = 1678738104;
        }
        impl crate::Serializable for GetMaskStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMaskStickers {
            type Return = crate::enums::messages::AllStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessageEditData {
            pub peer: crate::enums::InputPeer,
            pub id: i32,
        }
        impl crate::Identifiable for GetMessageEditData {
            const CONSTRUCTOR_ID: u32 = 4255550774;
        }
        impl crate::Serializable for GetMessageEditData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessageEditData {
            type Return = crate::enums::messages::MessageEditData;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessageReadParticipants {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
        }
        impl crate::Identifiable for GetMessageReadParticipants {
            const CONSTRUCTOR_ID: u32 = 745510839;
        }
        impl crate::Serializable for GetMessageReadParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessageReadParticipants {
            type Return = Vec<i64>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessages {
            pub id: Vec<crate::enums::InputMessage>,
        }
        impl crate::Identifiable for GetMessages {
            const CONSTRUCTOR_ID: u32 = 1673946374;
        }
        impl crate::Serializable for GetMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessages {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessagesViews {
            pub peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
            pub increment: bool,
        }
        impl crate::Identifiable for GetMessagesViews {
            const CONSTRUCTOR_ID: u32 = 1468322785;
        }
        impl crate::Serializable for GetMessagesViews {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                self.increment.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessagesViews {
            type Return = crate::enums::messages::MessageViews;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetOldFeaturedStickers {
            pub offset: i32,
            pub limit: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetOldFeaturedStickers {
            const CONSTRUCTOR_ID: u32 = 2127598753;
        }
        impl crate::Serializable for GetOldFeaturedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetOldFeaturedStickers {
            type Return = crate::enums::messages::FeaturedStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetOnlines {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetOnlines {
            const CONSTRUCTOR_ID: u32 = 1848369232;
        }
        impl crate::Serializable for GetOnlines {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetOnlines {
            type Return = crate::enums::ChatOnlines;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPeerDialogs {
            pub peers: Vec<crate::enums::InputDialogPeer>,
        }
        impl crate::Identifiable for GetPeerDialogs {
            const CONSTRUCTOR_ID: u32 = 3832593661;
        }
        impl crate::Serializable for GetPeerDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peers.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPeerDialogs {
            type Return = crate::enums::messages::PeerDialogs;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPeerSettings {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetPeerSettings {
            const CONSTRUCTOR_ID: u32 = 4024018594;
        }
        impl crate::Serializable for GetPeerSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPeerSettings {
            type Return = crate::enums::messages::PeerSettings;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPinnedDialogs {
            pub folder_id: i32,
        }
        impl crate::Identifiable for GetPinnedDialogs {
            const CONSTRUCTOR_ID: u32 = 3602468338;
        }
        impl crate::Serializable for GetPinnedDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.folder_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPinnedDialogs {
            type Return = crate::enums::messages::PeerDialogs;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPollResults {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
        }
        impl crate::Identifiable for GetPollResults {
            const CONSTRUCTOR_ID: u32 = 1941660731;
        }
        impl crate::Serializable for GetPollResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPollResults {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPollVotes {
            pub peer: crate::enums::InputPeer,
            pub id: i32,
            pub option: Option<Vec<u8>>,
            pub offset: Option<String>,
            pub limit: i32,
        }
        impl crate::Identifiable for GetPollVotes {
            const CONSTRUCTOR_ID: u32 = 3094231054;
        }
        impl crate::Serializable for GetPollVotes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.option.is_some() { 1 } else { 0 }
                    | if self.offset.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                if let Some(ref x) = self.option {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.offset {
                    x.serialize(buf);
                }
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPollVotes {
            type Return = crate::enums::messages::VotesList;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetRecentLocations {
            pub peer: crate::enums::InputPeer,
            pub limit: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetRecentLocations {
            const CONSTRUCTOR_ID: u32 = 1881817312;
        }
        impl crate::Serializable for GetRecentLocations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.limit.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetRecentLocations {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetRecentStickers {
            pub attached: bool,
            pub hash: i64,
        }
        impl crate::Identifiable for GetRecentStickers {
            const CONSTRUCTOR_ID: u32 = 2645114939;
        }
        impl crate::Serializable for GetRecentStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.attached { 1 } else { 0 }).serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetRecentStickers {
            type Return = crate::enums::messages::RecentStickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetReplies {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub offset_id: i32,
            pub offset_date: i32,
            pub add_offset: i32,
            pub limit: i32,
            pub max_id: i32,
            pub min_id: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for GetReplies {
            const CONSTRUCTOR_ID: u32 = 584962828;
        }
        impl crate::Serializable for GetReplies {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                self.offset_id.serialize(buf);
                self.offset_date.serialize(buf);
                self.add_offset.serialize(buf);
                self.limit.serialize(buf);
                self.max_id.serialize(buf);
                self.min_id.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetReplies {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSavedGifs {
            pub hash: i64,
        }
        impl crate::Identifiable for GetSavedGifs {
            const CONSTRUCTOR_ID: u32 = 1559270965;
        }
        impl crate::Serializable for GetSavedGifs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSavedGifs {
            type Return = crate::enums::messages::SavedGifs;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetScheduledHistory {
            pub peer: crate::enums::InputPeer,
            pub hash: i64,
        }
        impl crate::Identifiable for GetScheduledHistory {
            const CONSTRUCTOR_ID: u32 = 4111889931;
        }
        impl crate::Serializable for GetScheduledHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetScheduledHistory {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetScheduledMessages {
            pub peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for GetScheduledMessages {
            const CONSTRUCTOR_ID: u32 = 3183150180;
        }
        impl crate::Serializable for GetScheduledMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetScheduledMessages {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSearchCounters {
            pub peer: crate::enums::InputPeer,
            pub filters: Vec<crate::enums::MessagesFilter>,
        }
        impl crate::Identifiable for GetSearchCounters {
            const CONSTRUCTOR_ID: u32 = 1932455680;
        }
        impl crate::Serializable for GetSearchCounters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.filters.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSearchCounters {
            type Return = Vec<crate::enums::messages::SearchCounter>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSearchResultsCalendar {
            pub peer: crate::enums::InputPeer,
            pub filter: crate::enums::MessagesFilter,
            pub offset_id: i32,
            pub offset_date: i32,
        }
        impl crate::Identifiable for GetSearchResultsCalendar {
            const CONSTRUCTOR_ID: u32 = 1240514025;
        }
        impl crate::Serializable for GetSearchResultsCalendar {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.filter.serialize(buf);
                self.offset_id.serialize(buf);
                self.offset_date.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSearchResultsCalendar {
            type Return = crate::enums::messages::SearchResultsCalendar;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSearchResultsPositions {
            pub peer: crate::enums::InputPeer,
            pub filter: crate::enums::MessagesFilter,
            pub offset_id: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetSearchResultsPositions {
            const CONSTRUCTOR_ID: u32 = 1855292323;
        }
        impl crate::Serializable for GetSearchResultsPositions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.filter.serialize(buf);
                self.offset_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSearchResultsPositions {
            type Return = crate::enums::messages::SearchResultsPositions;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSplitRanges {}
        impl crate::Identifiable for GetSplitRanges {
            const CONSTRUCTOR_ID: u32 = 486505992;
        }
        impl crate::Serializable for GetSplitRanges {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSplitRanges {
            type Return = Vec<crate::enums::MessageRange>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetStickerSet {
            pub stickerset: crate::enums::InputStickerSet,
            pub hash: i32,
        }
        impl crate::Identifiable for GetStickerSet {
            const CONSTRUCTOR_ID: u32 = 3365989492;
        }
        impl crate::Serializable for GetStickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.stickerset.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetStickerSet {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetStickers {
            pub emoticon: String,
            pub hash: i64,
        }
        impl crate::Identifiable for GetStickers {
            const CONSTRUCTOR_ID: u32 = 3584414625;
        }
        impl crate::Serializable for GetStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.emoticon.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetStickers {
            type Return = crate::enums::messages::Stickers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSuggestedDialogFilters {}
        impl crate::Identifiable for GetSuggestedDialogFilters {
            const CONSTRUCTOR_ID: u32 = 2728186924;
        }
        impl crate::Serializable for GetSuggestedDialogFilters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSuggestedDialogFilters {
            type Return = Vec<crate::enums::DialogFilterSuggested>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetUnreadMentions {
            pub peer: crate::enums::InputPeer,
            pub offset_id: i32,
            pub add_offset: i32,
            pub limit: i32,
            pub max_id: i32,
            pub min_id: i32,
        }
        impl crate::Identifiable for GetUnreadMentions {
            const CONSTRUCTOR_ID: u32 = 1180140658;
        }
        impl crate::Serializable for GetUnreadMentions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.offset_id.serialize(buf);
                self.add_offset.serialize(buf);
                self.limit.serialize(buf);
                self.max_id.serialize(buf);
                self.min_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetUnreadMentions {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWebPage {
            pub url: String,
            pub hash: i32,
        }
        impl crate::Identifiable for GetWebPage {
            const CONSTRUCTOR_ID: u32 = 852135825;
        }
        impl crate::Serializable for GetWebPage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.url.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetWebPage {
            type Return = crate::enums::WebPage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWebPagePreview {
            pub message: String,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
        }
        impl crate::Identifiable for GetWebPagePreview {
            const CONSTRUCTOR_ID: u32 = 2338894028;
        }
        impl crate::Serializable for GetWebPagePreview {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.entities.is_some() { 8 } else { 0 }).serialize(buf);
                self.message.serialize(buf);
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for GetWebPagePreview {
            type Return = crate::enums::MessageMedia;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HideAllChatJoinRequests {
            pub approved: bool,
            pub peer: crate::enums::InputPeer,
            pub link: Option<String>,
        }
        impl crate::Identifiable for HideAllChatJoinRequests {
            const CONSTRUCTOR_ID: u32 = 3766875370;
        }
        impl crate::Serializable for HideAllChatJoinRequests {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.approved { 1 } else { 0 }
                    | if self.link.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.link {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for HideAllChatJoinRequests {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HideChatJoinRequest {
            pub approved: bool,
            pub peer: crate::enums::InputPeer,
            pub user_id: crate::enums::InputUser,
        }
        impl crate::Identifiable for HideChatJoinRequest {
            const CONSTRUCTOR_ID: u32 = 2145904661;
        }
        impl crate::Serializable for HideChatJoinRequest {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.approved { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.user_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for HideChatJoinRequest {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct HidePeerSettingsBar {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for HidePeerSettingsBar {
            const CONSTRUCTOR_ID: u32 = 1336717624;
        }
        impl crate::Serializable for HidePeerSettingsBar {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for HidePeerSettingsBar {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ImportChatInvite {
            pub hash: String,
        }
        impl crate::Identifiable for ImportChatInvite {
            const CONSTRUCTOR_ID: u32 = 1817183516;
        }
        impl crate::Serializable for ImportChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for ImportChatInvite {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InitHistoryImport {
            pub peer: crate::enums::InputPeer,
            pub file: crate::enums::InputFile,
            pub media_count: i32,
        }
        impl crate::Identifiable for InitHistoryImport {
            const CONSTRUCTOR_ID: u32 = 873008187;
        }
        impl crate::Serializable for InitHistoryImport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.file.serialize(buf);
                self.media_count.serialize(buf);
            }
        }
        impl crate::RemoteCall for InitHistoryImport {
            type Return = crate::enums::messages::HistoryImport;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InstallStickerSet {
            pub stickerset: crate::enums::InputStickerSet,
            pub archived: bool,
        }
        impl crate::Identifiable for InstallStickerSet {
            const CONSTRUCTOR_ID: u32 = 3348096096;
        }
        impl crate::Serializable for InstallStickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.stickerset.serialize(buf);
                self.archived.serialize(buf);
            }
        }
        impl crate::RemoteCall for InstallStickerSet {
            type Return = crate::enums::messages::StickerSetInstallResult;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MarkDialogUnread {
            pub unread: bool,
            pub peer: crate::enums::InputDialogPeer,
        }
        impl crate::Identifiable for MarkDialogUnread {
            const CONSTRUCTOR_ID: u32 = 3263617423;
        }
        impl crate::Serializable for MarkDialogUnread {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.unread { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for MarkDialogUnread {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct MigrateChat {
            pub chat_id: i64,
        }
        impl crate::Identifiable for MigrateChat {
            const CONSTRUCTOR_ID: u32 = 2726777625;
        }
        impl crate::Serializable for MigrateChat {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.chat_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for MigrateChat {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadDiscussion {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub read_max_id: i32,
        }
        impl crate::Identifiable for ReadDiscussion {
            const CONSTRUCTOR_ID: u32 = 4147227124;
        }
        impl crate::Serializable for ReadDiscussion {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                self.read_max_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadDiscussion {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadEncryptedHistory {
            pub peer: crate::enums::InputEncryptedChat,
            pub max_date: i32,
        }
        impl crate::Identifiable for ReadEncryptedHistory {
            const CONSTRUCTOR_ID: u32 = 2135648522;
        }
        impl crate::Serializable for ReadEncryptedHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.max_date.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadEncryptedHistory {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadFeaturedStickers {
            pub id: Vec<i64>,
        }
        impl crate::Identifiable for ReadFeaturedStickers {
            const CONSTRUCTOR_ID: u32 = 1527873830;
        }
        impl crate::Serializable for ReadFeaturedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadFeaturedStickers {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadHistory {
            pub peer: crate::enums::InputPeer,
            pub max_id: i32,
        }
        impl crate::Identifiable for ReadHistory {
            const CONSTRUCTOR_ID: u32 = 238054714;
        }
        impl crate::Serializable for ReadHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.max_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadHistory {
            type Return = crate::enums::messages::AffectedMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadMentions {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for ReadMentions {
            const CONSTRUCTOR_ID: u32 = 251759059;
        }
        impl crate::Serializable for ReadMentions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadMentions {
            type Return = crate::enums::messages::AffectedHistory;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadMessageContents {
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for ReadMessageContents {
            const CONSTRUCTOR_ID: u32 = 916930423;
        }
        impl crate::Serializable for ReadMessageContents {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReadMessageContents {
            type Return = crate::enums::messages::AffectedMessages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReceivedMessages {
            pub max_id: i32,
        }
        impl crate::Identifiable for ReceivedMessages {
            const CONSTRUCTOR_ID: u32 = 94983360;
        }
        impl crate::Serializable for ReceivedMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.max_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReceivedMessages {
            type Return = Vec<crate::enums::ReceivedNotifyMessage>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReceivedQueue {
            pub max_qts: i32,
        }
        impl crate::Identifiable for ReceivedQueue {
            const CONSTRUCTOR_ID: u32 = 1436924774;
        }
        impl crate::Serializable for ReceivedQueue {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.max_qts.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReceivedQueue {
            type Return = Vec<i64>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReorderPinnedDialogs {
            pub force: bool,
            pub folder_id: i32,
            pub order: Vec<crate::enums::InputDialogPeer>,
        }
        impl crate::Identifiable for ReorderPinnedDialogs {
            const CONSTRUCTOR_ID: u32 = 991616823;
        }
        impl crate::Serializable for ReorderPinnedDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.force { 1 } else { 0 }).serialize(buf);
                self.folder_id.serialize(buf);
                self.order.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReorderPinnedDialogs {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReorderStickerSets {
            pub masks: bool,
            pub order: Vec<i64>,
        }
        impl crate::Identifiable for ReorderStickerSets {
            const CONSTRUCTOR_ID: u32 = 2016638777;
        }
        impl crate::Serializable for ReorderStickerSets {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.masks { 1 } else { 0 }).serialize(buf);
                self.order.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReorderStickerSets {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Report {
            pub peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
            pub reason: crate::enums::ReportReason,
            pub message: String,
        }
        impl crate::Identifiable for Report {
            const CONSTRUCTOR_ID: u32 = 2303961934;
        }
        impl crate::Serializable for Report {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                self.reason.serialize(buf);
                self.message.serialize(buf);
            }
        }
        impl crate::RemoteCall for Report {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReportEncryptedSpam {
            pub peer: crate::enums::InputEncryptedChat,
        }
        impl crate::Identifiable for ReportEncryptedSpam {
            const CONSTRUCTOR_ID: u32 = 1259113487;
        }
        impl crate::Serializable for ReportEncryptedSpam {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReportEncryptedSpam {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReportSpam {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for ReportSpam {
            const CONSTRUCTOR_ID: u32 = 3474297563;
        }
        impl crate::Serializable for ReportSpam {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReportSpam {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RequestEncryption {
            pub user_id: crate::enums::InputUser,
            pub random_id: i32,
            pub g_a: Vec<u8>,
        }
        impl crate::Identifiable for RequestEncryption {
            const CONSTRUCTOR_ID: u32 = 4132286275;
        }
        impl crate::Serializable for RequestEncryption {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.user_id.serialize(buf);
                self.random_id.serialize(buf);
                self.g_a.serialize(buf);
            }
        }
        impl crate::RemoteCall for RequestEncryption {
            type Return = crate::enums::EncryptedChat;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RequestUrlAuth {
            pub peer: Option<crate::enums::InputPeer>,
            pub msg_id: Option<i32>,
            pub button_id: Option<i32>,
            pub url: Option<String>,
        }
        impl crate::Identifiable for RequestUrlAuth {
            const CONSTRUCTOR_ID: u32 = 428848198;
        }
        impl crate::Serializable for RequestUrlAuth {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.peer.is_some() { 2 } else { 0 }
                    | if self.msg_id.is_some() { 2 } else { 0 }
                    | if self.button_id.is_some() { 2 } else { 0 }
                    | if self.url.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.peer {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.msg_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.button_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.url {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for RequestUrlAuth {
            type Return = crate::enums::UrlAuthResult;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveDefaultSendAs {
            pub peer: crate::enums::InputPeer,
            pub send_as: crate::enums::InputPeer,
        }
        impl crate::Identifiable for SaveDefaultSendAs {
            const CONSTRUCTOR_ID: u32 = 3439189910;
        }
        impl crate::Serializable for SaveDefaultSendAs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.send_as.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveDefaultSendAs {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveDraft {
            pub no_webpage: bool,
            pub reply_to_msg_id: Option<i32>,
            pub peer: crate::enums::InputPeer,
            pub message: String,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
        }
        impl crate::Identifiable for SaveDraft {
            const CONSTRUCTOR_ID: u32 = 3157909835;
        }
        impl crate::Serializable for SaveDraft {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.no_webpage { 2 } else { 0 }
                    | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                    | if self.entities.is_some() { 8 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.reply_to_msg_id {
                    x.serialize(buf);
                }
                self.peer.serialize(buf);
                self.message.serialize(buf);
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SaveDraft {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveGif {
            pub id: crate::enums::InputDocument,
            pub unsave: bool,
        }
        impl crate::Identifiable for SaveGif {
            const CONSTRUCTOR_ID: u32 = 846868683;
        }
        impl crate::Serializable for SaveGif {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
                self.unsave.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveGif {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveRecentSticker {
            pub attached: bool,
            pub id: crate::enums::InputDocument,
            pub unsave: bool,
        }
        impl crate::Identifiable for SaveRecentSticker {
            const CONSTRUCTOR_ID: u32 = 958863608;
        }
        impl crate::Serializable for SaveRecentSticker {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.attached { 1 } else { 0 }).serialize(buf);
                self.id.serialize(buf);
                self.unsave.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveRecentSticker {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Search {
            pub peer: crate::enums::InputPeer,
            pub q: String,
            pub from_id: Option<crate::enums::InputPeer>,
            pub top_msg_id: Option<i32>,
            pub filter: crate::enums::MessagesFilter,
            pub min_date: i32,
            pub max_date: i32,
            pub offset_id: i32,
            pub add_offset: i32,
            pub limit: i32,
            pub max_id: i32,
            pub min_id: i32,
            pub hash: i64,
        }
        impl crate::Identifiable for Search {
            const CONSTRUCTOR_ID: u32 = 2700978018;
        }
        impl crate::Serializable for Search {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.from_id.is_some() { 1 } else { 0 }
                    | if self.top_msg_id.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.q.serialize(buf);
                if let Some(ref x) = self.from_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.top_msg_id {
                    x.serialize(buf);
                }
                self.filter.serialize(buf);
                self.min_date.serialize(buf);
                self.max_date.serialize(buf);
                self.offset_id.serialize(buf);
                self.add_offset.serialize(buf);
                self.limit.serialize(buf);
                self.max_id.serialize(buf);
                self.min_id.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for Search {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SearchGlobal {
            pub folder_id: Option<i32>,
            pub q: String,
            pub filter: crate::enums::MessagesFilter,
            pub min_date: i32,
            pub max_date: i32,
            pub offset_rate: i32,
            pub offset_peer: crate::enums::InputPeer,
            pub offset_id: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for SearchGlobal {
            const CONSTRUCTOR_ID: u32 = 1271290010;
        }
        impl crate::Serializable for SearchGlobal {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.folder_id.is_some() { 1 } else { 0 }).serialize(buf);
                if let Some(ref x) = self.folder_id {
                    x.serialize(buf);
                }
                self.q.serialize(buf);
                self.filter.serialize(buf);
                self.min_date.serialize(buf);
                self.max_date.serialize(buf);
                self.offset_rate.serialize(buf);
                self.offset_peer.serialize(buf);
                self.offset_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for SearchGlobal {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SearchStickerSets {
            pub exclude_featured: bool,
            pub q: String,
            pub hash: i64,
        }
        impl crate::Identifiable for SearchStickerSets {
            const CONSTRUCTOR_ID: u32 = 896555914;
        }
        impl crate::Serializable for SearchStickerSets {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.exclude_featured { 1 } else { 0 }).serialize(buf);
                self.q.serialize(buf);
                self.hash.serialize(buf);
            }
        }
        impl crate::RemoteCall for SearchStickerSets {
            type Return = crate::enums::messages::FoundStickerSets;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendEncrypted {
            pub silent: bool,
            pub peer: crate::enums::InputEncryptedChat,
            pub random_id: i64,
            pub data: Vec<u8>,
        }
        impl crate::Identifiable for SendEncrypted {
            const CONSTRUCTOR_ID: u32 = 1157265941;
        }
        impl crate::Serializable for SendEncrypted {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.silent { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.random_id.serialize(buf);
                self.data.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendEncrypted {
            type Return = crate::enums::messages::SentEncryptedMessage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendEncryptedFile {
            pub silent: bool,
            pub peer: crate::enums::InputEncryptedChat,
            pub random_id: i64,
            pub data: Vec<u8>,
            pub file: crate::enums::InputEncryptedFile,
        }
        impl crate::Identifiable for SendEncryptedFile {
            const CONSTRUCTOR_ID: u32 = 1431914525;
        }
        impl crate::Serializable for SendEncryptedFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.silent { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.random_id.serialize(buf);
                self.data.serialize(buf);
                self.file.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendEncryptedFile {
            type Return = crate::enums::messages::SentEncryptedMessage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendEncryptedService {
            pub peer: crate::enums::InputEncryptedChat,
            pub random_id: i64,
            pub data: Vec<u8>,
        }
        impl crate::Identifiable for SendEncryptedService {
            const CONSTRUCTOR_ID: u32 = 852769188;
        }
        impl crate::Serializable for SendEncryptedService {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.random_id.serialize(buf);
                self.data.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendEncryptedService {
            type Return = crate::enums::messages::SentEncryptedMessage;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendInlineBotResult {
            pub silent: bool,
            pub background: bool,
            pub clear_draft: bool,
            pub hide_via: bool,
            pub peer: crate::enums::InputPeer,
            pub reply_to_msg_id: Option<i32>,
            pub random_id: i64,
            pub query_id: i64,
            pub id: String,
            pub schedule_date: Option<i32>,
            pub send_as: Option<crate::enums::InputPeer>,
        }
        impl crate::Identifiable for SendInlineBotResult {
            const CONSTRUCTOR_ID: u32 = 2057376407;
        }
        impl crate::Serializable for SendInlineBotResult {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.silent { 32 } else { 0 }
                    | if self.background { 64 } else { 0 }
                    | if self.clear_draft { 128 } else { 0 }
                    | if self.hide_via { 2048 } else { 0 }
                    | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                    | if self.schedule_date.is_some() {
                        1024
                    } else {
                        0
                    }
                    | if self.send_as.is_some() { 8192 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.reply_to_msg_id {
                    x.serialize(buf);
                }
                self.random_id.serialize(buf);
                self.query_id.serialize(buf);
                self.id.serialize(buf);
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.send_as {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SendInlineBotResult {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendMedia {
            pub silent: bool,
            pub background: bool,
            pub clear_draft: bool,
            pub peer: crate::enums::InputPeer,
            pub reply_to_msg_id: Option<i32>,
            pub media: crate::enums::InputMedia,
            pub message: String,
            pub random_id: i64,
            pub reply_markup: Option<crate::enums::ReplyMarkup>,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
            pub schedule_date: Option<i32>,
            pub send_as: Option<crate::enums::InputPeer>,
        }
        impl crate::Identifiable for SendMedia {
            const CONSTRUCTOR_ID: u32 = 3797940448;
        }
        impl crate::Serializable for SendMedia {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.silent { 32 } else { 0 }
                    | if self.background { 64 } else { 0 }
                    | if self.clear_draft { 128 } else { 0 }
                    | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                    | if self.reply_markup.is_some() { 4 } else { 0 }
                    | if self.entities.is_some() { 8 } else { 0 }
                    | if self.schedule_date.is_some() {
                        1024
                    } else {
                        0
                    }
                    | if self.send_as.is_some() { 8192 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.reply_to_msg_id {
                    x.serialize(buf);
                }
                self.media.serialize(buf);
                self.message.serialize(buf);
                self.random_id.serialize(buf);
                if let Some(ref x) = self.reply_markup {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.send_as {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SendMedia {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendMessage {
            pub no_webpage: bool,
            pub silent: bool,
            pub background: bool,
            pub clear_draft: bool,
            pub peer: crate::enums::InputPeer,
            pub reply_to_msg_id: Option<i32>,
            pub message: String,
            pub random_id: i64,
            pub reply_markup: Option<crate::enums::ReplyMarkup>,
            pub entities: Option<Vec<crate::enums::MessageEntity>>,
            pub schedule_date: Option<i32>,
            pub send_as: Option<crate::enums::InputPeer>,
        }
        impl crate::Identifiable for SendMessage {
            const CONSTRUCTOR_ID: u32 = 228423076;
        }
        impl crate::Serializable for SendMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.no_webpage { 2 } else { 0 }
                    | if self.silent { 32 } else { 0 }
                    | if self.background { 64 } else { 0 }
                    | if self.clear_draft { 128 } else { 0 }
                    | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                    | if self.reply_markup.is_some() { 4 } else { 0 }
                    | if self.entities.is_some() { 8 } else { 0 }
                    | if self.schedule_date.is_some() {
                        1024
                    } else {
                        0
                    }
                    | if self.send_as.is_some() { 8192 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.reply_to_msg_id {
                    x.serialize(buf);
                }
                self.message.serialize(buf);
                self.random_id.serialize(buf);
                if let Some(ref x) = self.reply_markup {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.entities {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.send_as {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SendMessage {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendMultiMedia {
            pub silent: bool,
            pub background: bool,
            pub clear_draft: bool,
            pub peer: crate::enums::InputPeer,
            pub reply_to_msg_id: Option<i32>,
            pub multi_media: Vec<crate::enums::InputSingleMedia>,
            pub schedule_date: Option<i32>,
            pub send_as: Option<crate::enums::InputPeer>,
        }
        impl crate::Identifiable for SendMultiMedia {
            const CONSTRUCTOR_ID: u32 = 4160951183;
        }
        impl crate::Serializable for SendMultiMedia {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.silent { 32 } else { 0 }
                    | if self.background { 64 } else { 0 }
                    | if self.clear_draft { 128 } else { 0 }
                    | if self.reply_to_msg_id.is_some() { 1 } else { 0 }
                    | if self.schedule_date.is_some() {
                        1024
                    } else {
                        0
                    }
                    | if self.send_as.is_some() { 8192 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.reply_to_msg_id {
                    x.serialize(buf);
                }
                self.multi_media.serialize(buf);
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.send_as {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SendMultiMedia {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendScheduledMessages {
            pub peer: crate::enums::InputPeer,
            pub id: Vec<i32>,
        }
        impl crate::Identifiable for SendScheduledMessages {
            const CONSTRUCTOR_ID: u32 = 3174597898;
        }
        impl crate::Serializable for SendScheduledMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendScheduledMessages {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendScreenshotNotification {
            pub peer: crate::enums::InputPeer,
            pub reply_to_msg_id: i32,
            pub random_id: i64,
        }
        impl crate::Identifiable for SendScreenshotNotification {
            const CONSTRUCTOR_ID: u32 = 3380473888;
        }
        impl crate::Serializable for SendScreenshotNotification {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.reply_to_msg_id.serialize(buf);
                self.random_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendScreenshotNotification {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendVote {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub options: Vec<Vec<u8>>,
        }
        impl crate::Identifiable for SendVote {
            const CONSTRUCTOR_ID: u32 = 283795844;
        }
        impl crate::Serializable for SendVote {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                self.options.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendVote {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetBotCallbackAnswer {
            pub alert: bool,
            pub query_id: i64,
            pub message: Option<String>,
            pub url: Option<String>,
            pub cache_time: i32,
        }
        impl crate::Identifiable for SetBotCallbackAnswer {
            const CONSTRUCTOR_ID: u32 = 3582923530;
        }
        impl crate::Serializable for SetBotCallbackAnswer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.alert { 2 } else { 0 }
                    | if self.message.is_some() { 1 } else { 0 }
                    | if self.url.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.query_id.serialize(buf);
                if let Some(ref x) = self.message {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.url {
                    x.serialize(buf);
                }
                self.cache_time.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetBotCallbackAnswer {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetBotPrecheckoutResults {
            pub success: bool,
            pub query_id: i64,
            pub error: Option<String>,
        }
        impl crate::Identifiable for SetBotPrecheckoutResults {
            const CONSTRUCTOR_ID: u32 = 163765653;
        }
        impl crate::Serializable for SetBotPrecheckoutResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.success { 2 } else { 0 }
                    | if self.error.is_some() { 1 } else { 0 })
                .serialize(buf);
                self.query_id.serialize(buf);
                if let Some(ref x) = self.error {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SetBotPrecheckoutResults {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetBotShippingResults {
            pub query_id: i64,
            pub error: Option<String>,
            pub shipping_options: Option<Vec<crate::enums::ShippingOption>>,
        }
        impl crate::Identifiable for SetBotShippingResults {
            const CONSTRUCTOR_ID: u32 = 3858133754;
        }
        impl crate::Serializable for SetBotShippingResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.error.is_some() { 1 } else { 0 }
                    | if self.shipping_options.is_some() {
                        2
                    } else {
                        0
                    })
                .serialize(buf);
                self.query_id.serialize(buf);
                if let Some(ref x) = self.error {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.shipping_options {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SetBotShippingResults {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetChatTheme {
            pub peer: crate::enums::InputPeer,
            pub emoticon: String,
        }
        impl crate::Identifiable for SetChatTheme {
            const CONSTRUCTOR_ID: u32 = 3862683967;
        }
        impl crate::Serializable for SetChatTheme {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.emoticon.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetChatTheme {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetEncryptedTyping {
            pub peer: crate::enums::InputEncryptedChat,
            pub typing: bool,
        }
        impl crate::Identifiable for SetEncryptedTyping {
            const CONSTRUCTOR_ID: u32 = 2031374829;
        }
        impl crate::Serializable for SetEncryptedTyping {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.typing.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetEncryptedTyping {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetGameScore {
            pub edit_message: bool,
            pub force: bool,
            pub peer: crate::enums::InputPeer,
            pub id: i32,
            pub user_id: crate::enums::InputUser,
            pub score: i32,
        }
        impl crate::Identifiable for SetGameScore {
            const CONSTRUCTOR_ID: u32 = 2398678208;
        }
        impl crate::Serializable for SetGameScore {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.edit_message { 1 } else { 0 } | if self.force { 2 } else { 0 })
                    .serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
                self.user_id.serialize(buf);
                self.score.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetGameScore {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetHistoryTtl {
            pub peer: crate::enums::InputPeer,
            pub period: i32,
        }
        impl crate::Identifiable for SetHistoryTtl {
            const CONSTRUCTOR_ID: u32 = 3087949796;
        }
        impl crate::Serializable for SetHistoryTtl {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.period.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetHistoryTtl {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetInlineBotResults {
            pub gallery: bool,
            pub private: bool,
            pub query_id: i64,
            pub results: Vec<crate::enums::InputBotInlineResult>,
            pub cache_time: i32,
            pub next_offset: Option<String>,
            pub switch_pm: Option<crate::enums::InlineBotSwitchPm>,
        }
        impl crate::Identifiable for SetInlineBotResults {
            const CONSTRUCTOR_ID: u32 = 3948847622;
        }
        impl crate::Serializable for SetInlineBotResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.gallery { 1 } else { 0 }
                    | if self.private { 2 } else { 0 }
                    | if self.next_offset.is_some() { 4 } else { 0 }
                    | if self.switch_pm.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.query_id.serialize(buf);
                self.results.serialize(buf);
                self.cache_time.serialize(buf);
                if let Some(ref x) = self.next_offset {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.switch_pm {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SetInlineBotResults {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetInlineGameScore {
            pub edit_message: bool,
            pub force: bool,
            pub id: crate::enums::InputBotInlineMessageId,
            pub user_id: crate::enums::InputUser,
            pub score: i32,
        }
        impl crate::Identifiable for SetInlineGameScore {
            const CONSTRUCTOR_ID: u32 = 363700068;
        }
        impl crate::Serializable for SetInlineGameScore {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.edit_message { 1 } else { 0 } | if self.force { 2 } else { 0 })
                    .serialize(buf);
                self.id.serialize(buf);
                self.user_id.serialize(buf);
                self.score.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetInlineGameScore {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetTyping {
            pub peer: crate::enums::InputPeer,
            pub top_msg_id: Option<i32>,
            pub action: crate::enums::SendMessageAction,
        }
        impl crate::Identifiable for SetTyping {
            const CONSTRUCTOR_ID: u32 = 1486110434;
        }
        impl crate::Serializable for SetTyping {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.top_msg_id.is_some() { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                if let Some(ref x) = self.top_msg_id {
                    x.serialize(buf);
                }
                self.action.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetTyping {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StartBot {
            pub bot: crate::enums::InputUser,
            pub peer: crate::enums::InputPeer,
            pub random_id: i64,
            pub start_param: String,
        }
        impl crate::Identifiable for StartBot {
            const CONSTRUCTOR_ID: u32 = 3873403768;
        }
        impl crate::Serializable for StartBot {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.bot.serialize(buf);
                self.peer.serialize(buf);
                self.random_id.serialize(buf);
                self.start_param.serialize(buf);
            }
        }
        impl crate::RemoteCall for StartBot {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StartHistoryImport {
            pub peer: crate::enums::InputPeer,
            pub import_id: i64,
        }
        impl crate::Identifiable for StartHistoryImport {
            const CONSTRUCTOR_ID: u32 = 3023958852;
        }
        impl crate::Serializable for StartHistoryImport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.import_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for StartHistoryImport {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleDialogPin {
            pub pinned: bool,
            pub peer: crate::enums::InputDialogPeer,
        }
        impl crate::Identifiable for ToggleDialogPin {
            const CONSTRUCTOR_ID: u32 = 2805064279;
        }
        impl crate::Serializable for ToggleDialogPin {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.pinned { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleDialogPin {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleNoForwards {
            pub peer: crate::enums::InputPeer,
            pub enabled: bool,
        }
        impl crate::Identifiable for ToggleNoForwards {
            const CONSTRUCTOR_ID: u32 = 2971578274;
        }
        impl crate::Serializable for ToggleNoForwards {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.enabled.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleNoForwards {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleStickerSets {
            pub uninstall: bool,
            pub archive: bool,
            pub unarchive: bool,
            pub stickersets: Vec<crate::enums::InputStickerSet>,
        }
        impl crate::Identifiable for ToggleStickerSets {
            const CONSTRUCTOR_ID: u32 = 3037016042;
        }
        impl crate::Serializable for ToggleStickerSets {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.uninstall { 1 } else { 0 }
                    | if self.archive { 2 } else { 0 }
                    | if self.unarchive { 4 } else { 0 })
                .serialize(buf);
                self.stickersets.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleStickerSets {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UninstallStickerSet {
            pub stickerset: crate::enums::InputStickerSet,
        }
        impl crate::Identifiable for UninstallStickerSet {
            const CONSTRUCTOR_ID: u32 = 4184757726;
        }
        impl crate::Serializable for UninstallStickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.stickerset.serialize(buf);
            }
        }
        impl crate::RemoteCall for UninstallStickerSet {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UnpinAllMessages {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for UnpinAllMessages {
            const CONSTRUCTOR_ID: u32 = 4029004939;
        }
        impl crate::Serializable for UnpinAllMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for UnpinAllMessages {
            type Return = crate::enums::messages::AffectedHistory;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateDialogFilter {
            pub id: i32,
            pub filter: Option<crate::enums::DialogFilter>,
        }
        impl crate::Identifiable for UpdateDialogFilter {
            const CONSTRUCTOR_ID: u32 = 450142282;
        }
        impl crate::Serializable for UpdateDialogFilter {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.filter.is_some() { 1 } else { 0 }).serialize(buf);
                self.id.serialize(buf);
                if let Some(ref x) = self.filter {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for UpdateDialogFilter {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateDialogFiltersOrder {
            pub order: Vec<i32>,
        }
        impl crate::Identifiable for UpdateDialogFiltersOrder {
            const CONSTRUCTOR_ID: u32 = 3311649252;
        }
        impl crate::Serializable for UpdateDialogFiltersOrder {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.order.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateDialogFiltersOrder {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdatePinnedMessage {
            pub silent: bool,
            pub unpin: bool,
            pub pm_oneside: bool,
            pub peer: crate::enums::InputPeer,
            pub id: i32,
        }
        impl crate::Identifiable for UpdatePinnedMessage {
            const CONSTRUCTOR_ID: u32 = 3534419948;
        }
        impl crate::Serializable for UpdatePinnedMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.silent { 1 } else { 0 }
                    | if self.unpin { 2 } else { 0 }
                    | if self.pm_oneside { 4 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdatePinnedMessage {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadEncryptedFile {
            pub peer: crate::enums::InputEncryptedChat,
            pub file: crate::enums::InputEncryptedFile,
        }
        impl crate::Identifiable for UploadEncryptedFile {
            const CONSTRUCTOR_ID: u32 = 1347929239;
        }
        impl crate::Serializable for UploadEncryptedFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.file.serialize(buf);
            }
        }
        impl crate::RemoteCall for UploadEncryptedFile {
            type Return = crate::enums::EncryptedFile;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadImportedMedia {
            pub peer: crate::enums::InputPeer,
            pub import_id: i64,
            pub file_name: String,
            pub media: crate::enums::InputMedia,
        }
        impl crate::Identifiable for UploadImportedMedia {
            const CONSTRUCTOR_ID: u32 = 713433234;
        }
        impl crate::Serializable for UploadImportedMedia {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.import_id.serialize(buf);
                self.file_name.serialize(buf);
                self.media.serialize(buf);
            }
        }
        impl crate::RemoteCall for UploadImportedMedia {
            type Return = crate::enums::MessageMedia;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadMedia {
            pub peer: crate::enums::InputPeer,
            pub media: crate::enums::InputMedia,
        }
        impl crate::Identifiable for UploadMedia {
            const CONSTRUCTOR_ID: u32 = 1369162417;
        }
        impl crate::Serializable for UploadMedia {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.media.serialize(buf);
            }
        }
        impl crate::RemoteCall for UploadMedia {
            type Return = crate::enums::MessageMedia;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod payments {
        #[derive(Debug, Clone, PartialEq)]
        pub struct ClearSavedInfo {
            pub credentials: bool,
            pub info: bool,
        }
        impl crate::Identifiable for ClearSavedInfo {
            const CONSTRUCTOR_ID: u32 = 3627905217;
        }
        impl crate::Serializable for ClearSavedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.credentials { 1 } else { 0 } | if self.info { 2 } else { 0 })
                    .serialize(buf);
            }
        }
        impl crate::RemoteCall for ClearSavedInfo {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetBankCardData {
            pub number: String,
        }
        impl crate::Identifiable for GetBankCardData {
            const CONSTRUCTOR_ID: u32 = 779736953;
        }
        impl crate::Serializable for GetBankCardData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.number.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetBankCardData {
            type Return = crate::enums::payments::BankCardData;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPaymentForm {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub theme_params: Option<crate::enums::DataJson>,
        }
        impl crate::Identifiable for GetPaymentForm {
            const CONSTRUCTOR_ID: u32 = 2318613645;
        }
        impl crate::Serializable for GetPaymentForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.theme_params.is_some() { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                if let Some(ref x) = self.theme_params {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for GetPaymentForm {
            type Return = crate::enums::payments::PaymentForm;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetPaymentReceipt {
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
        }
        impl crate::Identifiable for GetPaymentReceipt {
            const CONSTRUCTOR_ID: u32 = 611897804;
        }
        impl crate::Serializable for GetPaymentReceipt {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetPaymentReceipt {
            type Return = crate::enums::payments::PaymentReceipt;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetSavedInfo {}
        impl crate::Identifiable for GetSavedInfo {
            const CONSTRUCTOR_ID: u32 = 578650699;
        }
        impl crate::Serializable for GetSavedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetSavedInfo {
            type Return = crate::enums::payments::SavedInfo;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendPaymentForm {
            pub form_id: i64,
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub requested_info_id: Option<String>,
            pub shipping_option_id: Option<String>,
            pub credentials: crate::enums::InputPaymentCredentials,
            pub tip_amount: Option<i64>,
        }
        impl crate::Identifiable for SendPaymentForm {
            const CONSTRUCTOR_ID: u32 = 818134173;
        }
        impl crate::Serializable for SendPaymentForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.requested_info_id.is_some() {
                        1
                    } else {
                        0
                    }
                    | if self.shipping_option_id.is_some() {
                        2
                    } else {
                        0
                    }
                    | if self.tip_amount.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.form_id.serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                if let Some(ref x) = self.requested_info_id {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.shipping_option_id {
                    x.serialize(buf);
                }
                self.credentials.serialize(buf);
                if let Some(ref x) = self.tip_amount {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for SendPaymentForm {
            type Return = crate::enums::payments::PaymentResult;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ValidateRequestedInfo {
            pub save: bool,
            pub peer: crate::enums::InputPeer,
            pub msg_id: i32,
            pub info: crate::enums::PaymentRequestedInfo,
        }
        impl crate::Identifiable for ValidateRequestedInfo {
            const CONSTRUCTOR_ID: u32 = 3675271536;
        }
        impl crate::Serializable for ValidateRequestedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.save { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.msg_id.serialize(buf);
                self.info.serialize(buf);
            }
        }
        impl crate::RemoteCall for ValidateRequestedInfo {
            type Return = crate::enums::payments::ValidatedRequestedInfo;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod phone {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AcceptCall {
            pub peer: crate::enums::InputPhoneCall,
            pub g_b: Vec<u8>,
            pub protocol: crate::enums::PhoneCallProtocol,
        }
        impl crate::Identifiable for AcceptCall {
            const CONSTRUCTOR_ID: u32 = 1003664544;
        }
        impl crate::Serializable for AcceptCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.g_b.serialize(buf);
                self.protocol.serialize(buf);
            }
        }
        impl crate::RemoteCall for AcceptCall {
            type Return = crate::enums::phone::PhoneCall;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckGroupCall {
            pub call: crate::enums::InputGroupCall,
            pub sources: Vec<i32>,
        }
        impl crate::Identifiable for CheckGroupCall {
            const CONSTRUCTOR_ID: u32 = 3046963575;
        }
        impl crate::Serializable for CheckGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.sources.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckGroupCall {
            type Return = Vec<i32>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ConfirmCall {
            pub peer: crate::enums::InputPhoneCall,
            pub g_a: Vec<u8>,
            pub key_fingerprint: i64,
            pub protocol: crate::enums::PhoneCallProtocol,
        }
        impl crate::Identifiable for ConfirmCall {
            const CONSTRUCTOR_ID: u32 = 788404002;
        }
        impl crate::Serializable for ConfirmCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.g_a.serialize(buf);
                self.key_fingerprint.serialize(buf);
                self.protocol.serialize(buf);
            }
        }
        impl crate::RemoteCall for ConfirmCall {
            type Return = crate::enums::phone::PhoneCall;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CreateGroupCall {
            pub peer: crate::enums::InputPeer,
            pub random_id: i32,
            pub title: Option<String>,
            pub schedule_date: Option<i32>,
        }
        impl crate::Identifiable for CreateGroupCall {
            const CONSTRUCTOR_ID: u32 = 1221445336;
        }
        impl crate::Serializable for CreateGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.title.is_some() { 1 } else { 0 }
                    | if self.schedule_date.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.peer.serialize(buf);
                self.random_id.serialize(buf);
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.schedule_date {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for CreateGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DiscardCall {
            pub video: bool,
            pub peer: crate::enums::InputPhoneCall,
            pub duration: i32,
            pub reason: crate::enums::PhoneCallDiscardReason,
            pub connection_id: i64,
        }
        impl crate::Identifiable for DiscardCall {
            const CONSTRUCTOR_ID: u32 = 2999697856;
        }
        impl crate::Serializable for DiscardCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.video { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.duration.serialize(buf);
                self.reason.serialize(buf);
                self.connection_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DiscardCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct DiscardGroupCall {
            pub call: crate::enums::InputGroupCall,
        }
        impl crate::Identifiable for DiscardGroupCall {
            const CONSTRUCTOR_ID: u32 = 2054648117;
        }
        impl crate::Serializable for DiscardGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
            }
        }
        impl crate::RemoteCall for DiscardGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditGroupCallParticipant {
            pub call: crate::enums::InputGroupCall,
            pub participant: crate::enums::InputPeer,
            pub muted: Option<bool>,
            pub volume: Option<i32>,
            pub raise_hand: Option<bool>,
            pub video_stopped: Option<bool>,
            pub video_paused: Option<bool>,
            pub presentation_paused: Option<bool>,
        }
        impl crate::Identifiable for EditGroupCallParticipant {
            const CONSTRUCTOR_ID: u32 = 2770811583;
        }
        impl crate::Serializable for EditGroupCallParticipant {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.muted.is_some() { 1 } else { 0 }
                    | if self.volume.is_some() { 2 } else { 0 }
                    | if self.raise_hand.is_some() { 4 } else { 0 }
                    | if self.video_stopped.is_some() { 8 } else { 0 }
                    | if self.video_paused.is_some() { 16 } else { 0 }
                    | if self.presentation_paused.is_some() {
                        32
                    } else {
                        0
                    })
                .serialize(buf);
                self.call.serialize(buf);
                self.participant.serialize(buf);
                if let Some(ref x) = self.muted {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.volume {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.raise_hand {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.video_stopped {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.video_paused {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.presentation_paused {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for EditGroupCallParticipant {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct EditGroupCallTitle {
            pub call: crate::enums::InputGroupCall,
            pub title: String,
        }
        impl crate::Identifiable for EditGroupCallTitle {
            const CONSTRUCTOR_ID: u32 = 480685066;
        }
        impl crate::Serializable for EditGroupCallTitle {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.title.serialize(buf);
            }
        }
        impl crate::RemoteCall for EditGroupCallTitle {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ExportGroupCallInvite {
            pub can_self_unmute: bool,
            pub call: crate::enums::InputGroupCall,
        }
        impl crate::Identifiable for ExportGroupCallInvite {
            const CONSTRUCTOR_ID: u32 = 3869926527;
        }
        impl crate::Serializable for ExportGroupCallInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.can_self_unmute { 1 } else { 0 }).serialize(buf);
                self.call.serialize(buf);
            }
        }
        impl crate::RemoteCall for ExportGroupCallInvite {
            type Return = crate::enums::phone::ExportedGroupCallInvite;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCallConfig {}
        impl crate::Identifiable for GetCallConfig {
            const CONSTRUCTOR_ID: u32 = 1430593449;
        }
        impl crate::Serializable for GetCallConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCallConfig {
            type Return = crate::enums::DataJson;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGroupCall {
            pub call: crate::enums::InputGroupCall,
            pub limit: i32,
        }
        impl crate::Identifiable for GetGroupCall {
            const CONSTRUCTOR_ID: u32 = 68699611;
        }
        impl crate::Serializable for GetGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGroupCall {
            type Return = crate::enums::phone::GroupCall;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGroupCallJoinAs {
            pub peer: crate::enums::InputPeer,
        }
        impl crate::Identifiable for GetGroupCallJoinAs {
            const CONSTRUCTOR_ID: u32 = 4017889594;
        }
        impl crate::Serializable for GetGroupCallJoinAs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGroupCallJoinAs {
            type Return = crate::enums::phone::JoinAsPeers;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetGroupParticipants {
            pub call: crate::enums::InputGroupCall,
            pub ids: Vec<crate::enums::InputPeer>,
            pub sources: Vec<i32>,
            pub offset: String,
            pub limit: i32,
        }
        impl crate::Identifiable for GetGroupParticipants {
            const CONSTRUCTOR_ID: u32 = 3310934187;
        }
        impl crate::Serializable for GetGroupParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.ids.serialize(buf);
                self.sources.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetGroupParticipants {
            type Return = crate::enums::phone::GroupParticipants;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct InviteToGroupCall {
            pub call: crate::enums::InputGroupCall,
            pub users: Vec<crate::enums::InputUser>,
        }
        impl crate::Identifiable for InviteToGroupCall {
            const CONSTRUCTOR_ID: u32 = 2067345760;
        }
        impl crate::Serializable for InviteToGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.users.serialize(buf);
            }
        }
        impl crate::RemoteCall for InviteToGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct JoinGroupCall {
            pub muted: bool,
            pub video_stopped: bool,
            pub call: crate::enums::InputGroupCall,
            pub join_as: crate::enums::InputPeer,
            pub invite_hash: Option<String>,
            pub params: crate::enums::DataJson,
        }
        impl crate::Identifiable for JoinGroupCall {
            const CONSTRUCTOR_ID: u32 = 2972909435;
        }
        impl crate::Serializable for JoinGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.muted { 1 } else { 0 }
                    | if self.video_stopped { 4 } else { 0 }
                    | if self.invite_hash.is_some() { 2 } else { 0 })
                .serialize(buf);
                self.call.serialize(buf);
                self.join_as.serialize(buf);
                if let Some(ref x) = self.invite_hash {
                    x.serialize(buf);
                }
                self.params.serialize(buf);
            }
        }
        impl crate::RemoteCall for JoinGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct JoinGroupCallPresentation {
            pub call: crate::enums::InputGroupCall,
            pub params: crate::enums::DataJson,
        }
        impl crate::Identifiable for JoinGroupCallPresentation {
            const CONSTRUCTOR_ID: u32 = 3421137860;
        }
        impl crate::Serializable for JoinGroupCallPresentation {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.params.serialize(buf);
            }
        }
        impl crate::RemoteCall for JoinGroupCallPresentation {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LeaveGroupCall {
            pub call: crate::enums::InputGroupCall,
            pub source: i32,
        }
        impl crate::Identifiable for LeaveGroupCall {
            const CONSTRUCTOR_ID: u32 = 1342404601;
        }
        impl crate::Serializable for LeaveGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.source.serialize(buf);
            }
        }
        impl crate::RemoteCall for LeaveGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LeaveGroupCallPresentation {
            pub call: crate::enums::InputGroupCall,
        }
        impl crate::Identifiable for LeaveGroupCallPresentation {
            const CONSTRUCTOR_ID: u32 = 475058500;
        }
        impl crate::Serializable for LeaveGroupCallPresentation {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
            }
        }
        impl crate::RemoteCall for LeaveGroupCallPresentation {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReceivedCall {
            pub peer: crate::enums::InputPhoneCall,
        }
        impl crate::Identifiable for ReceivedCall {
            const CONSTRUCTOR_ID: u32 = 399855457;
        }
        impl crate::Serializable for ReceivedCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReceivedCall {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RequestCall {
            pub video: bool,
            pub user_id: crate::enums::InputUser,
            pub random_id: i32,
            pub g_a_hash: Vec<u8>,
            pub protocol: crate::enums::PhoneCallProtocol,
        }
        impl crate::Identifiable for RequestCall {
            const CONSTRUCTOR_ID: u32 = 1124046573;
        }
        impl crate::Serializable for RequestCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.video { 1 } else { 0 }).serialize(buf);
                self.user_id.serialize(buf);
                self.random_id.serialize(buf);
                self.g_a_hash.serialize(buf);
                self.protocol.serialize(buf);
            }
        }
        impl crate::RemoteCall for RequestCall {
            type Return = crate::enums::phone::PhoneCall;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveCallDebug {
            pub peer: crate::enums::InputPhoneCall,
            pub debug: crate::enums::DataJson,
        }
        impl crate::Identifiable for SaveCallDebug {
            const CONSTRUCTOR_ID: u32 = 662363518;
        }
        impl crate::Serializable for SaveCallDebug {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.debug.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveCallDebug {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveDefaultGroupCallJoinAs {
            pub peer: crate::enums::InputPeer,
            pub join_as: crate::enums::InputPeer,
        }
        impl crate::Identifiable for SaveDefaultGroupCallJoinAs {
            const CONSTRUCTOR_ID: u32 = 1465786252;
        }
        impl crate::Serializable for SaveDefaultGroupCallJoinAs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.join_as.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveDefaultGroupCallJoinAs {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SendSignalingData {
            pub peer: crate::enums::InputPhoneCall,
            pub data: Vec<u8>,
        }
        impl crate::Identifiable for SendSignalingData {
            const CONSTRUCTOR_ID: u32 = 4286223235;
        }
        impl crate::Serializable for SendSignalingData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.peer.serialize(buf);
                self.data.serialize(buf);
            }
        }
        impl crate::RemoteCall for SendSignalingData {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetCallRating {
            pub user_initiative: bool,
            pub peer: crate::enums::InputPhoneCall,
            pub rating: i32,
            pub comment: String,
        }
        impl crate::Identifiable for SetCallRating {
            const CONSTRUCTOR_ID: u32 = 1508562471;
        }
        impl crate::Serializable for SetCallRating {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.user_initiative { 1 } else { 0 }).serialize(buf);
                self.peer.serialize(buf);
                self.rating.serialize(buf);
                self.comment.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetCallRating {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct StartScheduledGroupCall {
            pub call: crate::enums::InputGroupCall,
        }
        impl crate::Identifiable for StartScheduledGroupCall {
            const CONSTRUCTOR_ID: u32 = 1451287362;
        }
        impl crate::Serializable for StartScheduledGroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
            }
        }
        impl crate::RemoteCall for StartScheduledGroupCall {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleGroupCallRecord {
            pub start: bool,
            pub video: bool,
            pub call: crate::enums::InputGroupCall,
            pub title: Option<String>,
            pub video_portrait: Option<bool>,
        }
        impl crate::Identifiable for ToggleGroupCallRecord {
            const CONSTRUCTOR_ID: u32 = 4045981448;
        }
        impl crate::Serializable for ToggleGroupCallRecord {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.start { 1 } else { 0 }
                    | if self.video { 4 } else { 0 }
                    | if self.title.is_some() { 2 } else { 0 }
                    | if self.video_portrait.is_some() { 4 } else { 0 })
                .serialize(buf);
                self.call.serialize(buf);
                if let Some(ref x) = self.title {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.video_portrait {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for ToggleGroupCallRecord {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleGroupCallSettings {
            pub reset_invite_hash: bool,
            pub call: crate::enums::InputGroupCall,
            pub join_muted: Option<bool>,
        }
        impl crate::Identifiable for ToggleGroupCallSettings {
            const CONSTRUCTOR_ID: u32 = 1958458429;
        }
        impl crate::Serializable for ToggleGroupCallSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.reset_invite_hash { 2 } else { 0 }
                    | if self.join_muted.is_some() { 1 } else { 0 })
                .serialize(buf);
                self.call.serialize(buf);
                if let Some(ref x) = self.join_muted {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for ToggleGroupCallSettings {
            type Return = crate::enums::Updates;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ToggleGroupCallStartSubscription {
            pub call: crate::enums::InputGroupCall,
            pub subscribed: bool,
        }
        impl crate::Identifiable for ToggleGroupCallStartSubscription {
            const CONSTRUCTOR_ID: u32 = 563885286;
        }
        impl crate::Serializable for ToggleGroupCallStartSubscription {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.call.serialize(buf);
                self.subscribed.serialize(buf);
            }
        }
        impl crate::RemoteCall for ToggleGroupCallStartSubscription {
            type Return = crate::enums::Updates;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod photos {
        #[derive(Debug, Clone, PartialEq)]
        pub struct DeletePhotos {
            pub id: Vec<crate::enums::InputPhoto>,
        }
        impl crate::Identifiable for DeletePhotos {
            const CONSTRUCTOR_ID: u32 = 2278522671;
        }
        impl crate::Serializable for DeletePhotos {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for DeletePhotos {
            type Return = Vec<i64>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetUserPhotos {
            pub user_id: crate::enums::InputUser,
            pub offset: i32,
            pub max_id: i64,
            pub limit: i32,
        }
        impl crate::Identifiable for GetUserPhotos {
            const CONSTRUCTOR_ID: u32 = 2446144168;
        }
        impl crate::Serializable for GetUserPhotos {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.user_id.serialize(buf);
                self.offset.serialize(buf);
                self.max_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetUserPhotos {
            type Return = crate::enums::photos::Photos;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UpdateProfilePhoto {
            pub id: crate::enums::InputPhoto,
        }
        impl crate::Identifiable for UpdateProfilePhoto {
            const CONSTRUCTOR_ID: u32 = 1926525996;
        }
        impl crate::Serializable for UpdateProfilePhoto {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for UpdateProfilePhoto {
            type Return = crate::enums::photos::Photo;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct UploadProfilePhoto {
            pub file: Option<crate::enums::InputFile>,
            pub video: Option<crate::enums::InputFile>,
            pub video_start_ts: Option<f64>,
        }
        impl crate::Identifiable for UploadProfilePhoto {
            const CONSTRUCTOR_ID: u32 = 2314407785;
        }
        impl crate::Serializable for UploadProfilePhoto {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.file.is_some() { 1 } else { 0 }
                    | if self.video.is_some() { 2 } else { 0 }
                    | if self.video_start_ts.is_some() { 4 } else { 0 })
                .serialize(buf);
                if let Some(ref x) = self.file {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.video {
                    x.serialize(buf);
                }
                if let Some(ref x) = self.video_start_ts {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for UploadProfilePhoto {
            type Return = crate::enums::photos::Photo;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod stats {
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetBroadcastStats {
            pub dark: bool,
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for GetBroadcastStats {
            const CONSTRUCTOR_ID: u32 = 2873246746;
        }
        impl crate::Serializable for GetBroadcastStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.dark { 1 } else { 0 }).serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetBroadcastStats {
            type Return = crate::enums::stats::BroadcastStats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMegagroupStats {
            pub dark: bool,
            pub channel: crate::enums::InputChannel,
        }
        impl crate::Identifiable for GetMegagroupStats {
            const CONSTRUCTOR_ID: u32 = 3705636359;
        }
        impl crate::Serializable for GetMegagroupStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.dark { 1 } else { 0 }).serialize(buf);
                self.channel.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMegagroupStats {
            type Return = crate::enums::stats::MegagroupStats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessagePublicForwards {
            pub channel: crate::enums::InputChannel,
            pub msg_id: i32,
            pub offset_rate: i32,
            pub offset_peer: crate::enums::InputPeer,
            pub offset_id: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetMessagePublicForwards {
            const CONSTRUCTOR_ID: u32 = 1445996571;
        }
        impl crate::Serializable for GetMessagePublicForwards {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.channel.serialize(buf);
                self.msg_id.serialize(buf);
                self.offset_rate.serialize(buf);
                self.offset_peer.serialize(buf);
                self.offset_id.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessagePublicForwards {
            type Return = crate::enums::messages::Messages;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetMessageStats {
            pub dark: bool,
            pub channel: crate::enums::InputChannel,
            pub msg_id: i32,
        }
        impl crate::Identifiable for GetMessageStats {
            const CONSTRUCTOR_ID: u32 = 3068175349;
        }
        impl crate::Serializable for GetMessageStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.dark { 1 } else { 0 }).serialize(buf);
                self.channel.serialize(buf);
                self.msg_id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetMessageStats {
            type Return = crate::enums::stats::MessageStats;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct LoadAsyncGraph {
            pub token: String,
            pub x: Option<i64>,
        }
        impl crate::Identifiable for LoadAsyncGraph {
            const CONSTRUCTOR_ID: u32 = 1646092192;
        }
        impl crate::Serializable for LoadAsyncGraph {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.x.is_some() { 1 } else { 0 }).serialize(buf);
                self.token.serialize(buf);
                if let Some(ref x) = self.x {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for LoadAsyncGraph {
            type Return = crate::enums::StatsGraph;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod stickers {
        #[derive(Debug, Clone, PartialEq)]
        pub struct AddStickerToSet {
            pub stickerset: crate::enums::InputStickerSet,
            pub sticker: crate::enums::InputStickerSetItem,
        }
        impl crate::Identifiable for AddStickerToSet {
            const CONSTRUCTOR_ID: u32 = 2253651646;
        }
        impl crate::Serializable for AddStickerToSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.stickerset.serialize(buf);
                self.sticker.serialize(buf);
            }
        }
        impl crate::RemoteCall for AddStickerToSet {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ChangeStickerPosition {
            pub sticker: crate::enums::InputDocument,
            pub position: i32,
        }
        impl crate::Identifiable for ChangeStickerPosition {
            const CONSTRUCTOR_ID: u32 = 4290172106;
        }
        impl crate::Serializable for ChangeStickerPosition {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.sticker.serialize(buf);
                self.position.serialize(buf);
            }
        }
        impl crate::RemoteCall for ChangeStickerPosition {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CheckShortName {
            pub short_name: String,
        }
        impl crate::Identifiable for CheckShortName {
            const CONSTRUCTOR_ID: u32 = 676017721;
        }
        impl crate::Serializable for CheckShortName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.short_name.serialize(buf);
            }
        }
        impl crate::RemoteCall for CheckShortName {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct CreateStickerSet {
            pub masks: bool,
            pub animated: bool,
            pub user_id: crate::enums::InputUser,
            pub title: String,
            pub short_name: String,
            pub thumb: Option<crate::enums::InputDocument>,
            pub stickers: Vec<crate::enums::InputStickerSetItem>,
            pub software: Option<String>,
        }
        impl crate::Identifiable for CreateStickerSet {
            const CONSTRUCTOR_ID: u32 = 2418125671;
        }
        impl crate::Serializable for CreateStickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32
                    | if self.masks { 1 } else { 0 }
                    | if self.animated { 2 } else { 0 }
                    | if self.thumb.is_some() { 4 } else { 0 }
                    | if self.software.is_some() { 8 } else { 0 })
                .serialize(buf);
                self.user_id.serialize(buf);
                self.title.serialize(buf);
                self.short_name.serialize(buf);
                if let Some(ref x) = self.thumb {
                    x.serialize(buf);
                }
                self.stickers.serialize(buf);
                if let Some(ref x) = self.software {
                    x.serialize(buf);
                }
            }
        }
        impl crate::RemoteCall for CreateStickerSet {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct RemoveStickerFromSet {
            pub sticker: crate::enums::InputDocument,
        }
        impl crate::Identifiable for RemoveStickerFromSet {
            const CONSTRUCTOR_ID: u32 = 4151709521;
        }
        impl crate::Serializable for RemoveStickerFromSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.sticker.serialize(buf);
            }
        }
        impl crate::RemoteCall for RemoveStickerFromSet {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetStickerSetThumb {
            pub stickerset: crate::enums::InputStickerSet,
            pub thumb: crate::enums::InputDocument,
        }
        impl crate::Identifiable for SetStickerSetThumb {
            const CONSTRUCTOR_ID: u32 = 2587250224;
        }
        impl crate::Serializable for SetStickerSetThumb {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.stickerset.serialize(buf);
                self.thumb.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetStickerSetThumb {
            type Return = crate::enums::messages::StickerSet;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SuggestShortName {
            pub title: String,
        }
        impl crate::Identifiable for SuggestShortName {
            const CONSTRUCTOR_ID: u32 = 1303364867;
        }
        impl crate::Serializable for SuggestShortName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.title.serialize(buf);
            }
        }
        impl crate::RemoteCall for SuggestShortName {
            type Return = crate::enums::stickers::SuggestedShortName;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod updates {
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetChannelDifference {
            pub force: bool,
            pub channel: crate::enums::InputChannel,
            pub filter: crate::enums::ChannelMessagesFilter,
            pub pts: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetChannelDifference {
            const CONSTRUCTOR_ID: u32 = 51854712;
        }
        impl crate::Serializable for GetChannelDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.force { 1 } else { 0 }).serialize(buf);
                self.channel.serialize(buf);
                self.filter.serialize(buf);
                self.pts.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetChannelDifference {
            type Return = crate::enums::updates::ChannelDifference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetDifference {
            pub pts: i32,
            pub pts_total_limit: Option<i32>,
            pub date: i32,
            pub qts: i32,
        }
        impl crate::Identifiable for GetDifference {
            const CONSTRUCTOR_ID: u32 = 630429265;
        }
        impl crate::Serializable for GetDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.pts_total_limit.is_some() { 1 } else { 0 }).serialize(buf);
                self.pts.serialize(buf);
                if let Some(ref x) = self.pts_total_limit {
                    x.serialize(buf);
                }
                self.date.serialize(buf);
                self.qts.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetDifference {
            type Return = crate::enums::updates::Difference;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetState {}
        impl crate::Identifiable for GetState {
            const CONSTRUCTOR_ID: u32 = 3990128682;
        }
        impl crate::Serializable for GetState {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetState {
            type Return = crate::enums::updates::State;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod upload {
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCdnFile {
            pub file_token: Vec<u8>,
            pub offset: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetCdnFile {
            const CONSTRUCTOR_ID: u32 = 536919235;
        }
        impl crate::Serializable for GetCdnFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file_token.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCdnFile {
            type Return = crate::enums::upload::CdnFile;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetCdnFileHashes {
            pub file_token: Vec<u8>,
            pub offset: i32,
        }
        impl crate::Identifiable for GetCdnFileHashes {
            const CONSTRUCTOR_ID: u32 = 1302676017;
        }
        impl crate::Serializable for GetCdnFileHashes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file_token.serialize(buf);
                self.offset.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetCdnFileHashes {
            type Return = Vec<crate::enums::FileHash>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFile {
            pub precise: bool,
            pub cdn_supported: bool,
            pub location: crate::enums::InputFileLocation,
            pub offset: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetFile {
            const CONSTRUCTOR_ID: u32 = 2975505148;
        }
        impl crate::Serializable for GetFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                (0u32 | if self.precise { 1 } else { 0 } | if self.cdn_supported { 2 } else { 0 })
                    .serialize(buf);
                self.location.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFile {
            type Return = crate::enums::upload::File;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFileHashes {
            pub location: crate::enums::InputFileLocation,
            pub offset: i32,
        }
        impl crate::Identifiable for GetFileHashes {
            const CONSTRUCTOR_ID: u32 = 3338819889;
        }
        impl crate::Serializable for GetFileHashes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.location.serialize(buf);
                self.offset.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFileHashes {
            type Return = Vec<crate::enums::FileHash>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetWebFile {
            pub location: crate::enums::InputWebFileLocation,
            pub offset: i32,
            pub limit: i32,
        }
        impl crate::Identifiable for GetWebFile {
            const CONSTRUCTOR_ID: u32 = 619086221;
        }
        impl crate::Serializable for GetWebFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.location.serialize(buf);
                self.offset.serialize(buf);
                self.limit.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetWebFile {
            type Return = crate::enums::upload::WebFile;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct ReuploadCdnFile {
            pub file_token: Vec<u8>,
            pub request_token: Vec<u8>,
        }
        impl crate::Identifiable for ReuploadCdnFile {
            const CONSTRUCTOR_ID: u32 = 2603046056;
        }
        impl crate::Serializable for ReuploadCdnFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file_token.serialize(buf);
                self.request_token.serialize(buf);
            }
        }
        impl crate::RemoteCall for ReuploadCdnFile {
            type Return = Vec<crate::enums::FileHash>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveBigFilePart {
            pub file_id: i64,
            pub file_part: i32,
            pub file_total_parts: i32,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for SaveBigFilePart {
            const CONSTRUCTOR_ID: u32 = 3732629309;
        }
        impl crate::Serializable for SaveBigFilePart {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file_id.serialize(buf);
                self.file_part.serialize(buf);
                self.file_total_parts.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveBigFilePart {
            type Return = bool;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SaveFilePart {
            pub file_id: i64,
            pub file_part: i32,
            pub bytes: Vec<u8>,
        }
        impl crate::Identifiable for SaveFilePart {
            const CONSTRUCTOR_ID: u32 = 3003426337;
        }
        impl crate::Serializable for SaveFilePart {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.file_id.serialize(buf);
                self.file_part.serialize(buf);
                self.bytes.serialize(buf);
            }
        }
        impl crate::RemoteCall for SaveFilePart {
            type Return = bool;
        }
    }
    #[allow(clippy::unreadable_literal)]
    pub mod users {
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetFullUser {
            pub id: crate::enums::InputUser,
        }
        impl crate::Identifiable for GetFullUser {
            const CONSTRUCTOR_ID: u32 = 3054459160;
        }
        impl crate::Serializable for GetFullUser {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetFullUser {
            type Return = crate::enums::users::UserFull;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct GetUsers {
            pub id: Vec<crate::enums::InputUser>,
        }
        impl crate::Identifiable for GetUsers {
            const CONSTRUCTOR_ID: u32 = 227648840;
        }
        impl crate::Serializable for GetUsers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
            }
        }
        impl crate::RemoteCall for GetUsers {
            type Return = Vec<crate::enums::User>;
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct SetSecureValueErrors {
            pub id: crate::enums::InputUser,
            pub errors: Vec<crate::enums::SecureValueError>,
        }
        impl crate::Identifiable for SetSecureValueErrors {
            const CONSTRUCTOR_ID: u32 = 2429064373;
        }
        impl crate::Serializable for SetSecureValueErrors {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                Self::CONSTRUCTOR_ID.serialize(buf);
                self.id.serialize(buf);
                self.errors.serialize(buf);
            }
        }
        impl crate::RemoteCall for SetSecureValueErrors {
            type Return = bool;
        }
    }
}
/// This module contains all of the boxed types, each
/// represented by a `enum`. All of them implement
/// [`Serializable`] and [`Deserializable`].
///
/// [`Serializable`]: /grammers_tl_types/trait.Serializable.html
/// [`Deserializable`]: /grammers_tl_types/trait.Deserializable.html
#[allow(clippy::large_enum_variant)]
pub mod enums {
    #[derive(Debug, Clone, PartialEq)]
    pub enum AccessPointRule {
        Rule(crate::types::AccessPointRule),
    }
    impl crate::Serializable for AccessPointRule {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Rule(x) => {
                    crate::types::AccessPointRule::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for AccessPointRule {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::AccessPointRule::CONSTRUCTOR_ID => {
                    Self::Rule(crate::types::AccessPointRule::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::AccessPointRule> for AccessPointRule {
        fn from(x: crate::types::AccessPointRule) -> Self {
            AccessPointRule::Rule(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum AccountDaysTtl {
        Ttl(crate::types::AccountDaysTtl),
    }
    impl crate::Serializable for AccountDaysTtl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Ttl(x) => {
                    crate::types::AccountDaysTtl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for AccountDaysTtl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::AccountDaysTtl::CONSTRUCTOR_ID => {
                    Self::Ttl(crate::types::AccountDaysTtl::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::AccountDaysTtl> for AccountDaysTtl {
        fn from(x: crate::types::AccountDaysTtl) -> Self {
            AccountDaysTtl::Ttl(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Authorization {
        Authorization(crate::types::Authorization),
    }
    impl crate::Serializable for Authorization {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Authorization(x) => {
                    crate::types::Authorization::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Authorization {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Authorization::CONSTRUCTOR_ID => {
                    Self::Authorization(crate::types::Authorization::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Authorization> for Authorization {
        fn from(x: crate::types::Authorization) -> Self {
            Authorization::Authorization(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum AutoDownloadSettings {
        Settings(crate::types::AutoDownloadSettings),
    }
    impl crate::Serializable for AutoDownloadSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::AutoDownloadSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for AutoDownloadSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::AutoDownloadSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::AutoDownloadSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::AutoDownloadSettings> for AutoDownloadSettings {
        fn from(x: crate::types::AutoDownloadSettings) -> Self {
            AutoDownloadSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BadMsgNotification {
        Notification(crate::types::BadMsgNotification),
        BadServerSalt(crate::types::BadServerSalt),
    }
    impl BadMsgNotification {
        pub fn error_code(&self) -> i32 {
            match self {
                Self::Notification(i) => i.error_code,
                Self::BadServerSalt(i) => i.error_code,
            }
        }
        pub fn bad_msg_seqno(&self) -> i32 {
            match self {
                Self::Notification(i) => i.bad_msg_seqno,
                Self::BadServerSalt(i) => i.bad_msg_seqno,
            }
        }
        pub fn bad_msg_id(&self) -> i64 {
            match self {
                Self::Notification(i) => i.bad_msg_id,
                Self::BadServerSalt(i) => i.bad_msg_id,
            }
        }
    }
    impl crate::Serializable for BadMsgNotification {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Notification(x) => {
                    crate::types::BadMsgNotification::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BadServerSalt(x) => {
                    crate::types::BadServerSalt::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BadMsgNotification {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BadMsgNotification::CONSTRUCTOR_ID => {
                    Self::Notification(crate::types::BadMsgNotification::deserialize(buf)?)
                }
                crate::types::BadServerSalt::CONSTRUCTOR_ID => {
                    Self::BadServerSalt(crate::types::BadServerSalt::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BadMsgNotification> for BadMsgNotification {
        fn from(x: crate::types::BadMsgNotification) -> Self {
            BadMsgNotification::Notification(x)
        }
    }
    impl From<crate::types::BadServerSalt> for BadMsgNotification {
        fn from(x: crate::types::BadServerSalt) -> Self {
            BadMsgNotification::BadServerSalt(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BankCardOpenUrl {
        Url(crate::types::BankCardOpenUrl),
    }
    impl crate::Serializable for BankCardOpenUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Url(x) => {
                    crate::types::BankCardOpenUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BankCardOpenUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BankCardOpenUrl::CONSTRUCTOR_ID => {
                    Self::Url(crate::types::BankCardOpenUrl::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BankCardOpenUrl> for BankCardOpenUrl {
        fn from(x: crate::types::BankCardOpenUrl) -> Self {
            BankCardOpenUrl::Url(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BaseTheme {
        Classic,
        Day,
        Night,
        Tinted,
        Arctic,
    }
    impl crate::Serializable for BaseTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Classic => {
                    crate::types::BaseThemeClassic::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Day => {
                    crate::types::BaseThemeDay::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Night => {
                    crate::types::BaseThemeNight::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Tinted => {
                    crate::types::BaseThemeTinted::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Arctic => {
                    crate::types::BaseThemeArctic::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for BaseTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BaseThemeClassic::CONSTRUCTOR_ID => Self::Classic,
                crate::types::BaseThemeDay::CONSTRUCTOR_ID => Self::Day,
                crate::types::BaseThemeNight::CONSTRUCTOR_ID => Self::Night,
                crate::types::BaseThemeTinted::CONSTRUCTOR_ID => Self::Tinted,
                crate::types::BaseThemeArctic::CONSTRUCTOR_ID => Self::Arctic,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BaseThemeClassic> for BaseTheme {
        fn from(_x: crate::types::BaseThemeClassic) -> Self {
            BaseTheme::Classic
        }
    }
    impl From<crate::types::BaseThemeDay> for BaseTheme {
        fn from(_x: crate::types::BaseThemeDay) -> Self {
            BaseTheme::Day
        }
    }
    impl From<crate::types::BaseThemeNight> for BaseTheme {
        fn from(_x: crate::types::BaseThemeNight) -> Self {
            BaseTheme::Night
        }
    }
    impl From<crate::types::BaseThemeTinted> for BaseTheme {
        fn from(_x: crate::types::BaseThemeTinted) -> Self {
            BaseTheme::Tinted
        }
    }
    impl From<crate::types::BaseThemeArctic> for BaseTheme {
        fn from(_x: crate::types::BaseThemeArctic) -> Self {
            BaseTheme::Arctic
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BindAuthKeyInner {
        Inner(crate::types::BindAuthKeyInner),
    }
    impl crate::Serializable for BindAuthKeyInner {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Inner(x) => {
                    crate::types::BindAuthKeyInner::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BindAuthKeyInner {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BindAuthKeyInner::CONSTRUCTOR_ID => {
                    Self::Inner(crate::types::BindAuthKeyInner::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BindAuthKeyInner> for BindAuthKeyInner {
        fn from(x: crate::types::BindAuthKeyInner) -> Self {
            BindAuthKeyInner::Inner(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BotCommand {
        Command(crate::types::BotCommand),
    }
    impl crate::Serializable for BotCommand {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Command(x) => {
                    crate::types::BotCommand::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BotCommand {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BotCommand::CONSTRUCTOR_ID => {
                    Self::Command(crate::types::BotCommand::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BotCommand> for BotCommand {
        fn from(x: crate::types::BotCommand) -> Self {
            BotCommand::Command(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BotCommandScope {
        Default,
        Users,
        Chats,
        ChatAdmins,
        Peer(crate::types::BotCommandScopePeer),
        PeerAdmins(crate::types::BotCommandScopePeerAdmins),
        PeerUser(crate::types::BotCommandScopePeerUser),
    }
    impl crate::Serializable for BotCommandScope {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Default => {
                    crate::types::BotCommandScopeDefault::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Users => {
                    crate::types::BotCommandScopeUsers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Chats => {
                    crate::types::BotCommandScopeChats::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChatAdmins => {
                    crate::types::BotCommandScopeChatAdmins::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Peer(x) => {
                    crate::types::BotCommandScopePeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerAdmins(x) => {
                    crate::types::BotCommandScopePeerAdmins::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerUser(x) => {
                    crate::types::BotCommandScopePeerUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BotCommandScope {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BotCommandScopeDefault::CONSTRUCTOR_ID => Self::Default,
                crate::types::BotCommandScopeUsers::CONSTRUCTOR_ID => Self::Users,
                crate::types::BotCommandScopeChats::CONSTRUCTOR_ID => Self::Chats,
                crate::types::BotCommandScopeChatAdmins::CONSTRUCTOR_ID => Self::ChatAdmins,
                crate::types::BotCommandScopePeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::BotCommandScopePeer::deserialize(buf)?)
                }
                crate::types::BotCommandScopePeerAdmins::CONSTRUCTOR_ID => {
                    Self::PeerAdmins(crate::types::BotCommandScopePeerAdmins::deserialize(buf)?)
                }
                crate::types::BotCommandScopePeerUser::CONSTRUCTOR_ID => {
                    Self::PeerUser(crate::types::BotCommandScopePeerUser::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BotCommandScopeDefault> for BotCommandScope {
        fn from(_x: crate::types::BotCommandScopeDefault) -> Self {
            BotCommandScope::Default
        }
    }
    impl From<crate::types::BotCommandScopeUsers> for BotCommandScope {
        fn from(_x: crate::types::BotCommandScopeUsers) -> Self {
            BotCommandScope::Users
        }
    }
    impl From<crate::types::BotCommandScopeChats> for BotCommandScope {
        fn from(_x: crate::types::BotCommandScopeChats) -> Self {
            BotCommandScope::Chats
        }
    }
    impl From<crate::types::BotCommandScopeChatAdmins> for BotCommandScope {
        fn from(_x: crate::types::BotCommandScopeChatAdmins) -> Self {
            BotCommandScope::ChatAdmins
        }
    }
    impl From<crate::types::BotCommandScopePeer> for BotCommandScope {
        fn from(x: crate::types::BotCommandScopePeer) -> Self {
            BotCommandScope::Peer(x)
        }
    }
    impl From<crate::types::BotCommandScopePeerAdmins> for BotCommandScope {
        fn from(x: crate::types::BotCommandScopePeerAdmins) -> Self {
            BotCommandScope::PeerAdmins(x)
        }
    }
    impl From<crate::types::BotCommandScopePeerUser> for BotCommandScope {
        fn from(x: crate::types::BotCommandScopePeerUser) -> Self {
            BotCommandScope::PeerUser(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BotInfo {
        Info(crate::types::BotInfo),
    }
    impl crate::Serializable for BotInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Info(x) => {
                    crate::types::BotInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BotInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BotInfo::CONSTRUCTOR_ID => {
                    Self::Info(crate::types::BotInfo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BotInfo> for BotInfo {
        fn from(x: crate::types::BotInfo) -> Self {
            BotInfo::Info(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BotInlineMessage {
        MediaAuto(crate::types::BotInlineMessageMediaAuto),
        Text(crate::types::BotInlineMessageText),
        MediaGeo(crate::types::BotInlineMessageMediaGeo),
        MediaVenue(crate::types::BotInlineMessageMediaVenue),
        MediaContact(crate::types::BotInlineMessageMediaContact),
        MediaInvoice(crate::types::BotInlineMessageMediaInvoice),
    }
    impl crate::Serializable for BotInlineMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::MediaAuto(x) => {
                    crate::types::BotInlineMessageMediaAuto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Text(x) => {
                    crate::types::BotInlineMessageText::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaGeo(x) => {
                    crate::types::BotInlineMessageMediaGeo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaVenue(x) => {
                    crate::types::BotInlineMessageMediaVenue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaContact(x) => {
                    crate::types::BotInlineMessageMediaContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaInvoice(x) => {
                    crate::types::BotInlineMessageMediaInvoice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BotInlineMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BotInlineMessageMediaAuto::CONSTRUCTOR_ID => {
                    Self::MediaAuto(crate::types::BotInlineMessageMediaAuto::deserialize(buf)?)
                }
                crate::types::BotInlineMessageText::CONSTRUCTOR_ID => {
                    Self::Text(crate::types::BotInlineMessageText::deserialize(buf)?)
                }
                crate::types::BotInlineMessageMediaGeo::CONSTRUCTOR_ID => {
                    Self::MediaGeo(crate::types::BotInlineMessageMediaGeo::deserialize(buf)?)
                }
                crate::types::BotInlineMessageMediaVenue::CONSTRUCTOR_ID => {
                    Self::MediaVenue(crate::types::BotInlineMessageMediaVenue::deserialize(buf)?)
                }
                crate::types::BotInlineMessageMediaContact::CONSTRUCTOR_ID => Self::MediaContact(
                    crate::types::BotInlineMessageMediaContact::deserialize(buf)?,
                ),
                crate::types::BotInlineMessageMediaInvoice::CONSTRUCTOR_ID => Self::MediaInvoice(
                    crate::types::BotInlineMessageMediaInvoice::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BotInlineMessageMediaAuto> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageMediaAuto) -> Self {
            BotInlineMessage::MediaAuto(x)
        }
    }
    impl From<crate::types::BotInlineMessageText> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageText) -> Self {
            BotInlineMessage::Text(x)
        }
    }
    impl From<crate::types::BotInlineMessageMediaGeo> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageMediaGeo) -> Self {
            BotInlineMessage::MediaGeo(x)
        }
    }
    impl From<crate::types::BotInlineMessageMediaVenue> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageMediaVenue) -> Self {
            BotInlineMessage::MediaVenue(x)
        }
    }
    impl From<crate::types::BotInlineMessageMediaContact> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageMediaContact) -> Self {
            BotInlineMessage::MediaContact(x)
        }
    }
    impl From<crate::types::BotInlineMessageMediaInvoice> for BotInlineMessage {
        fn from(x: crate::types::BotInlineMessageMediaInvoice) -> Self {
            BotInlineMessage::MediaInvoice(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum BotInlineResult {
        Result(crate::types::BotInlineResult),
        BotInlineMediaResult(crate::types::BotInlineMediaResult),
    }
    impl BotInlineResult {
        pub fn r#type(&self) -> String {
            match self {
                Self::Result(i) => i.r#type.clone(),
                Self::BotInlineMediaResult(i) => i.r#type.clone(),
            }
        }
        pub fn send_message(&self) -> crate::enums::BotInlineMessage {
            match self {
                Self::Result(i) => i.send_message.clone(),
                Self::BotInlineMediaResult(i) => i.send_message.clone(),
            }
        }
        pub fn id(&self) -> String {
            match self {
                Self::Result(i) => i.id.clone(),
                Self::BotInlineMediaResult(i) => i.id.clone(),
            }
        }
    }
    impl crate::Serializable for BotInlineResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Result(x) => {
                    crate::types::BotInlineResult::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotInlineMediaResult(x) => {
                    crate::types::BotInlineMediaResult::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for BotInlineResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::BotInlineResult::CONSTRUCTOR_ID => {
                    Self::Result(crate::types::BotInlineResult::deserialize(buf)?)
                }
                crate::types::BotInlineMediaResult::CONSTRUCTOR_ID => Self::BotInlineMediaResult(
                    crate::types::BotInlineMediaResult::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::BotInlineResult> for BotInlineResult {
        fn from(x: crate::types::BotInlineResult) -> Self {
            BotInlineResult::Result(x)
        }
    }
    impl From<crate::types::BotInlineMediaResult> for BotInlineResult {
        fn from(x: crate::types::BotInlineMediaResult) -> Self {
            BotInlineResult::BotInlineMediaResult(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum CdnConfig {
        Config(crate::types::CdnConfig),
    }
    impl crate::Serializable for CdnConfig {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Config(x) => {
                    crate::types::CdnConfig::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for CdnConfig {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::CdnConfig::CONSTRUCTOR_ID => {
                    Self::Config(crate::types::CdnConfig::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::CdnConfig> for CdnConfig {
        fn from(x: crate::types::CdnConfig) -> Self {
            CdnConfig::Config(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum CdnPublicKey {
        Key(crate::types::CdnPublicKey),
    }
    impl crate::Serializable for CdnPublicKey {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Key(x) => {
                    crate::types::CdnPublicKey::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for CdnPublicKey {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::CdnPublicKey::CONSTRUCTOR_ID => {
                    Self::Key(crate::types::CdnPublicKey::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::CdnPublicKey> for CdnPublicKey {
        fn from(x: crate::types::CdnPublicKey) -> Self {
            CdnPublicKey::Key(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelAdminLogEvent {
        Event(crate::types::ChannelAdminLogEvent),
    }
    impl crate::Serializable for ChannelAdminLogEvent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Event(x) => {
                    crate::types::ChannelAdminLogEvent::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelAdminLogEvent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelAdminLogEvent::CONSTRUCTOR_ID => {
                    Self::Event(crate::types::ChannelAdminLogEvent::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelAdminLogEvent> for ChannelAdminLogEvent {
        fn from(x: crate::types::ChannelAdminLogEvent) -> Self {
            ChannelAdminLogEvent::Event(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelAdminLogEventAction {
        ChangeTitle(crate::types::ChannelAdminLogEventActionChangeTitle),
        ChangeAbout(crate::types::ChannelAdminLogEventActionChangeAbout),
        ChangeUsername(crate::types::ChannelAdminLogEventActionChangeUsername),
        ChangePhoto(crate::types::ChannelAdminLogEventActionChangePhoto),
        ToggleInvites(crate::types::ChannelAdminLogEventActionToggleInvites),
        ToggleSignatures(crate::types::ChannelAdminLogEventActionToggleSignatures),
        UpdatePinned(crate::types::ChannelAdminLogEventActionUpdatePinned),
        EditMessage(crate::types::ChannelAdminLogEventActionEditMessage),
        DeleteMessage(crate::types::ChannelAdminLogEventActionDeleteMessage),
        ParticipantJoin,
        ParticipantLeave,
        ParticipantInvite(crate::types::ChannelAdminLogEventActionParticipantInvite),
        ParticipantToggleBan(crate::types::ChannelAdminLogEventActionParticipantToggleBan),
        ParticipantToggleAdmin(crate::types::ChannelAdminLogEventActionParticipantToggleAdmin),
        ChangeStickerSet(crate::types::ChannelAdminLogEventActionChangeStickerSet),
        TogglePreHistoryHidden(crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden),
        DefaultBannedRights(crate::types::ChannelAdminLogEventActionDefaultBannedRights),
        StopPoll(crate::types::ChannelAdminLogEventActionStopPoll),
        ChangeLinkedChat(crate::types::ChannelAdminLogEventActionChangeLinkedChat),
        ChangeLocation(crate::types::ChannelAdminLogEventActionChangeLocation),
        ToggleSlowMode(crate::types::ChannelAdminLogEventActionToggleSlowMode),
        StartGroupCall(crate::types::ChannelAdminLogEventActionStartGroupCall),
        DiscardGroupCall(crate::types::ChannelAdminLogEventActionDiscardGroupCall),
        ParticipantMute(crate::types::ChannelAdminLogEventActionParticipantMute),
        ParticipantUnmute(crate::types::ChannelAdminLogEventActionParticipantUnmute),
        ToggleGroupCallSetting(crate::types::ChannelAdminLogEventActionToggleGroupCallSetting),
        ParticipantJoinByInvite(crate::types::ChannelAdminLogEventActionParticipantJoinByInvite),
        ExportedInviteDelete(crate::types::ChannelAdminLogEventActionExportedInviteDelete),
        ExportedInviteRevoke(crate::types::ChannelAdminLogEventActionExportedInviteRevoke),
        ExportedInviteEdit(crate::types::ChannelAdminLogEventActionExportedInviteEdit),
        ParticipantVolume(crate::types::ChannelAdminLogEventActionParticipantVolume),
        ChangeHistoryTtl(crate::types::ChannelAdminLogEventActionChangeHistoryTtl),
        ParticipantJoinByRequest(crate::types::ChannelAdminLogEventActionParticipantJoinByRequest),
        ToggleNoForwards(crate::types::ChannelAdminLogEventActionToggleNoForwards),
        SendMessage(crate::types::ChannelAdminLogEventActionSendMessage),
    }
    impl crate::Serializable for ChannelAdminLogEventAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::ChangeTitle(x) => {
                    crate::types::ChannelAdminLogEventActionChangeTitle::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeAbout(x) => {
                    crate::types::ChannelAdminLogEventActionChangeAbout::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeUsername(x) => {
                    crate::types::ChannelAdminLogEventActionChangeUsername::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangePhoto(x) => {
                    crate::types::ChannelAdminLogEventActionChangePhoto::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ToggleInvites(x) => {
                    crate::types::ChannelAdminLogEventActionToggleInvites::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ToggleSignatures(x) => {
                    crate::types::ChannelAdminLogEventActionToggleSignatures::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::UpdatePinned(x) => {
                    crate::types::ChannelAdminLogEventActionUpdatePinned::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::EditMessage(x) => {
                    crate::types::ChannelAdminLogEventActionEditMessage::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::DeleteMessage(x) => {
                    crate::types::ChannelAdminLogEventActionDeleteMessage::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantJoin => {
                    crate::types::ChannelAdminLogEventActionParticipantJoin::CONSTRUCTOR_ID
                        .serialize(buf);
                }
                Self::ParticipantLeave => {
                    crate::types::ChannelAdminLogEventActionParticipantLeave::CONSTRUCTOR_ID
                        .serialize(buf);
                }
                Self::ParticipantInvite(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantInvite::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantToggleBan(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantToggleBan::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantToggleAdmin(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantToggleAdmin::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeStickerSet(x) => {
                    crate::types::ChannelAdminLogEventActionChangeStickerSet::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::TogglePreHistoryHidden(x) => {
                    crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::DefaultBannedRights(x) => {
                    crate::types::ChannelAdminLogEventActionDefaultBannedRights::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::StopPoll(x) => {
                    crate::types::ChannelAdminLogEventActionStopPoll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeLinkedChat(x) => {
                    crate::types::ChannelAdminLogEventActionChangeLinkedChat::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeLocation(x) => {
                    crate::types::ChannelAdminLogEventActionChangeLocation::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ToggleSlowMode(x) => {
                    crate::types::ChannelAdminLogEventActionToggleSlowMode::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::StartGroupCall(x) => {
                    crate::types::ChannelAdminLogEventActionStartGroupCall::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::DiscardGroupCall(x) => {
                    crate::types::ChannelAdminLogEventActionDiscardGroupCall::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantMute(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantMute::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantUnmute(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantUnmute::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ToggleGroupCallSetting(x) => {
                    crate::types::ChannelAdminLogEventActionToggleGroupCallSetting::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantJoinByInvite(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantJoinByInvite::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ExportedInviteDelete(x) => {
                    crate::types::ChannelAdminLogEventActionExportedInviteDelete::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ExportedInviteRevoke(x) => {
                    crate::types::ChannelAdminLogEventActionExportedInviteRevoke::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ExportedInviteEdit(x) => {
                    crate::types::ChannelAdminLogEventActionExportedInviteEdit::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantVolume(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantVolume::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ChangeHistoryTtl(x) => {
                    crate::types::ChannelAdminLogEventActionChangeHistoryTtl::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantJoinByRequest(x) => {
                    crate::types::ChannelAdminLogEventActionParticipantJoinByRequest::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ToggleNoForwards(x) => {
                    crate::types::ChannelAdminLogEventActionToggleNoForwards::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessage(x) => {
                    crate::types::ChannelAdminLogEventActionSendMessage::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelAdminLogEventActionChangeTitle::CONSTRUCTOR_ID => Self::ChangeTitle(crate::types::ChannelAdminLogEventActionChangeTitle::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeAbout::CONSTRUCTOR_ID => Self::ChangeAbout(crate::types::ChannelAdminLogEventActionChangeAbout::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeUsername::CONSTRUCTOR_ID => Self::ChangeUsername(crate::types::ChannelAdminLogEventActionChangeUsername::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangePhoto::CONSTRUCTOR_ID => Self::ChangePhoto(crate::types::ChannelAdminLogEventActionChangePhoto::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionToggleInvites::CONSTRUCTOR_ID => Self::ToggleInvites(crate::types::ChannelAdminLogEventActionToggleInvites::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionToggleSignatures::CONSTRUCTOR_ID => Self::ToggleSignatures(crate::types::ChannelAdminLogEventActionToggleSignatures::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionUpdatePinned::CONSTRUCTOR_ID => Self::UpdatePinned(crate::types::ChannelAdminLogEventActionUpdatePinned::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionEditMessage::CONSTRUCTOR_ID => Self::EditMessage(crate::types::ChannelAdminLogEventActionEditMessage::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionDeleteMessage::CONSTRUCTOR_ID => Self::DeleteMessage(crate::types::ChannelAdminLogEventActionDeleteMessage::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantJoin::CONSTRUCTOR_ID => Self::ParticipantJoin,
                crate::types::ChannelAdminLogEventActionParticipantLeave::CONSTRUCTOR_ID => Self::ParticipantLeave,
                crate::types::ChannelAdminLogEventActionParticipantInvite::CONSTRUCTOR_ID => Self::ParticipantInvite(crate::types::ChannelAdminLogEventActionParticipantInvite::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantToggleBan::CONSTRUCTOR_ID => Self::ParticipantToggleBan(crate::types::ChannelAdminLogEventActionParticipantToggleBan::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantToggleAdmin::CONSTRUCTOR_ID => Self::ParticipantToggleAdmin(crate::types::ChannelAdminLogEventActionParticipantToggleAdmin::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeStickerSet::CONSTRUCTOR_ID => Self::ChangeStickerSet(crate::types::ChannelAdminLogEventActionChangeStickerSet::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden::CONSTRUCTOR_ID => Self::TogglePreHistoryHidden(crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionDefaultBannedRights::CONSTRUCTOR_ID => Self::DefaultBannedRights(crate::types::ChannelAdminLogEventActionDefaultBannedRights::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionStopPoll::CONSTRUCTOR_ID => Self::StopPoll(crate::types::ChannelAdminLogEventActionStopPoll::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeLinkedChat::CONSTRUCTOR_ID => Self::ChangeLinkedChat(crate::types::ChannelAdminLogEventActionChangeLinkedChat::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeLocation::CONSTRUCTOR_ID => Self::ChangeLocation(crate::types::ChannelAdminLogEventActionChangeLocation::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionToggleSlowMode::CONSTRUCTOR_ID => Self::ToggleSlowMode(crate::types::ChannelAdminLogEventActionToggleSlowMode::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionStartGroupCall::CONSTRUCTOR_ID => Self::StartGroupCall(crate::types::ChannelAdminLogEventActionStartGroupCall::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionDiscardGroupCall::CONSTRUCTOR_ID => Self::DiscardGroupCall(crate::types::ChannelAdminLogEventActionDiscardGroupCall::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantMute::CONSTRUCTOR_ID => Self::ParticipantMute(crate::types::ChannelAdminLogEventActionParticipantMute::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantUnmute::CONSTRUCTOR_ID => Self::ParticipantUnmute(crate::types::ChannelAdminLogEventActionParticipantUnmute::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionToggleGroupCallSetting::CONSTRUCTOR_ID => Self::ToggleGroupCallSetting(crate::types::ChannelAdminLogEventActionToggleGroupCallSetting::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantJoinByInvite::CONSTRUCTOR_ID => Self::ParticipantJoinByInvite(crate::types::ChannelAdminLogEventActionParticipantJoinByInvite::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionExportedInviteDelete::CONSTRUCTOR_ID => Self::ExportedInviteDelete(crate::types::ChannelAdminLogEventActionExportedInviteDelete::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionExportedInviteRevoke::CONSTRUCTOR_ID => Self::ExportedInviteRevoke(crate::types::ChannelAdminLogEventActionExportedInviteRevoke::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionExportedInviteEdit::CONSTRUCTOR_ID => Self::ExportedInviteEdit(crate::types::ChannelAdminLogEventActionExportedInviteEdit::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantVolume::CONSTRUCTOR_ID => Self::ParticipantVolume(crate::types::ChannelAdminLogEventActionParticipantVolume::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionChangeHistoryTtl::CONSTRUCTOR_ID => Self::ChangeHistoryTtl(crate::types::ChannelAdminLogEventActionChangeHistoryTtl::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionParticipantJoinByRequest::CONSTRUCTOR_ID => Self::ParticipantJoinByRequest(crate::types::ChannelAdminLogEventActionParticipantJoinByRequest::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionToggleNoForwards::CONSTRUCTOR_ID => Self::ToggleNoForwards(crate::types::ChannelAdminLogEventActionToggleNoForwards::deserialize(buf)?),
                crate::types::ChannelAdminLogEventActionSendMessage::CONSTRUCTOR_ID => Self::SendMessage(crate::types::ChannelAdminLogEventActionSendMessage::deserialize(buf)?),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeTitle> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeTitle) -> Self {
            ChannelAdminLogEventAction::ChangeTitle(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeAbout> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeAbout) -> Self {
            ChannelAdminLogEventAction::ChangeAbout(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeUsername> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeUsername) -> Self {
            ChannelAdminLogEventAction::ChangeUsername(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangePhoto> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangePhoto) -> Self {
            ChannelAdminLogEventAction::ChangePhoto(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionToggleInvites> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionToggleInvites) -> Self {
            ChannelAdminLogEventAction::ToggleInvites(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionToggleSignatures> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionToggleSignatures) -> Self {
            ChannelAdminLogEventAction::ToggleSignatures(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionUpdatePinned> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionUpdatePinned) -> Self {
            ChannelAdminLogEventAction::UpdatePinned(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionEditMessage> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionEditMessage) -> Self {
            ChannelAdminLogEventAction::EditMessage(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionDeleteMessage> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionDeleteMessage) -> Self {
            ChannelAdminLogEventAction::DeleteMessage(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantJoin> for ChannelAdminLogEventAction {
        fn from(_x: crate::types::ChannelAdminLogEventActionParticipantJoin) -> Self {
            ChannelAdminLogEventAction::ParticipantJoin
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantLeave> for ChannelAdminLogEventAction {
        fn from(_x: crate::types::ChannelAdminLogEventActionParticipantLeave) -> Self {
            ChannelAdminLogEventAction::ParticipantLeave
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantInvite>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantInvite) -> Self {
            ChannelAdminLogEventAction::ParticipantInvite(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantToggleBan>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantToggleBan) -> Self {
            ChannelAdminLogEventAction::ParticipantToggleBan(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantToggleAdmin>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantToggleAdmin) -> Self {
            ChannelAdminLogEventAction::ParticipantToggleAdmin(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeStickerSet> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeStickerSet) -> Self {
            ChannelAdminLogEventAction::ChangeStickerSet(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionTogglePreHistoryHidden) -> Self {
            ChannelAdminLogEventAction::TogglePreHistoryHidden(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionDefaultBannedRights>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionDefaultBannedRights) -> Self {
            ChannelAdminLogEventAction::DefaultBannedRights(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionStopPoll> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionStopPoll) -> Self {
            ChannelAdminLogEventAction::StopPoll(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeLinkedChat> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeLinkedChat) -> Self {
            ChannelAdminLogEventAction::ChangeLinkedChat(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeLocation> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeLocation) -> Self {
            ChannelAdminLogEventAction::ChangeLocation(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionToggleSlowMode> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionToggleSlowMode) -> Self {
            ChannelAdminLogEventAction::ToggleSlowMode(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionStartGroupCall> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionStartGroupCall) -> Self {
            ChannelAdminLogEventAction::StartGroupCall(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionDiscardGroupCall> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionDiscardGroupCall) -> Self {
            ChannelAdminLogEventAction::DiscardGroupCall(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantMute> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantMute) -> Self {
            ChannelAdminLogEventAction::ParticipantMute(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantUnmute>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantUnmute) -> Self {
            ChannelAdminLogEventAction::ParticipantUnmute(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionToggleGroupCallSetting>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionToggleGroupCallSetting) -> Self {
            ChannelAdminLogEventAction::ToggleGroupCallSetting(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantJoinByInvite>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantJoinByInvite) -> Self {
            ChannelAdminLogEventAction::ParticipantJoinByInvite(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionExportedInviteDelete>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionExportedInviteDelete) -> Self {
            ChannelAdminLogEventAction::ExportedInviteDelete(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionExportedInviteRevoke>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionExportedInviteRevoke) -> Self {
            ChannelAdminLogEventAction::ExportedInviteRevoke(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionExportedInviteEdit>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionExportedInviteEdit) -> Self {
            ChannelAdminLogEventAction::ExportedInviteEdit(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantVolume>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantVolume) -> Self {
            ChannelAdminLogEventAction::ParticipantVolume(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionChangeHistoryTtl> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionChangeHistoryTtl) -> Self {
            ChannelAdminLogEventAction::ChangeHistoryTtl(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionParticipantJoinByRequest>
        for ChannelAdminLogEventAction
    {
        fn from(x: crate::types::ChannelAdminLogEventActionParticipantJoinByRequest) -> Self {
            ChannelAdminLogEventAction::ParticipantJoinByRequest(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionToggleNoForwards> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionToggleNoForwards) -> Self {
            ChannelAdminLogEventAction::ToggleNoForwards(x)
        }
    }
    impl From<crate::types::ChannelAdminLogEventActionSendMessage> for ChannelAdminLogEventAction {
        fn from(x: crate::types::ChannelAdminLogEventActionSendMessage) -> Self {
            ChannelAdminLogEventAction::SendMessage(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelAdminLogEventsFilter {
        Filter(crate::types::ChannelAdminLogEventsFilter),
    }
    impl crate::Serializable for ChannelAdminLogEventsFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Filter(x) => {
                    crate::types::ChannelAdminLogEventsFilter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelAdminLogEventsFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelAdminLogEventsFilter::CONSTRUCTOR_ID => {
                    Self::Filter(crate::types::ChannelAdminLogEventsFilter::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelAdminLogEventsFilter> for ChannelAdminLogEventsFilter {
        fn from(x: crate::types::ChannelAdminLogEventsFilter) -> Self {
            ChannelAdminLogEventsFilter::Filter(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelLocation {
        Empty,
        Location(crate::types::ChannelLocation),
    }
    impl crate::Serializable for ChannelLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::ChannelLocationEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Location(x) => {
                    crate::types::ChannelLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelLocationEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::ChannelLocation::CONSTRUCTOR_ID => {
                    Self::Location(crate::types::ChannelLocation::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelLocationEmpty> for ChannelLocation {
        fn from(_x: crate::types::ChannelLocationEmpty) -> Self {
            ChannelLocation::Empty
        }
    }
    impl From<crate::types::ChannelLocation> for ChannelLocation {
        fn from(x: crate::types::ChannelLocation) -> Self {
            ChannelLocation::Location(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelMessagesFilter {
        Empty,
        Filter(crate::types::ChannelMessagesFilter),
    }
    impl crate::Serializable for ChannelMessagesFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::ChannelMessagesFilterEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Filter(x) => {
                    crate::types::ChannelMessagesFilter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelMessagesFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelMessagesFilterEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::ChannelMessagesFilter::CONSTRUCTOR_ID => {
                    Self::Filter(crate::types::ChannelMessagesFilter::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelMessagesFilterEmpty> for ChannelMessagesFilter {
        fn from(_x: crate::types::ChannelMessagesFilterEmpty) -> Self {
            ChannelMessagesFilter::Empty
        }
    }
    impl From<crate::types::ChannelMessagesFilter> for ChannelMessagesFilter {
        fn from(x: crate::types::ChannelMessagesFilter) -> Self {
            ChannelMessagesFilter::Filter(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelParticipant {
        Participant(crate::types::ChannelParticipant),
        ParticipantSelf(crate::types::ChannelParticipantSelf),
        Creator(crate::types::ChannelParticipantCreator),
        Admin(crate::types::ChannelParticipantAdmin),
        Banned(crate::types::ChannelParticipantBanned),
        Left(crate::types::ChannelParticipantLeft),
    }
    impl crate::Serializable for ChannelParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Participant(x) => {
                    crate::types::ChannelParticipant::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ParticipantSelf(x) => {
                    crate::types::ChannelParticipantSelf::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Creator(x) => {
                    crate::types::ChannelParticipantCreator::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Admin(x) => {
                    crate::types::ChannelParticipantAdmin::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Banned(x) => {
                    crate::types::ChannelParticipantBanned::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Left(x) => {
                    crate::types::ChannelParticipantLeft::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelParticipant::CONSTRUCTOR_ID => {
                    Self::Participant(crate::types::ChannelParticipant::deserialize(buf)?)
                }
                crate::types::ChannelParticipantSelf::CONSTRUCTOR_ID => {
                    Self::ParticipantSelf(crate::types::ChannelParticipantSelf::deserialize(buf)?)
                }
                crate::types::ChannelParticipantCreator::CONSTRUCTOR_ID => {
                    Self::Creator(crate::types::ChannelParticipantCreator::deserialize(buf)?)
                }
                crate::types::ChannelParticipantAdmin::CONSTRUCTOR_ID => {
                    Self::Admin(crate::types::ChannelParticipantAdmin::deserialize(buf)?)
                }
                crate::types::ChannelParticipantBanned::CONSTRUCTOR_ID => {
                    Self::Banned(crate::types::ChannelParticipantBanned::deserialize(buf)?)
                }
                crate::types::ChannelParticipantLeft::CONSTRUCTOR_ID => {
                    Self::Left(crate::types::ChannelParticipantLeft::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelParticipant> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipant) -> Self {
            ChannelParticipant::Participant(x)
        }
    }
    impl From<crate::types::ChannelParticipantSelf> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipantSelf) -> Self {
            ChannelParticipant::ParticipantSelf(x)
        }
    }
    impl From<crate::types::ChannelParticipantCreator> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipantCreator) -> Self {
            ChannelParticipant::Creator(x)
        }
    }
    impl From<crate::types::ChannelParticipantAdmin> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipantAdmin) -> Self {
            ChannelParticipant::Admin(x)
        }
    }
    impl From<crate::types::ChannelParticipantBanned> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipantBanned) -> Self {
            ChannelParticipant::Banned(x)
        }
    }
    impl From<crate::types::ChannelParticipantLeft> for ChannelParticipant {
        fn from(x: crate::types::ChannelParticipantLeft) -> Self {
            ChannelParticipant::Left(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChannelParticipantsFilter {
        ChannelParticipantsRecent,
        ChannelParticipantsAdmins,
        ChannelParticipantsKicked(crate::types::ChannelParticipantsKicked),
        ChannelParticipantsBots,
        ChannelParticipantsBanned(crate::types::ChannelParticipantsBanned),
        ChannelParticipantsSearch(crate::types::ChannelParticipantsSearch),
        ChannelParticipantsContacts(crate::types::ChannelParticipantsContacts),
        ChannelParticipantsMentions(crate::types::ChannelParticipantsMentions),
    }
    impl crate::Serializable for ChannelParticipantsFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::ChannelParticipantsRecent => {
                    crate::types::ChannelParticipantsRecent::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelParticipantsAdmins => {
                    crate::types::ChannelParticipantsAdmins::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelParticipantsKicked(x) => {
                    crate::types::ChannelParticipantsKicked::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelParticipantsBots => {
                    crate::types::ChannelParticipantsBots::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelParticipantsBanned(x) => {
                    crate::types::ChannelParticipantsBanned::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelParticipantsSearch(x) => {
                    crate::types::ChannelParticipantsSearch::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelParticipantsContacts(x) => {
                    crate::types::ChannelParticipantsContacts::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelParticipantsMentions(x) => {
                    crate::types::ChannelParticipantsMentions::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChannelParticipantsFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChannelParticipantsRecent::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsRecent
                }
                crate::types::ChannelParticipantsAdmins::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsAdmins
                }
                crate::types::ChannelParticipantsKicked::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsKicked(
                        crate::types::ChannelParticipantsKicked::deserialize(buf)?,
                    )
                }
                crate::types::ChannelParticipantsBots::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsBots
                }
                crate::types::ChannelParticipantsBanned::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsBanned(
                        crate::types::ChannelParticipantsBanned::deserialize(buf)?,
                    )
                }
                crate::types::ChannelParticipantsSearch::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsSearch(
                        crate::types::ChannelParticipantsSearch::deserialize(buf)?,
                    )
                }
                crate::types::ChannelParticipantsContacts::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsContacts(
                        crate::types::ChannelParticipantsContacts::deserialize(buf)?,
                    )
                }
                crate::types::ChannelParticipantsMentions::CONSTRUCTOR_ID => {
                    Self::ChannelParticipantsMentions(
                        crate::types::ChannelParticipantsMentions::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChannelParticipantsRecent> for ChannelParticipantsFilter {
        fn from(_x: crate::types::ChannelParticipantsRecent) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsRecent
        }
    }
    impl From<crate::types::ChannelParticipantsAdmins> for ChannelParticipantsFilter {
        fn from(_x: crate::types::ChannelParticipantsAdmins) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsAdmins
        }
    }
    impl From<crate::types::ChannelParticipantsKicked> for ChannelParticipantsFilter {
        fn from(x: crate::types::ChannelParticipantsKicked) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsKicked(x)
        }
    }
    impl From<crate::types::ChannelParticipantsBots> for ChannelParticipantsFilter {
        fn from(_x: crate::types::ChannelParticipantsBots) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsBots
        }
    }
    impl From<crate::types::ChannelParticipantsBanned> for ChannelParticipantsFilter {
        fn from(x: crate::types::ChannelParticipantsBanned) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsBanned(x)
        }
    }
    impl From<crate::types::ChannelParticipantsSearch> for ChannelParticipantsFilter {
        fn from(x: crate::types::ChannelParticipantsSearch) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsSearch(x)
        }
    }
    impl From<crate::types::ChannelParticipantsContacts> for ChannelParticipantsFilter {
        fn from(x: crate::types::ChannelParticipantsContacts) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsContacts(x)
        }
    }
    impl From<crate::types::ChannelParticipantsMentions> for ChannelParticipantsFilter {
        fn from(x: crate::types::ChannelParticipantsMentions) -> Self {
            ChannelParticipantsFilter::ChannelParticipantsMentions(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Chat {
        Empty(crate::types::ChatEmpty),
        Chat(crate::types::Chat),
        Forbidden(crate::types::ChatForbidden),
        Channel(crate::types::Channel),
        ChannelForbidden(crate::types::ChannelForbidden),
    }
    impl Chat {
        pub fn id(&self) -> i64 {
            match self {
                Self::Empty(i) => i.id,
                Self::Chat(i) => i.id,
                Self::Forbidden(i) => i.id,
                Self::Channel(i) => i.id,
                Self::ChannelForbidden(i) => i.id,
            }
        }
    }
    impl crate::Serializable for Chat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::ChatEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Chat(x) => {
                    crate::types::Chat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Forbidden(x) => {
                    crate::types::ChatForbidden::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Channel(x) => {
                    crate::types::Channel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelForbidden(x) => {
                    crate::types::ChannelForbidden::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Chat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::ChatEmpty::deserialize(buf)?)
                }
                crate::types::Chat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::Chat::deserialize(buf)?)
                }
                crate::types::ChatForbidden::CONSTRUCTOR_ID => {
                    Self::Forbidden(crate::types::ChatForbidden::deserialize(buf)?)
                }
                crate::types::Channel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::Channel::deserialize(buf)?)
                }
                crate::types::ChannelForbidden::CONSTRUCTOR_ID => {
                    Self::ChannelForbidden(crate::types::ChannelForbidden::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatEmpty> for Chat {
        fn from(x: crate::types::ChatEmpty) -> Self {
            Chat::Empty(x)
        }
    }
    impl From<crate::types::Chat> for Chat {
        fn from(x: crate::types::Chat) -> Self {
            Chat::Chat(x)
        }
    }
    impl From<crate::types::ChatForbidden> for Chat {
        fn from(x: crate::types::ChatForbidden) -> Self {
            Chat::Forbidden(x)
        }
    }
    impl From<crate::types::Channel> for Chat {
        fn from(x: crate::types::Channel) -> Self {
            Chat::Channel(x)
        }
    }
    impl From<crate::types::ChannelForbidden> for Chat {
        fn from(x: crate::types::ChannelForbidden) -> Self {
            Chat::ChannelForbidden(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatAdminRights {
        Rights(crate::types::ChatAdminRights),
    }
    impl crate::Serializable for ChatAdminRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Rights(x) => {
                    crate::types::ChatAdminRights::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatAdminRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatAdminRights::CONSTRUCTOR_ID => {
                    Self::Rights(crate::types::ChatAdminRights::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatAdminRights> for ChatAdminRights {
        fn from(x: crate::types::ChatAdminRights) -> Self {
            ChatAdminRights::Rights(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatAdminWithInvites {
        Invites(crate::types::ChatAdminWithInvites),
    }
    impl crate::Serializable for ChatAdminWithInvites {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Invites(x) => {
                    crate::types::ChatAdminWithInvites::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatAdminWithInvites {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatAdminWithInvites::CONSTRUCTOR_ID => {
                    Self::Invites(crate::types::ChatAdminWithInvites::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatAdminWithInvites> for ChatAdminWithInvites {
        fn from(x: crate::types::ChatAdminWithInvites) -> Self {
            ChatAdminWithInvites::Invites(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatBannedRights {
        Rights(crate::types::ChatBannedRights),
    }
    impl crate::Serializable for ChatBannedRights {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Rights(x) => {
                    crate::types::ChatBannedRights::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatBannedRights {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatBannedRights::CONSTRUCTOR_ID => {
                    Self::Rights(crate::types::ChatBannedRights::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatBannedRights> for ChatBannedRights {
        fn from(x: crate::types::ChatBannedRights) -> Self {
            ChatBannedRights::Rights(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatFull {
        Full(crate::types::ChatFull),
        ChannelFull(crate::types::ChannelFull),
    }
    impl ChatFull {
        pub fn about(&self) -> String {
            match self {
                Self::Full(i) => i.about.clone(),
                Self::ChannelFull(i) => i.about.clone(),
            }
        }
        pub fn id(&self) -> i64 {
            match self {
                Self::Full(i) => i.id,
                Self::ChannelFull(i) => i.id,
            }
        }
        pub fn notify_settings(&self) -> crate::enums::PeerNotifySettings {
            match self {
                Self::Full(i) => i.notify_settings.clone(),
                Self::ChannelFull(i) => i.notify_settings.clone(),
            }
        }
    }
    impl crate::Serializable for ChatFull {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Full(x) => {
                    crate::types::ChatFull::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelFull(x) => {
                    crate::types::ChannelFull::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatFull {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatFull::CONSTRUCTOR_ID => {
                    Self::Full(crate::types::ChatFull::deserialize(buf)?)
                }
                crate::types::ChannelFull::CONSTRUCTOR_ID => {
                    Self::ChannelFull(crate::types::ChannelFull::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatFull> for ChatFull {
        fn from(x: crate::types::ChatFull) -> Self {
            ChatFull::Full(x)
        }
    }
    impl From<crate::types::ChannelFull> for ChatFull {
        fn from(x: crate::types::ChannelFull) -> Self {
            ChatFull::ChannelFull(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatInvite {
        Already(crate::types::ChatInviteAlready),
        Invite(crate::types::ChatInvite),
        Peek(crate::types::ChatInvitePeek),
    }
    impl crate::Serializable for ChatInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Already(x) => {
                    crate::types::ChatInviteAlready::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Invite(x) => {
                    crate::types::ChatInvite::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Peek(x) => {
                    crate::types::ChatInvitePeek::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatInviteAlready::CONSTRUCTOR_ID => {
                    Self::Already(crate::types::ChatInviteAlready::deserialize(buf)?)
                }
                crate::types::ChatInvite::CONSTRUCTOR_ID => {
                    Self::Invite(crate::types::ChatInvite::deserialize(buf)?)
                }
                crate::types::ChatInvitePeek::CONSTRUCTOR_ID => {
                    Self::Peek(crate::types::ChatInvitePeek::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatInviteAlready> for ChatInvite {
        fn from(x: crate::types::ChatInviteAlready) -> Self {
            ChatInvite::Already(x)
        }
    }
    impl From<crate::types::ChatInvite> for ChatInvite {
        fn from(x: crate::types::ChatInvite) -> Self {
            ChatInvite::Invite(x)
        }
    }
    impl From<crate::types::ChatInvitePeek> for ChatInvite {
        fn from(x: crate::types::ChatInvitePeek) -> Self {
            ChatInvite::Peek(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatInviteImporter {
        Importer(crate::types::ChatInviteImporter),
    }
    impl crate::Serializable for ChatInviteImporter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Importer(x) => {
                    crate::types::ChatInviteImporter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatInviteImporter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatInviteImporter::CONSTRUCTOR_ID => {
                    Self::Importer(crate::types::ChatInviteImporter::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatInviteImporter> for ChatInviteImporter {
        fn from(x: crate::types::ChatInviteImporter) -> Self {
            ChatInviteImporter::Importer(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatOnlines {
        Onlines(crate::types::ChatOnlines),
    }
    impl crate::Serializable for ChatOnlines {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Onlines(x) => {
                    crate::types::ChatOnlines::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatOnlines {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatOnlines::CONSTRUCTOR_ID => {
                    Self::Onlines(crate::types::ChatOnlines::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatOnlines> for ChatOnlines {
        fn from(x: crate::types::ChatOnlines) -> Self {
            ChatOnlines::Onlines(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatParticipant {
        Participant(crate::types::ChatParticipant),
        Creator(crate::types::ChatParticipantCreator),
        Admin(crate::types::ChatParticipantAdmin),
    }
    impl ChatParticipant {
        pub fn user_id(&self) -> i64 {
            match self {
                Self::Participant(i) => i.user_id,
                Self::Creator(i) => i.user_id,
                Self::Admin(i) => i.user_id,
            }
        }
    }
    impl crate::Serializable for ChatParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Participant(x) => {
                    crate::types::ChatParticipant::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Creator(x) => {
                    crate::types::ChatParticipantCreator::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Admin(x) => {
                    crate::types::ChatParticipantAdmin::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatParticipant::CONSTRUCTOR_ID => {
                    Self::Participant(crate::types::ChatParticipant::deserialize(buf)?)
                }
                crate::types::ChatParticipantCreator::CONSTRUCTOR_ID => {
                    Self::Creator(crate::types::ChatParticipantCreator::deserialize(buf)?)
                }
                crate::types::ChatParticipantAdmin::CONSTRUCTOR_ID => {
                    Self::Admin(crate::types::ChatParticipantAdmin::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatParticipant> for ChatParticipant {
        fn from(x: crate::types::ChatParticipant) -> Self {
            ChatParticipant::Participant(x)
        }
    }
    impl From<crate::types::ChatParticipantCreator> for ChatParticipant {
        fn from(x: crate::types::ChatParticipantCreator) -> Self {
            ChatParticipant::Creator(x)
        }
    }
    impl From<crate::types::ChatParticipantAdmin> for ChatParticipant {
        fn from(x: crate::types::ChatParticipantAdmin) -> Self {
            ChatParticipant::Admin(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatParticipants {
        Forbidden(crate::types::ChatParticipantsForbidden),
        Participants(crate::types::ChatParticipants),
    }
    impl ChatParticipants {
        pub fn chat_id(&self) -> i64 {
            match self {
                Self::Forbidden(i) => i.chat_id,
                Self::Participants(i) => i.chat_id,
            }
        }
    }
    impl crate::Serializable for ChatParticipants {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Forbidden(x) => {
                    crate::types::ChatParticipantsForbidden::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Participants(x) => {
                    crate::types::ChatParticipants::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatParticipants {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatParticipantsForbidden::CONSTRUCTOR_ID => {
                    Self::Forbidden(crate::types::ChatParticipantsForbidden::deserialize(buf)?)
                }
                crate::types::ChatParticipants::CONSTRUCTOR_ID => {
                    Self::Participants(crate::types::ChatParticipants::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatParticipantsForbidden> for ChatParticipants {
        fn from(x: crate::types::ChatParticipantsForbidden) -> Self {
            ChatParticipants::Forbidden(x)
        }
    }
    impl From<crate::types::ChatParticipants> for ChatParticipants {
        fn from(x: crate::types::ChatParticipants) -> Self {
            ChatParticipants::Participants(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ChatPhoto {
        Empty,
        Photo(crate::types::ChatPhoto),
    }
    impl crate::Serializable for ChatPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::ChatPhotoEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Photo(x) => {
                    crate::types::ChatPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ChatPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatPhotoEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::ChatPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::ChatPhoto::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatPhotoEmpty> for ChatPhoto {
        fn from(_x: crate::types::ChatPhotoEmpty) -> Self {
            ChatPhoto::Empty
        }
    }
    impl From<crate::types::ChatPhoto> for ChatPhoto {
        fn from(x: crate::types::ChatPhoto) -> Self {
            ChatPhoto::Photo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ClientDhInnerData {
        Data(crate::types::ClientDhInnerData),
    }
    impl crate::Serializable for ClientDhInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Data(x) => {
                    crate::types::ClientDhInnerData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ClientDhInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ClientDhInnerData::CONSTRUCTOR_ID => {
                    Self::Data(crate::types::ClientDhInnerData::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ClientDhInnerData> for ClientDhInnerData {
        fn from(x: crate::types::ClientDhInnerData) -> Self {
            ClientDhInnerData::Data(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum CodeSettings {
        Settings(crate::types::CodeSettings),
    }
    impl crate::Serializable for CodeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::CodeSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for CodeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::CodeSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::CodeSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::CodeSettings> for CodeSettings {
        fn from(x: crate::types::CodeSettings) -> Self {
            CodeSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Config {
        Config(crate::types::Config),
    }
    impl crate::Serializable for Config {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Config(x) => {
                    crate::types::Config::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Config {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Config::CONSTRUCTOR_ID => {
                    Self::Config(crate::types::Config::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Config> for Config {
        fn from(x: crate::types::Config) -> Self {
            Config::Config(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Contact {
        Contact(crate::types::Contact),
    }
    impl crate::Serializable for Contact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Contact(x) => {
                    crate::types::Contact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Contact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Contact::CONSTRUCTOR_ID => {
                    Self::Contact(crate::types::Contact::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Contact> for Contact {
        fn from(x: crate::types::Contact) -> Self {
            Contact::Contact(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ContactStatus {
        Status(crate::types::ContactStatus),
    }
    impl crate::Serializable for ContactStatus {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Status(x) => {
                    crate::types::ContactStatus::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ContactStatus {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ContactStatus::CONSTRUCTOR_ID => {
                    Self::Status(crate::types::ContactStatus::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ContactStatus> for ContactStatus {
        fn from(x: crate::types::ContactStatus) -> Self {
            ContactStatus::Status(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DataJson {
        Json(crate::types::DataJson),
    }
    impl crate::Serializable for DataJson {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Json(x) => {
                    crate::types::DataJson::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DataJson {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DataJson::CONSTRUCTOR_ID => {
                    Self::Json(crate::types::DataJson::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DataJson> for DataJson {
        fn from(x: crate::types::DataJson) -> Self {
            DataJson::Json(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DcOption {
        Option(crate::types::DcOption),
    }
    impl crate::Serializable for DcOption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Option(x) => {
                    crate::types::DcOption::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DcOption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DcOption::CONSTRUCTOR_ID => {
                    Self::Option(crate::types::DcOption::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DcOption> for DcOption {
        fn from(x: crate::types::DcOption) -> Self {
            DcOption::Option(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DestroyAuthKeyRes {
        DestroyAuthKeyOk,
        DestroyAuthKeyNone,
        DestroyAuthKeyFail,
    }
    impl crate::Serializable for DestroyAuthKeyRes {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::DestroyAuthKeyOk => {
                    crate::types::DestroyAuthKeyOk::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::DestroyAuthKeyNone => {
                    crate::types::DestroyAuthKeyNone::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::DestroyAuthKeyFail => {
                    crate::types::DestroyAuthKeyFail::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for DestroyAuthKeyRes {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DestroyAuthKeyOk::CONSTRUCTOR_ID => Self::DestroyAuthKeyOk,
                crate::types::DestroyAuthKeyNone::CONSTRUCTOR_ID => Self::DestroyAuthKeyNone,
                crate::types::DestroyAuthKeyFail::CONSTRUCTOR_ID => Self::DestroyAuthKeyFail,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DestroyAuthKeyOk> for DestroyAuthKeyRes {
        fn from(_x: crate::types::DestroyAuthKeyOk) -> Self {
            DestroyAuthKeyRes::DestroyAuthKeyOk
        }
    }
    impl From<crate::types::DestroyAuthKeyNone> for DestroyAuthKeyRes {
        fn from(_x: crate::types::DestroyAuthKeyNone) -> Self {
            DestroyAuthKeyRes::DestroyAuthKeyNone
        }
    }
    impl From<crate::types::DestroyAuthKeyFail> for DestroyAuthKeyRes {
        fn from(_x: crate::types::DestroyAuthKeyFail) -> Self {
            DestroyAuthKeyRes::DestroyAuthKeyFail
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DestroySessionRes {
        DestroySessionOk(crate::types::DestroySessionOk),
        DestroySessionNone(crate::types::DestroySessionNone),
    }
    impl DestroySessionRes {
        pub fn session_id(&self) -> i64 {
            match self {
                Self::DestroySessionOk(i) => i.session_id,
                Self::DestroySessionNone(i) => i.session_id,
            }
        }
    }
    impl crate::Serializable for DestroySessionRes {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::DestroySessionOk(x) => {
                    crate::types::DestroySessionOk::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DestroySessionNone(x) => {
                    crate::types::DestroySessionNone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DestroySessionRes {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DestroySessionOk::CONSTRUCTOR_ID => {
                    Self::DestroySessionOk(crate::types::DestroySessionOk::deserialize(buf)?)
                }
                crate::types::DestroySessionNone::CONSTRUCTOR_ID => {
                    Self::DestroySessionNone(crate::types::DestroySessionNone::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DestroySessionOk> for DestroySessionRes {
        fn from(x: crate::types::DestroySessionOk) -> Self {
            DestroySessionRes::DestroySessionOk(x)
        }
    }
    impl From<crate::types::DestroySessionNone> for DestroySessionRes {
        fn from(x: crate::types::DestroySessionNone) -> Self {
            DestroySessionRes::DestroySessionNone(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Dialog {
        Dialog(crate::types::Dialog),
        Folder(crate::types::DialogFolder),
    }
    impl Dialog {
        pub fn pinned(&self) -> bool {
            match self {
                Self::Dialog(i) => i.pinned,
                Self::Folder(i) => i.pinned,
            }
        }
        pub fn peer(&self) -> crate::enums::Peer {
            match self {
                Self::Dialog(i) => i.peer.clone(),
                Self::Folder(i) => i.peer.clone(),
            }
        }
        pub fn top_message(&self) -> i32 {
            match self {
                Self::Dialog(i) => i.top_message,
                Self::Folder(i) => i.top_message,
            }
        }
    }
    impl crate::Serializable for Dialog {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Dialog(x) => {
                    crate::types::Dialog::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Folder(x) => {
                    crate::types::DialogFolder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Dialog {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Dialog::CONSTRUCTOR_ID => {
                    Self::Dialog(crate::types::Dialog::deserialize(buf)?)
                }
                crate::types::DialogFolder::CONSTRUCTOR_ID => {
                    Self::Folder(crate::types::DialogFolder::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Dialog> for Dialog {
        fn from(x: crate::types::Dialog) -> Self {
            Dialog::Dialog(x)
        }
    }
    impl From<crate::types::DialogFolder> for Dialog {
        fn from(x: crate::types::DialogFolder) -> Self {
            Dialog::Folder(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DialogFilter {
        Filter(crate::types::DialogFilter),
    }
    impl crate::Serializable for DialogFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Filter(x) => {
                    crate::types::DialogFilter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DialogFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DialogFilter::CONSTRUCTOR_ID => {
                    Self::Filter(crate::types::DialogFilter::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DialogFilter> for DialogFilter {
        fn from(x: crate::types::DialogFilter) -> Self {
            DialogFilter::Filter(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DialogFilterSuggested {
        Suggested(crate::types::DialogFilterSuggested),
    }
    impl crate::Serializable for DialogFilterSuggested {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Suggested(x) => {
                    crate::types::DialogFilterSuggested::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DialogFilterSuggested {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DialogFilterSuggested::CONSTRUCTOR_ID => {
                    Self::Suggested(crate::types::DialogFilterSuggested::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DialogFilterSuggested> for DialogFilterSuggested {
        fn from(x: crate::types::DialogFilterSuggested) -> Self {
            DialogFilterSuggested::Suggested(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DialogPeer {
        Peer(crate::types::DialogPeer),
        Folder(crate::types::DialogPeerFolder),
    }
    impl crate::Serializable for DialogPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::DialogPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Folder(x) => {
                    crate::types::DialogPeerFolder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DialogPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DialogPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::DialogPeer::deserialize(buf)?)
                }
                crate::types::DialogPeerFolder::CONSTRUCTOR_ID => {
                    Self::Folder(crate::types::DialogPeerFolder::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DialogPeer> for DialogPeer {
        fn from(x: crate::types::DialogPeer) -> Self {
            DialogPeer::Peer(x)
        }
    }
    impl From<crate::types::DialogPeerFolder> for DialogPeer {
        fn from(x: crate::types::DialogPeerFolder) -> Self {
            DialogPeer::Folder(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Document {
        Empty(crate::types::DocumentEmpty),
        Document(crate::types::Document),
    }
    impl Document {
        pub fn id(&self) -> i64 {
            match self {
                Self::Empty(i) => i.id,
                Self::Document(i) => i.id,
            }
        }
    }
    impl crate::Serializable for Document {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::DocumentEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Document(x) => {
                    crate::types::Document::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Document {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DocumentEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::DocumentEmpty::deserialize(buf)?)
                }
                crate::types::Document::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::Document::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DocumentEmpty> for Document {
        fn from(x: crate::types::DocumentEmpty) -> Self {
            Document::Empty(x)
        }
    }
    impl From<crate::types::Document> for Document {
        fn from(x: crate::types::Document) -> Self {
            Document::Document(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DocumentAttribute {
        ImageSize(crate::types::DocumentAttributeImageSize),
        Animated,
        Sticker(crate::types::DocumentAttributeSticker),
        Video(crate::types::DocumentAttributeVideo),
        Audio(crate::types::DocumentAttributeAudio),
        Filename(crate::types::DocumentAttributeFilename),
        HasStickers,
    }
    impl crate::Serializable for DocumentAttribute {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::ImageSize(x) => {
                    crate::types::DocumentAttributeImageSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Animated => {
                    crate::types::DocumentAttributeAnimated::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Sticker(x) => {
                    crate::types::DocumentAttributeSticker::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Video(x) => {
                    crate::types::DocumentAttributeVideo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Audio(x) => {
                    crate::types::DocumentAttributeAudio::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Filename(x) => {
                    crate::types::DocumentAttributeFilename::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::HasStickers => {
                    crate::types::DocumentAttributeHasStickers::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for DocumentAttribute {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DocumentAttributeImageSize::CONSTRUCTOR_ID => {
                    Self::ImageSize(crate::types::DocumentAttributeImageSize::deserialize(buf)?)
                }
                crate::types::DocumentAttributeAnimated::CONSTRUCTOR_ID => Self::Animated,
                crate::types::DocumentAttributeSticker::CONSTRUCTOR_ID => {
                    Self::Sticker(crate::types::DocumentAttributeSticker::deserialize(buf)?)
                }
                crate::types::DocumentAttributeVideo::CONSTRUCTOR_ID => {
                    Self::Video(crate::types::DocumentAttributeVideo::deserialize(buf)?)
                }
                crate::types::DocumentAttributeAudio::CONSTRUCTOR_ID => {
                    Self::Audio(crate::types::DocumentAttributeAudio::deserialize(buf)?)
                }
                crate::types::DocumentAttributeFilename::CONSTRUCTOR_ID => {
                    Self::Filename(crate::types::DocumentAttributeFilename::deserialize(buf)?)
                }
                crate::types::DocumentAttributeHasStickers::CONSTRUCTOR_ID => Self::HasStickers,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DocumentAttributeImageSize> for DocumentAttribute {
        fn from(x: crate::types::DocumentAttributeImageSize) -> Self {
            DocumentAttribute::ImageSize(x)
        }
    }
    impl From<crate::types::DocumentAttributeAnimated> for DocumentAttribute {
        fn from(_x: crate::types::DocumentAttributeAnimated) -> Self {
            DocumentAttribute::Animated
        }
    }
    impl From<crate::types::DocumentAttributeSticker> for DocumentAttribute {
        fn from(x: crate::types::DocumentAttributeSticker) -> Self {
            DocumentAttribute::Sticker(x)
        }
    }
    impl From<crate::types::DocumentAttributeVideo> for DocumentAttribute {
        fn from(x: crate::types::DocumentAttributeVideo) -> Self {
            DocumentAttribute::Video(x)
        }
    }
    impl From<crate::types::DocumentAttributeAudio> for DocumentAttribute {
        fn from(x: crate::types::DocumentAttributeAudio) -> Self {
            DocumentAttribute::Audio(x)
        }
    }
    impl From<crate::types::DocumentAttributeFilename> for DocumentAttribute {
        fn from(x: crate::types::DocumentAttributeFilename) -> Self {
            DocumentAttribute::Filename(x)
        }
    }
    impl From<crate::types::DocumentAttributeHasStickers> for DocumentAttribute {
        fn from(_x: crate::types::DocumentAttributeHasStickers) -> Self {
            DocumentAttribute::HasStickers
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum DraftMessage {
        Empty(crate::types::DraftMessageEmpty),
        Message(crate::types::DraftMessage),
    }
    impl crate::Serializable for DraftMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::DraftMessageEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Message(x) => {
                    crate::types::DraftMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for DraftMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DraftMessageEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::DraftMessageEmpty::deserialize(buf)?)
                }
                crate::types::DraftMessage::CONSTRUCTOR_ID => {
                    Self::Message(crate::types::DraftMessage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DraftMessageEmpty> for DraftMessage {
        fn from(x: crate::types::DraftMessageEmpty) -> Self {
            DraftMessage::Empty(x)
        }
    }
    impl From<crate::types::DraftMessage> for DraftMessage {
        fn from(x: crate::types::DraftMessage) -> Self {
            DraftMessage::Message(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EmojiKeyword {
        Keyword(crate::types::EmojiKeyword),
        Deleted(crate::types::EmojiKeywordDeleted),
    }
    impl EmojiKeyword {
        pub fn keyword(&self) -> String {
            match self {
                Self::Keyword(i) => i.keyword.clone(),
                Self::Deleted(i) => i.keyword.clone(),
            }
        }
        pub fn emoticons(&self) -> Vec<String> {
            match self {
                Self::Keyword(i) => i.emoticons.clone(),
                Self::Deleted(i) => i.emoticons.clone(),
            }
        }
    }
    impl crate::Serializable for EmojiKeyword {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Keyword(x) => {
                    crate::types::EmojiKeyword::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Deleted(x) => {
                    crate::types::EmojiKeywordDeleted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EmojiKeyword {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EmojiKeyword::CONSTRUCTOR_ID => {
                    Self::Keyword(crate::types::EmojiKeyword::deserialize(buf)?)
                }
                crate::types::EmojiKeywordDeleted::CONSTRUCTOR_ID => {
                    Self::Deleted(crate::types::EmojiKeywordDeleted::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EmojiKeyword> for EmojiKeyword {
        fn from(x: crate::types::EmojiKeyword) -> Self {
            EmojiKeyword::Keyword(x)
        }
    }
    impl From<crate::types::EmojiKeywordDeleted> for EmojiKeyword {
        fn from(x: crate::types::EmojiKeywordDeleted) -> Self {
            EmojiKeyword::Deleted(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EmojiKeywordsDifference {
        Difference(crate::types::EmojiKeywordsDifference),
    }
    impl crate::Serializable for EmojiKeywordsDifference {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Difference(x) => {
                    crate::types::EmojiKeywordsDifference::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EmojiKeywordsDifference {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EmojiKeywordsDifference::CONSTRUCTOR_ID => {
                    Self::Difference(crate::types::EmojiKeywordsDifference::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EmojiKeywordsDifference> for EmojiKeywordsDifference {
        fn from(x: crate::types::EmojiKeywordsDifference) -> Self {
            EmojiKeywordsDifference::Difference(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EmojiLanguage {
        Language(crate::types::EmojiLanguage),
    }
    impl crate::Serializable for EmojiLanguage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Language(x) => {
                    crate::types::EmojiLanguage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EmojiLanguage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EmojiLanguage::CONSTRUCTOR_ID => {
                    Self::Language(crate::types::EmojiLanguage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EmojiLanguage> for EmojiLanguage {
        fn from(x: crate::types::EmojiLanguage) -> Self {
            EmojiLanguage::Language(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EmojiUrl {
        Url(crate::types::EmojiUrl),
    }
    impl crate::Serializable for EmojiUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Url(x) => {
                    crate::types::EmojiUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EmojiUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EmojiUrl::CONSTRUCTOR_ID => {
                    Self::Url(crate::types::EmojiUrl::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EmojiUrl> for EmojiUrl {
        fn from(x: crate::types::EmojiUrl) -> Self {
            EmojiUrl::Url(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EncryptedChat {
        Empty(crate::types::EncryptedChatEmpty),
        Waiting(crate::types::EncryptedChatWaiting),
        Requested(crate::types::EncryptedChatRequested),
        Chat(crate::types::EncryptedChat),
        Discarded(crate::types::EncryptedChatDiscarded),
    }
    impl EncryptedChat {
        pub fn id(&self) -> i32 {
            match self {
                Self::Empty(i) => i.id,
                Self::Waiting(i) => i.id,
                Self::Requested(i) => i.id,
                Self::Chat(i) => i.id,
                Self::Discarded(i) => i.id,
            }
        }
    }
    impl crate::Serializable for EncryptedChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::EncryptedChatEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Waiting(x) => {
                    crate::types::EncryptedChatWaiting::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Requested(x) => {
                    crate::types::EncryptedChatRequested::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Chat(x) => {
                    crate::types::EncryptedChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Discarded(x) => {
                    crate::types::EncryptedChatDiscarded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EncryptedChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EncryptedChatEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::EncryptedChatEmpty::deserialize(buf)?)
                }
                crate::types::EncryptedChatWaiting::CONSTRUCTOR_ID => {
                    Self::Waiting(crate::types::EncryptedChatWaiting::deserialize(buf)?)
                }
                crate::types::EncryptedChatRequested::CONSTRUCTOR_ID => {
                    Self::Requested(crate::types::EncryptedChatRequested::deserialize(buf)?)
                }
                crate::types::EncryptedChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::EncryptedChat::deserialize(buf)?)
                }
                crate::types::EncryptedChatDiscarded::CONSTRUCTOR_ID => {
                    Self::Discarded(crate::types::EncryptedChatDiscarded::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EncryptedChatEmpty> for EncryptedChat {
        fn from(x: crate::types::EncryptedChatEmpty) -> Self {
            EncryptedChat::Empty(x)
        }
    }
    impl From<crate::types::EncryptedChatWaiting> for EncryptedChat {
        fn from(x: crate::types::EncryptedChatWaiting) -> Self {
            EncryptedChat::Waiting(x)
        }
    }
    impl From<crate::types::EncryptedChatRequested> for EncryptedChat {
        fn from(x: crate::types::EncryptedChatRequested) -> Self {
            EncryptedChat::Requested(x)
        }
    }
    impl From<crate::types::EncryptedChat> for EncryptedChat {
        fn from(x: crate::types::EncryptedChat) -> Self {
            EncryptedChat::Chat(x)
        }
    }
    impl From<crate::types::EncryptedChatDiscarded> for EncryptedChat {
        fn from(x: crate::types::EncryptedChatDiscarded) -> Self {
            EncryptedChat::Discarded(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EncryptedFile {
        Empty,
        File(crate::types::EncryptedFile),
    }
    impl crate::Serializable for EncryptedFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::EncryptedFileEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::File(x) => {
                    crate::types::EncryptedFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EncryptedFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EncryptedFileEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::EncryptedFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::EncryptedFile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EncryptedFileEmpty> for EncryptedFile {
        fn from(_x: crate::types::EncryptedFileEmpty) -> Self {
            EncryptedFile::Empty
        }
    }
    impl From<crate::types::EncryptedFile> for EncryptedFile {
        fn from(x: crate::types::EncryptedFile) -> Self {
            EncryptedFile::File(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum EncryptedMessage {
        Message(crate::types::EncryptedMessage),
        Service(crate::types::EncryptedMessageService),
    }
    impl EncryptedMessage {
        pub fn chat_id(&self) -> i32 {
            match self {
                Self::Message(i) => i.chat_id,
                Self::Service(i) => i.chat_id,
            }
        }
        pub fn date(&self) -> i32 {
            match self {
                Self::Message(i) => i.date,
                Self::Service(i) => i.date,
            }
        }
        pub fn bytes(&self) -> Vec<u8> {
            match self {
                Self::Message(i) => i.bytes.clone(),
                Self::Service(i) => i.bytes.clone(),
            }
        }
        pub fn random_id(&self) -> i64 {
            match self {
                Self::Message(i) => i.random_id,
                Self::Service(i) => i.random_id,
            }
        }
    }
    impl crate::Serializable for EncryptedMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Message(x) => {
                    crate::types::EncryptedMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Service(x) => {
                    crate::types::EncryptedMessageService::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for EncryptedMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::EncryptedMessage::CONSTRUCTOR_ID => {
                    Self::Message(crate::types::EncryptedMessage::deserialize(buf)?)
                }
                crate::types::EncryptedMessageService::CONSTRUCTOR_ID => {
                    Self::Service(crate::types::EncryptedMessageService::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::EncryptedMessage> for EncryptedMessage {
        fn from(x: crate::types::EncryptedMessage) -> Self {
            EncryptedMessage::Message(x)
        }
    }
    impl From<crate::types::EncryptedMessageService> for EncryptedMessage {
        fn from(x: crate::types::EncryptedMessageService) -> Self {
            EncryptedMessage::Service(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Error {
        Error(crate::types::Error),
    }
    impl crate::Serializable for Error {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Error(x) => {
                    crate::types::Error::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Error {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Error::CONSTRUCTOR_ID => {
                    Self::Error(crate::types::Error::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Error> for Error {
        fn from(x: crate::types::Error) -> Self {
            Error::Error(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ExportedChatInvite {
        ChatInviteExported(crate::types::ChatInviteExported),
    }
    impl crate::Serializable for ExportedChatInvite {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::ChatInviteExported(x) => {
                    crate::types::ChatInviteExported::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ExportedChatInvite {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ChatInviteExported::CONSTRUCTOR_ID => {
                    Self::ChatInviteExported(crate::types::ChatInviteExported::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ChatInviteExported> for ExportedChatInvite {
        fn from(x: crate::types::ChatInviteExported) -> Self {
            ExportedChatInvite::ChatInviteExported(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ExportedMessageLink {
        Link(crate::types::ExportedMessageLink),
    }
    impl crate::Serializable for ExportedMessageLink {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Link(x) => {
                    crate::types::ExportedMessageLink::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ExportedMessageLink {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ExportedMessageLink::CONSTRUCTOR_ID => {
                    Self::Link(crate::types::ExportedMessageLink::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ExportedMessageLink> for ExportedMessageLink {
        fn from(x: crate::types::ExportedMessageLink) -> Self {
            ExportedMessageLink::Link(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum FileHash {
        Hash(crate::types::FileHash),
    }
    impl crate::Serializable for FileHash {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Hash(x) => {
                    crate::types::FileHash::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for FileHash {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::FileHash::CONSTRUCTOR_ID => {
                    Self::Hash(crate::types::FileHash::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::FileHash> for FileHash {
        fn from(x: crate::types::FileHash) -> Self {
            FileHash::Hash(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Folder {
        Folder(crate::types::Folder),
    }
    impl crate::Serializable for Folder {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Folder(x) => {
                    crate::types::Folder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Folder {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Folder::CONSTRUCTOR_ID => {
                    Self::Folder(crate::types::Folder::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Folder> for Folder {
        fn from(x: crate::types::Folder) -> Self {
            Folder::Folder(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum FolderPeer {
        Peer(crate::types::FolderPeer),
    }
    impl crate::Serializable for FolderPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::FolderPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for FolderPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::FolderPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::FolderPeer::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::FolderPeer> for FolderPeer {
        fn from(x: crate::types::FolderPeer) -> Self {
            FolderPeer::Peer(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum FutureSalt {
        Salt(crate::types::FutureSalt),
    }
    impl crate::Serializable for FutureSalt {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Salt(x) => {
                    crate::types::FutureSalt::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for FutureSalt {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::FutureSalt::CONSTRUCTOR_ID => {
                    Self::Salt(crate::types::FutureSalt::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::FutureSalt> for FutureSalt {
        fn from(x: crate::types::FutureSalt) -> Self {
            FutureSalt::Salt(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum FutureSalts {
        Salts(crate::types::FutureSalts),
    }
    impl crate::Serializable for FutureSalts {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Salts(x) => {
                    crate::types::FutureSalts::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for FutureSalts {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::FutureSalts::CONSTRUCTOR_ID => {
                    Self::Salts(crate::types::FutureSalts::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::FutureSalts> for FutureSalts {
        fn from(x: crate::types::FutureSalts) -> Self {
            FutureSalts::Salts(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Game {
        Game(crate::types::Game),
    }
    impl crate::Serializable for Game {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Game(x) => {
                    crate::types::Game::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Game {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Game::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::Game::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Game> for Game {
        fn from(x: crate::types::Game) -> Self {
            Game::Game(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GeoPoint {
        Empty,
        Point(crate::types::GeoPoint),
    }
    impl crate::Serializable for GeoPoint {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::GeoPointEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Point(x) => {
                    crate::types::GeoPoint::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GeoPoint {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GeoPointEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::GeoPoint::CONSTRUCTOR_ID => {
                    Self::Point(crate::types::GeoPoint::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GeoPointEmpty> for GeoPoint {
        fn from(_x: crate::types::GeoPointEmpty) -> Self {
            GeoPoint::Empty
        }
    }
    impl From<crate::types::GeoPoint> for GeoPoint {
        fn from(x: crate::types::GeoPoint) -> Self {
            GeoPoint::Point(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GlobalPrivacySettings {
        Settings(crate::types::GlobalPrivacySettings),
    }
    impl crate::Serializable for GlobalPrivacySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::GlobalPrivacySettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GlobalPrivacySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GlobalPrivacySettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::GlobalPrivacySettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GlobalPrivacySettings> for GlobalPrivacySettings {
        fn from(x: crate::types::GlobalPrivacySettings) -> Self {
            GlobalPrivacySettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GroupCall {
        Discarded(crate::types::GroupCallDiscarded),
        Call(crate::types::GroupCall),
    }
    impl GroupCall {
        pub fn id(&self) -> i64 {
            match self {
                Self::Discarded(i) => i.id,
                Self::Call(i) => i.id,
            }
        }
        pub fn access_hash(&self) -> i64 {
            match self {
                Self::Discarded(i) => i.access_hash,
                Self::Call(i) => i.access_hash,
            }
        }
    }
    impl crate::Serializable for GroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Discarded(x) => {
                    crate::types::GroupCallDiscarded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Call(x) => {
                    crate::types::GroupCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GroupCallDiscarded::CONSTRUCTOR_ID => {
                    Self::Discarded(crate::types::GroupCallDiscarded::deserialize(buf)?)
                }
                crate::types::GroupCall::CONSTRUCTOR_ID => {
                    Self::Call(crate::types::GroupCall::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GroupCallDiscarded> for GroupCall {
        fn from(x: crate::types::GroupCallDiscarded) -> Self {
            GroupCall::Discarded(x)
        }
    }
    impl From<crate::types::GroupCall> for GroupCall {
        fn from(x: crate::types::GroupCall) -> Self {
            GroupCall::Call(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GroupCallParticipant {
        Participant(crate::types::GroupCallParticipant),
    }
    impl crate::Serializable for GroupCallParticipant {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Participant(x) => {
                    crate::types::GroupCallParticipant::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GroupCallParticipant {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GroupCallParticipant::CONSTRUCTOR_ID => {
                    Self::Participant(crate::types::GroupCallParticipant::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GroupCallParticipant> for GroupCallParticipant {
        fn from(x: crate::types::GroupCallParticipant) -> Self {
            GroupCallParticipant::Participant(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GroupCallParticipantVideo {
        Video(crate::types::GroupCallParticipantVideo),
    }
    impl crate::Serializable for GroupCallParticipantVideo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Video(x) => {
                    crate::types::GroupCallParticipantVideo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GroupCallParticipantVideo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GroupCallParticipantVideo::CONSTRUCTOR_ID => {
                    Self::Video(crate::types::GroupCallParticipantVideo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GroupCallParticipantVideo> for GroupCallParticipantVideo {
        fn from(x: crate::types::GroupCallParticipantVideo) -> Self {
            GroupCallParticipantVideo::Video(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum GroupCallParticipantVideoSourceGroup {
        Group(crate::types::GroupCallParticipantVideoSourceGroup),
    }
    impl crate::Serializable for GroupCallParticipantVideoSourceGroup {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Group(x) => {
                    crate::types::GroupCallParticipantVideoSourceGroup::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for GroupCallParticipantVideoSourceGroup {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::GroupCallParticipantVideoSourceGroup::CONSTRUCTOR_ID => Self::Group(
                    crate::types::GroupCallParticipantVideoSourceGroup::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::GroupCallParticipantVideoSourceGroup>
        for GroupCallParticipantVideoSourceGroup
    {
        fn from(x: crate::types::GroupCallParticipantVideoSourceGroup) -> Self {
            GroupCallParticipantVideoSourceGroup::Group(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum HighScore {
        Score(crate::types::HighScore),
    }
    impl crate::Serializable for HighScore {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Score(x) => {
                    crate::types::HighScore::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for HighScore {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::HighScore::CONSTRUCTOR_ID => {
                    Self::Score(crate::types::HighScore::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::HighScore> for HighScore {
        fn from(x: crate::types::HighScore) -> Self {
            HighScore::Score(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum HttpWait {
        Wait(crate::types::HttpWait),
    }
    impl crate::Serializable for HttpWait {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Wait(x) => {
                    crate::types::HttpWait::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for HttpWait {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::HttpWait::CONSTRUCTOR_ID => {
                    Self::Wait(crate::types::HttpWait::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::HttpWait> for HttpWait {
        fn from(x: crate::types::HttpWait) -> Self {
            HttpWait::Wait(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ImportedContact {
        Contact(crate::types::ImportedContact),
    }
    impl crate::Serializable for ImportedContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Contact(x) => {
                    crate::types::ImportedContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ImportedContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ImportedContact::CONSTRUCTOR_ID => {
                    Self::Contact(crate::types::ImportedContact::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ImportedContact> for ImportedContact {
        fn from(x: crate::types::ImportedContact) -> Self {
            ImportedContact::Contact(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InlineBotSwitchPm {
        Pm(crate::types::InlineBotSwitchPm),
    }
    impl crate::Serializable for InlineBotSwitchPm {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Pm(x) => {
                    crate::types::InlineBotSwitchPm::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InlineBotSwitchPm {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InlineBotSwitchPm::CONSTRUCTOR_ID => {
                    Self::Pm(crate::types::InlineBotSwitchPm::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InlineBotSwitchPm> for InlineBotSwitchPm {
        fn from(x: crate::types::InlineBotSwitchPm) -> Self {
            InlineBotSwitchPm::Pm(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InlineQueryPeerType {
        SameBotPm,
        Pm,
        Chat,
        Megagroup,
        Broadcast,
    }
    impl crate::Serializable for InlineQueryPeerType {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::SameBotPm => {
                    crate::types::InlineQueryPeerTypeSameBotPm::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Pm => {
                    crate::types::InlineQueryPeerTypePm::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Chat => {
                    crate::types::InlineQueryPeerTypeChat::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Megagroup => {
                    crate::types::InlineQueryPeerTypeMegagroup::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Broadcast => {
                    crate::types::InlineQueryPeerTypeBroadcast::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for InlineQueryPeerType {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InlineQueryPeerTypeSameBotPm::CONSTRUCTOR_ID => Self::SameBotPm,
                crate::types::InlineQueryPeerTypePm::CONSTRUCTOR_ID => Self::Pm,
                crate::types::InlineQueryPeerTypeChat::CONSTRUCTOR_ID => Self::Chat,
                crate::types::InlineQueryPeerTypeMegagroup::CONSTRUCTOR_ID => Self::Megagroup,
                crate::types::InlineQueryPeerTypeBroadcast::CONSTRUCTOR_ID => Self::Broadcast,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InlineQueryPeerTypeSameBotPm> for InlineQueryPeerType {
        fn from(_x: crate::types::InlineQueryPeerTypeSameBotPm) -> Self {
            InlineQueryPeerType::SameBotPm
        }
    }
    impl From<crate::types::InlineQueryPeerTypePm> for InlineQueryPeerType {
        fn from(_x: crate::types::InlineQueryPeerTypePm) -> Self {
            InlineQueryPeerType::Pm
        }
    }
    impl From<crate::types::InlineQueryPeerTypeChat> for InlineQueryPeerType {
        fn from(_x: crate::types::InlineQueryPeerTypeChat) -> Self {
            InlineQueryPeerType::Chat
        }
    }
    impl From<crate::types::InlineQueryPeerTypeMegagroup> for InlineQueryPeerType {
        fn from(_x: crate::types::InlineQueryPeerTypeMegagroup) -> Self {
            InlineQueryPeerType::Megagroup
        }
    }
    impl From<crate::types::InlineQueryPeerTypeBroadcast> for InlineQueryPeerType {
        fn from(_x: crate::types::InlineQueryPeerTypeBroadcast) -> Self {
            InlineQueryPeerType::Broadcast
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputAppEvent {
        Event(crate::types::InputAppEvent),
    }
    impl crate::Serializable for InputAppEvent {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Event(x) => {
                    crate::types::InputAppEvent::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputAppEvent {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputAppEvent::CONSTRUCTOR_ID => {
                    Self::Event(crate::types::InputAppEvent::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputAppEvent> for InputAppEvent {
        fn from(x: crate::types::InputAppEvent) -> Self {
            InputAppEvent::Event(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputBotInlineMessage {
        MediaAuto(crate::types::InputBotInlineMessageMediaAuto),
        Text(crate::types::InputBotInlineMessageText),
        MediaGeo(crate::types::InputBotInlineMessageMediaGeo),
        MediaVenue(crate::types::InputBotInlineMessageMediaVenue),
        MediaContact(crate::types::InputBotInlineMessageMediaContact),
        Game(crate::types::InputBotInlineMessageGame),
        MediaInvoice(crate::types::InputBotInlineMessageMediaInvoice),
    }
    impl crate::Serializable for InputBotInlineMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::MediaAuto(x) => {
                    crate::types::InputBotInlineMessageMediaAuto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Text(x) => {
                    crate::types::InputBotInlineMessageText::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaGeo(x) => {
                    crate::types::InputBotInlineMessageMediaGeo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaVenue(x) => {
                    crate::types::InputBotInlineMessageMediaVenue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaContact(x) => {
                    crate::types::InputBotInlineMessageMediaContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Game(x) => {
                    crate::types::InputBotInlineMessageGame::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MediaInvoice(x) => {
                    crate::types::InputBotInlineMessageMediaInvoice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputBotInlineMessageMediaAuto::CONSTRUCTOR_ID => Self::MediaAuto(
                    crate::types::InputBotInlineMessageMediaAuto::deserialize(buf)?,
                ),
                crate::types::InputBotInlineMessageText::CONSTRUCTOR_ID => {
                    Self::Text(crate::types::InputBotInlineMessageText::deserialize(buf)?)
                }
                crate::types::InputBotInlineMessageMediaGeo::CONSTRUCTOR_ID => Self::MediaGeo(
                    crate::types::InputBotInlineMessageMediaGeo::deserialize(buf)?,
                ),
                crate::types::InputBotInlineMessageMediaVenue::CONSTRUCTOR_ID => Self::MediaVenue(
                    crate::types::InputBotInlineMessageMediaVenue::deserialize(buf)?,
                ),
                crate::types::InputBotInlineMessageMediaContact::CONSTRUCTOR_ID => {
                    Self::MediaContact(
                        crate::types::InputBotInlineMessageMediaContact::deserialize(buf)?,
                    )
                }
                crate::types::InputBotInlineMessageGame::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::InputBotInlineMessageGame::deserialize(buf)?)
                }
                crate::types::InputBotInlineMessageMediaInvoice::CONSTRUCTOR_ID => {
                    Self::MediaInvoice(
                        crate::types::InputBotInlineMessageMediaInvoice::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputBotInlineMessageMediaAuto> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageMediaAuto) -> Self {
            InputBotInlineMessage::MediaAuto(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageText> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageText) -> Self {
            InputBotInlineMessage::Text(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageMediaGeo> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageMediaGeo) -> Self {
            InputBotInlineMessage::MediaGeo(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageMediaVenue> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageMediaVenue) -> Self {
            InputBotInlineMessage::MediaVenue(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageMediaContact> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageMediaContact) -> Self {
            InputBotInlineMessage::MediaContact(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageGame> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageGame) -> Self {
            InputBotInlineMessage::Game(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageMediaInvoice> for InputBotInlineMessage {
        fn from(x: crate::types::InputBotInlineMessageMediaInvoice) -> Self {
            InputBotInlineMessage::MediaInvoice(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputBotInlineMessageId {
        Id(crate::types::InputBotInlineMessageId),
        Id64(crate::types::InputBotInlineMessageId64),
    }
    impl InputBotInlineMessageId {
        pub fn dc_id(&self) -> i32 {
            match self {
                Self::Id(i) => i.dc_id,
                Self::Id64(i) => i.dc_id,
            }
        }
        pub fn access_hash(&self) -> i64 {
            match self {
                Self::Id(i) => i.access_hash,
                Self::Id64(i) => i.access_hash,
            }
        }
    }
    impl crate::Serializable for InputBotInlineMessageId {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Id(x) => {
                    crate::types::InputBotInlineMessageId::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Id64(x) => {
                    crate::types::InputBotInlineMessageId64::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputBotInlineMessageId {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputBotInlineMessageId::CONSTRUCTOR_ID => {
                    Self::Id(crate::types::InputBotInlineMessageId::deserialize(buf)?)
                }
                crate::types::InputBotInlineMessageId64::CONSTRUCTOR_ID => {
                    Self::Id64(crate::types::InputBotInlineMessageId64::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputBotInlineMessageId> for InputBotInlineMessageId {
        fn from(x: crate::types::InputBotInlineMessageId) -> Self {
            InputBotInlineMessageId::Id(x)
        }
    }
    impl From<crate::types::InputBotInlineMessageId64> for InputBotInlineMessageId {
        fn from(x: crate::types::InputBotInlineMessageId64) -> Self {
            InputBotInlineMessageId::Id64(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputBotInlineResult {
        Result(crate::types::InputBotInlineResult),
        Photo(crate::types::InputBotInlineResultPhoto),
        Document(crate::types::InputBotInlineResultDocument),
        Game(crate::types::InputBotInlineResultGame),
    }
    impl InputBotInlineResult {
        pub fn send_message(&self) -> crate::enums::InputBotInlineMessage {
            match self {
                Self::Result(i) => i.send_message.clone(),
                Self::Photo(i) => i.send_message.clone(),
                Self::Document(i) => i.send_message.clone(),
                Self::Game(i) => i.send_message.clone(),
            }
        }
        pub fn id(&self) -> String {
            match self {
                Self::Result(i) => i.id.clone(),
                Self::Photo(i) => i.id.clone(),
                Self::Document(i) => i.id.clone(),
                Self::Game(i) => i.id.clone(),
            }
        }
    }
    impl crate::Serializable for InputBotInlineResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Result(x) => {
                    crate::types::InputBotInlineResult::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Photo(x) => {
                    crate::types::InputBotInlineResultPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Document(x) => {
                    crate::types::InputBotInlineResultDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Game(x) => {
                    crate::types::InputBotInlineResultGame::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputBotInlineResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputBotInlineResult::CONSTRUCTOR_ID => {
                    Self::Result(crate::types::InputBotInlineResult::deserialize(buf)?)
                }
                crate::types::InputBotInlineResultPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::InputBotInlineResultPhoto::deserialize(buf)?)
                }
                crate::types::InputBotInlineResultDocument::CONSTRUCTOR_ID => Self::Document(
                    crate::types::InputBotInlineResultDocument::deserialize(buf)?,
                ),
                crate::types::InputBotInlineResultGame::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::InputBotInlineResultGame::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputBotInlineResult> for InputBotInlineResult {
        fn from(x: crate::types::InputBotInlineResult) -> Self {
            InputBotInlineResult::Result(x)
        }
    }
    impl From<crate::types::InputBotInlineResultPhoto> for InputBotInlineResult {
        fn from(x: crate::types::InputBotInlineResultPhoto) -> Self {
            InputBotInlineResult::Photo(x)
        }
    }
    impl From<crate::types::InputBotInlineResultDocument> for InputBotInlineResult {
        fn from(x: crate::types::InputBotInlineResultDocument) -> Self {
            InputBotInlineResult::Document(x)
        }
    }
    impl From<crate::types::InputBotInlineResultGame> for InputBotInlineResult {
        fn from(x: crate::types::InputBotInlineResultGame) -> Self {
            InputBotInlineResult::Game(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputChannel {
        Empty,
        Channel(crate::types::InputChannel),
        FromMessage(crate::types::InputChannelFromMessage),
    }
    impl crate::Serializable for InputChannel {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputChannelEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Channel(x) => {
                    crate::types::InputChannel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::FromMessage(x) => {
                    crate::types::InputChannelFromMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputChannel {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputChannelEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputChannel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::InputChannel::deserialize(buf)?)
                }
                crate::types::InputChannelFromMessage::CONSTRUCTOR_ID => {
                    Self::FromMessage(crate::types::InputChannelFromMessage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputChannelEmpty> for InputChannel {
        fn from(_x: crate::types::InputChannelEmpty) -> Self {
            InputChannel::Empty
        }
    }
    impl From<crate::types::InputChannel> for InputChannel {
        fn from(x: crate::types::InputChannel) -> Self {
            InputChannel::Channel(x)
        }
    }
    impl From<crate::types::InputChannelFromMessage> for InputChannel {
        fn from(x: crate::types::InputChannelFromMessage) -> Self {
            InputChannel::FromMessage(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputChatPhoto {
        Empty,
        InputChatUploadedPhoto(crate::types::InputChatUploadedPhoto),
        Photo(crate::types::InputChatPhoto),
    }
    impl crate::Serializable for InputChatPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputChatPhotoEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputChatUploadedPhoto(x) => {
                    crate::types::InputChatUploadedPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Photo(x) => {
                    crate::types::InputChatPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputChatPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputChatPhotoEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputChatUploadedPhoto::CONSTRUCTOR_ID => {
                    Self::InputChatUploadedPhoto(crate::types::InputChatUploadedPhoto::deserialize(
                        buf,
                    )?)
                }
                crate::types::InputChatPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::InputChatPhoto::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputChatPhotoEmpty> for InputChatPhoto {
        fn from(_x: crate::types::InputChatPhotoEmpty) -> Self {
            InputChatPhoto::Empty
        }
    }
    impl From<crate::types::InputChatUploadedPhoto> for InputChatPhoto {
        fn from(x: crate::types::InputChatUploadedPhoto) -> Self {
            InputChatPhoto::InputChatUploadedPhoto(x)
        }
    }
    impl From<crate::types::InputChatPhoto> for InputChatPhoto {
        fn from(x: crate::types::InputChatPhoto) -> Self {
            InputChatPhoto::Photo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputCheckPasswordSrp {
        InputCheckPasswordEmpty,
        Srp(crate::types::InputCheckPasswordSrp),
    }
    impl crate::Serializable for InputCheckPasswordSrp {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::InputCheckPasswordEmpty => {
                    crate::types::InputCheckPasswordEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Srp(x) => {
                    crate::types::InputCheckPasswordSrp::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputCheckPasswordSrp {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputCheckPasswordEmpty::CONSTRUCTOR_ID => {
                    Self::InputCheckPasswordEmpty
                }
                crate::types::InputCheckPasswordSrp::CONSTRUCTOR_ID => {
                    Self::Srp(crate::types::InputCheckPasswordSrp::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputCheckPasswordEmpty> for InputCheckPasswordSrp {
        fn from(_x: crate::types::InputCheckPasswordEmpty) -> Self {
            InputCheckPasswordSrp::InputCheckPasswordEmpty
        }
    }
    impl From<crate::types::InputCheckPasswordSrp> for InputCheckPasswordSrp {
        fn from(x: crate::types::InputCheckPasswordSrp) -> Self {
            InputCheckPasswordSrp::Srp(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputClientProxy {
        Proxy(crate::types::InputClientProxy),
    }
    impl crate::Serializable for InputClientProxy {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Proxy(x) => {
                    crate::types::InputClientProxy::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputClientProxy {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputClientProxy::CONSTRUCTOR_ID => {
                    Self::Proxy(crate::types::InputClientProxy::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputClientProxy> for InputClientProxy {
        fn from(x: crate::types::InputClientProxy) -> Self {
            InputClientProxy::Proxy(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputContact {
        InputPhoneContact(crate::types::InputPhoneContact),
    }
    impl crate::Serializable for InputContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::InputPhoneContact(x) => {
                    crate::types::InputPhoneContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPhoneContact::CONSTRUCTOR_ID => {
                    Self::InputPhoneContact(crate::types::InputPhoneContact::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPhoneContact> for InputContact {
        fn from(x: crate::types::InputPhoneContact) -> Self {
            InputContact::InputPhoneContact(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputDialogPeer {
        Peer(crate::types::InputDialogPeer),
        Folder(crate::types::InputDialogPeerFolder),
    }
    impl crate::Serializable for InputDialogPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::InputDialogPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Folder(x) => {
                    crate::types::InputDialogPeerFolder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputDialogPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputDialogPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::InputDialogPeer::deserialize(buf)?)
                }
                crate::types::InputDialogPeerFolder::CONSTRUCTOR_ID => {
                    Self::Folder(crate::types::InputDialogPeerFolder::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputDialogPeer> for InputDialogPeer {
        fn from(x: crate::types::InputDialogPeer) -> Self {
            InputDialogPeer::Peer(x)
        }
    }
    impl From<crate::types::InputDialogPeerFolder> for InputDialogPeer {
        fn from(x: crate::types::InputDialogPeerFolder) -> Self {
            InputDialogPeer::Folder(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputDocument {
        Empty,
        Document(crate::types::InputDocument),
    }
    impl crate::Serializable for InputDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputDocumentEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Document(x) => {
                    crate::types::InputDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputDocumentEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::InputDocument::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputDocumentEmpty> for InputDocument {
        fn from(_x: crate::types::InputDocumentEmpty) -> Self {
            InputDocument::Empty
        }
    }
    impl From<crate::types::InputDocument> for InputDocument {
        fn from(x: crate::types::InputDocument) -> Self {
            InputDocument::Document(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputEncryptedChat {
        Chat(crate::types::InputEncryptedChat),
    }
    impl crate::Serializable for InputEncryptedChat {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Chat(x) => {
                    crate::types::InputEncryptedChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputEncryptedChat {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputEncryptedChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::InputEncryptedChat::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputEncryptedChat> for InputEncryptedChat {
        fn from(x: crate::types::InputEncryptedChat) -> Self {
            InputEncryptedChat::Chat(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputEncryptedFile {
        Empty,
        Uploaded(crate::types::InputEncryptedFileUploaded),
        File(crate::types::InputEncryptedFile),
        BigUploaded(crate::types::InputEncryptedFileBigUploaded),
    }
    impl crate::Serializable for InputEncryptedFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputEncryptedFileEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Uploaded(x) => {
                    crate::types::InputEncryptedFileUploaded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::File(x) => {
                    crate::types::InputEncryptedFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BigUploaded(x) => {
                    crate::types::InputEncryptedFileBigUploaded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputEncryptedFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputEncryptedFileEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputEncryptedFileUploaded::CONSTRUCTOR_ID => {
                    Self::Uploaded(crate::types::InputEncryptedFileUploaded::deserialize(buf)?)
                }
                crate::types::InputEncryptedFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::InputEncryptedFile::deserialize(buf)?)
                }
                crate::types::InputEncryptedFileBigUploaded::CONSTRUCTOR_ID => Self::BigUploaded(
                    crate::types::InputEncryptedFileBigUploaded::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputEncryptedFileEmpty> for InputEncryptedFile {
        fn from(_x: crate::types::InputEncryptedFileEmpty) -> Self {
            InputEncryptedFile::Empty
        }
    }
    impl From<crate::types::InputEncryptedFileUploaded> for InputEncryptedFile {
        fn from(x: crate::types::InputEncryptedFileUploaded) -> Self {
            InputEncryptedFile::Uploaded(x)
        }
    }
    impl From<crate::types::InputEncryptedFile> for InputEncryptedFile {
        fn from(x: crate::types::InputEncryptedFile) -> Self {
            InputEncryptedFile::File(x)
        }
    }
    impl From<crate::types::InputEncryptedFileBigUploaded> for InputEncryptedFile {
        fn from(x: crate::types::InputEncryptedFileBigUploaded) -> Self {
            InputEncryptedFile::BigUploaded(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputFile {
        File(crate::types::InputFile),
        Big(crate::types::InputFileBig),
    }
    impl InputFile {
        pub fn parts(&self) -> i32 {
            match self {
                Self::File(i) => i.parts,
                Self::Big(i) => i.parts,
            }
        }
        pub fn id(&self) -> i64 {
            match self {
                Self::File(i) => i.id,
                Self::Big(i) => i.id,
            }
        }
        pub fn name(&self) -> String {
            match self {
                Self::File(i) => i.name.clone(),
                Self::Big(i) => i.name.clone(),
            }
        }
    }
    impl crate::Serializable for InputFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::File(x) => {
                    crate::types::InputFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Big(x) => {
                    crate::types::InputFileBig::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::InputFile::deserialize(buf)?)
                }
                crate::types::InputFileBig::CONSTRUCTOR_ID => {
                    Self::Big(crate::types::InputFileBig::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputFile> for InputFile {
        fn from(x: crate::types::InputFile) -> Self {
            InputFile::File(x)
        }
    }
    impl From<crate::types::InputFileBig> for InputFile {
        fn from(x: crate::types::InputFileBig) -> Self {
            InputFile::Big(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputFileLocation {
        Location(crate::types::InputFileLocation),
        InputEncryptedFileLocation(crate::types::InputEncryptedFileLocation),
        InputDocumentFileLocation(crate::types::InputDocumentFileLocation),
        InputSecureFileLocation(crate::types::InputSecureFileLocation),
        InputTakeoutFileLocation,
        InputPhotoFileLocation(crate::types::InputPhotoFileLocation),
        InputPhotoLegacyFileLocation(crate::types::InputPhotoLegacyFileLocation),
        InputPeerPhotoFileLocation(crate::types::InputPeerPhotoFileLocation),
        InputStickerSetThumb(crate::types::InputStickerSetThumb),
        InputGroupCallStream(crate::types::InputGroupCallStream),
    }
    impl crate::Serializable for InputFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Location(x) => {
                    crate::types::InputFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputEncryptedFileLocation(x) => {
                    crate::types::InputEncryptedFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputDocumentFileLocation(x) => {
                    crate::types::InputDocumentFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputSecureFileLocation(x) => {
                    crate::types::InputSecureFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputTakeoutFileLocation => {
                    crate::types::InputTakeoutFileLocation::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputPhotoFileLocation(x) => {
                    crate::types::InputPhotoFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputPhotoLegacyFileLocation(x) => {
                    crate::types::InputPhotoLegacyFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputPeerPhotoFileLocation(x) => {
                    crate::types::InputPeerPhotoFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputStickerSetThumb(x) => {
                    crate::types::InputStickerSetThumb::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputGroupCallStream(x) => {
                    crate::types::InputGroupCallStream::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputFileLocation::CONSTRUCTOR_ID => {
                    Self::Location(crate::types::InputFileLocation::deserialize(buf)?)
                }
                crate::types::InputEncryptedFileLocation::CONSTRUCTOR_ID => {
                    Self::InputEncryptedFileLocation(
                        crate::types::InputEncryptedFileLocation::deserialize(buf)?,
                    )
                }
                crate::types::InputDocumentFileLocation::CONSTRUCTOR_ID => {
                    Self::InputDocumentFileLocation(
                        crate::types::InputDocumentFileLocation::deserialize(buf)?,
                    )
                }
                crate::types::InputSecureFileLocation::CONSTRUCTOR_ID => {
                    Self::InputSecureFileLocation(
                        crate::types::InputSecureFileLocation::deserialize(buf)?,
                    )
                }
                crate::types::InputTakeoutFileLocation::CONSTRUCTOR_ID => {
                    Self::InputTakeoutFileLocation
                }
                crate::types::InputPhotoFileLocation::CONSTRUCTOR_ID => {
                    Self::InputPhotoFileLocation(crate::types::InputPhotoFileLocation::deserialize(
                        buf,
                    )?)
                }
                crate::types::InputPhotoLegacyFileLocation::CONSTRUCTOR_ID => {
                    Self::InputPhotoLegacyFileLocation(
                        crate::types::InputPhotoLegacyFileLocation::deserialize(buf)?,
                    )
                }
                crate::types::InputPeerPhotoFileLocation::CONSTRUCTOR_ID => {
                    Self::InputPeerPhotoFileLocation(
                        crate::types::InputPeerPhotoFileLocation::deserialize(buf)?,
                    )
                }
                crate::types::InputStickerSetThumb::CONSTRUCTOR_ID => Self::InputStickerSetThumb(
                    crate::types::InputStickerSetThumb::deserialize(buf)?,
                ),
                crate::types::InputGroupCallStream::CONSTRUCTOR_ID => Self::InputGroupCallStream(
                    crate::types::InputGroupCallStream::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputFileLocation) -> Self {
            InputFileLocation::Location(x)
        }
    }
    impl From<crate::types::InputEncryptedFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputEncryptedFileLocation) -> Self {
            InputFileLocation::InputEncryptedFileLocation(x)
        }
    }
    impl From<crate::types::InputDocumentFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputDocumentFileLocation) -> Self {
            InputFileLocation::InputDocumentFileLocation(x)
        }
    }
    impl From<crate::types::InputSecureFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputSecureFileLocation) -> Self {
            InputFileLocation::InputSecureFileLocation(x)
        }
    }
    impl From<crate::types::InputTakeoutFileLocation> for InputFileLocation {
        fn from(_x: crate::types::InputTakeoutFileLocation) -> Self {
            InputFileLocation::InputTakeoutFileLocation
        }
    }
    impl From<crate::types::InputPhotoFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputPhotoFileLocation) -> Self {
            InputFileLocation::InputPhotoFileLocation(x)
        }
    }
    impl From<crate::types::InputPhotoLegacyFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputPhotoLegacyFileLocation) -> Self {
            InputFileLocation::InputPhotoLegacyFileLocation(x)
        }
    }
    impl From<crate::types::InputPeerPhotoFileLocation> for InputFileLocation {
        fn from(x: crate::types::InputPeerPhotoFileLocation) -> Self {
            InputFileLocation::InputPeerPhotoFileLocation(x)
        }
    }
    impl From<crate::types::InputStickerSetThumb> for InputFileLocation {
        fn from(x: crate::types::InputStickerSetThumb) -> Self {
            InputFileLocation::InputStickerSetThumb(x)
        }
    }
    impl From<crate::types::InputGroupCallStream> for InputFileLocation {
        fn from(x: crate::types::InputGroupCallStream) -> Self {
            InputFileLocation::InputGroupCallStream(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputFolderPeer {
        Peer(crate::types::InputFolderPeer),
    }
    impl crate::Serializable for InputFolderPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::InputFolderPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputFolderPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputFolderPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::InputFolderPeer::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputFolderPeer> for InputFolderPeer {
        fn from(x: crate::types::InputFolderPeer) -> Self {
            InputFolderPeer::Peer(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputGame {
        Id(crate::types::InputGameId),
        ShortName(crate::types::InputGameShortName),
    }
    impl crate::Serializable for InputGame {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Id(x) => {
                    crate::types::InputGameId::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ShortName(x) => {
                    crate::types::InputGameShortName::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputGame {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputGameId::CONSTRUCTOR_ID => {
                    Self::Id(crate::types::InputGameId::deserialize(buf)?)
                }
                crate::types::InputGameShortName::CONSTRUCTOR_ID => {
                    Self::ShortName(crate::types::InputGameShortName::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputGameId> for InputGame {
        fn from(x: crate::types::InputGameId) -> Self {
            InputGame::Id(x)
        }
    }
    impl From<crate::types::InputGameShortName> for InputGame {
        fn from(x: crate::types::InputGameShortName) -> Self {
            InputGame::ShortName(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputGeoPoint {
        Empty,
        Point(crate::types::InputGeoPoint),
    }
    impl crate::Serializable for InputGeoPoint {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputGeoPointEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Point(x) => {
                    crate::types::InputGeoPoint::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputGeoPoint {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputGeoPointEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputGeoPoint::CONSTRUCTOR_ID => {
                    Self::Point(crate::types::InputGeoPoint::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputGeoPointEmpty> for InputGeoPoint {
        fn from(_x: crate::types::InputGeoPointEmpty) -> Self {
            InputGeoPoint::Empty
        }
    }
    impl From<crate::types::InputGeoPoint> for InputGeoPoint {
        fn from(x: crate::types::InputGeoPoint) -> Self {
            InputGeoPoint::Point(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputGroupCall {
        Call(crate::types::InputGroupCall),
    }
    impl crate::Serializable for InputGroupCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Call(x) => {
                    crate::types::InputGroupCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputGroupCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputGroupCall::CONSTRUCTOR_ID => {
                    Self::Call(crate::types::InputGroupCall::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputGroupCall> for InputGroupCall {
        fn from(x: crate::types::InputGroupCall) -> Self {
            InputGroupCall::Call(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputMedia {
        Empty,
        UploadedPhoto(crate::types::InputMediaUploadedPhoto),
        Photo(crate::types::InputMediaPhoto),
        GeoPoint(crate::types::InputMediaGeoPoint),
        Contact(crate::types::InputMediaContact),
        UploadedDocument(crate::types::InputMediaUploadedDocument),
        Document(crate::types::InputMediaDocument),
        Venue(crate::types::InputMediaVenue),
        PhotoExternal(crate::types::InputMediaPhotoExternal),
        DocumentExternal(crate::types::InputMediaDocumentExternal),
        Game(crate::types::InputMediaGame),
        Invoice(crate::types::InputMediaInvoice),
        GeoLive(crate::types::InputMediaGeoLive),
        Poll(crate::types::InputMediaPoll),
        Dice(crate::types::InputMediaDice),
    }
    impl crate::Serializable for InputMedia {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputMediaEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::UploadedPhoto(x) => {
                    crate::types::InputMediaUploadedPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Photo(x) => {
                    crate::types::InputMediaPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GeoPoint(x) => {
                    crate::types::InputMediaGeoPoint::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Contact(x) => {
                    crate::types::InputMediaContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UploadedDocument(x) => {
                    crate::types::InputMediaUploadedDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Document(x) => {
                    crate::types::InputMediaDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Venue(x) => {
                    crate::types::InputMediaVenue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhotoExternal(x) => {
                    crate::types::InputMediaPhotoExternal::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DocumentExternal(x) => {
                    crate::types::InputMediaDocumentExternal::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Game(x) => {
                    crate::types::InputMediaGame::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Invoice(x) => {
                    crate::types::InputMediaInvoice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GeoLive(x) => {
                    crate::types::InputMediaGeoLive::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Poll(x) => {
                    crate::types::InputMediaPoll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Dice(x) => {
                    crate::types::InputMediaDice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputMedia {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputMediaEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputMediaUploadedPhoto::CONSTRUCTOR_ID => {
                    Self::UploadedPhoto(crate::types::InputMediaUploadedPhoto::deserialize(buf)?)
                }
                crate::types::InputMediaPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::InputMediaPhoto::deserialize(buf)?)
                }
                crate::types::InputMediaGeoPoint::CONSTRUCTOR_ID => {
                    Self::GeoPoint(crate::types::InputMediaGeoPoint::deserialize(buf)?)
                }
                crate::types::InputMediaContact::CONSTRUCTOR_ID => {
                    Self::Contact(crate::types::InputMediaContact::deserialize(buf)?)
                }
                crate::types::InputMediaUploadedDocument::CONSTRUCTOR_ID => Self::UploadedDocument(
                    crate::types::InputMediaUploadedDocument::deserialize(buf)?,
                ),
                crate::types::InputMediaDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::InputMediaDocument::deserialize(buf)?)
                }
                crate::types::InputMediaVenue::CONSTRUCTOR_ID => {
                    Self::Venue(crate::types::InputMediaVenue::deserialize(buf)?)
                }
                crate::types::InputMediaPhotoExternal::CONSTRUCTOR_ID => {
                    Self::PhotoExternal(crate::types::InputMediaPhotoExternal::deserialize(buf)?)
                }
                crate::types::InputMediaDocumentExternal::CONSTRUCTOR_ID => Self::DocumentExternal(
                    crate::types::InputMediaDocumentExternal::deserialize(buf)?,
                ),
                crate::types::InputMediaGame::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::InputMediaGame::deserialize(buf)?)
                }
                crate::types::InputMediaInvoice::CONSTRUCTOR_ID => {
                    Self::Invoice(crate::types::InputMediaInvoice::deserialize(buf)?)
                }
                crate::types::InputMediaGeoLive::CONSTRUCTOR_ID => {
                    Self::GeoLive(crate::types::InputMediaGeoLive::deserialize(buf)?)
                }
                crate::types::InputMediaPoll::CONSTRUCTOR_ID => {
                    Self::Poll(crate::types::InputMediaPoll::deserialize(buf)?)
                }
                crate::types::InputMediaDice::CONSTRUCTOR_ID => {
                    Self::Dice(crate::types::InputMediaDice::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputMediaEmpty> for InputMedia {
        fn from(_x: crate::types::InputMediaEmpty) -> Self {
            InputMedia::Empty
        }
    }
    impl From<crate::types::InputMediaUploadedPhoto> for InputMedia {
        fn from(x: crate::types::InputMediaUploadedPhoto) -> Self {
            InputMedia::UploadedPhoto(x)
        }
    }
    impl From<crate::types::InputMediaPhoto> for InputMedia {
        fn from(x: crate::types::InputMediaPhoto) -> Self {
            InputMedia::Photo(x)
        }
    }
    impl From<crate::types::InputMediaGeoPoint> for InputMedia {
        fn from(x: crate::types::InputMediaGeoPoint) -> Self {
            InputMedia::GeoPoint(x)
        }
    }
    impl From<crate::types::InputMediaContact> for InputMedia {
        fn from(x: crate::types::InputMediaContact) -> Self {
            InputMedia::Contact(x)
        }
    }
    impl From<crate::types::InputMediaUploadedDocument> for InputMedia {
        fn from(x: crate::types::InputMediaUploadedDocument) -> Self {
            InputMedia::UploadedDocument(x)
        }
    }
    impl From<crate::types::InputMediaDocument> for InputMedia {
        fn from(x: crate::types::InputMediaDocument) -> Self {
            InputMedia::Document(x)
        }
    }
    impl From<crate::types::InputMediaVenue> for InputMedia {
        fn from(x: crate::types::InputMediaVenue) -> Self {
            InputMedia::Venue(x)
        }
    }
    impl From<crate::types::InputMediaPhotoExternal> for InputMedia {
        fn from(x: crate::types::InputMediaPhotoExternal) -> Self {
            InputMedia::PhotoExternal(x)
        }
    }
    impl From<crate::types::InputMediaDocumentExternal> for InputMedia {
        fn from(x: crate::types::InputMediaDocumentExternal) -> Self {
            InputMedia::DocumentExternal(x)
        }
    }
    impl From<crate::types::InputMediaGame> for InputMedia {
        fn from(x: crate::types::InputMediaGame) -> Self {
            InputMedia::Game(x)
        }
    }
    impl From<crate::types::InputMediaInvoice> for InputMedia {
        fn from(x: crate::types::InputMediaInvoice) -> Self {
            InputMedia::Invoice(x)
        }
    }
    impl From<crate::types::InputMediaGeoLive> for InputMedia {
        fn from(x: crate::types::InputMediaGeoLive) -> Self {
            InputMedia::GeoLive(x)
        }
    }
    impl From<crate::types::InputMediaPoll> for InputMedia {
        fn from(x: crate::types::InputMediaPoll) -> Self {
            InputMedia::Poll(x)
        }
    }
    impl From<crate::types::InputMediaDice> for InputMedia {
        fn from(x: crate::types::InputMediaDice) -> Self {
            InputMedia::Dice(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputMessage {
        Id(crate::types::InputMessageId),
        ReplyTo(crate::types::InputMessageReplyTo),
        Pinned,
        CallbackQuery(crate::types::InputMessageCallbackQuery),
    }
    impl crate::Serializable for InputMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Id(x) => {
                    crate::types::InputMessageId::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReplyTo(x) => {
                    crate::types::InputMessageReplyTo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Pinned => {
                    crate::types::InputMessagePinned::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::CallbackQuery(x) => {
                    crate::types::InputMessageCallbackQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputMessageId::CONSTRUCTOR_ID => {
                    Self::Id(crate::types::InputMessageId::deserialize(buf)?)
                }
                crate::types::InputMessageReplyTo::CONSTRUCTOR_ID => {
                    Self::ReplyTo(crate::types::InputMessageReplyTo::deserialize(buf)?)
                }
                crate::types::InputMessagePinned::CONSTRUCTOR_ID => Self::Pinned,
                crate::types::InputMessageCallbackQuery::CONSTRUCTOR_ID => {
                    Self::CallbackQuery(crate::types::InputMessageCallbackQuery::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputMessageId> for InputMessage {
        fn from(x: crate::types::InputMessageId) -> Self {
            InputMessage::Id(x)
        }
    }
    impl From<crate::types::InputMessageReplyTo> for InputMessage {
        fn from(x: crate::types::InputMessageReplyTo) -> Self {
            InputMessage::ReplyTo(x)
        }
    }
    impl From<crate::types::InputMessagePinned> for InputMessage {
        fn from(_x: crate::types::InputMessagePinned) -> Self {
            InputMessage::Pinned
        }
    }
    impl From<crate::types::InputMessageCallbackQuery> for InputMessage {
        fn from(x: crate::types::InputMessageCallbackQuery) -> Self {
            InputMessage::CallbackQuery(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputNotifyPeer {
        Peer(crate::types::InputNotifyPeer),
        InputNotifyUsers,
        InputNotifyChats,
        InputNotifyBroadcasts,
    }
    impl crate::Serializable for InputNotifyPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::InputNotifyPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputNotifyUsers => {
                    crate::types::InputNotifyUsers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputNotifyChats => {
                    crate::types::InputNotifyChats::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputNotifyBroadcasts => {
                    crate::types::InputNotifyBroadcasts::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for InputNotifyPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputNotifyPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::InputNotifyPeer::deserialize(buf)?)
                }
                crate::types::InputNotifyUsers::CONSTRUCTOR_ID => Self::InputNotifyUsers,
                crate::types::InputNotifyChats::CONSTRUCTOR_ID => Self::InputNotifyChats,
                crate::types::InputNotifyBroadcasts::CONSTRUCTOR_ID => Self::InputNotifyBroadcasts,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputNotifyPeer> for InputNotifyPeer {
        fn from(x: crate::types::InputNotifyPeer) -> Self {
            InputNotifyPeer::Peer(x)
        }
    }
    impl From<crate::types::InputNotifyUsers> for InputNotifyPeer {
        fn from(_x: crate::types::InputNotifyUsers) -> Self {
            InputNotifyPeer::InputNotifyUsers
        }
    }
    impl From<crate::types::InputNotifyChats> for InputNotifyPeer {
        fn from(_x: crate::types::InputNotifyChats) -> Self {
            InputNotifyPeer::InputNotifyChats
        }
    }
    impl From<crate::types::InputNotifyBroadcasts> for InputNotifyPeer {
        fn from(_x: crate::types::InputNotifyBroadcasts) -> Self {
            InputNotifyPeer::InputNotifyBroadcasts
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPaymentCredentials {
        Saved(crate::types::InputPaymentCredentialsSaved),
        Credentials(crate::types::InputPaymentCredentials),
        ApplePay(crate::types::InputPaymentCredentialsApplePay),
        GooglePay(crate::types::InputPaymentCredentialsGooglePay),
    }
    impl crate::Serializable for InputPaymentCredentials {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Saved(x) => {
                    crate::types::InputPaymentCredentialsSaved::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Credentials(x) => {
                    crate::types::InputPaymentCredentials::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ApplePay(x) => {
                    crate::types::InputPaymentCredentialsApplePay::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GooglePay(x) => {
                    crate::types::InputPaymentCredentialsGooglePay::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPaymentCredentials {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPaymentCredentialsSaved::CONSTRUCTOR_ID => Self::Saved(
                    crate::types::InputPaymentCredentialsSaved::deserialize(buf)?,
                ),
                crate::types::InputPaymentCredentials::CONSTRUCTOR_ID => {
                    Self::Credentials(crate::types::InputPaymentCredentials::deserialize(buf)?)
                }
                crate::types::InputPaymentCredentialsApplePay::CONSTRUCTOR_ID => Self::ApplePay(
                    crate::types::InputPaymentCredentialsApplePay::deserialize(buf)?,
                ),
                crate::types::InputPaymentCredentialsGooglePay::CONSTRUCTOR_ID => Self::GooglePay(
                    crate::types::InputPaymentCredentialsGooglePay::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPaymentCredentialsSaved> for InputPaymentCredentials {
        fn from(x: crate::types::InputPaymentCredentialsSaved) -> Self {
            InputPaymentCredentials::Saved(x)
        }
    }
    impl From<crate::types::InputPaymentCredentials> for InputPaymentCredentials {
        fn from(x: crate::types::InputPaymentCredentials) -> Self {
            InputPaymentCredentials::Credentials(x)
        }
    }
    impl From<crate::types::InputPaymentCredentialsApplePay> for InputPaymentCredentials {
        fn from(x: crate::types::InputPaymentCredentialsApplePay) -> Self {
            InputPaymentCredentials::ApplePay(x)
        }
    }
    impl From<crate::types::InputPaymentCredentialsGooglePay> for InputPaymentCredentials {
        fn from(x: crate::types::InputPaymentCredentialsGooglePay) -> Self {
            InputPaymentCredentials::GooglePay(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPeer {
        Empty,
        PeerSelf,
        Chat(crate::types::InputPeerChat),
        User(crate::types::InputPeerUser),
        Channel(crate::types::InputPeerChannel),
        UserFromMessage(Box<crate::types::InputPeerUserFromMessage>),
        ChannelFromMessage(Box<crate::types::InputPeerChannelFromMessage>),
    }
    impl crate::Serializable for InputPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputPeerEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PeerSelf => {
                    crate::types::InputPeerSelf::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Chat(x) => {
                    crate::types::InputPeerChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::User(x) => {
                    crate::types::InputPeerUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Channel(x) => {
                    crate::types::InputPeerChannel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserFromMessage(x) => {
                    crate::types::InputPeerUserFromMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelFromMessage(x) => {
                    crate::types::InputPeerChannelFromMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPeerEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputPeerSelf::CONSTRUCTOR_ID => Self::PeerSelf,
                crate::types::InputPeerChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::InputPeerChat::deserialize(buf)?)
                }
                crate::types::InputPeerUser::CONSTRUCTOR_ID => {
                    Self::User(crate::types::InputPeerUser::deserialize(buf)?)
                }
                crate::types::InputPeerChannel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::InputPeerChannel::deserialize(buf)?)
                }
                crate::types::InputPeerUserFromMessage::CONSTRUCTOR_ID => Self::UserFromMessage(
                    Box::new(crate::types::InputPeerUserFromMessage::deserialize(buf)?),
                ),
                crate::types::InputPeerChannelFromMessage::CONSTRUCTOR_ID => {
                    Self::ChannelFromMessage(Box::new(
                        crate::types::InputPeerChannelFromMessage::deserialize(buf)?,
                    ))
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPeerEmpty> for InputPeer {
        fn from(_x: crate::types::InputPeerEmpty) -> Self {
            InputPeer::Empty
        }
    }
    impl From<crate::types::InputPeerSelf> for InputPeer {
        fn from(_x: crate::types::InputPeerSelf) -> Self {
            InputPeer::PeerSelf
        }
    }
    impl From<crate::types::InputPeerChat> for InputPeer {
        fn from(x: crate::types::InputPeerChat) -> Self {
            InputPeer::Chat(x)
        }
    }
    impl From<crate::types::InputPeerUser> for InputPeer {
        fn from(x: crate::types::InputPeerUser) -> Self {
            InputPeer::User(x)
        }
    }
    impl From<crate::types::InputPeerChannel> for InputPeer {
        fn from(x: crate::types::InputPeerChannel) -> Self {
            InputPeer::Channel(x)
        }
    }
    impl From<crate::types::InputPeerUserFromMessage> for InputPeer {
        fn from(x: crate::types::InputPeerUserFromMessage) -> Self {
            InputPeer::UserFromMessage(Box::new(x))
        }
    }
    impl From<crate::types::InputPeerChannelFromMessage> for InputPeer {
        fn from(x: crate::types::InputPeerChannelFromMessage) -> Self {
            InputPeer::ChannelFromMessage(Box::new(x))
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPeerNotifySettings {
        Settings(crate::types::InputPeerNotifySettings),
    }
    impl crate::Serializable for InputPeerNotifySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::InputPeerNotifySettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPeerNotifySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPeerNotifySettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::InputPeerNotifySettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPeerNotifySettings> for InputPeerNotifySettings {
        fn from(x: crate::types::InputPeerNotifySettings) -> Self {
            InputPeerNotifySettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPhoneCall {
        Call(crate::types::InputPhoneCall),
    }
    impl crate::Serializable for InputPhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Call(x) => {
                    crate::types::InputPhoneCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPhoneCall::CONSTRUCTOR_ID => {
                    Self::Call(crate::types::InputPhoneCall::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPhoneCall> for InputPhoneCall {
        fn from(x: crate::types::InputPhoneCall) -> Self {
            InputPhoneCall::Call(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPhoto {
        Empty,
        Photo(crate::types::InputPhoto),
    }
    impl crate::Serializable for InputPhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputPhotoEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Photo(x) => {
                    crate::types::InputPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPhotoEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::InputPhoto::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPhotoEmpty> for InputPhoto {
        fn from(_x: crate::types::InputPhotoEmpty) -> Self {
            InputPhoto::Empty
        }
    }
    impl From<crate::types::InputPhoto> for InputPhoto {
        fn from(x: crate::types::InputPhoto) -> Self {
            InputPhoto::Photo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPrivacyKey {
        StatusTimestamp,
        ChatInvite,
        PhoneCall,
        PhoneP2P,
        Forwards,
        ProfilePhoto,
        PhoneNumber,
        AddedByPhone,
    }
    impl crate::Serializable for InputPrivacyKey {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::StatusTimestamp => {
                    crate::types::InputPrivacyKeyStatusTimestamp::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChatInvite => {
                    crate::types::InputPrivacyKeyChatInvite::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneCall => {
                    crate::types::InputPrivacyKeyPhoneCall::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneP2P => {
                    crate::types::InputPrivacyKeyPhoneP2P::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Forwards => {
                    crate::types::InputPrivacyKeyForwards::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ProfilePhoto => {
                    crate::types::InputPrivacyKeyProfilePhoto::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneNumber => {
                    crate::types::InputPrivacyKeyPhoneNumber::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::AddedByPhone => {
                    crate::types::InputPrivacyKeyAddedByPhone::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for InputPrivacyKey {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPrivacyKeyStatusTimestamp::CONSTRUCTOR_ID => {
                    Self::StatusTimestamp
                }
                crate::types::InputPrivacyKeyChatInvite::CONSTRUCTOR_ID => Self::ChatInvite,
                crate::types::InputPrivacyKeyPhoneCall::CONSTRUCTOR_ID => Self::PhoneCall,
                crate::types::InputPrivacyKeyPhoneP2P::CONSTRUCTOR_ID => Self::PhoneP2P,
                crate::types::InputPrivacyKeyForwards::CONSTRUCTOR_ID => Self::Forwards,
                crate::types::InputPrivacyKeyProfilePhoto::CONSTRUCTOR_ID => Self::ProfilePhoto,
                crate::types::InputPrivacyKeyPhoneNumber::CONSTRUCTOR_ID => Self::PhoneNumber,
                crate::types::InputPrivacyKeyAddedByPhone::CONSTRUCTOR_ID => Self::AddedByPhone,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPrivacyKeyStatusTimestamp> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyStatusTimestamp) -> Self {
            InputPrivacyKey::StatusTimestamp
        }
    }
    impl From<crate::types::InputPrivacyKeyChatInvite> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyChatInvite) -> Self {
            InputPrivacyKey::ChatInvite
        }
    }
    impl From<crate::types::InputPrivacyKeyPhoneCall> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyPhoneCall) -> Self {
            InputPrivacyKey::PhoneCall
        }
    }
    impl From<crate::types::InputPrivacyKeyPhoneP2P> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyPhoneP2P) -> Self {
            InputPrivacyKey::PhoneP2P
        }
    }
    impl From<crate::types::InputPrivacyKeyForwards> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyForwards) -> Self {
            InputPrivacyKey::Forwards
        }
    }
    impl From<crate::types::InputPrivacyKeyProfilePhoto> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyProfilePhoto) -> Self {
            InputPrivacyKey::ProfilePhoto
        }
    }
    impl From<crate::types::InputPrivacyKeyPhoneNumber> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyPhoneNumber) -> Self {
            InputPrivacyKey::PhoneNumber
        }
    }
    impl From<crate::types::InputPrivacyKeyAddedByPhone> for InputPrivacyKey {
        fn from(_x: crate::types::InputPrivacyKeyAddedByPhone) -> Self {
            InputPrivacyKey::AddedByPhone
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputPrivacyRule {
        InputPrivacyValueAllowContacts,
        InputPrivacyValueAllowAll,
        InputPrivacyValueAllowUsers(crate::types::InputPrivacyValueAllowUsers),
        InputPrivacyValueDisallowContacts,
        InputPrivacyValueDisallowAll,
        InputPrivacyValueDisallowUsers(crate::types::InputPrivacyValueDisallowUsers),
        InputPrivacyValueAllowChatParticipants(
            crate::types::InputPrivacyValueAllowChatParticipants,
        ),
        InputPrivacyValueDisallowChatParticipants(
            crate::types::InputPrivacyValueDisallowChatParticipants,
        ),
    }
    impl crate::Serializable for InputPrivacyRule {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::InputPrivacyValueAllowContacts => {
                    crate::types::InputPrivacyValueAllowContacts::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputPrivacyValueAllowAll => {
                    crate::types::InputPrivacyValueAllowAll::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputPrivacyValueAllowUsers(x) => {
                    crate::types::InputPrivacyValueAllowUsers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputPrivacyValueDisallowContacts => {
                    crate::types::InputPrivacyValueDisallowContacts::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputPrivacyValueDisallowAll => {
                    crate::types::InputPrivacyValueDisallowAll::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputPrivacyValueDisallowUsers(x) => {
                    crate::types::InputPrivacyValueDisallowUsers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputPrivacyValueAllowChatParticipants(x) => {
                    crate::types::InputPrivacyValueAllowChatParticipants::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::InputPrivacyValueDisallowChatParticipants(x) => {
                    crate::types::InputPrivacyValueDisallowChatParticipants::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputPrivacyRule {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputPrivacyValueAllowContacts::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueAllowContacts
                }
                crate::types::InputPrivacyValueAllowAll::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueAllowAll
                }
                crate::types::InputPrivacyValueAllowUsers::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueAllowUsers(
                        crate::types::InputPrivacyValueAllowUsers::deserialize(buf)?,
                    )
                }
                crate::types::InputPrivacyValueDisallowContacts::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueDisallowContacts
                }
                crate::types::InputPrivacyValueDisallowAll::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueDisallowAll
                }
                crate::types::InputPrivacyValueDisallowUsers::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueDisallowUsers(
                        crate::types::InputPrivacyValueDisallowUsers::deserialize(buf)?,
                    )
                }
                crate::types::InputPrivacyValueAllowChatParticipants::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueAllowChatParticipants(
                        crate::types::InputPrivacyValueAllowChatParticipants::deserialize(buf)?,
                    )
                }
                crate::types::InputPrivacyValueDisallowChatParticipants::CONSTRUCTOR_ID => {
                    Self::InputPrivacyValueDisallowChatParticipants(
                        crate::types::InputPrivacyValueDisallowChatParticipants::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputPrivacyValueAllowContacts> for InputPrivacyRule {
        fn from(_x: crate::types::InputPrivacyValueAllowContacts) -> Self {
            InputPrivacyRule::InputPrivacyValueAllowContacts
        }
    }
    impl From<crate::types::InputPrivacyValueAllowAll> for InputPrivacyRule {
        fn from(_x: crate::types::InputPrivacyValueAllowAll) -> Self {
            InputPrivacyRule::InputPrivacyValueAllowAll
        }
    }
    impl From<crate::types::InputPrivacyValueAllowUsers> for InputPrivacyRule {
        fn from(x: crate::types::InputPrivacyValueAllowUsers) -> Self {
            InputPrivacyRule::InputPrivacyValueAllowUsers(x)
        }
    }
    impl From<crate::types::InputPrivacyValueDisallowContacts> for InputPrivacyRule {
        fn from(_x: crate::types::InputPrivacyValueDisallowContacts) -> Self {
            InputPrivacyRule::InputPrivacyValueDisallowContacts
        }
    }
    impl From<crate::types::InputPrivacyValueDisallowAll> for InputPrivacyRule {
        fn from(_x: crate::types::InputPrivacyValueDisallowAll) -> Self {
            InputPrivacyRule::InputPrivacyValueDisallowAll
        }
    }
    impl From<crate::types::InputPrivacyValueDisallowUsers> for InputPrivacyRule {
        fn from(x: crate::types::InputPrivacyValueDisallowUsers) -> Self {
            InputPrivacyRule::InputPrivacyValueDisallowUsers(x)
        }
    }
    impl From<crate::types::InputPrivacyValueAllowChatParticipants> for InputPrivacyRule {
        fn from(x: crate::types::InputPrivacyValueAllowChatParticipants) -> Self {
            InputPrivacyRule::InputPrivacyValueAllowChatParticipants(x)
        }
    }
    impl From<crate::types::InputPrivacyValueDisallowChatParticipants> for InputPrivacyRule {
        fn from(x: crate::types::InputPrivacyValueDisallowChatParticipants) -> Self {
            InputPrivacyRule::InputPrivacyValueDisallowChatParticipants(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputSecureFile {
        Uploaded(crate::types::InputSecureFileUploaded),
        File(crate::types::InputSecureFile),
    }
    impl InputSecureFile {
        pub fn id(&self) -> i64 {
            match self {
                Self::Uploaded(i) => i.id,
                Self::File(i) => i.id,
            }
        }
    }
    impl crate::Serializable for InputSecureFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Uploaded(x) => {
                    crate::types::InputSecureFileUploaded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::File(x) => {
                    crate::types::InputSecureFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputSecureFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputSecureFileUploaded::CONSTRUCTOR_ID => {
                    Self::Uploaded(crate::types::InputSecureFileUploaded::deserialize(buf)?)
                }
                crate::types::InputSecureFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::InputSecureFile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputSecureFileUploaded> for InputSecureFile {
        fn from(x: crate::types::InputSecureFileUploaded) -> Self {
            InputSecureFile::Uploaded(x)
        }
    }
    impl From<crate::types::InputSecureFile> for InputSecureFile {
        fn from(x: crate::types::InputSecureFile) -> Self {
            InputSecureFile::File(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputSecureValue {
        Value(crate::types::InputSecureValue),
    }
    impl crate::Serializable for InputSecureValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Value(x) => {
                    crate::types::InputSecureValue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputSecureValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputSecureValue::CONSTRUCTOR_ID => {
                    Self::Value(crate::types::InputSecureValue::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputSecureValue> for InputSecureValue {
        fn from(x: crate::types::InputSecureValue) -> Self {
            InputSecureValue::Value(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputSingleMedia {
        Media(crate::types::InputSingleMedia),
    }
    impl crate::Serializable for InputSingleMedia {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Media(x) => {
                    crate::types::InputSingleMedia::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputSingleMedia {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputSingleMedia::CONSTRUCTOR_ID => {
                    Self::Media(crate::types::InputSingleMedia::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputSingleMedia> for InputSingleMedia {
        fn from(x: crate::types::InputSingleMedia) -> Self {
            InputSingleMedia::Media(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputStickerSet {
        Empty,
        Id(crate::types::InputStickerSetId),
        ShortName(crate::types::InputStickerSetShortName),
        AnimatedEmoji,
        Dice(crate::types::InputStickerSetDice),
        AnimatedEmojiAnimations,
    }
    impl crate::Serializable for InputStickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputStickerSetEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Id(x) => {
                    crate::types::InputStickerSetId::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ShortName(x) => {
                    crate::types::InputStickerSetShortName::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::AnimatedEmoji => {
                    crate::types::InputStickerSetAnimatedEmoji::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Dice(x) => {
                    crate::types::InputStickerSetDice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::AnimatedEmojiAnimations => {
                    crate::types::InputStickerSetAnimatedEmojiAnimations::CONSTRUCTOR_ID
                        .serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for InputStickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputStickerSetEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputStickerSetId::CONSTRUCTOR_ID => {
                    Self::Id(crate::types::InputStickerSetId::deserialize(buf)?)
                }
                crate::types::InputStickerSetShortName::CONSTRUCTOR_ID => {
                    Self::ShortName(crate::types::InputStickerSetShortName::deserialize(buf)?)
                }
                crate::types::InputStickerSetAnimatedEmoji::CONSTRUCTOR_ID => Self::AnimatedEmoji,
                crate::types::InputStickerSetDice::CONSTRUCTOR_ID => {
                    Self::Dice(crate::types::InputStickerSetDice::deserialize(buf)?)
                }
                crate::types::InputStickerSetAnimatedEmojiAnimations::CONSTRUCTOR_ID => {
                    Self::AnimatedEmojiAnimations
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputStickerSetEmpty> for InputStickerSet {
        fn from(_x: crate::types::InputStickerSetEmpty) -> Self {
            InputStickerSet::Empty
        }
    }
    impl From<crate::types::InputStickerSetId> for InputStickerSet {
        fn from(x: crate::types::InputStickerSetId) -> Self {
            InputStickerSet::Id(x)
        }
    }
    impl From<crate::types::InputStickerSetShortName> for InputStickerSet {
        fn from(x: crate::types::InputStickerSetShortName) -> Self {
            InputStickerSet::ShortName(x)
        }
    }
    impl From<crate::types::InputStickerSetAnimatedEmoji> for InputStickerSet {
        fn from(_x: crate::types::InputStickerSetAnimatedEmoji) -> Self {
            InputStickerSet::AnimatedEmoji
        }
    }
    impl From<crate::types::InputStickerSetDice> for InputStickerSet {
        fn from(x: crate::types::InputStickerSetDice) -> Self {
            InputStickerSet::Dice(x)
        }
    }
    impl From<crate::types::InputStickerSetAnimatedEmojiAnimations> for InputStickerSet {
        fn from(_x: crate::types::InputStickerSetAnimatedEmojiAnimations) -> Self {
            InputStickerSet::AnimatedEmojiAnimations
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputStickerSetItem {
        Item(crate::types::InputStickerSetItem),
    }
    impl crate::Serializable for InputStickerSetItem {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Item(x) => {
                    crate::types::InputStickerSetItem::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputStickerSetItem {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputStickerSetItem::CONSTRUCTOR_ID => {
                    Self::Item(crate::types::InputStickerSetItem::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputStickerSetItem> for InputStickerSetItem {
        fn from(x: crate::types::InputStickerSetItem) -> Self {
            InputStickerSetItem::Item(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputStickeredMedia {
        Photo(crate::types::InputStickeredMediaPhoto),
        Document(crate::types::InputStickeredMediaDocument),
    }
    impl crate::Serializable for InputStickeredMedia {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Photo(x) => {
                    crate::types::InputStickeredMediaPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Document(x) => {
                    crate::types::InputStickeredMediaDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputStickeredMedia {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputStickeredMediaPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::InputStickeredMediaPhoto::deserialize(buf)?)
                }
                crate::types::InputStickeredMediaDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::InputStickeredMediaDocument::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputStickeredMediaPhoto> for InputStickeredMedia {
        fn from(x: crate::types::InputStickeredMediaPhoto) -> Self {
            InputStickeredMedia::Photo(x)
        }
    }
    impl From<crate::types::InputStickeredMediaDocument> for InputStickeredMedia {
        fn from(x: crate::types::InputStickeredMediaDocument) -> Self {
            InputStickeredMedia::Document(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputTheme {
        Theme(crate::types::InputTheme),
        Slug(crate::types::InputThemeSlug),
    }
    impl crate::Serializable for InputTheme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Theme(x) => {
                    crate::types::InputTheme::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Slug(x) => {
                    crate::types::InputThemeSlug::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputTheme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputTheme::CONSTRUCTOR_ID => {
                    Self::Theme(crate::types::InputTheme::deserialize(buf)?)
                }
                crate::types::InputThemeSlug::CONSTRUCTOR_ID => {
                    Self::Slug(crate::types::InputThemeSlug::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputTheme> for InputTheme {
        fn from(x: crate::types::InputTheme) -> Self {
            InputTheme::Theme(x)
        }
    }
    impl From<crate::types::InputThemeSlug> for InputTheme {
        fn from(x: crate::types::InputThemeSlug) -> Self {
            InputTheme::Slug(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputThemeSettings {
        Settings(crate::types::InputThemeSettings),
    }
    impl crate::Serializable for InputThemeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::InputThemeSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputThemeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputThemeSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::InputThemeSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputThemeSettings> for InputThemeSettings {
        fn from(x: crate::types::InputThemeSettings) -> Self {
            InputThemeSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputUser {
        Empty,
        UserSelf,
        User(crate::types::InputUser),
        FromMessage(crate::types::InputUserFromMessage),
    }
    impl crate::Serializable for InputUser {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::InputUserEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::UserSelf => {
                    crate::types::InputUserSelf::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::User(x) => {
                    crate::types::InputUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::FromMessage(x) => {
                    crate::types::InputUserFromMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputUser {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputUserEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::InputUserSelf::CONSTRUCTOR_ID => Self::UserSelf,
                crate::types::InputUser::CONSTRUCTOR_ID => {
                    Self::User(crate::types::InputUser::deserialize(buf)?)
                }
                crate::types::InputUserFromMessage::CONSTRUCTOR_ID => {
                    Self::FromMessage(crate::types::InputUserFromMessage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputUserEmpty> for InputUser {
        fn from(_x: crate::types::InputUserEmpty) -> Self {
            InputUser::Empty
        }
    }
    impl From<crate::types::InputUserSelf> for InputUser {
        fn from(_x: crate::types::InputUserSelf) -> Self {
            InputUser::UserSelf
        }
    }
    impl From<crate::types::InputUser> for InputUser {
        fn from(x: crate::types::InputUser) -> Self {
            InputUser::User(x)
        }
    }
    impl From<crate::types::InputUserFromMessage> for InputUser {
        fn from(x: crate::types::InputUserFromMessage) -> Self {
            InputUser::FromMessage(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputWallPaper {
        Paper(crate::types::InputWallPaper),
        Slug(crate::types::InputWallPaperSlug),
        NoFile(crate::types::InputWallPaperNoFile),
    }
    impl crate::Serializable for InputWallPaper {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Paper(x) => {
                    crate::types::InputWallPaper::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Slug(x) => {
                    crate::types::InputWallPaperSlug::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NoFile(x) => {
                    crate::types::InputWallPaperNoFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputWallPaper {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputWallPaper::CONSTRUCTOR_ID => {
                    Self::Paper(crate::types::InputWallPaper::deserialize(buf)?)
                }
                crate::types::InputWallPaperSlug::CONSTRUCTOR_ID => {
                    Self::Slug(crate::types::InputWallPaperSlug::deserialize(buf)?)
                }
                crate::types::InputWallPaperNoFile::CONSTRUCTOR_ID => {
                    Self::NoFile(crate::types::InputWallPaperNoFile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputWallPaper> for InputWallPaper {
        fn from(x: crate::types::InputWallPaper) -> Self {
            InputWallPaper::Paper(x)
        }
    }
    impl From<crate::types::InputWallPaperSlug> for InputWallPaper {
        fn from(x: crate::types::InputWallPaperSlug) -> Self {
            InputWallPaper::Slug(x)
        }
    }
    impl From<crate::types::InputWallPaperNoFile> for InputWallPaper {
        fn from(x: crate::types::InputWallPaperNoFile) -> Self {
            InputWallPaper::NoFile(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputWebDocument {
        Document(crate::types::InputWebDocument),
    }
    impl crate::Serializable for InputWebDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Document(x) => {
                    crate::types::InputWebDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputWebDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputWebDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::InputWebDocument::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputWebDocument> for InputWebDocument {
        fn from(x: crate::types::InputWebDocument) -> Self {
            InputWebDocument::Document(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum InputWebFileLocation {
        Location(crate::types::InputWebFileLocation),
        InputWebFileGeoPointLocation(crate::types::InputWebFileGeoPointLocation),
    }
    impl InputWebFileLocation {
        pub fn access_hash(&self) -> i64 {
            match self {
                Self::Location(i) => i.access_hash,
                Self::InputWebFileGeoPointLocation(i) => i.access_hash,
            }
        }
    }
    impl crate::Serializable for InputWebFileLocation {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Location(x) => {
                    crate::types::InputWebFileLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputWebFileGeoPointLocation(x) => {
                    crate::types::InputWebFileGeoPointLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for InputWebFileLocation {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputWebFileLocation::CONSTRUCTOR_ID => {
                    Self::Location(crate::types::InputWebFileLocation::deserialize(buf)?)
                }
                crate::types::InputWebFileGeoPointLocation::CONSTRUCTOR_ID => {
                    Self::InputWebFileGeoPointLocation(
                        crate::types::InputWebFileGeoPointLocation::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputWebFileLocation> for InputWebFileLocation {
        fn from(x: crate::types::InputWebFileLocation) -> Self {
            InputWebFileLocation::Location(x)
        }
    }
    impl From<crate::types::InputWebFileGeoPointLocation> for InputWebFileLocation {
        fn from(x: crate::types::InputWebFileGeoPointLocation) -> Self {
            InputWebFileLocation::InputWebFileGeoPointLocation(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Invoice {
        Invoice(crate::types::Invoice),
    }
    impl crate::Serializable for Invoice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Invoice(x) => {
                    crate::types::Invoice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Invoice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Invoice::CONSTRUCTOR_ID => {
                    Self::Invoice(crate::types::Invoice::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Invoice> for Invoice {
        fn from(x: crate::types::Invoice) -> Self {
            Invoice::Invoice(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum IpPort {
        Port(crate::types::IpPort),
        Secret(crate::types::IpPortSecret),
    }
    impl IpPort {
        pub fn port(&self) -> i32 {
            match self {
                Self::Port(i) => i.port,
                Self::Secret(i) => i.port,
            }
        }
        pub fn ipv4(&self) -> i32 {
            match self {
                Self::Port(i) => i.ipv4,
                Self::Secret(i) => i.ipv4,
            }
        }
    }
    impl crate::Serializable for IpPort {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Port(x) => {
                    crate::types::IpPort::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Secret(x) => {
                    crate::types::IpPortSecret::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for IpPort {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::IpPort::CONSTRUCTOR_ID => {
                    Self::Port(crate::types::IpPort::deserialize(buf)?)
                }
                crate::types::IpPortSecret::CONSTRUCTOR_ID => {
                    Self::Secret(crate::types::IpPortSecret::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::IpPort> for IpPort {
        fn from(x: crate::types::IpPort) -> Self {
            IpPort::Port(x)
        }
    }
    impl From<crate::types::IpPortSecret> for IpPort {
        fn from(x: crate::types::IpPortSecret) -> Self {
            IpPort::Secret(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum JsonobjectValue {
        JsonObjectValue(crate::types::JsonObjectValue),
    }
    impl crate::Serializable for JsonobjectValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::JsonObjectValue(x) => {
                    crate::types::JsonObjectValue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for JsonobjectValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::JsonObjectValue::CONSTRUCTOR_ID => {
                    Self::JsonObjectValue(crate::types::JsonObjectValue::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::JsonObjectValue> for JsonobjectValue {
        fn from(x: crate::types::JsonObjectValue) -> Self {
            JsonobjectValue::JsonObjectValue(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Jsonvalue {
        JsonNull,
        JsonBool(crate::types::JsonBool),
        JsonNumber(crate::types::JsonNumber),
        JsonString(crate::types::JsonString),
        JsonArray(crate::types::JsonArray),
        JsonObject(crate::types::JsonObject),
    }
    impl crate::Serializable for Jsonvalue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::JsonNull => {
                    crate::types::JsonNull::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::JsonBool(x) => {
                    crate::types::JsonBool::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::JsonNumber(x) => {
                    crate::types::JsonNumber::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::JsonString(x) => {
                    crate::types::JsonString::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::JsonArray(x) => {
                    crate::types::JsonArray::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::JsonObject(x) => {
                    crate::types::JsonObject::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Jsonvalue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::JsonNull::CONSTRUCTOR_ID => Self::JsonNull,
                crate::types::JsonBool::CONSTRUCTOR_ID => {
                    Self::JsonBool(crate::types::JsonBool::deserialize(buf)?)
                }
                crate::types::JsonNumber::CONSTRUCTOR_ID => {
                    Self::JsonNumber(crate::types::JsonNumber::deserialize(buf)?)
                }
                crate::types::JsonString::CONSTRUCTOR_ID => {
                    Self::JsonString(crate::types::JsonString::deserialize(buf)?)
                }
                crate::types::JsonArray::CONSTRUCTOR_ID => {
                    Self::JsonArray(crate::types::JsonArray::deserialize(buf)?)
                }
                crate::types::JsonObject::CONSTRUCTOR_ID => {
                    Self::JsonObject(crate::types::JsonObject::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::JsonNull> for Jsonvalue {
        fn from(_x: crate::types::JsonNull) -> Self {
            Jsonvalue::JsonNull
        }
    }
    impl From<crate::types::JsonBool> for Jsonvalue {
        fn from(x: crate::types::JsonBool) -> Self {
            Jsonvalue::JsonBool(x)
        }
    }
    impl From<crate::types::JsonNumber> for Jsonvalue {
        fn from(x: crate::types::JsonNumber) -> Self {
            Jsonvalue::JsonNumber(x)
        }
    }
    impl From<crate::types::JsonString> for Jsonvalue {
        fn from(x: crate::types::JsonString) -> Self {
            Jsonvalue::JsonString(x)
        }
    }
    impl From<crate::types::JsonArray> for Jsonvalue {
        fn from(x: crate::types::JsonArray) -> Self {
            Jsonvalue::JsonArray(x)
        }
    }
    impl From<crate::types::JsonObject> for Jsonvalue {
        fn from(x: crate::types::JsonObject) -> Self {
            Jsonvalue::JsonObject(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum KeyboardButton {
        Button(crate::types::KeyboardButton),
        Url(crate::types::KeyboardButtonUrl),
        Callback(crate::types::KeyboardButtonCallback),
        RequestPhone(crate::types::KeyboardButtonRequestPhone),
        RequestGeoLocation(crate::types::KeyboardButtonRequestGeoLocation),
        SwitchInline(crate::types::KeyboardButtonSwitchInline),
        Game(crate::types::KeyboardButtonGame),
        Buy(crate::types::KeyboardButtonBuy),
        UrlAuth(crate::types::KeyboardButtonUrlAuth),
        InputKeyboardButtonUrlAuth(crate::types::InputKeyboardButtonUrlAuth),
        RequestPoll(crate::types::KeyboardButtonRequestPoll),
        InputKeyboardButtonUserProfile(crate::types::InputKeyboardButtonUserProfile),
        UserProfile(crate::types::KeyboardButtonUserProfile),
    }
    impl KeyboardButton {
        pub fn text(&self) -> String {
            match self {
                Self::Button(i) => i.text.clone(),
                Self::Url(i) => i.text.clone(),
                Self::Callback(i) => i.text.clone(),
                Self::RequestPhone(i) => i.text.clone(),
                Self::RequestGeoLocation(i) => i.text.clone(),
                Self::SwitchInline(i) => i.text.clone(),
                Self::Game(i) => i.text.clone(),
                Self::Buy(i) => i.text.clone(),
                Self::UrlAuth(i) => i.text.clone(),
                Self::InputKeyboardButtonUrlAuth(i) => i.text.clone(),
                Self::RequestPoll(i) => i.text.clone(),
                Self::InputKeyboardButtonUserProfile(i) => i.text.clone(),
                Self::UserProfile(i) => i.text.clone(),
            }
        }
    }
    impl crate::Serializable for KeyboardButton {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Button(x) => {
                    crate::types::KeyboardButton::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Url(x) => {
                    crate::types::KeyboardButtonUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Callback(x) => {
                    crate::types::KeyboardButtonCallback::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::RequestPhone(x) => {
                    crate::types::KeyboardButtonRequestPhone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::RequestGeoLocation(x) => {
                    crate::types::KeyboardButtonRequestGeoLocation::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SwitchInline(x) => {
                    crate::types::KeyboardButtonSwitchInline::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Game(x) => {
                    crate::types::KeyboardButtonGame::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Buy(x) => {
                    crate::types::KeyboardButtonBuy::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UrlAuth(x) => {
                    crate::types::KeyboardButtonUrlAuth::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputKeyboardButtonUrlAuth(x) => {
                    crate::types::InputKeyboardButtonUrlAuth::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::RequestPoll(x) => {
                    crate::types::KeyboardButtonRequestPoll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputKeyboardButtonUserProfile(x) => {
                    crate::types::InputKeyboardButtonUserProfile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserProfile(x) => {
                    crate::types::KeyboardButtonUserProfile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for KeyboardButton {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::KeyboardButton::CONSTRUCTOR_ID => {
                    Self::Button(crate::types::KeyboardButton::deserialize(buf)?)
                }
                crate::types::KeyboardButtonUrl::CONSTRUCTOR_ID => {
                    Self::Url(crate::types::KeyboardButtonUrl::deserialize(buf)?)
                }
                crate::types::KeyboardButtonCallback::CONSTRUCTOR_ID => {
                    Self::Callback(crate::types::KeyboardButtonCallback::deserialize(buf)?)
                }
                crate::types::KeyboardButtonRequestPhone::CONSTRUCTOR_ID => {
                    Self::RequestPhone(crate::types::KeyboardButtonRequestPhone::deserialize(buf)?)
                }
                crate::types::KeyboardButtonRequestGeoLocation::CONSTRUCTOR_ID => {
                    Self::RequestGeoLocation(
                        crate::types::KeyboardButtonRequestGeoLocation::deserialize(buf)?,
                    )
                }
                crate::types::KeyboardButtonSwitchInline::CONSTRUCTOR_ID => {
                    Self::SwitchInline(crate::types::KeyboardButtonSwitchInline::deserialize(buf)?)
                }
                crate::types::KeyboardButtonGame::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::KeyboardButtonGame::deserialize(buf)?)
                }
                crate::types::KeyboardButtonBuy::CONSTRUCTOR_ID => {
                    Self::Buy(crate::types::KeyboardButtonBuy::deserialize(buf)?)
                }
                crate::types::KeyboardButtonUrlAuth::CONSTRUCTOR_ID => {
                    Self::UrlAuth(crate::types::KeyboardButtonUrlAuth::deserialize(buf)?)
                }
                crate::types::InputKeyboardButtonUrlAuth::CONSTRUCTOR_ID => {
                    Self::InputKeyboardButtonUrlAuth(
                        crate::types::InputKeyboardButtonUrlAuth::deserialize(buf)?,
                    )
                }
                crate::types::KeyboardButtonRequestPoll::CONSTRUCTOR_ID => {
                    Self::RequestPoll(crate::types::KeyboardButtonRequestPoll::deserialize(buf)?)
                }
                crate::types::InputKeyboardButtonUserProfile::CONSTRUCTOR_ID => {
                    Self::InputKeyboardButtonUserProfile(
                        crate::types::InputKeyboardButtonUserProfile::deserialize(buf)?,
                    )
                }
                crate::types::KeyboardButtonUserProfile::CONSTRUCTOR_ID => {
                    Self::UserProfile(crate::types::KeyboardButtonUserProfile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::KeyboardButton> for KeyboardButton {
        fn from(x: crate::types::KeyboardButton) -> Self {
            KeyboardButton::Button(x)
        }
    }
    impl From<crate::types::KeyboardButtonUrl> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonUrl) -> Self {
            KeyboardButton::Url(x)
        }
    }
    impl From<crate::types::KeyboardButtonCallback> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonCallback) -> Self {
            KeyboardButton::Callback(x)
        }
    }
    impl From<crate::types::KeyboardButtonRequestPhone> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonRequestPhone) -> Self {
            KeyboardButton::RequestPhone(x)
        }
    }
    impl From<crate::types::KeyboardButtonRequestGeoLocation> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonRequestGeoLocation) -> Self {
            KeyboardButton::RequestGeoLocation(x)
        }
    }
    impl From<crate::types::KeyboardButtonSwitchInline> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonSwitchInline) -> Self {
            KeyboardButton::SwitchInline(x)
        }
    }
    impl From<crate::types::KeyboardButtonGame> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonGame) -> Self {
            KeyboardButton::Game(x)
        }
    }
    impl From<crate::types::KeyboardButtonBuy> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonBuy) -> Self {
            KeyboardButton::Buy(x)
        }
    }
    impl From<crate::types::KeyboardButtonUrlAuth> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonUrlAuth) -> Self {
            KeyboardButton::UrlAuth(x)
        }
    }
    impl From<crate::types::InputKeyboardButtonUrlAuth> for KeyboardButton {
        fn from(x: crate::types::InputKeyboardButtonUrlAuth) -> Self {
            KeyboardButton::InputKeyboardButtonUrlAuth(x)
        }
    }
    impl From<crate::types::KeyboardButtonRequestPoll> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonRequestPoll) -> Self {
            KeyboardButton::RequestPoll(x)
        }
    }
    impl From<crate::types::InputKeyboardButtonUserProfile> for KeyboardButton {
        fn from(x: crate::types::InputKeyboardButtonUserProfile) -> Self {
            KeyboardButton::InputKeyboardButtonUserProfile(x)
        }
    }
    impl From<crate::types::KeyboardButtonUserProfile> for KeyboardButton {
        fn from(x: crate::types::KeyboardButtonUserProfile) -> Self {
            KeyboardButton::UserProfile(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum KeyboardButtonRow {
        Row(crate::types::KeyboardButtonRow),
    }
    impl crate::Serializable for KeyboardButtonRow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Row(x) => {
                    crate::types::KeyboardButtonRow::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for KeyboardButtonRow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::KeyboardButtonRow::CONSTRUCTOR_ID => {
                    Self::Row(crate::types::KeyboardButtonRow::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::KeyboardButtonRow> for KeyboardButtonRow {
        fn from(x: crate::types::KeyboardButtonRow) -> Self {
            KeyboardButtonRow::Row(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum LabeledPrice {
        Price(crate::types::LabeledPrice),
    }
    impl crate::Serializable for LabeledPrice {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Price(x) => {
                    crate::types::LabeledPrice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for LabeledPrice {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::LabeledPrice::CONSTRUCTOR_ID => {
                    Self::Price(crate::types::LabeledPrice::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::LabeledPrice> for LabeledPrice {
        fn from(x: crate::types::LabeledPrice) -> Self {
            LabeledPrice::Price(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum LangPackDifference {
        Difference(crate::types::LangPackDifference),
    }
    impl crate::Serializable for LangPackDifference {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Difference(x) => {
                    crate::types::LangPackDifference::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for LangPackDifference {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::LangPackDifference::CONSTRUCTOR_ID => {
                    Self::Difference(crate::types::LangPackDifference::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::LangPackDifference> for LangPackDifference {
        fn from(x: crate::types::LangPackDifference) -> Self {
            LangPackDifference::Difference(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum LangPackLanguage {
        Language(crate::types::LangPackLanguage),
    }
    impl crate::Serializable for LangPackLanguage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Language(x) => {
                    crate::types::LangPackLanguage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for LangPackLanguage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::LangPackLanguage::CONSTRUCTOR_ID => {
                    Self::Language(crate::types::LangPackLanguage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::LangPackLanguage> for LangPackLanguage {
        fn from(x: crate::types::LangPackLanguage) -> Self {
            LangPackLanguage::Language(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum LangPackString {
        String(crate::types::LangPackString),
        Pluralized(crate::types::LangPackStringPluralized),
        Deleted(crate::types::LangPackStringDeleted),
    }
    impl LangPackString {
        pub fn key(&self) -> String {
            match self {
                Self::String(i) => i.key.clone(),
                Self::Pluralized(i) => i.key.clone(),
                Self::Deleted(i) => i.key.clone(),
            }
        }
    }
    impl crate::Serializable for LangPackString {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::String(x) => {
                    crate::types::LangPackString::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Pluralized(x) => {
                    crate::types::LangPackStringPluralized::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Deleted(x) => {
                    crate::types::LangPackStringDeleted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for LangPackString {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::LangPackString::CONSTRUCTOR_ID => {
                    Self::String(crate::types::LangPackString::deserialize(buf)?)
                }
                crate::types::LangPackStringPluralized::CONSTRUCTOR_ID => {
                    Self::Pluralized(crate::types::LangPackStringPluralized::deserialize(buf)?)
                }
                crate::types::LangPackStringDeleted::CONSTRUCTOR_ID => {
                    Self::Deleted(crate::types::LangPackStringDeleted::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::LangPackString> for LangPackString {
        fn from(x: crate::types::LangPackString) -> Self {
            LangPackString::String(x)
        }
    }
    impl From<crate::types::LangPackStringPluralized> for LangPackString {
        fn from(x: crate::types::LangPackStringPluralized) -> Self {
            LangPackString::Pluralized(x)
        }
    }
    impl From<crate::types::LangPackStringDeleted> for LangPackString {
        fn from(x: crate::types::LangPackStringDeleted) -> Self {
            LangPackString::Deleted(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MaskCoords {
        Coords(crate::types::MaskCoords),
    }
    impl crate::Serializable for MaskCoords {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Coords(x) => {
                    crate::types::MaskCoords::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MaskCoords {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MaskCoords::CONSTRUCTOR_ID => {
                    Self::Coords(crate::types::MaskCoords::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MaskCoords> for MaskCoords {
        fn from(x: crate::types::MaskCoords) -> Self {
            MaskCoords::Coords(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Message {
        Empty(crate::types::MessageEmpty),
        Message(crate::types::Message),
        Service(crate::types::MessageService),
    }
    impl Message {
        pub fn id(&self) -> i32 {
            match self {
                Self::Empty(i) => i.id,
                Self::Message(i) => i.id,
                Self::Service(i) => i.id,
            }
        }
    }
    impl crate::Serializable for Message {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::MessageEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Message(x) => {
                    crate::types::Message::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Service(x) => {
                    crate::types::MessageService::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Message {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::MessageEmpty::deserialize(buf)?)
                }
                crate::types::Message::CONSTRUCTOR_ID => {
                    Self::Message(crate::types::Message::deserialize(buf)?)
                }
                crate::types::MessageService::CONSTRUCTOR_ID => {
                    Self::Service(crate::types::MessageService::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageEmpty> for Message {
        fn from(x: crate::types::MessageEmpty) -> Self {
            Message::Empty(x)
        }
    }
    impl From<crate::types::Message> for Message {
        fn from(x: crate::types::Message) -> Self {
            Message::Message(x)
        }
    }
    impl From<crate::types::MessageService> for Message {
        fn from(x: crate::types::MessageService) -> Self {
            Message::Service(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageAction {
        Empty,
        ChatCreate(crate::types::MessageActionChatCreate),
        ChatEditTitle(crate::types::MessageActionChatEditTitle),
        ChatEditPhoto(crate::types::MessageActionChatEditPhoto),
        ChatDeletePhoto,
        ChatAddUser(crate::types::MessageActionChatAddUser),
        ChatDeleteUser(crate::types::MessageActionChatDeleteUser),
        ChatJoinedByLink(crate::types::MessageActionChatJoinedByLink),
        ChannelCreate(crate::types::MessageActionChannelCreate),
        ChatMigrateTo(crate::types::MessageActionChatMigrateTo),
        ChannelMigrateFrom(crate::types::MessageActionChannelMigrateFrom),
        PinMessage,
        HistoryClear,
        GameScore(crate::types::MessageActionGameScore),
        PaymentSentMe(crate::types::MessageActionPaymentSentMe),
        PaymentSent(crate::types::MessageActionPaymentSent),
        PhoneCall(crate::types::MessageActionPhoneCall),
        ScreenshotTaken,
        CustomAction(crate::types::MessageActionCustomAction),
        BotAllowed(crate::types::MessageActionBotAllowed),
        SecureValuesSentMe(crate::types::MessageActionSecureValuesSentMe),
        SecureValuesSent(crate::types::MessageActionSecureValuesSent),
        ContactSignUp,
        GeoProximityReached(crate::types::MessageActionGeoProximityReached),
        GroupCall(crate::types::MessageActionGroupCall),
        InviteToGroupCall(crate::types::MessageActionInviteToGroupCall),
        SetMessagesTtl(crate::types::MessageActionSetMessagesTtl),
        GroupCallScheduled(crate::types::MessageActionGroupCallScheduled),
        SetChatTheme(crate::types::MessageActionSetChatTheme),
        ChatJoinedByRequest,
    }
    impl crate::Serializable for MessageAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::MessageActionEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChatCreate(x) => {
                    crate::types::MessageActionChatCreate::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatEditTitle(x) => {
                    crate::types::MessageActionChatEditTitle::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatEditPhoto(x) => {
                    crate::types::MessageActionChatEditPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatDeletePhoto => {
                    crate::types::MessageActionChatDeletePhoto::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChatAddUser(x) => {
                    crate::types::MessageActionChatAddUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatDeleteUser(x) => {
                    crate::types::MessageActionChatDeleteUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatJoinedByLink(x) => {
                    crate::types::MessageActionChatJoinedByLink::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelCreate(x) => {
                    crate::types::MessageActionChannelCreate::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatMigrateTo(x) => {
                    crate::types::MessageActionChatMigrateTo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelMigrateFrom(x) => {
                    crate::types::MessageActionChannelMigrateFrom::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PinMessage => {
                    crate::types::MessageActionPinMessage::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::HistoryClear => {
                    crate::types::MessageActionHistoryClear::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::GameScore(x) => {
                    crate::types::MessageActionGameScore::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PaymentSentMe(x) => {
                    crate::types::MessageActionPaymentSentMe::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PaymentSent(x) => {
                    crate::types::MessageActionPaymentSent::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhoneCall(x) => {
                    crate::types::MessageActionPhoneCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ScreenshotTaken => {
                    crate::types::MessageActionScreenshotTaken::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::CustomAction(x) => {
                    crate::types::MessageActionCustomAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotAllowed(x) => {
                    crate::types::MessageActionBotAllowed::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SecureValuesSentMe(x) => {
                    crate::types::MessageActionSecureValuesSentMe::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SecureValuesSent(x) => {
                    crate::types::MessageActionSecureValuesSent::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ContactSignUp => {
                    crate::types::MessageActionContactSignUp::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::GeoProximityReached(x) => {
                    crate::types::MessageActionGeoProximityReached::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GroupCall(x) => {
                    crate::types::MessageActionGroupCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InviteToGroupCall(x) => {
                    crate::types::MessageActionInviteToGroupCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SetMessagesTtl(x) => {
                    crate::types::MessageActionSetMessagesTtl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GroupCallScheduled(x) => {
                    crate::types::MessageActionGroupCallScheduled::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SetChatTheme(x) => {
                    crate::types::MessageActionSetChatTheme::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatJoinedByRequest => {
                    crate::types::MessageActionChatJoinedByRequest::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for MessageAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageActionEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::MessageActionChatCreate::CONSTRUCTOR_ID => {
                    Self::ChatCreate(crate::types::MessageActionChatCreate::deserialize(buf)?)
                }
                crate::types::MessageActionChatEditTitle::CONSTRUCTOR_ID => {
                    Self::ChatEditTitle(crate::types::MessageActionChatEditTitle::deserialize(buf)?)
                }
                crate::types::MessageActionChatEditPhoto::CONSTRUCTOR_ID => {
                    Self::ChatEditPhoto(crate::types::MessageActionChatEditPhoto::deserialize(buf)?)
                }
                crate::types::MessageActionChatDeletePhoto::CONSTRUCTOR_ID => Self::ChatDeletePhoto,
                crate::types::MessageActionChatAddUser::CONSTRUCTOR_ID => {
                    Self::ChatAddUser(crate::types::MessageActionChatAddUser::deserialize(buf)?)
                }
                crate::types::MessageActionChatDeleteUser::CONSTRUCTOR_ID => Self::ChatDeleteUser(
                    crate::types::MessageActionChatDeleteUser::deserialize(buf)?,
                ),
                crate::types::MessageActionChatJoinedByLink::CONSTRUCTOR_ID => {
                    Self::ChatJoinedByLink(
                        crate::types::MessageActionChatJoinedByLink::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionChannelCreate::CONSTRUCTOR_ID => {
                    Self::ChannelCreate(crate::types::MessageActionChannelCreate::deserialize(buf)?)
                }
                crate::types::MessageActionChatMigrateTo::CONSTRUCTOR_ID => {
                    Self::ChatMigrateTo(crate::types::MessageActionChatMigrateTo::deserialize(buf)?)
                }
                crate::types::MessageActionChannelMigrateFrom::CONSTRUCTOR_ID => {
                    Self::ChannelMigrateFrom(
                        crate::types::MessageActionChannelMigrateFrom::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionPinMessage::CONSTRUCTOR_ID => Self::PinMessage,
                crate::types::MessageActionHistoryClear::CONSTRUCTOR_ID => Self::HistoryClear,
                crate::types::MessageActionGameScore::CONSTRUCTOR_ID => {
                    Self::GameScore(crate::types::MessageActionGameScore::deserialize(buf)?)
                }
                crate::types::MessageActionPaymentSentMe::CONSTRUCTOR_ID => {
                    Self::PaymentSentMe(crate::types::MessageActionPaymentSentMe::deserialize(buf)?)
                }
                crate::types::MessageActionPaymentSent::CONSTRUCTOR_ID => {
                    Self::PaymentSent(crate::types::MessageActionPaymentSent::deserialize(buf)?)
                }
                crate::types::MessageActionPhoneCall::CONSTRUCTOR_ID => {
                    Self::PhoneCall(crate::types::MessageActionPhoneCall::deserialize(buf)?)
                }
                crate::types::MessageActionScreenshotTaken::CONSTRUCTOR_ID => Self::ScreenshotTaken,
                crate::types::MessageActionCustomAction::CONSTRUCTOR_ID => {
                    Self::CustomAction(crate::types::MessageActionCustomAction::deserialize(buf)?)
                }
                crate::types::MessageActionBotAllowed::CONSTRUCTOR_ID => {
                    Self::BotAllowed(crate::types::MessageActionBotAllowed::deserialize(buf)?)
                }
                crate::types::MessageActionSecureValuesSentMe::CONSTRUCTOR_ID => {
                    Self::SecureValuesSentMe(
                        crate::types::MessageActionSecureValuesSentMe::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionSecureValuesSent::CONSTRUCTOR_ID => {
                    Self::SecureValuesSent(
                        crate::types::MessageActionSecureValuesSent::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionContactSignUp::CONSTRUCTOR_ID => Self::ContactSignUp,
                crate::types::MessageActionGeoProximityReached::CONSTRUCTOR_ID => {
                    Self::GeoProximityReached(
                        crate::types::MessageActionGeoProximityReached::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionGroupCall::CONSTRUCTOR_ID => {
                    Self::GroupCall(crate::types::MessageActionGroupCall::deserialize(buf)?)
                }
                crate::types::MessageActionInviteToGroupCall::CONSTRUCTOR_ID => {
                    Self::InviteToGroupCall(
                        crate::types::MessageActionInviteToGroupCall::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionSetMessagesTtl::CONSTRUCTOR_ID => Self::SetMessagesTtl(
                    crate::types::MessageActionSetMessagesTtl::deserialize(buf)?,
                ),
                crate::types::MessageActionGroupCallScheduled::CONSTRUCTOR_ID => {
                    Self::GroupCallScheduled(
                        crate::types::MessageActionGroupCallScheduled::deserialize(buf)?,
                    )
                }
                crate::types::MessageActionSetChatTheme::CONSTRUCTOR_ID => {
                    Self::SetChatTheme(crate::types::MessageActionSetChatTheme::deserialize(buf)?)
                }
                crate::types::MessageActionChatJoinedByRequest::CONSTRUCTOR_ID => {
                    Self::ChatJoinedByRequest
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageActionEmpty> for MessageAction {
        fn from(_x: crate::types::MessageActionEmpty) -> Self {
            MessageAction::Empty
        }
    }
    impl From<crate::types::MessageActionChatCreate> for MessageAction {
        fn from(x: crate::types::MessageActionChatCreate) -> Self {
            MessageAction::ChatCreate(x)
        }
    }
    impl From<crate::types::MessageActionChatEditTitle> for MessageAction {
        fn from(x: crate::types::MessageActionChatEditTitle) -> Self {
            MessageAction::ChatEditTitle(x)
        }
    }
    impl From<crate::types::MessageActionChatEditPhoto> for MessageAction {
        fn from(x: crate::types::MessageActionChatEditPhoto) -> Self {
            MessageAction::ChatEditPhoto(x)
        }
    }
    impl From<crate::types::MessageActionChatDeletePhoto> for MessageAction {
        fn from(_x: crate::types::MessageActionChatDeletePhoto) -> Self {
            MessageAction::ChatDeletePhoto
        }
    }
    impl From<crate::types::MessageActionChatAddUser> for MessageAction {
        fn from(x: crate::types::MessageActionChatAddUser) -> Self {
            MessageAction::ChatAddUser(x)
        }
    }
    impl From<crate::types::MessageActionChatDeleteUser> for MessageAction {
        fn from(x: crate::types::MessageActionChatDeleteUser) -> Self {
            MessageAction::ChatDeleteUser(x)
        }
    }
    impl From<crate::types::MessageActionChatJoinedByLink> for MessageAction {
        fn from(x: crate::types::MessageActionChatJoinedByLink) -> Self {
            MessageAction::ChatJoinedByLink(x)
        }
    }
    impl From<crate::types::MessageActionChannelCreate> for MessageAction {
        fn from(x: crate::types::MessageActionChannelCreate) -> Self {
            MessageAction::ChannelCreate(x)
        }
    }
    impl From<crate::types::MessageActionChatMigrateTo> for MessageAction {
        fn from(x: crate::types::MessageActionChatMigrateTo) -> Self {
            MessageAction::ChatMigrateTo(x)
        }
    }
    impl From<crate::types::MessageActionChannelMigrateFrom> for MessageAction {
        fn from(x: crate::types::MessageActionChannelMigrateFrom) -> Self {
            MessageAction::ChannelMigrateFrom(x)
        }
    }
    impl From<crate::types::MessageActionPinMessage> for MessageAction {
        fn from(_x: crate::types::MessageActionPinMessage) -> Self {
            MessageAction::PinMessage
        }
    }
    impl From<crate::types::MessageActionHistoryClear> for MessageAction {
        fn from(_x: crate::types::MessageActionHistoryClear) -> Self {
            MessageAction::HistoryClear
        }
    }
    impl From<crate::types::MessageActionGameScore> for MessageAction {
        fn from(x: crate::types::MessageActionGameScore) -> Self {
            MessageAction::GameScore(x)
        }
    }
    impl From<crate::types::MessageActionPaymentSentMe> for MessageAction {
        fn from(x: crate::types::MessageActionPaymentSentMe) -> Self {
            MessageAction::PaymentSentMe(x)
        }
    }
    impl From<crate::types::MessageActionPaymentSent> for MessageAction {
        fn from(x: crate::types::MessageActionPaymentSent) -> Self {
            MessageAction::PaymentSent(x)
        }
    }
    impl From<crate::types::MessageActionPhoneCall> for MessageAction {
        fn from(x: crate::types::MessageActionPhoneCall) -> Self {
            MessageAction::PhoneCall(x)
        }
    }
    impl From<crate::types::MessageActionScreenshotTaken> for MessageAction {
        fn from(_x: crate::types::MessageActionScreenshotTaken) -> Self {
            MessageAction::ScreenshotTaken
        }
    }
    impl From<crate::types::MessageActionCustomAction> for MessageAction {
        fn from(x: crate::types::MessageActionCustomAction) -> Self {
            MessageAction::CustomAction(x)
        }
    }
    impl From<crate::types::MessageActionBotAllowed> for MessageAction {
        fn from(x: crate::types::MessageActionBotAllowed) -> Self {
            MessageAction::BotAllowed(x)
        }
    }
    impl From<crate::types::MessageActionSecureValuesSentMe> for MessageAction {
        fn from(x: crate::types::MessageActionSecureValuesSentMe) -> Self {
            MessageAction::SecureValuesSentMe(x)
        }
    }
    impl From<crate::types::MessageActionSecureValuesSent> for MessageAction {
        fn from(x: crate::types::MessageActionSecureValuesSent) -> Self {
            MessageAction::SecureValuesSent(x)
        }
    }
    impl From<crate::types::MessageActionContactSignUp> for MessageAction {
        fn from(_x: crate::types::MessageActionContactSignUp) -> Self {
            MessageAction::ContactSignUp
        }
    }
    impl From<crate::types::MessageActionGeoProximityReached> for MessageAction {
        fn from(x: crate::types::MessageActionGeoProximityReached) -> Self {
            MessageAction::GeoProximityReached(x)
        }
    }
    impl From<crate::types::MessageActionGroupCall> for MessageAction {
        fn from(x: crate::types::MessageActionGroupCall) -> Self {
            MessageAction::GroupCall(x)
        }
    }
    impl From<crate::types::MessageActionInviteToGroupCall> for MessageAction {
        fn from(x: crate::types::MessageActionInviteToGroupCall) -> Self {
            MessageAction::InviteToGroupCall(x)
        }
    }
    impl From<crate::types::MessageActionSetMessagesTtl> for MessageAction {
        fn from(x: crate::types::MessageActionSetMessagesTtl) -> Self {
            MessageAction::SetMessagesTtl(x)
        }
    }
    impl From<crate::types::MessageActionGroupCallScheduled> for MessageAction {
        fn from(x: crate::types::MessageActionGroupCallScheduled) -> Self {
            MessageAction::GroupCallScheduled(x)
        }
    }
    impl From<crate::types::MessageActionSetChatTheme> for MessageAction {
        fn from(x: crate::types::MessageActionSetChatTheme) -> Self {
            MessageAction::SetChatTheme(x)
        }
    }
    impl From<crate::types::MessageActionChatJoinedByRequest> for MessageAction {
        fn from(_x: crate::types::MessageActionChatJoinedByRequest) -> Self {
            MessageAction::ChatJoinedByRequest
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageEntity {
        Unknown(crate::types::MessageEntityUnknown),
        Mention(crate::types::MessageEntityMention),
        Hashtag(crate::types::MessageEntityHashtag),
        BotCommand(crate::types::MessageEntityBotCommand),
        Url(crate::types::MessageEntityUrl),
        Email(crate::types::MessageEntityEmail),
        Bold(crate::types::MessageEntityBold),
        Italic(crate::types::MessageEntityItalic),
        Code(crate::types::MessageEntityCode),
        Pre(crate::types::MessageEntityPre),
        TextUrl(crate::types::MessageEntityTextUrl),
        MentionName(crate::types::MessageEntityMentionName),
        InputMessageEntityMentionName(crate::types::InputMessageEntityMentionName),
        Phone(crate::types::MessageEntityPhone),
        Cashtag(crate::types::MessageEntityCashtag),
        Underline(crate::types::MessageEntityUnderline),
        Strike(crate::types::MessageEntityStrike),
        Blockquote(crate::types::MessageEntityBlockquote),
        BankCard(crate::types::MessageEntityBankCard),
    }
    impl MessageEntity {
        pub fn offset(&self) -> i32 {
            match self {
                Self::Unknown(i) => i.offset,
                Self::Mention(i) => i.offset,
                Self::Hashtag(i) => i.offset,
                Self::BotCommand(i) => i.offset,
                Self::Url(i) => i.offset,
                Self::Email(i) => i.offset,
                Self::Bold(i) => i.offset,
                Self::Italic(i) => i.offset,
                Self::Code(i) => i.offset,
                Self::Pre(i) => i.offset,
                Self::TextUrl(i) => i.offset,
                Self::MentionName(i) => i.offset,
                Self::InputMessageEntityMentionName(i) => i.offset,
                Self::Phone(i) => i.offset,
                Self::Cashtag(i) => i.offset,
                Self::Underline(i) => i.offset,
                Self::Strike(i) => i.offset,
                Self::Blockquote(i) => i.offset,
                Self::BankCard(i) => i.offset,
            }
        }
        pub fn length(&self) -> i32 {
            match self {
                Self::Unknown(i) => i.length,
                Self::Mention(i) => i.length,
                Self::Hashtag(i) => i.length,
                Self::BotCommand(i) => i.length,
                Self::Url(i) => i.length,
                Self::Email(i) => i.length,
                Self::Bold(i) => i.length,
                Self::Italic(i) => i.length,
                Self::Code(i) => i.length,
                Self::Pre(i) => i.length,
                Self::TextUrl(i) => i.length,
                Self::MentionName(i) => i.length,
                Self::InputMessageEntityMentionName(i) => i.length,
                Self::Phone(i) => i.length,
                Self::Cashtag(i) => i.length,
                Self::Underline(i) => i.length,
                Self::Strike(i) => i.length,
                Self::Blockquote(i) => i.length,
                Self::BankCard(i) => i.length,
            }
        }
    }
    impl crate::Serializable for MessageEntity {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Unknown(x) => {
                    crate::types::MessageEntityUnknown::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Mention(x) => {
                    crate::types::MessageEntityMention::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Hashtag(x) => {
                    crate::types::MessageEntityHashtag::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotCommand(x) => {
                    crate::types::MessageEntityBotCommand::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Url(x) => {
                    crate::types::MessageEntityUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Email(x) => {
                    crate::types::MessageEntityEmail::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Bold(x) => {
                    crate::types::MessageEntityBold::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Italic(x) => {
                    crate::types::MessageEntityItalic::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Code(x) => {
                    crate::types::MessageEntityCode::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Pre(x) => {
                    crate::types::MessageEntityPre::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextUrl(x) => {
                    crate::types::MessageEntityTextUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MentionName(x) => {
                    crate::types::MessageEntityMentionName::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputMessageEntityMentionName(x) => {
                    crate::types::InputMessageEntityMentionName::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Phone(x) => {
                    crate::types::MessageEntityPhone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Cashtag(x) => {
                    crate::types::MessageEntityCashtag::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Underline(x) => {
                    crate::types::MessageEntityUnderline::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Strike(x) => {
                    crate::types::MessageEntityStrike::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Blockquote(x) => {
                    crate::types::MessageEntityBlockquote::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BankCard(x) => {
                    crate::types::MessageEntityBankCard::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageEntity {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageEntityUnknown::CONSTRUCTOR_ID => {
                    Self::Unknown(crate::types::MessageEntityUnknown::deserialize(buf)?)
                }
                crate::types::MessageEntityMention::CONSTRUCTOR_ID => {
                    Self::Mention(crate::types::MessageEntityMention::deserialize(buf)?)
                }
                crate::types::MessageEntityHashtag::CONSTRUCTOR_ID => {
                    Self::Hashtag(crate::types::MessageEntityHashtag::deserialize(buf)?)
                }
                crate::types::MessageEntityBotCommand::CONSTRUCTOR_ID => {
                    Self::BotCommand(crate::types::MessageEntityBotCommand::deserialize(buf)?)
                }
                crate::types::MessageEntityUrl::CONSTRUCTOR_ID => {
                    Self::Url(crate::types::MessageEntityUrl::deserialize(buf)?)
                }
                crate::types::MessageEntityEmail::CONSTRUCTOR_ID => {
                    Self::Email(crate::types::MessageEntityEmail::deserialize(buf)?)
                }
                crate::types::MessageEntityBold::CONSTRUCTOR_ID => {
                    Self::Bold(crate::types::MessageEntityBold::deserialize(buf)?)
                }
                crate::types::MessageEntityItalic::CONSTRUCTOR_ID => {
                    Self::Italic(crate::types::MessageEntityItalic::deserialize(buf)?)
                }
                crate::types::MessageEntityCode::CONSTRUCTOR_ID => {
                    Self::Code(crate::types::MessageEntityCode::deserialize(buf)?)
                }
                crate::types::MessageEntityPre::CONSTRUCTOR_ID => {
                    Self::Pre(crate::types::MessageEntityPre::deserialize(buf)?)
                }
                crate::types::MessageEntityTextUrl::CONSTRUCTOR_ID => {
                    Self::TextUrl(crate::types::MessageEntityTextUrl::deserialize(buf)?)
                }
                crate::types::MessageEntityMentionName::CONSTRUCTOR_ID => {
                    Self::MentionName(crate::types::MessageEntityMentionName::deserialize(buf)?)
                }
                crate::types::InputMessageEntityMentionName::CONSTRUCTOR_ID => {
                    Self::InputMessageEntityMentionName(
                        crate::types::InputMessageEntityMentionName::deserialize(buf)?,
                    )
                }
                crate::types::MessageEntityPhone::CONSTRUCTOR_ID => {
                    Self::Phone(crate::types::MessageEntityPhone::deserialize(buf)?)
                }
                crate::types::MessageEntityCashtag::CONSTRUCTOR_ID => {
                    Self::Cashtag(crate::types::MessageEntityCashtag::deserialize(buf)?)
                }
                crate::types::MessageEntityUnderline::CONSTRUCTOR_ID => {
                    Self::Underline(crate::types::MessageEntityUnderline::deserialize(buf)?)
                }
                crate::types::MessageEntityStrike::CONSTRUCTOR_ID => {
                    Self::Strike(crate::types::MessageEntityStrike::deserialize(buf)?)
                }
                crate::types::MessageEntityBlockquote::CONSTRUCTOR_ID => {
                    Self::Blockquote(crate::types::MessageEntityBlockquote::deserialize(buf)?)
                }
                crate::types::MessageEntityBankCard::CONSTRUCTOR_ID => {
                    Self::BankCard(crate::types::MessageEntityBankCard::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageEntityUnknown> for MessageEntity {
        fn from(x: crate::types::MessageEntityUnknown) -> Self {
            MessageEntity::Unknown(x)
        }
    }
    impl From<crate::types::MessageEntityMention> for MessageEntity {
        fn from(x: crate::types::MessageEntityMention) -> Self {
            MessageEntity::Mention(x)
        }
    }
    impl From<crate::types::MessageEntityHashtag> for MessageEntity {
        fn from(x: crate::types::MessageEntityHashtag) -> Self {
            MessageEntity::Hashtag(x)
        }
    }
    impl From<crate::types::MessageEntityBotCommand> for MessageEntity {
        fn from(x: crate::types::MessageEntityBotCommand) -> Self {
            MessageEntity::BotCommand(x)
        }
    }
    impl From<crate::types::MessageEntityUrl> for MessageEntity {
        fn from(x: crate::types::MessageEntityUrl) -> Self {
            MessageEntity::Url(x)
        }
    }
    impl From<crate::types::MessageEntityEmail> for MessageEntity {
        fn from(x: crate::types::MessageEntityEmail) -> Self {
            MessageEntity::Email(x)
        }
    }
    impl From<crate::types::MessageEntityBold> for MessageEntity {
        fn from(x: crate::types::MessageEntityBold) -> Self {
            MessageEntity::Bold(x)
        }
    }
    impl From<crate::types::MessageEntityItalic> for MessageEntity {
        fn from(x: crate::types::MessageEntityItalic) -> Self {
            MessageEntity::Italic(x)
        }
    }
    impl From<crate::types::MessageEntityCode> for MessageEntity {
        fn from(x: crate::types::MessageEntityCode) -> Self {
            MessageEntity::Code(x)
        }
    }
    impl From<crate::types::MessageEntityPre> for MessageEntity {
        fn from(x: crate::types::MessageEntityPre) -> Self {
            MessageEntity::Pre(x)
        }
    }
    impl From<crate::types::MessageEntityTextUrl> for MessageEntity {
        fn from(x: crate::types::MessageEntityTextUrl) -> Self {
            MessageEntity::TextUrl(x)
        }
    }
    impl From<crate::types::MessageEntityMentionName> for MessageEntity {
        fn from(x: crate::types::MessageEntityMentionName) -> Self {
            MessageEntity::MentionName(x)
        }
    }
    impl From<crate::types::InputMessageEntityMentionName> for MessageEntity {
        fn from(x: crate::types::InputMessageEntityMentionName) -> Self {
            MessageEntity::InputMessageEntityMentionName(x)
        }
    }
    impl From<crate::types::MessageEntityPhone> for MessageEntity {
        fn from(x: crate::types::MessageEntityPhone) -> Self {
            MessageEntity::Phone(x)
        }
    }
    impl From<crate::types::MessageEntityCashtag> for MessageEntity {
        fn from(x: crate::types::MessageEntityCashtag) -> Self {
            MessageEntity::Cashtag(x)
        }
    }
    impl From<crate::types::MessageEntityUnderline> for MessageEntity {
        fn from(x: crate::types::MessageEntityUnderline) -> Self {
            MessageEntity::Underline(x)
        }
    }
    impl From<crate::types::MessageEntityStrike> for MessageEntity {
        fn from(x: crate::types::MessageEntityStrike) -> Self {
            MessageEntity::Strike(x)
        }
    }
    impl From<crate::types::MessageEntityBlockquote> for MessageEntity {
        fn from(x: crate::types::MessageEntityBlockquote) -> Self {
            MessageEntity::Blockquote(x)
        }
    }
    impl From<crate::types::MessageEntityBankCard> for MessageEntity {
        fn from(x: crate::types::MessageEntityBankCard) -> Self {
            MessageEntity::BankCard(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageFwdHeader {
        Header(crate::types::MessageFwdHeader),
    }
    impl crate::Serializable for MessageFwdHeader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Header(x) => {
                    crate::types::MessageFwdHeader::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageFwdHeader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageFwdHeader::CONSTRUCTOR_ID => {
                    Self::Header(crate::types::MessageFwdHeader::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageFwdHeader> for MessageFwdHeader {
        fn from(x: crate::types::MessageFwdHeader) -> Self {
            MessageFwdHeader::Header(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageInteractionCounters {
        Counters(crate::types::MessageInteractionCounters),
    }
    impl crate::Serializable for MessageInteractionCounters {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Counters(x) => {
                    crate::types::MessageInteractionCounters::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageInteractionCounters {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageInteractionCounters::CONSTRUCTOR_ID => {
                    Self::Counters(crate::types::MessageInteractionCounters::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageInteractionCounters> for MessageInteractionCounters {
        fn from(x: crate::types::MessageInteractionCounters) -> Self {
            MessageInteractionCounters::Counters(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageMedia {
        Empty,
        Photo(crate::types::MessageMediaPhoto),
        Geo(crate::types::MessageMediaGeo),
        Contact(crate::types::MessageMediaContact),
        Unsupported,
        Document(crate::types::MessageMediaDocument),
        WebPage(crate::types::MessageMediaWebPage),
        Venue(crate::types::MessageMediaVenue),
        Game(crate::types::MessageMediaGame),
        Invoice(crate::types::MessageMediaInvoice),
        GeoLive(crate::types::MessageMediaGeoLive),
        Poll(crate::types::MessageMediaPoll),
        Dice(crate::types::MessageMediaDice),
    }
    impl crate::Serializable for MessageMedia {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::MessageMediaEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Photo(x) => {
                    crate::types::MessageMediaPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Geo(x) => {
                    crate::types::MessageMediaGeo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Contact(x) => {
                    crate::types::MessageMediaContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Unsupported => {
                    crate::types::MessageMediaUnsupported::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Document(x) => {
                    crate::types::MessageMediaDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::WebPage(x) => {
                    crate::types::MessageMediaWebPage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Venue(x) => {
                    crate::types::MessageMediaVenue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Game(x) => {
                    crate::types::MessageMediaGame::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Invoice(x) => {
                    crate::types::MessageMediaInvoice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GeoLive(x) => {
                    crate::types::MessageMediaGeoLive::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Poll(x) => {
                    crate::types::MessageMediaPoll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Dice(x) => {
                    crate::types::MessageMediaDice::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageMedia {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageMediaEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::MessageMediaPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::MessageMediaPhoto::deserialize(buf)?)
                }
                crate::types::MessageMediaGeo::CONSTRUCTOR_ID => {
                    Self::Geo(crate::types::MessageMediaGeo::deserialize(buf)?)
                }
                crate::types::MessageMediaContact::CONSTRUCTOR_ID => {
                    Self::Contact(crate::types::MessageMediaContact::deserialize(buf)?)
                }
                crate::types::MessageMediaUnsupported::CONSTRUCTOR_ID => Self::Unsupported,
                crate::types::MessageMediaDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::MessageMediaDocument::deserialize(buf)?)
                }
                crate::types::MessageMediaWebPage::CONSTRUCTOR_ID => {
                    Self::WebPage(crate::types::MessageMediaWebPage::deserialize(buf)?)
                }
                crate::types::MessageMediaVenue::CONSTRUCTOR_ID => {
                    Self::Venue(crate::types::MessageMediaVenue::deserialize(buf)?)
                }
                crate::types::MessageMediaGame::CONSTRUCTOR_ID => {
                    Self::Game(crate::types::MessageMediaGame::deserialize(buf)?)
                }
                crate::types::MessageMediaInvoice::CONSTRUCTOR_ID => {
                    Self::Invoice(crate::types::MessageMediaInvoice::deserialize(buf)?)
                }
                crate::types::MessageMediaGeoLive::CONSTRUCTOR_ID => {
                    Self::GeoLive(crate::types::MessageMediaGeoLive::deserialize(buf)?)
                }
                crate::types::MessageMediaPoll::CONSTRUCTOR_ID => {
                    Self::Poll(crate::types::MessageMediaPoll::deserialize(buf)?)
                }
                crate::types::MessageMediaDice::CONSTRUCTOR_ID => {
                    Self::Dice(crate::types::MessageMediaDice::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageMediaEmpty> for MessageMedia {
        fn from(_x: crate::types::MessageMediaEmpty) -> Self {
            MessageMedia::Empty
        }
    }
    impl From<crate::types::MessageMediaPhoto> for MessageMedia {
        fn from(x: crate::types::MessageMediaPhoto) -> Self {
            MessageMedia::Photo(x)
        }
    }
    impl From<crate::types::MessageMediaGeo> for MessageMedia {
        fn from(x: crate::types::MessageMediaGeo) -> Self {
            MessageMedia::Geo(x)
        }
    }
    impl From<crate::types::MessageMediaContact> for MessageMedia {
        fn from(x: crate::types::MessageMediaContact) -> Self {
            MessageMedia::Contact(x)
        }
    }
    impl From<crate::types::MessageMediaUnsupported> for MessageMedia {
        fn from(_x: crate::types::MessageMediaUnsupported) -> Self {
            MessageMedia::Unsupported
        }
    }
    impl From<crate::types::MessageMediaDocument> for MessageMedia {
        fn from(x: crate::types::MessageMediaDocument) -> Self {
            MessageMedia::Document(x)
        }
    }
    impl From<crate::types::MessageMediaWebPage> for MessageMedia {
        fn from(x: crate::types::MessageMediaWebPage) -> Self {
            MessageMedia::WebPage(x)
        }
    }
    impl From<crate::types::MessageMediaVenue> for MessageMedia {
        fn from(x: crate::types::MessageMediaVenue) -> Self {
            MessageMedia::Venue(x)
        }
    }
    impl From<crate::types::MessageMediaGame> for MessageMedia {
        fn from(x: crate::types::MessageMediaGame) -> Self {
            MessageMedia::Game(x)
        }
    }
    impl From<crate::types::MessageMediaInvoice> for MessageMedia {
        fn from(x: crate::types::MessageMediaInvoice) -> Self {
            MessageMedia::Invoice(x)
        }
    }
    impl From<crate::types::MessageMediaGeoLive> for MessageMedia {
        fn from(x: crate::types::MessageMediaGeoLive) -> Self {
            MessageMedia::GeoLive(x)
        }
    }
    impl From<crate::types::MessageMediaPoll> for MessageMedia {
        fn from(x: crate::types::MessageMediaPoll) -> Self {
            MessageMedia::Poll(x)
        }
    }
    impl From<crate::types::MessageMediaDice> for MessageMedia {
        fn from(x: crate::types::MessageMediaDice) -> Self {
            MessageMedia::Dice(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageRange {
        Range(crate::types::MessageRange),
    }
    impl crate::Serializable for MessageRange {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Range(x) => {
                    crate::types::MessageRange::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageRange {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageRange::CONSTRUCTOR_ID => {
                    Self::Range(crate::types::MessageRange::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageRange> for MessageRange {
        fn from(x: crate::types::MessageRange) -> Self {
            MessageRange::Range(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageReplies {
        Replies(crate::types::MessageReplies),
    }
    impl crate::Serializable for MessageReplies {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Replies(x) => {
                    crate::types::MessageReplies::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageReplies {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageReplies::CONSTRUCTOR_ID => {
                    Self::Replies(crate::types::MessageReplies::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageReplies> for MessageReplies {
        fn from(x: crate::types::MessageReplies) -> Self {
            MessageReplies::Replies(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageReplyHeader {
        Header(crate::types::MessageReplyHeader),
    }
    impl crate::Serializable for MessageReplyHeader {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Header(x) => {
                    crate::types::MessageReplyHeader::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageReplyHeader {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageReplyHeader::CONSTRUCTOR_ID => {
                    Self::Header(crate::types::MessageReplyHeader::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageReplyHeader> for MessageReplyHeader {
        fn from(x: crate::types::MessageReplyHeader) -> Self {
            MessageReplyHeader::Header(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageUserVote {
        Vote(crate::types::MessageUserVote),
        InputOption(crate::types::MessageUserVoteInputOption),
        Multiple(crate::types::MessageUserVoteMultiple),
    }
    impl MessageUserVote {
        pub fn user_id(&self) -> i64 {
            match self {
                Self::Vote(i) => i.user_id,
                Self::InputOption(i) => i.user_id,
                Self::Multiple(i) => i.user_id,
            }
        }
        pub fn date(&self) -> i32 {
            match self {
                Self::Vote(i) => i.date,
                Self::InputOption(i) => i.date,
                Self::Multiple(i) => i.date,
            }
        }
    }
    impl crate::Serializable for MessageUserVote {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Vote(x) => {
                    crate::types::MessageUserVote::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputOption(x) => {
                    crate::types::MessageUserVoteInputOption::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Multiple(x) => {
                    crate::types::MessageUserVoteMultiple::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageUserVote {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageUserVote::CONSTRUCTOR_ID => {
                    Self::Vote(crate::types::MessageUserVote::deserialize(buf)?)
                }
                crate::types::MessageUserVoteInputOption::CONSTRUCTOR_ID => {
                    Self::InputOption(crate::types::MessageUserVoteInputOption::deserialize(buf)?)
                }
                crate::types::MessageUserVoteMultiple::CONSTRUCTOR_ID => {
                    Self::Multiple(crate::types::MessageUserVoteMultiple::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageUserVote> for MessageUserVote {
        fn from(x: crate::types::MessageUserVote) -> Self {
            MessageUserVote::Vote(x)
        }
    }
    impl From<crate::types::MessageUserVoteInputOption> for MessageUserVote {
        fn from(x: crate::types::MessageUserVoteInputOption) -> Self {
            MessageUserVote::InputOption(x)
        }
    }
    impl From<crate::types::MessageUserVoteMultiple> for MessageUserVote {
        fn from(x: crate::types::MessageUserVoteMultiple) -> Self {
            MessageUserVote::Multiple(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessageViews {
        Views(crate::types::MessageViews),
    }
    impl crate::Serializable for MessageViews {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Views(x) => {
                    crate::types::MessageViews::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MessageViews {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MessageViews::CONSTRUCTOR_ID => {
                    Self::Views(crate::types::MessageViews::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MessageViews> for MessageViews {
        fn from(x: crate::types::MessageViews) -> Self {
            MessageViews::Views(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MessagesFilter {
        InputMessagesFilterEmpty,
        InputMessagesFilterPhotos,
        InputMessagesFilterVideo,
        InputMessagesFilterPhotoVideo,
        InputMessagesFilterDocument,
        InputMessagesFilterUrl,
        InputMessagesFilterGif,
        InputMessagesFilterVoice,
        InputMessagesFilterMusic,
        InputMessagesFilterChatPhotos,
        InputMessagesFilterPhoneCalls(crate::types::InputMessagesFilterPhoneCalls),
        InputMessagesFilterRoundVoice,
        InputMessagesFilterRoundVideo,
        InputMessagesFilterMyMentions,
        InputMessagesFilterGeo,
        InputMessagesFilterContacts,
        InputMessagesFilterPinned,
    }
    impl crate::Serializable for MessagesFilter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::InputMessagesFilterEmpty => {
                    crate::types::InputMessagesFilterEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterPhotos => {
                    crate::types::InputMessagesFilterPhotos::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterVideo => {
                    crate::types::InputMessagesFilterVideo::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterPhotoVideo => {
                    crate::types::InputMessagesFilterPhotoVideo::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterDocument => {
                    crate::types::InputMessagesFilterDocument::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterUrl => {
                    crate::types::InputMessagesFilterUrl::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterGif => {
                    crate::types::InputMessagesFilterGif::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterVoice => {
                    crate::types::InputMessagesFilterVoice::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterMusic => {
                    crate::types::InputMessagesFilterMusic::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterChatPhotos => {
                    crate::types::InputMessagesFilterChatPhotos::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterPhoneCalls(x) => {
                    crate::types::InputMessagesFilterPhoneCalls::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InputMessagesFilterRoundVoice => {
                    crate::types::InputMessagesFilterRoundVoice::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterRoundVideo => {
                    crate::types::InputMessagesFilterRoundVideo::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterMyMentions => {
                    crate::types::InputMessagesFilterMyMentions::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterGeo => {
                    crate::types::InputMessagesFilterGeo::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterContacts => {
                    crate::types::InputMessagesFilterContacts::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputMessagesFilterPinned => {
                    crate::types::InputMessagesFilterPinned::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for MessagesFilter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputMessagesFilterEmpty::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterEmpty
                }
                crate::types::InputMessagesFilterPhotos::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterPhotos
                }
                crate::types::InputMessagesFilterVideo::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterVideo
                }
                crate::types::InputMessagesFilterPhotoVideo::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterPhotoVideo
                }
                crate::types::InputMessagesFilterDocument::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterDocument
                }
                crate::types::InputMessagesFilterUrl::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterUrl
                }
                crate::types::InputMessagesFilterGif::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterGif
                }
                crate::types::InputMessagesFilterVoice::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterVoice
                }
                crate::types::InputMessagesFilterMusic::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterMusic
                }
                crate::types::InputMessagesFilterChatPhotos::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterChatPhotos
                }
                crate::types::InputMessagesFilterPhoneCalls::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterPhoneCalls(
                        crate::types::InputMessagesFilterPhoneCalls::deserialize(buf)?,
                    )
                }
                crate::types::InputMessagesFilterRoundVoice::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterRoundVoice
                }
                crate::types::InputMessagesFilterRoundVideo::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterRoundVideo
                }
                crate::types::InputMessagesFilterMyMentions::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterMyMentions
                }
                crate::types::InputMessagesFilterGeo::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterGeo
                }
                crate::types::InputMessagesFilterContacts::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterContacts
                }
                crate::types::InputMessagesFilterPinned::CONSTRUCTOR_ID => {
                    Self::InputMessagesFilterPinned
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputMessagesFilterEmpty> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterEmpty) -> Self {
            MessagesFilter::InputMessagesFilterEmpty
        }
    }
    impl From<crate::types::InputMessagesFilterPhotos> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterPhotos) -> Self {
            MessagesFilter::InputMessagesFilterPhotos
        }
    }
    impl From<crate::types::InputMessagesFilterVideo> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterVideo) -> Self {
            MessagesFilter::InputMessagesFilterVideo
        }
    }
    impl From<crate::types::InputMessagesFilterPhotoVideo> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterPhotoVideo) -> Self {
            MessagesFilter::InputMessagesFilterPhotoVideo
        }
    }
    impl From<crate::types::InputMessagesFilterDocument> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterDocument) -> Self {
            MessagesFilter::InputMessagesFilterDocument
        }
    }
    impl From<crate::types::InputMessagesFilterUrl> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterUrl) -> Self {
            MessagesFilter::InputMessagesFilterUrl
        }
    }
    impl From<crate::types::InputMessagesFilterGif> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterGif) -> Self {
            MessagesFilter::InputMessagesFilterGif
        }
    }
    impl From<crate::types::InputMessagesFilterVoice> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterVoice) -> Self {
            MessagesFilter::InputMessagesFilterVoice
        }
    }
    impl From<crate::types::InputMessagesFilterMusic> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterMusic) -> Self {
            MessagesFilter::InputMessagesFilterMusic
        }
    }
    impl From<crate::types::InputMessagesFilterChatPhotos> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterChatPhotos) -> Self {
            MessagesFilter::InputMessagesFilterChatPhotos
        }
    }
    impl From<crate::types::InputMessagesFilterPhoneCalls> for MessagesFilter {
        fn from(x: crate::types::InputMessagesFilterPhoneCalls) -> Self {
            MessagesFilter::InputMessagesFilterPhoneCalls(x)
        }
    }
    impl From<crate::types::InputMessagesFilterRoundVoice> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterRoundVoice) -> Self {
            MessagesFilter::InputMessagesFilterRoundVoice
        }
    }
    impl From<crate::types::InputMessagesFilterRoundVideo> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterRoundVideo) -> Self {
            MessagesFilter::InputMessagesFilterRoundVideo
        }
    }
    impl From<crate::types::InputMessagesFilterMyMentions> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterMyMentions) -> Self {
            MessagesFilter::InputMessagesFilterMyMentions
        }
    }
    impl From<crate::types::InputMessagesFilterGeo> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterGeo) -> Self {
            MessagesFilter::InputMessagesFilterGeo
        }
    }
    impl From<crate::types::InputMessagesFilterContacts> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterContacts) -> Self {
            MessagesFilter::InputMessagesFilterContacts
        }
    }
    impl From<crate::types::InputMessagesFilterPinned> for MessagesFilter {
        fn from(_x: crate::types::InputMessagesFilterPinned) -> Self {
            MessagesFilter::InputMessagesFilterPinned
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgDetailedInfo {
        Info(crate::types::MsgDetailedInfo),
        MsgNewDetailedInfo(crate::types::MsgNewDetailedInfo),
    }
    impl MsgDetailedInfo {
        pub fn status(&self) -> i32 {
            match self {
                Self::Info(i) => i.status,
                Self::MsgNewDetailedInfo(i) => i.status,
            }
        }
        pub fn bytes(&self) -> i32 {
            match self {
                Self::Info(i) => i.bytes,
                Self::MsgNewDetailedInfo(i) => i.bytes,
            }
        }
        pub fn answer_msg_id(&self) -> i64 {
            match self {
                Self::Info(i) => i.answer_msg_id,
                Self::MsgNewDetailedInfo(i) => i.answer_msg_id,
            }
        }
    }
    impl crate::Serializable for MsgDetailedInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Info(x) => {
                    crate::types::MsgDetailedInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MsgNewDetailedInfo(x) => {
                    crate::types::MsgNewDetailedInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgDetailedInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgDetailedInfo::CONSTRUCTOR_ID => {
                    Self::Info(crate::types::MsgDetailedInfo::deserialize(buf)?)
                }
                crate::types::MsgNewDetailedInfo::CONSTRUCTOR_ID => {
                    Self::MsgNewDetailedInfo(crate::types::MsgNewDetailedInfo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgDetailedInfo> for MsgDetailedInfo {
        fn from(x: crate::types::MsgDetailedInfo) -> Self {
            MsgDetailedInfo::Info(x)
        }
    }
    impl From<crate::types::MsgNewDetailedInfo> for MsgDetailedInfo {
        fn from(x: crate::types::MsgNewDetailedInfo) -> Self {
            MsgDetailedInfo::MsgNewDetailedInfo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgResendReq {
        Req(crate::types::MsgResendReq),
        MsgResendAnsReq(crate::types::MsgResendAnsReq),
    }
    impl MsgResendReq {
        pub fn msg_ids(&self) -> Vec<i64> {
            match self {
                Self::Req(i) => i.msg_ids.clone(),
                Self::MsgResendAnsReq(i) => i.msg_ids.clone(),
            }
        }
    }
    impl crate::Serializable for MsgResendReq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Req(x) => {
                    crate::types::MsgResendReq::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MsgResendAnsReq(x) => {
                    crate::types::MsgResendAnsReq::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgResendReq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgResendReq::CONSTRUCTOR_ID => {
                    Self::Req(crate::types::MsgResendReq::deserialize(buf)?)
                }
                crate::types::MsgResendAnsReq::CONSTRUCTOR_ID => {
                    Self::MsgResendAnsReq(crate::types::MsgResendAnsReq::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgResendReq> for MsgResendReq {
        fn from(x: crate::types::MsgResendReq) -> Self {
            MsgResendReq::Req(x)
        }
    }
    impl From<crate::types::MsgResendAnsReq> for MsgResendReq {
        fn from(x: crate::types::MsgResendAnsReq) -> Self {
            MsgResendReq::MsgResendAnsReq(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgsAck {
        Ack(crate::types::MsgsAck),
    }
    impl crate::Serializable for MsgsAck {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Ack(x) => {
                    crate::types::MsgsAck::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgsAck {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgsAck::CONSTRUCTOR_ID => {
                    Self::Ack(crate::types::MsgsAck::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgsAck> for MsgsAck {
        fn from(x: crate::types::MsgsAck) -> Self {
            MsgsAck::Ack(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgsAllInfo {
        Info(crate::types::MsgsAllInfo),
    }
    impl crate::Serializable for MsgsAllInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Info(x) => {
                    crate::types::MsgsAllInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgsAllInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgsAllInfo::CONSTRUCTOR_ID => {
                    Self::Info(crate::types::MsgsAllInfo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgsAllInfo> for MsgsAllInfo {
        fn from(x: crate::types::MsgsAllInfo) -> Self {
            MsgsAllInfo::Info(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgsStateInfo {
        Info(crate::types::MsgsStateInfo),
    }
    impl crate::Serializable for MsgsStateInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Info(x) => {
                    crate::types::MsgsStateInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgsStateInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgsStateInfo::CONSTRUCTOR_ID => {
                    Self::Info(crate::types::MsgsStateInfo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgsStateInfo> for MsgsStateInfo {
        fn from(x: crate::types::MsgsStateInfo) -> Self {
            MsgsStateInfo::Info(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum MsgsStateReq {
        Req(crate::types::MsgsStateReq),
    }
    impl crate::Serializable for MsgsStateReq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Req(x) => {
                    crate::types::MsgsStateReq::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for MsgsStateReq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::MsgsStateReq::CONSTRUCTOR_ID => {
                    Self::Req(crate::types::MsgsStateReq::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::MsgsStateReq> for MsgsStateReq {
        fn from(x: crate::types::MsgsStateReq) -> Self {
            MsgsStateReq::Req(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum NearestDc {
        Dc(crate::types::NearestDc),
    }
    impl crate::Serializable for NearestDc {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Dc(x) => {
                    crate::types::NearestDc::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for NearestDc {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::NearestDc::CONSTRUCTOR_ID => {
                    Self::Dc(crate::types::NearestDc::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::NearestDc> for NearestDc {
        fn from(x: crate::types::NearestDc) -> Self {
            NearestDc::Dc(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum NewSession {
        Created(crate::types::NewSessionCreated),
    }
    impl crate::Serializable for NewSession {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Created(x) => {
                    crate::types::NewSessionCreated::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for NewSession {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::NewSessionCreated::CONSTRUCTOR_ID => {
                    Self::Created(crate::types::NewSessionCreated::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::NewSessionCreated> for NewSession {
        fn from(x: crate::types::NewSessionCreated) -> Self {
            NewSession::Created(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum NotifyPeer {
        Peer(crate::types::NotifyPeer),
        NotifyUsers,
        NotifyChats,
        NotifyBroadcasts,
    }
    impl crate::Serializable for NotifyPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::NotifyPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NotifyUsers => {
                    crate::types::NotifyUsers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::NotifyChats => {
                    crate::types::NotifyChats::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::NotifyBroadcasts => {
                    crate::types::NotifyBroadcasts::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for NotifyPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::NotifyPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::NotifyPeer::deserialize(buf)?)
                }
                crate::types::NotifyUsers::CONSTRUCTOR_ID => Self::NotifyUsers,
                crate::types::NotifyChats::CONSTRUCTOR_ID => Self::NotifyChats,
                crate::types::NotifyBroadcasts::CONSTRUCTOR_ID => Self::NotifyBroadcasts,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::NotifyPeer> for NotifyPeer {
        fn from(x: crate::types::NotifyPeer) -> Self {
            NotifyPeer::Peer(x)
        }
    }
    impl From<crate::types::NotifyUsers> for NotifyPeer {
        fn from(_x: crate::types::NotifyUsers) -> Self {
            NotifyPeer::NotifyUsers
        }
    }
    impl From<crate::types::NotifyChats> for NotifyPeer {
        fn from(_x: crate::types::NotifyChats) -> Self {
            NotifyPeer::NotifyChats
        }
    }
    impl From<crate::types::NotifyBroadcasts> for NotifyPeer {
        fn from(_x: crate::types::NotifyBroadcasts) -> Self {
            NotifyPeer::NotifyBroadcasts
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Null {
        Null,
    }
    impl crate::Serializable for Null {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Null => {
                    crate::types::Null::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for Null {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Null::CONSTRUCTOR_ID => Self::Null,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Null> for Null {
        fn from(_x: crate::types::Null) -> Self {
            Null::Null
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PQInnerData {
        Data(crate::types::PQInnerData),
        Dc(crate::types::PQInnerDataDc),
        Temp(crate::types::PQInnerDataTemp),
        TempDc(crate::types::PQInnerDataTempDc),
    }
    impl PQInnerData {
        pub fn p(&self) -> Vec<u8> {
            match self {
                Self::Data(i) => i.p.clone(),
                Self::Dc(i) => i.p.clone(),
                Self::Temp(i) => i.p.clone(),
                Self::TempDc(i) => i.p.clone(),
            }
        }
        pub fn nonce(&self) -> [u8; 16] {
            match self {
                Self::Data(i) => i.nonce.clone(),
                Self::Dc(i) => i.nonce.clone(),
                Self::Temp(i) => i.nonce.clone(),
                Self::TempDc(i) => i.nonce.clone(),
            }
        }
        pub fn new_nonce(&self) -> [u8; 32] {
            match self {
                Self::Data(i) => i.new_nonce.clone(),
                Self::Dc(i) => i.new_nonce.clone(),
                Self::Temp(i) => i.new_nonce.clone(),
                Self::TempDc(i) => i.new_nonce.clone(),
            }
        }
        pub fn q(&self) -> Vec<u8> {
            match self {
                Self::Data(i) => i.q.clone(),
                Self::Dc(i) => i.q.clone(),
                Self::Temp(i) => i.q.clone(),
                Self::TempDc(i) => i.q.clone(),
            }
        }
        pub fn pq(&self) -> Vec<u8> {
            match self {
                Self::Data(i) => i.pq.clone(),
                Self::Dc(i) => i.pq.clone(),
                Self::Temp(i) => i.pq.clone(),
                Self::TempDc(i) => i.pq.clone(),
            }
        }
        pub fn server_nonce(&self) -> [u8; 16] {
            match self {
                Self::Data(i) => i.server_nonce.clone(),
                Self::Dc(i) => i.server_nonce.clone(),
                Self::Temp(i) => i.server_nonce.clone(),
                Self::TempDc(i) => i.server_nonce.clone(),
            }
        }
    }
    impl crate::Serializable for PQInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Data(x) => {
                    crate::types::PQInnerData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Dc(x) => {
                    crate::types::PQInnerDataDc::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Temp(x) => {
                    crate::types::PQInnerDataTemp::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TempDc(x) => {
                    crate::types::PQInnerDataTempDc::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PQInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PQInnerData::CONSTRUCTOR_ID => {
                    Self::Data(crate::types::PQInnerData::deserialize(buf)?)
                }
                crate::types::PQInnerDataDc::CONSTRUCTOR_ID => {
                    Self::Dc(crate::types::PQInnerDataDc::deserialize(buf)?)
                }
                crate::types::PQInnerDataTemp::CONSTRUCTOR_ID => {
                    Self::Temp(crate::types::PQInnerDataTemp::deserialize(buf)?)
                }
                crate::types::PQInnerDataTempDc::CONSTRUCTOR_ID => {
                    Self::TempDc(crate::types::PQInnerDataTempDc::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PQInnerData> for PQInnerData {
        fn from(x: crate::types::PQInnerData) -> Self {
            PQInnerData::Data(x)
        }
    }
    impl From<crate::types::PQInnerDataDc> for PQInnerData {
        fn from(x: crate::types::PQInnerDataDc) -> Self {
            PQInnerData::Dc(x)
        }
    }
    impl From<crate::types::PQInnerDataTemp> for PQInnerData {
        fn from(x: crate::types::PQInnerDataTemp) -> Self {
            PQInnerData::Temp(x)
        }
    }
    impl From<crate::types::PQInnerDataTempDc> for PQInnerData {
        fn from(x: crate::types::PQInnerDataTempDc) -> Self {
            PQInnerData::TempDc(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Page {
        Page(crate::types::Page),
    }
    impl crate::Serializable for Page {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Page(x) => {
                    crate::types::Page::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Page {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Page::CONSTRUCTOR_ID => {
                    Self::Page(crate::types::Page::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Page> for Page {
        fn from(x: crate::types::Page) -> Self {
            Page::Page(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageBlock {
        Unsupported,
        Title(crate::types::PageBlockTitle),
        Subtitle(crate::types::PageBlockSubtitle),
        AuthorDate(crate::types::PageBlockAuthorDate),
        Header(crate::types::PageBlockHeader),
        Subheader(crate::types::PageBlockSubheader),
        Paragraph(crate::types::PageBlockParagraph),
        Preformatted(crate::types::PageBlockPreformatted),
        Footer(crate::types::PageBlockFooter),
        Divider,
        Anchor(crate::types::PageBlockAnchor),
        List(crate::types::PageBlockList),
        Blockquote(crate::types::PageBlockBlockquote),
        Pullquote(crate::types::PageBlockPullquote),
        Photo(crate::types::PageBlockPhoto),
        Video(crate::types::PageBlockVideo),
        Cover(Box<crate::types::PageBlockCover>),
        Embed(crate::types::PageBlockEmbed),
        EmbedPost(crate::types::PageBlockEmbedPost),
        Collage(crate::types::PageBlockCollage),
        Slideshow(crate::types::PageBlockSlideshow),
        Channel(crate::types::PageBlockChannel),
        Audio(crate::types::PageBlockAudio),
        Kicker(crate::types::PageBlockKicker),
        Table(crate::types::PageBlockTable),
        OrderedList(crate::types::PageBlockOrderedList),
        Details(crate::types::PageBlockDetails),
        RelatedArticles(crate::types::PageBlockRelatedArticles),
        Map(crate::types::PageBlockMap),
    }
    impl crate::Serializable for PageBlock {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Unsupported => {
                    crate::types::PageBlockUnsupported::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Title(x) => {
                    crate::types::PageBlockTitle::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Subtitle(x) => {
                    crate::types::PageBlockSubtitle::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::AuthorDate(x) => {
                    crate::types::PageBlockAuthorDate::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Header(x) => {
                    crate::types::PageBlockHeader::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Subheader(x) => {
                    crate::types::PageBlockSubheader::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Paragraph(x) => {
                    crate::types::PageBlockParagraph::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Preformatted(x) => {
                    crate::types::PageBlockPreformatted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Footer(x) => {
                    crate::types::PageBlockFooter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Divider => {
                    crate::types::PageBlockDivider::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Anchor(x) => {
                    crate::types::PageBlockAnchor::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::List(x) => {
                    crate::types::PageBlockList::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Blockquote(x) => {
                    crate::types::PageBlockBlockquote::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Pullquote(x) => {
                    crate::types::PageBlockPullquote::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Photo(x) => {
                    crate::types::PageBlockPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Video(x) => {
                    crate::types::PageBlockVideo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Cover(x) => {
                    crate::types::PageBlockCover::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Embed(x) => {
                    crate::types::PageBlockEmbed::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::EmbedPost(x) => {
                    crate::types::PageBlockEmbedPost::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Collage(x) => {
                    crate::types::PageBlockCollage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Slideshow(x) => {
                    crate::types::PageBlockSlideshow::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Channel(x) => {
                    crate::types::PageBlockChannel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Audio(x) => {
                    crate::types::PageBlockAudio::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Kicker(x) => {
                    crate::types::PageBlockKicker::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Table(x) => {
                    crate::types::PageBlockTable::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::OrderedList(x) => {
                    crate::types::PageBlockOrderedList::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Details(x) => {
                    crate::types::PageBlockDetails::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::RelatedArticles(x) => {
                    crate::types::PageBlockRelatedArticles::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Map(x) => {
                    crate::types::PageBlockMap::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageBlock {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageBlockUnsupported::CONSTRUCTOR_ID => Self::Unsupported,
                crate::types::PageBlockTitle::CONSTRUCTOR_ID => {
                    Self::Title(crate::types::PageBlockTitle::deserialize(buf)?)
                }
                crate::types::PageBlockSubtitle::CONSTRUCTOR_ID => {
                    Self::Subtitle(crate::types::PageBlockSubtitle::deserialize(buf)?)
                }
                crate::types::PageBlockAuthorDate::CONSTRUCTOR_ID => {
                    Self::AuthorDate(crate::types::PageBlockAuthorDate::deserialize(buf)?)
                }
                crate::types::PageBlockHeader::CONSTRUCTOR_ID => {
                    Self::Header(crate::types::PageBlockHeader::deserialize(buf)?)
                }
                crate::types::PageBlockSubheader::CONSTRUCTOR_ID => {
                    Self::Subheader(crate::types::PageBlockSubheader::deserialize(buf)?)
                }
                crate::types::PageBlockParagraph::CONSTRUCTOR_ID => {
                    Self::Paragraph(crate::types::PageBlockParagraph::deserialize(buf)?)
                }
                crate::types::PageBlockPreformatted::CONSTRUCTOR_ID => {
                    Self::Preformatted(crate::types::PageBlockPreformatted::deserialize(buf)?)
                }
                crate::types::PageBlockFooter::CONSTRUCTOR_ID => {
                    Self::Footer(crate::types::PageBlockFooter::deserialize(buf)?)
                }
                crate::types::PageBlockDivider::CONSTRUCTOR_ID => Self::Divider,
                crate::types::PageBlockAnchor::CONSTRUCTOR_ID => {
                    Self::Anchor(crate::types::PageBlockAnchor::deserialize(buf)?)
                }
                crate::types::PageBlockList::CONSTRUCTOR_ID => {
                    Self::List(crate::types::PageBlockList::deserialize(buf)?)
                }
                crate::types::PageBlockBlockquote::CONSTRUCTOR_ID => {
                    Self::Blockquote(crate::types::PageBlockBlockquote::deserialize(buf)?)
                }
                crate::types::PageBlockPullquote::CONSTRUCTOR_ID => {
                    Self::Pullquote(crate::types::PageBlockPullquote::deserialize(buf)?)
                }
                crate::types::PageBlockPhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::PageBlockPhoto::deserialize(buf)?)
                }
                crate::types::PageBlockVideo::CONSTRUCTOR_ID => {
                    Self::Video(crate::types::PageBlockVideo::deserialize(buf)?)
                }
                crate::types::PageBlockCover::CONSTRUCTOR_ID => {
                    Self::Cover(Box::new(crate::types::PageBlockCover::deserialize(buf)?))
                }
                crate::types::PageBlockEmbed::CONSTRUCTOR_ID => {
                    Self::Embed(crate::types::PageBlockEmbed::deserialize(buf)?)
                }
                crate::types::PageBlockEmbedPost::CONSTRUCTOR_ID => {
                    Self::EmbedPost(crate::types::PageBlockEmbedPost::deserialize(buf)?)
                }
                crate::types::PageBlockCollage::CONSTRUCTOR_ID => {
                    Self::Collage(crate::types::PageBlockCollage::deserialize(buf)?)
                }
                crate::types::PageBlockSlideshow::CONSTRUCTOR_ID => {
                    Self::Slideshow(crate::types::PageBlockSlideshow::deserialize(buf)?)
                }
                crate::types::PageBlockChannel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::PageBlockChannel::deserialize(buf)?)
                }
                crate::types::PageBlockAudio::CONSTRUCTOR_ID => {
                    Self::Audio(crate::types::PageBlockAudio::deserialize(buf)?)
                }
                crate::types::PageBlockKicker::CONSTRUCTOR_ID => {
                    Self::Kicker(crate::types::PageBlockKicker::deserialize(buf)?)
                }
                crate::types::PageBlockTable::CONSTRUCTOR_ID => {
                    Self::Table(crate::types::PageBlockTable::deserialize(buf)?)
                }
                crate::types::PageBlockOrderedList::CONSTRUCTOR_ID => {
                    Self::OrderedList(crate::types::PageBlockOrderedList::deserialize(buf)?)
                }
                crate::types::PageBlockDetails::CONSTRUCTOR_ID => {
                    Self::Details(crate::types::PageBlockDetails::deserialize(buf)?)
                }
                crate::types::PageBlockRelatedArticles::CONSTRUCTOR_ID => {
                    Self::RelatedArticles(crate::types::PageBlockRelatedArticles::deserialize(buf)?)
                }
                crate::types::PageBlockMap::CONSTRUCTOR_ID => {
                    Self::Map(crate::types::PageBlockMap::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageBlockUnsupported> for PageBlock {
        fn from(_x: crate::types::PageBlockUnsupported) -> Self {
            PageBlock::Unsupported
        }
    }
    impl From<crate::types::PageBlockTitle> for PageBlock {
        fn from(x: crate::types::PageBlockTitle) -> Self {
            PageBlock::Title(x)
        }
    }
    impl From<crate::types::PageBlockSubtitle> for PageBlock {
        fn from(x: crate::types::PageBlockSubtitle) -> Self {
            PageBlock::Subtitle(x)
        }
    }
    impl From<crate::types::PageBlockAuthorDate> for PageBlock {
        fn from(x: crate::types::PageBlockAuthorDate) -> Self {
            PageBlock::AuthorDate(x)
        }
    }
    impl From<crate::types::PageBlockHeader> for PageBlock {
        fn from(x: crate::types::PageBlockHeader) -> Self {
            PageBlock::Header(x)
        }
    }
    impl From<crate::types::PageBlockSubheader> for PageBlock {
        fn from(x: crate::types::PageBlockSubheader) -> Self {
            PageBlock::Subheader(x)
        }
    }
    impl From<crate::types::PageBlockParagraph> for PageBlock {
        fn from(x: crate::types::PageBlockParagraph) -> Self {
            PageBlock::Paragraph(x)
        }
    }
    impl From<crate::types::PageBlockPreformatted> for PageBlock {
        fn from(x: crate::types::PageBlockPreformatted) -> Self {
            PageBlock::Preformatted(x)
        }
    }
    impl From<crate::types::PageBlockFooter> for PageBlock {
        fn from(x: crate::types::PageBlockFooter) -> Self {
            PageBlock::Footer(x)
        }
    }
    impl From<crate::types::PageBlockDivider> for PageBlock {
        fn from(_x: crate::types::PageBlockDivider) -> Self {
            PageBlock::Divider
        }
    }
    impl From<crate::types::PageBlockAnchor> for PageBlock {
        fn from(x: crate::types::PageBlockAnchor) -> Self {
            PageBlock::Anchor(x)
        }
    }
    impl From<crate::types::PageBlockList> for PageBlock {
        fn from(x: crate::types::PageBlockList) -> Self {
            PageBlock::List(x)
        }
    }
    impl From<crate::types::PageBlockBlockquote> for PageBlock {
        fn from(x: crate::types::PageBlockBlockquote) -> Self {
            PageBlock::Blockquote(x)
        }
    }
    impl From<crate::types::PageBlockPullquote> for PageBlock {
        fn from(x: crate::types::PageBlockPullquote) -> Self {
            PageBlock::Pullquote(x)
        }
    }
    impl From<crate::types::PageBlockPhoto> for PageBlock {
        fn from(x: crate::types::PageBlockPhoto) -> Self {
            PageBlock::Photo(x)
        }
    }
    impl From<crate::types::PageBlockVideo> for PageBlock {
        fn from(x: crate::types::PageBlockVideo) -> Self {
            PageBlock::Video(x)
        }
    }
    impl From<crate::types::PageBlockCover> for PageBlock {
        fn from(x: crate::types::PageBlockCover) -> Self {
            PageBlock::Cover(Box::new(x))
        }
    }
    impl From<crate::types::PageBlockEmbed> for PageBlock {
        fn from(x: crate::types::PageBlockEmbed) -> Self {
            PageBlock::Embed(x)
        }
    }
    impl From<crate::types::PageBlockEmbedPost> for PageBlock {
        fn from(x: crate::types::PageBlockEmbedPost) -> Self {
            PageBlock::EmbedPost(x)
        }
    }
    impl From<crate::types::PageBlockCollage> for PageBlock {
        fn from(x: crate::types::PageBlockCollage) -> Self {
            PageBlock::Collage(x)
        }
    }
    impl From<crate::types::PageBlockSlideshow> for PageBlock {
        fn from(x: crate::types::PageBlockSlideshow) -> Self {
            PageBlock::Slideshow(x)
        }
    }
    impl From<crate::types::PageBlockChannel> for PageBlock {
        fn from(x: crate::types::PageBlockChannel) -> Self {
            PageBlock::Channel(x)
        }
    }
    impl From<crate::types::PageBlockAudio> for PageBlock {
        fn from(x: crate::types::PageBlockAudio) -> Self {
            PageBlock::Audio(x)
        }
    }
    impl From<crate::types::PageBlockKicker> for PageBlock {
        fn from(x: crate::types::PageBlockKicker) -> Self {
            PageBlock::Kicker(x)
        }
    }
    impl From<crate::types::PageBlockTable> for PageBlock {
        fn from(x: crate::types::PageBlockTable) -> Self {
            PageBlock::Table(x)
        }
    }
    impl From<crate::types::PageBlockOrderedList> for PageBlock {
        fn from(x: crate::types::PageBlockOrderedList) -> Self {
            PageBlock::OrderedList(x)
        }
    }
    impl From<crate::types::PageBlockDetails> for PageBlock {
        fn from(x: crate::types::PageBlockDetails) -> Self {
            PageBlock::Details(x)
        }
    }
    impl From<crate::types::PageBlockRelatedArticles> for PageBlock {
        fn from(x: crate::types::PageBlockRelatedArticles) -> Self {
            PageBlock::RelatedArticles(x)
        }
    }
    impl From<crate::types::PageBlockMap> for PageBlock {
        fn from(x: crate::types::PageBlockMap) -> Self {
            PageBlock::Map(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageCaption {
        Caption(crate::types::PageCaption),
    }
    impl crate::Serializable for PageCaption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Caption(x) => {
                    crate::types::PageCaption::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageCaption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageCaption::CONSTRUCTOR_ID => {
                    Self::Caption(crate::types::PageCaption::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageCaption> for PageCaption {
        fn from(x: crate::types::PageCaption) -> Self {
            PageCaption::Caption(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageListItem {
        Text(crate::types::PageListItemText),
        Blocks(crate::types::PageListItemBlocks),
    }
    impl crate::Serializable for PageListItem {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Text(x) => {
                    crate::types::PageListItemText::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Blocks(x) => {
                    crate::types::PageListItemBlocks::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageListItem {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageListItemText::CONSTRUCTOR_ID => {
                    Self::Text(crate::types::PageListItemText::deserialize(buf)?)
                }
                crate::types::PageListItemBlocks::CONSTRUCTOR_ID => {
                    Self::Blocks(crate::types::PageListItemBlocks::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageListItemText> for PageListItem {
        fn from(x: crate::types::PageListItemText) -> Self {
            PageListItem::Text(x)
        }
    }
    impl From<crate::types::PageListItemBlocks> for PageListItem {
        fn from(x: crate::types::PageListItemBlocks) -> Self {
            PageListItem::Blocks(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageListOrderedItem {
        Text(crate::types::PageListOrderedItemText),
        Blocks(crate::types::PageListOrderedItemBlocks),
    }
    impl PageListOrderedItem {
        pub fn num(&self) -> String {
            match self {
                Self::Text(i) => i.num.clone(),
                Self::Blocks(i) => i.num.clone(),
            }
        }
    }
    impl crate::Serializable for PageListOrderedItem {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Text(x) => {
                    crate::types::PageListOrderedItemText::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Blocks(x) => {
                    crate::types::PageListOrderedItemBlocks::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageListOrderedItem {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageListOrderedItemText::CONSTRUCTOR_ID => {
                    Self::Text(crate::types::PageListOrderedItemText::deserialize(buf)?)
                }
                crate::types::PageListOrderedItemBlocks::CONSTRUCTOR_ID => {
                    Self::Blocks(crate::types::PageListOrderedItemBlocks::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageListOrderedItemText> for PageListOrderedItem {
        fn from(x: crate::types::PageListOrderedItemText) -> Self {
            PageListOrderedItem::Text(x)
        }
    }
    impl From<crate::types::PageListOrderedItemBlocks> for PageListOrderedItem {
        fn from(x: crate::types::PageListOrderedItemBlocks) -> Self {
            PageListOrderedItem::Blocks(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageRelatedArticle {
        Article(crate::types::PageRelatedArticle),
    }
    impl crate::Serializable for PageRelatedArticle {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Article(x) => {
                    crate::types::PageRelatedArticle::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageRelatedArticle {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageRelatedArticle::CONSTRUCTOR_ID => {
                    Self::Article(crate::types::PageRelatedArticle::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageRelatedArticle> for PageRelatedArticle {
        fn from(x: crate::types::PageRelatedArticle) -> Self {
            PageRelatedArticle::Article(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageTableCell {
        Cell(crate::types::PageTableCell),
    }
    impl crate::Serializable for PageTableCell {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Cell(x) => {
                    crate::types::PageTableCell::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageTableCell {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageTableCell::CONSTRUCTOR_ID => {
                    Self::Cell(crate::types::PageTableCell::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageTableCell> for PageTableCell {
        fn from(x: crate::types::PageTableCell) -> Self {
            PageTableCell::Cell(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PageTableRow {
        Row(crate::types::PageTableRow),
    }
    impl crate::Serializable for PageTableRow {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Row(x) => {
                    crate::types::PageTableRow::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PageTableRow {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PageTableRow::CONSTRUCTOR_ID => {
                    Self::Row(crate::types::PageTableRow::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PageTableRow> for PageTableRow {
        fn from(x: crate::types::PageTableRow) -> Self {
            PageTableRow::Row(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PasswordKdfAlgo {
        Unknown,
        Sha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow(
            crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow,
        ),
    }
    impl crate::Serializable for PasswordKdfAlgo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Unknown => {
                    crate::types::PasswordKdfAlgoUnknown::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Sha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow(x) => {
                    crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PasswordKdfAlgo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PasswordKdfAlgoUnknown::CONSTRUCTOR_ID => Self::Unknown,
                crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow::CONSTRUCTOR_ID => Self::Sha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow(crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow::deserialize(buf)?),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PasswordKdfAlgoUnknown> for PasswordKdfAlgo {
        fn from(_x: crate::types::PasswordKdfAlgoUnknown) -> Self {
            PasswordKdfAlgo::Unknown
        }
    }
    impl From<crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow>
        for PasswordKdfAlgo
    {
        fn from(
            x: crate::types::PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow,
        ) -> Self {
            PasswordKdfAlgo::Sha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PaymentCharge {
        Charge(crate::types::PaymentCharge),
    }
    impl crate::Serializable for PaymentCharge {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Charge(x) => {
                    crate::types::PaymentCharge::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PaymentCharge {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PaymentCharge::CONSTRUCTOR_ID => {
                    Self::Charge(crate::types::PaymentCharge::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PaymentCharge> for PaymentCharge {
        fn from(x: crate::types::PaymentCharge) -> Self {
            PaymentCharge::Charge(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PaymentRequestedInfo {
        Info(crate::types::PaymentRequestedInfo),
    }
    impl crate::Serializable for PaymentRequestedInfo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Info(x) => {
                    crate::types::PaymentRequestedInfo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PaymentRequestedInfo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PaymentRequestedInfo::CONSTRUCTOR_ID => {
                    Self::Info(crate::types::PaymentRequestedInfo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PaymentRequestedInfo> for PaymentRequestedInfo {
        fn from(x: crate::types::PaymentRequestedInfo) -> Self {
            PaymentRequestedInfo::Info(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PaymentSavedCredentials {
        Card(crate::types::PaymentSavedCredentialsCard),
    }
    impl crate::Serializable for PaymentSavedCredentials {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Card(x) => {
                    crate::types::PaymentSavedCredentialsCard::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PaymentSavedCredentials {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PaymentSavedCredentialsCard::CONSTRUCTOR_ID => {
                    Self::Card(crate::types::PaymentSavedCredentialsCard::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PaymentSavedCredentialsCard> for PaymentSavedCredentials {
        fn from(x: crate::types::PaymentSavedCredentialsCard) -> Self {
            PaymentSavedCredentials::Card(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Peer {
        User(crate::types::PeerUser),
        Chat(crate::types::PeerChat),
        Channel(crate::types::PeerChannel),
    }
    impl crate::Serializable for Peer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::User(x) => {
                    crate::types::PeerUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Chat(x) => {
                    crate::types::PeerChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Channel(x) => {
                    crate::types::PeerChannel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Peer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PeerUser::CONSTRUCTOR_ID => {
                    Self::User(crate::types::PeerUser::deserialize(buf)?)
                }
                crate::types::PeerChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::PeerChat::deserialize(buf)?)
                }
                crate::types::PeerChannel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::PeerChannel::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PeerUser> for Peer {
        fn from(x: crate::types::PeerUser) -> Self {
            Peer::User(x)
        }
    }
    impl From<crate::types::PeerChat> for Peer {
        fn from(x: crate::types::PeerChat) -> Self {
            Peer::Chat(x)
        }
    }
    impl From<crate::types::PeerChannel> for Peer {
        fn from(x: crate::types::PeerChannel) -> Self {
            Peer::Channel(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PeerBlocked {
        Blocked(crate::types::PeerBlocked),
    }
    impl crate::Serializable for PeerBlocked {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Blocked(x) => {
                    crate::types::PeerBlocked::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PeerBlocked {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PeerBlocked::CONSTRUCTOR_ID => {
                    Self::Blocked(crate::types::PeerBlocked::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PeerBlocked> for PeerBlocked {
        fn from(x: crate::types::PeerBlocked) -> Self {
            PeerBlocked::Blocked(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PeerLocated {
        Located(crate::types::PeerLocated),
        PeerSelfLocated(crate::types::PeerSelfLocated),
    }
    impl PeerLocated {
        pub fn expires(&self) -> i32 {
            match self {
                Self::Located(i) => i.expires,
                Self::PeerSelfLocated(i) => i.expires,
            }
        }
    }
    impl crate::Serializable for PeerLocated {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Located(x) => {
                    crate::types::PeerLocated::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerSelfLocated(x) => {
                    crate::types::PeerSelfLocated::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PeerLocated {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PeerLocated::CONSTRUCTOR_ID => {
                    Self::Located(crate::types::PeerLocated::deserialize(buf)?)
                }
                crate::types::PeerSelfLocated::CONSTRUCTOR_ID => {
                    Self::PeerSelfLocated(crate::types::PeerSelfLocated::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PeerLocated> for PeerLocated {
        fn from(x: crate::types::PeerLocated) -> Self {
            PeerLocated::Located(x)
        }
    }
    impl From<crate::types::PeerSelfLocated> for PeerLocated {
        fn from(x: crate::types::PeerSelfLocated) -> Self {
            PeerLocated::PeerSelfLocated(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PeerNotifySettings {
        Settings(crate::types::PeerNotifySettings),
    }
    impl crate::Serializable for PeerNotifySettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::PeerNotifySettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PeerNotifySettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PeerNotifySettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::PeerNotifySettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PeerNotifySettings> for PeerNotifySettings {
        fn from(x: crate::types::PeerNotifySettings) -> Self {
            PeerNotifySettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PeerSettings {
        Settings(crate::types::PeerSettings),
    }
    impl crate::Serializable for PeerSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::PeerSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PeerSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PeerSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::PeerSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PeerSettings> for PeerSettings {
        fn from(x: crate::types::PeerSettings) -> Self {
            PeerSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhoneCall {
        Empty(crate::types::PhoneCallEmpty),
        Waiting(crate::types::PhoneCallWaiting),
        Requested(crate::types::PhoneCallRequested),
        Accepted(crate::types::PhoneCallAccepted),
        Call(crate::types::PhoneCall),
        Discarded(crate::types::PhoneCallDiscarded),
    }
    impl PhoneCall {
        pub fn id(&self) -> i64 {
            match self {
                Self::Empty(i) => i.id,
                Self::Waiting(i) => i.id,
                Self::Requested(i) => i.id,
                Self::Accepted(i) => i.id,
                Self::Call(i) => i.id,
                Self::Discarded(i) => i.id,
            }
        }
    }
    impl crate::Serializable for PhoneCall {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::PhoneCallEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Waiting(x) => {
                    crate::types::PhoneCallWaiting::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Requested(x) => {
                    crate::types::PhoneCallRequested::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Accepted(x) => {
                    crate::types::PhoneCallAccepted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Call(x) => {
                    crate::types::PhoneCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Discarded(x) => {
                    crate::types::PhoneCallDiscarded::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PhoneCall {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhoneCallEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::PhoneCallEmpty::deserialize(buf)?)
                }
                crate::types::PhoneCallWaiting::CONSTRUCTOR_ID => {
                    Self::Waiting(crate::types::PhoneCallWaiting::deserialize(buf)?)
                }
                crate::types::PhoneCallRequested::CONSTRUCTOR_ID => {
                    Self::Requested(crate::types::PhoneCallRequested::deserialize(buf)?)
                }
                crate::types::PhoneCallAccepted::CONSTRUCTOR_ID => {
                    Self::Accepted(crate::types::PhoneCallAccepted::deserialize(buf)?)
                }
                crate::types::PhoneCall::CONSTRUCTOR_ID => {
                    Self::Call(crate::types::PhoneCall::deserialize(buf)?)
                }
                crate::types::PhoneCallDiscarded::CONSTRUCTOR_ID => {
                    Self::Discarded(crate::types::PhoneCallDiscarded::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhoneCallEmpty> for PhoneCall {
        fn from(x: crate::types::PhoneCallEmpty) -> Self {
            PhoneCall::Empty(x)
        }
    }
    impl From<crate::types::PhoneCallWaiting> for PhoneCall {
        fn from(x: crate::types::PhoneCallWaiting) -> Self {
            PhoneCall::Waiting(x)
        }
    }
    impl From<crate::types::PhoneCallRequested> for PhoneCall {
        fn from(x: crate::types::PhoneCallRequested) -> Self {
            PhoneCall::Requested(x)
        }
    }
    impl From<crate::types::PhoneCallAccepted> for PhoneCall {
        fn from(x: crate::types::PhoneCallAccepted) -> Self {
            PhoneCall::Accepted(x)
        }
    }
    impl From<crate::types::PhoneCall> for PhoneCall {
        fn from(x: crate::types::PhoneCall) -> Self {
            PhoneCall::Call(x)
        }
    }
    impl From<crate::types::PhoneCallDiscarded> for PhoneCall {
        fn from(x: crate::types::PhoneCallDiscarded) -> Self {
            PhoneCall::Discarded(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhoneCallDiscardReason {
        Missed,
        Disconnect,
        Hangup,
        Busy,
    }
    impl crate::Serializable for PhoneCallDiscardReason {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Missed => {
                    crate::types::PhoneCallDiscardReasonMissed::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Disconnect => {
                    crate::types::PhoneCallDiscardReasonDisconnect::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Hangup => {
                    crate::types::PhoneCallDiscardReasonHangup::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Busy => {
                    crate::types::PhoneCallDiscardReasonBusy::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for PhoneCallDiscardReason {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhoneCallDiscardReasonMissed::CONSTRUCTOR_ID => Self::Missed,
                crate::types::PhoneCallDiscardReasonDisconnect::CONSTRUCTOR_ID => Self::Disconnect,
                crate::types::PhoneCallDiscardReasonHangup::CONSTRUCTOR_ID => Self::Hangup,
                crate::types::PhoneCallDiscardReasonBusy::CONSTRUCTOR_ID => Self::Busy,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhoneCallDiscardReasonMissed> for PhoneCallDiscardReason {
        fn from(_x: crate::types::PhoneCallDiscardReasonMissed) -> Self {
            PhoneCallDiscardReason::Missed
        }
    }
    impl From<crate::types::PhoneCallDiscardReasonDisconnect> for PhoneCallDiscardReason {
        fn from(_x: crate::types::PhoneCallDiscardReasonDisconnect) -> Self {
            PhoneCallDiscardReason::Disconnect
        }
    }
    impl From<crate::types::PhoneCallDiscardReasonHangup> for PhoneCallDiscardReason {
        fn from(_x: crate::types::PhoneCallDiscardReasonHangup) -> Self {
            PhoneCallDiscardReason::Hangup
        }
    }
    impl From<crate::types::PhoneCallDiscardReasonBusy> for PhoneCallDiscardReason {
        fn from(_x: crate::types::PhoneCallDiscardReasonBusy) -> Self {
            PhoneCallDiscardReason::Busy
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhoneCallProtocol {
        Protocol(crate::types::PhoneCallProtocol),
    }
    impl crate::Serializable for PhoneCallProtocol {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Protocol(x) => {
                    crate::types::PhoneCallProtocol::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PhoneCallProtocol {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhoneCallProtocol::CONSTRUCTOR_ID => {
                    Self::Protocol(crate::types::PhoneCallProtocol::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhoneCallProtocol> for PhoneCallProtocol {
        fn from(x: crate::types::PhoneCallProtocol) -> Self {
            PhoneCallProtocol::Protocol(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhoneConnection {
        Connection(crate::types::PhoneConnection),
        Webrtc(crate::types::PhoneConnectionWebrtc),
    }
    impl PhoneConnection {
        pub fn ipv6(&self) -> String {
            match self {
                Self::Connection(i) => i.ipv6.clone(),
                Self::Webrtc(i) => i.ipv6.clone(),
            }
        }
        pub fn ip(&self) -> String {
            match self {
                Self::Connection(i) => i.ip.clone(),
                Self::Webrtc(i) => i.ip.clone(),
            }
        }
        pub fn id(&self) -> i64 {
            match self {
                Self::Connection(i) => i.id,
                Self::Webrtc(i) => i.id,
            }
        }
        pub fn port(&self) -> i32 {
            match self {
                Self::Connection(i) => i.port,
                Self::Webrtc(i) => i.port,
            }
        }
    }
    impl crate::Serializable for PhoneConnection {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Connection(x) => {
                    crate::types::PhoneConnection::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Webrtc(x) => {
                    crate::types::PhoneConnectionWebrtc::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PhoneConnection {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhoneConnection::CONSTRUCTOR_ID => {
                    Self::Connection(crate::types::PhoneConnection::deserialize(buf)?)
                }
                crate::types::PhoneConnectionWebrtc::CONSTRUCTOR_ID => {
                    Self::Webrtc(crate::types::PhoneConnectionWebrtc::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhoneConnection> for PhoneConnection {
        fn from(x: crate::types::PhoneConnection) -> Self {
            PhoneConnection::Connection(x)
        }
    }
    impl From<crate::types::PhoneConnectionWebrtc> for PhoneConnection {
        fn from(x: crate::types::PhoneConnectionWebrtc) -> Self {
            PhoneConnection::Webrtc(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Photo {
        Empty(crate::types::PhotoEmpty),
        Photo(crate::types::Photo),
    }
    impl Photo {
        pub fn id(&self) -> i64 {
            match self {
                Self::Empty(i) => i.id,
                Self::Photo(i) => i.id,
            }
        }
    }
    impl crate::Serializable for Photo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::PhotoEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Photo(x) => {
                    crate::types::Photo::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Photo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhotoEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::PhotoEmpty::deserialize(buf)?)
                }
                crate::types::Photo::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::Photo::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhotoEmpty> for Photo {
        fn from(x: crate::types::PhotoEmpty) -> Self {
            Photo::Empty(x)
        }
    }
    impl From<crate::types::Photo> for Photo {
        fn from(x: crate::types::Photo) -> Self {
            Photo::Photo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhotoSize {
        Empty(crate::types::PhotoSizeEmpty),
        Size(crate::types::PhotoSize),
        PhotoCachedSize(crate::types::PhotoCachedSize),
        PhotoStrippedSize(crate::types::PhotoStrippedSize),
        Progressive(crate::types::PhotoSizeProgressive),
        PhotoPathSize(crate::types::PhotoPathSize),
    }
    impl PhotoSize {
        pub fn r#type(&self) -> String {
            match self {
                Self::Empty(i) => i.r#type.clone(),
                Self::Size(i) => i.r#type.clone(),
                Self::PhotoCachedSize(i) => i.r#type.clone(),
                Self::PhotoStrippedSize(i) => i.r#type.clone(),
                Self::Progressive(i) => i.r#type.clone(),
                Self::PhotoPathSize(i) => i.r#type.clone(),
            }
        }
    }
    impl crate::Serializable for PhotoSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::PhotoSizeEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Size(x) => {
                    crate::types::PhotoSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhotoCachedSize(x) => {
                    crate::types::PhotoCachedSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhotoStrippedSize(x) => {
                    crate::types::PhotoStrippedSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Progressive(x) => {
                    crate::types::PhotoSizeProgressive::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhotoPathSize(x) => {
                    crate::types::PhotoPathSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PhotoSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PhotoSizeEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::PhotoSizeEmpty::deserialize(buf)?)
                }
                crate::types::PhotoSize::CONSTRUCTOR_ID => {
                    Self::Size(crate::types::PhotoSize::deserialize(buf)?)
                }
                crate::types::PhotoCachedSize::CONSTRUCTOR_ID => {
                    Self::PhotoCachedSize(crate::types::PhotoCachedSize::deserialize(buf)?)
                }
                crate::types::PhotoStrippedSize::CONSTRUCTOR_ID => {
                    Self::PhotoStrippedSize(crate::types::PhotoStrippedSize::deserialize(buf)?)
                }
                crate::types::PhotoSizeProgressive::CONSTRUCTOR_ID => {
                    Self::Progressive(crate::types::PhotoSizeProgressive::deserialize(buf)?)
                }
                crate::types::PhotoPathSize::CONSTRUCTOR_ID => {
                    Self::PhotoPathSize(crate::types::PhotoPathSize::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PhotoSizeEmpty> for PhotoSize {
        fn from(x: crate::types::PhotoSizeEmpty) -> Self {
            PhotoSize::Empty(x)
        }
    }
    impl From<crate::types::PhotoSize> for PhotoSize {
        fn from(x: crate::types::PhotoSize) -> Self {
            PhotoSize::Size(x)
        }
    }
    impl From<crate::types::PhotoCachedSize> for PhotoSize {
        fn from(x: crate::types::PhotoCachedSize) -> Self {
            PhotoSize::PhotoCachedSize(x)
        }
    }
    impl From<crate::types::PhotoStrippedSize> for PhotoSize {
        fn from(x: crate::types::PhotoStrippedSize) -> Self {
            PhotoSize::PhotoStrippedSize(x)
        }
    }
    impl From<crate::types::PhotoSizeProgressive> for PhotoSize {
        fn from(x: crate::types::PhotoSizeProgressive) -> Self {
            PhotoSize::Progressive(x)
        }
    }
    impl From<crate::types::PhotoPathSize> for PhotoSize {
        fn from(x: crate::types::PhotoPathSize) -> Self {
            PhotoSize::PhotoPathSize(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Poll {
        Poll(crate::types::Poll),
    }
    impl crate::Serializable for Poll {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Poll(x) => {
                    crate::types::Poll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Poll {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Poll::CONSTRUCTOR_ID => {
                    Self::Poll(crate::types::Poll::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Poll> for Poll {
        fn from(x: crate::types::Poll) -> Self {
            Poll::Poll(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PollAnswer {
        Answer(crate::types::PollAnswer),
    }
    impl crate::Serializable for PollAnswer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Answer(x) => {
                    crate::types::PollAnswer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PollAnswer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PollAnswer::CONSTRUCTOR_ID => {
                    Self::Answer(crate::types::PollAnswer::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PollAnswer> for PollAnswer {
        fn from(x: crate::types::PollAnswer) -> Self {
            PollAnswer::Answer(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PollAnswerVoters {
        Voters(crate::types::PollAnswerVoters),
    }
    impl crate::Serializable for PollAnswerVoters {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Voters(x) => {
                    crate::types::PollAnswerVoters::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PollAnswerVoters {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PollAnswerVoters::CONSTRUCTOR_ID => {
                    Self::Voters(crate::types::PollAnswerVoters::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PollAnswerVoters> for PollAnswerVoters {
        fn from(x: crate::types::PollAnswerVoters) -> Self {
            PollAnswerVoters::Voters(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PollResults {
        Results(crate::types::PollResults),
    }
    impl crate::Serializable for PollResults {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Results(x) => {
                    crate::types::PollResults::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PollResults {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PollResults::CONSTRUCTOR_ID => {
                    Self::Results(crate::types::PollResults::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PollResults> for PollResults {
        fn from(x: crate::types::PollResults) -> Self {
            PollResults::Results(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Pong {
        Pong(crate::types::Pong),
    }
    impl crate::Serializable for Pong {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Pong(x) => {
                    crate::types::Pong::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Pong {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Pong::CONSTRUCTOR_ID => {
                    Self::Pong(crate::types::Pong::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Pong> for Pong {
        fn from(x: crate::types::Pong) -> Self {
            Pong::Pong(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PopularContact {
        Contact(crate::types::PopularContact),
    }
    impl crate::Serializable for PopularContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Contact(x) => {
                    crate::types::PopularContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PopularContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PopularContact::CONSTRUCTOR_ID => {
                    Self::Contact(crate::types::PopularContact::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PopularContact> for PopularContact {
        fn from(x: crate::types::PopularContact) -> Self {
            PopularContact::Contact(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PostAddress {
        Address(crate::types::PostAddress),
    }
    impl crate::Serializable for PostAddress {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Address(x) => {
                    crate::types::PostAddress::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PostAddress {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PostAddress::CONSTRUCTOR_ID => {
                    Self::Address(crate::types::PostAddress::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PostAddress> for PostAddress {
        fn from(x: crate::types::PostAddress) -> Self {
            PostAddress::Address(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PrivacyKey {
        StatusTimestamp,
        ChatInvite,
        PhoneCall,
        PhoneP2P,
        Forwards,
        ProfilePhoto,
        PhoneNumber,
        AddedByPhone,
    }
    impl crate::Serializable for PrivacyKey {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::StatusTimestamp => {
                    crate::types::PrivacyKeyStatusTimestamp::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChatInvite => {
                    crate::types::PrivacyKeyChatInvite::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneCall => {
                    crate::types::PrivacyKeyPhoneCall::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneP2P => {
                    crate::types::PrivacyKeyPhoneP2P::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Forwards => {
                    crate::types::PrivacyKeyForwards::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ProfilePhoto => {
                    crate::types::PrivacyKeyProfilePhoto::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneNumber => {
                    crate::types::PrivacyKeyPhoneNumber::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::AddedByPhone => {
                    crate::types::PrivacyKeyAddedByPhone::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for PrivacyKey {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PrivacyKeyStatusTimestamp::CONSTRUCTOR_ID => Self::StatusTimestamp,
                crate::types::PrivacyKeyChatInvite::CONSTRUCTOR_ID => Self::ChatInvite,
                crate::types::PrivacyKeyPhoneCall::CONSTRUCTOR_ID => Self::PhoneCall,
                crate::types::PrivacyKeyPhoneP2P::CONSTRUCTOR_ID => Self::PhoneP2P,
                crate::types::PrivacyKeyForwards::CONSTRUCTOR_ID => Self::Forwards,
                crate::types::PrivacyKeyProfilePhoto::CONSTRUCTOR_ID => Self::ProfilePhoto,
                crate::types::PrivacyKeyPhoneNumber::CONSTRUCTOR_ID => Self::PhoneNumber,
                crate::types::PrivacyKeyAddedByPhone::CONSTRUCTOR_ID => Self::AddedByPhone,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PrivacyKeyStatusTimestamp> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyStatusTimestamp) -> Self {
            PrivacyKey::StatusTimestamp
        }
    }
    impl From<crate::types::PrivacyKeyChatInvite> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyChatInvite) -> Self {
            PrivacyKey::ChatInvite
        }
    }
    impl From<crate::types::PrivacyKeyPhoneCall> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyPhoneCall) -> Self {
            PrivacyKey::PhoneCall
        }
    }
    impl From<crate::types::PrivacyKeyPhoneP2P> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyPhoneP2P) -> Self {
            PrivacyKey::PhoneP2P
        }
    }
    impl From<crate::types::PrivacyKeyForwards> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyForwards) -> Self {
            PrivacyKey::Forwards
        }
    }
    impl From<crate::types::PrivacyKeyProfilePhoto> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyProfilePhoto) -> Self {
            PrivacyKey::ProfilePhoto
        }
    }
    impl From<crate::types::PrivacyKeyPhoneNumber> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyPhoneNumber) -> Self {
            PrivacyKey::PhoneNumber
        }
    }
    impl From<crate::types::PrivacyKeyAddedByPhone> for PrivacyKey {
        fn from(_x: crate::types::PrivacyKeyAddedByPhone) -> Self {
            PrivacyKey::AddedByPhone
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum PrivacyRule {
        PrivacyValueAllowContacts,
        PrivacyValueAllowAll,
        PrivacyValueAllowUsers(crate::types::PrivacyValueAllowUsers),
        PrivacyValueDisallowContacts,
        PrivacyValueDisallowAll,
        PrivacyValueDisallowUsers(crate::types::PrivacyValueDisallowUsers),
        PrivacyValueAllowChatParticipants(crate::types::PrivacyValueAllowChatParticipants),
        PrivacyValueDisallowChatParticipants(crate::types::PrivacyValueDisallowChatParticipants),
    }
    impl crate::Serializable for PrivacyRule {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::PrivacyValueAllowContacts => {
                    crate::types::PrivacyValueAllowContacts::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PrivacyValueAllowAll => {
                    crate::types::PrivacyValueAllowAll::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PrivacyValueAllowUsers(x) => {
                    crate::types::PrivacyValueAllowUsers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PrivacyValueDisallowContacts => {
                    crate::types::PrivacyValueDisallowContacts::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PrivacyValueDisallowAll => {
                    crate::types::PrivacyValueDisallowAll::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PrivacyValueDisallowUsers(x) => {
                    crate::types::PrivacyValueDisallowUsers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PrivacyValueAllowChatParticipants(x) => {
                    crate::types::PrivacyValueAllowChatParticipants::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PrivacyValueDisallowChatParticipants(x) => {
                    crate::types::PrivacyValueDisallowChatParticipants::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for PrivacyRule {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::PrivacyValueAllowContacts::CONSTRUCTOR_ID => {
                    Self::PrivacyValueAllowContacts
                }
                crate::types::PrivacyValueAllowAll::CONSTRUCTOR_ID => Self::PrivacyValueAllowAll,
                crate::types::PrivacyValueAllowUsers::CONSTRUCTOR_ID => {
                    Self::PrivacyValueAllowUsers(crate::types::PrivacyValueAllowUsers::deserialize(
                        buf,
                    )?)
                }
                crate::types::PrivacyValueDisallowContacts::CONSTRUCTOR_ID => {
                    Self::PrivacyValueDisallowContacts
                }
                crate::types::PrivacyValueDisallowAll::CONSTRUCTOR_ID => {
                    Self::PrivacyValueDisallowAll
                }
                crate::types::PrivacyValueDisallowUsers::CONSTRUCTOR_ID => {
                    Self::PrivacyValueDisallowUsers(
                        crate::types::PrivacyValueDisallowUsers::deserialize(buf)?,
                    )
                }
                crate::types::PrivacyValueAllowChatParticipants::CONSTRUCTOR_ID => {
                    Self::PrivacyValueAllowChatParticipants(
                        crate::types::PrivacyValueAllowChatParticipants::deserialize(buf)?,
                    )
                }
                crate::types::PrivacyValueDisallowChatParticipants::CONSTRUCTOR_ID => {
                    Self::PrivacyValueDisallowChatParticipants(
                        crate::types::PrivacyValueDisallowChatParticipants::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::PrivacyValueAllowContacts> for PrivacyRule {
        fn from(_x: crate::types::PrivacyValueAllowContacts) -> Self {
            PrivacyRule::PrivacyValueAllowContacts
        }
    }
    impl From<crate::types::PrivacyValueAllowAll> for PrivacyRule {
        fn from(_x: crate::types::PrivacyValueAllowAll) -> Self {
            PrivacyRule::PrivacyValueAllowAll
        }
    }
    impl From<crate::types::PrivacyValueAllowUsers> for PrivacyRule {
        fn from(x: crate::types::PrivacyValueAllowUsers) -> Self {
            PrivacyRule::PrivacyValueAllowUsers(x)
        }
    }
    impl From<crate::types::PrivacyValueDisallowContacts> for PrivacyRule {
        fn from(_x: crate::types::PrivacyValueDisallowContacts) -> Self {
            PrivacyRule::PrivacyValueDisallowContacts
        }
    }
    impl From<crate::types::PrivacyValueDisallowAll> for PrivacyRule {
        fn from(_x: crate::types::PrivacyValueDisallowAll) -> Self {
            PrivacyRule::PrivacyValueDisallowAll
        }
    }
    impl From<crate::types::PrivacyValueDisallowUsers> for PrivacyRule {
        fn from(x: crate::types::PrivacyValueDisallowUsers) -> Self {
            PrivacyRule::PrivacyValueDisallowUsers(x)
        }
    }
    impl From<crate::types::PrivacyValueAllowChatParticipants> for PrivacyRule {
        fn from(x: crate::types::PrivacyValueAllowChatParticipants) -> Self {
            PrivacyRule::PrivacyValueAllowChatParticipants(x)
        }
    }
    impl From<crate::types::PrivacyValueDisallowChatParticipants> for PrivacyRule {
        fn from(x: crate::types::PrivacyValueDisallowChatParticipants) -> Self {
            PrivacyRule::PrivacyValueDisallowChatParticipants(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ReceivedNotifyMessage {
        Message(crate::types::ReceivedNotifyMessage),
    }
    impl crate::Serializable for ReceivedNotifyMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Message(x) => {
                    crate::types::ReceivedNotifyMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ReceivedNotifyMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ReceivedNotifyMessage::CONSTRUCTOR_ID => {
                    Self::Message(crate::types::ReceivedNotifyMessage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ReceivedNotifyMessage> for ReceivedNotifyMessage {
        fn from(x: crate::types::ReceivedNotifyMessage) -> Self {
            ReceivedNotifyMessage::Message(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum RecentMeUrl {
        Unknown(crate::types::RecentMeUrlUnknown),
        User(crate::types::RecentMeUrlUser),
        Chat(crate::types::RecentMeUrlChat),
        ChatInvite(crate::types::RecentMeUrlChatInvite),
        StickerSet(crate::types::RecentMeUrlStickerSet),
    }
    impl RecentMeUrl {
        pub fn url(&self) -> String {
            match self {
                Self::Unknown(i) => i.url.clone(),
                Self::User(i) => i.url.clone(),
                Self::Chat(i) => i.url.clone(),
                Self::ChatInvite(i) => i.url.clone(),
                Self::StickerSet(i) => i.url.clone(),
            }
        }
    }
    impl crate::Serializable for RecentMeUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Unknown(x) => {
                    crate::types::RecentMeUrlUnknown::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::User(x) => {
                    crate::types::RecentMeUrlUser::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Chat(x) => {
                    crate::types::RecentMeUrlChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatInvite(x) => {
                    crate::types::RecentMeUrlChatInvite::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::StickerSet(x) => {
                    crate::types::RecentMeUrlStickerSet::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for RecentMeUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::RecentMeUrlUnknown::CONSTRUCTOR_ID => {
                    Self::Unknown(crate::types::RecentMeUrlUnknown::deserialize(buf)?)
                }
                crate::types::RecentMeUrlUser::CONSTRUCTOR_ID => {
                    Self::User(crate::types::RecentMeUrlUser::deserialize(buf)?)
                }
                crate::types::RecentMeUrlChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::RecentMeUrlChat::deserialize(buf)?)
                }
                crate::types::RecentMeUrlChatInvite::CONSTRUCTOR_ID => {
                    Self::ChatInvite(crate::types::RecentMeUrlChatInvite::deserialize(buf)?)
                }
                crate::types::RecentMeUrlStickerSet::CONSTRUCTOR_ID => {
                    Self::StickerSet(crate::types::RecentMeUrlStickerSet::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::RecentMeUrlUnknown> for RecentMeUrl {
        fn from(x: crate::types::RecentMeUrlUnknown) -> Self {
            RecentMeUrl::Unknown(x)
        }
    }
    impl From<crate::types::RecentMeUrlUser> for RecentMeUrl {
        fn from(x: crate::types::RecentMeUrlUser) -> Self {
            RecentMeUrl::User(x)
        }
    }
    impl From<crate::types::RecentMeUrlChat> for RecentMeUrl {
        fn from(x: crate::types::RecentMeUrlChat) -> Self {
            RecentMeUrl::Chat(x)
        }
    }
    impl From<crate::types::RecentMeUrlChatInvite> for RecentMeUrl {
        fn from(x: crate::types::RecentMeUrlChatInvite) -> Self {
            RecentMeUrl::ChatInvite(x)
        }
    }
    impl From<crate::types::RecentMeUrlStickerSet> for RecentMeUrl {
        fn from(x: crate::types::RecentMeUrlStickerSet) -> Self {
            RecentMeUrl::StickerSet(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ReplyMarkup {
        ReplyKeyboardHide(crate::types::ReplyKeyboardHide),
        ReplyKeyboardForceReply(crate::types::ReplyKeyboardForceReply),
        ReplyKeyboardMarkup(crate::types::ReplyKeyboardMarkup),
        ReplyInlineMarkup(crate::types::ReplyInlineMarkup),
    }
    impl crate::Serializable for ReplyMarkup {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::ReplyKeyboardHide(x) => {
                    crate::types::ReplyKeyboardHide::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReplyKeyboardForceReply(x) => {
                    crate::types::ReplyKeyboardForceReply::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReplyKeyboardMarkup(x) => {
                    crate::types::ReplyKeyboardMarkup::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReplyInlineMarkup(x) => {
                    crate::types::ReplyInlineMarkup::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ReplyMarkup {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ReplyKeyboardHide::CONSTRUCTOR_ID => {
                    Self::ReplyKeyboardHide(crate::types::ReplyKeyboardHide::deserialize(buf)?)
                }
                crate::types::ReplyKeyboardForceReply::CONSTRUCTOR_ID => {
                    Self::ReplyKeyboardForceReply(
                        crate::types::ReplyKeyboardForceReply::deserialize(buf)?,
                    )
                }
                crate::types::ReplyKeyboardMarkup::CONSTRUCTOR_ID => {
                    Self::ReplyKeyboardMarkup(crate::types::ReplyKeyboardMarkup::deserialize(buf)?)
                }
                crate::types::ReplyInlineMarkup::CONSTRUCTOR_ID => {
                    Self::ReplyInlineMarkup(crate::types::ReplyInlineMarkup::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ReplyKeyboardHide> for ReplyMarkup {
        fn from(x: crate::types::ReplyKeyboardHide) -> Self {
            ReplyMarkup::ReplyKeyboardHide(x)
        }
    }
    impl From<crate::types::ReplyKeyboardForceReply> for ReplyMarkup {
        fn from(x: crate::types::ReplyKeyboardForceReply) -> Self {
            ReplyMarkup::ReplyKeyboardForceReply(x)
        }
    }
    impl From<crate::types::ReplyKeyboardMarkup> for ReplyMarkup {
        fn from(x: crate::types::ReplyKeyboardMarkup) -> Self {
            ReplyMarkup::ReplyKeyboardMarkup(x)
        }
    }
    impl From<crate::types::ReplyInlineMarkup> for ReplyMarkup {
        fn from(x: crate::types::ReplyInlineMarkup) -> Self {
            ReplyMarkup::ReplyInlineMarkup(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ReportReason {
        InputReportReasonSpam,
        InputReportReasonViolence,
        InputReportReasonPornography,
        InputReportReasonChildAbuse,
        InputReportReasonOther,
        InputReportReasonCopyright,
        InputReportReasonGeoIrrelevant,
        InputReportReasonFake,
    }
    impl crate::Serializable for ReportReason {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::InputReportReasonSpam => {
                    crate::types::InputReportReasonSpam::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonViolence => {
                    crate::types::InputReportReasonViolence::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonPornography => {
                    crate::types::InputReportReasonPornography::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonChildAbuse => {
                    crate::types::InputReportReasonChildAbuse::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonOther => {
                    crate::types::InputReportReasonOther::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonCopyright => {
                    crate::types::InputReportReasonCopyright::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonGeoIrrelevant => {
                    crate::types::InputReportReasonGeoIrrelevant::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InputReportReasonFake => {
                    crate::types::InputReportReasonFake::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for ReportReason {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::InputReportReasonSpam::CONSTRUCTOR_ID => Self::InputReportReasonSpam,
                crate::types::InputReportReasonViolence::CONSTRUCTOR_ID => {
                    Self::InputReportReasonViolence
                }
                crate::types::InputReportReasonPornography::CONSTRUCTOR_ID => {
                    Self::InputReportReasonPornography
                }
                crate::types::InputReportReasonChildAbuse::CONSTRUCTOR_ID => {
                    Self::InputReportReasonChildAbuse
                }
                crate::types::InputReportReasonOther::CONSTRUCTOR_ID => {
                    Self::InputReportReasonOther
                }
                crate::types::InputReportReasonCopyright::CONSTRUCTOR_ID => {
                    Self::InputReportReasonCopyright
                }
                crate::types::InputReportReasonGeoIrrelevant::CONSTRUCTOR_ID => {
                    Self::InputReportReasonGeoIrrelevant
                }
                crate::types::InputReportReasonFake::CONSTRUCTOR_ID => Self::InputReportReasonFake,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::InputReportReasonSpam> for ReportReason {
        fn from(_x: crate::types::InputReportReasonSpam) -> Self {
            ReportReason::InputReportReasonSpam
        }
    }
    impl From<crate::types::InputReportReasonViolence> for ReportReason {
        fn from(_x: crate::types::InputReportReasonViolence) -> Self {
            ReportReason::InputReportReasonViolence
        }
    }
    impl From<crate::types::InputReportReasonPornography> for ReportReason {
        fn from(_x: crate::types::InputReportReasonPornography) -> Self {
            ReportReason::InputReportReasonPornography
        }
    }
    impl From<crate::types::InputReportReasonChildAbuse> for ReportReason {
        fn from(_x: crate::types::InputReportReasonChildAbuse) -> Self {
            ReportReason::InputReportReasonChildAbuse
        }
    }
    impl From<crate::types::InputReportReasonOther> for ReportReason {
        fn from(_x: crate::types::InputReportReasonOther) -> Self {
            ReportReason::InputReportReasonOther
        }
    }
    impl From<crate::types::InputReportReasonCopyright> for ReportReason {
        fn from(_x: crate::types::InputReportReasonCopyright) -> Self {
            ReportReason::InputReportReasonCopyright
        }
    }
    impl From<crate::types::InputReportReasonGeoIrrelevant> for ReportReason {
        fn from(_x: crate::types::InputReportReasonGeoIrrelevant) -> Self {
            ReportReason::InputReportReasonGeoIrrelevant
        }
    }
    impl From<crate::types::InputReportReasonFake> for ReportReason {
        fn from(_x: crate::types::InputReportReasonFake) -> Self {
            ReportReason::InputReportReasonFake
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ResPq {
        Pq(crate::types::ResPq),
    }
    impl crate::Serializable for ResPq {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Pq(x) => {
                    crate::types::ResPq::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ResPq {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ResPq::CONSTRUCTOR_ID => {
                    Self::Pq(crate::types::ResPq::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ResPq> for ResPq {
        fn from(x: crate::types::ResPq) -> Self {
            ResPq::Pq(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum RestrictionReason {
        Reason(crate::types::RestrictionReason),
    }
    impl crate::Serializable for RestrictionReason {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Reason(x) => {
                    crate::types::RestrictionReason::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for RestrictionReason {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::RestrictionReason::CONSTRUCTOR_ID => {
                    Self::Reason(crate::types::RestrictionReason::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::RestrictionReason> for RestrictionReason {
        fn from(x: crate::types::RestrictionReason) -> Self {
            RestrictionReason::Reason(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum RichText {
        TextEmpty,
        TextPlain(crate::types::TextPlain),
        TextBold(Box<crate::types::TextBold>),
        TextItalic(Box<crate::types::TextItalic>),
        TextUnderline(Box<crate::types::TextUnderline>),
        TextStrike(Box<crate::types::TextStrike>),
        TextFixed(Box<crate::types::TextFixed>),
        TextUrl(Box<crate::types::TextUrl>),
        TextEmail(Box<crate::types::TextEmail>),
        TextConcat(crate::types::TextConcat),
        TextSubscript(Box<crate::types::TextSubscript>),
        TextSuperscript(Box<crate::types::TextSuperscript>),
        TextMarked(Box<crate::types::TextMarked>),
        TextPhone(Box<crate::types::TextPhone>),
        TextImage(crate::types::TextImage),
        TextAnchor(Box<crate::types::TextAnchor>),
    }
    impl crate::Serializable for RichText {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::TextEmpty => {
                    crate::types::TextEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::TextPlain(x) => {
                    crate::types::TextPlain::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextBold(x) => {
                    crate::types::TextBold::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextItalic(x) => {
                    crate::types::TextItalic::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextUnderline(x) => {
                    crate::types::TextUnderline::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextStrike(x) => {
                    crate::types::TextStrike::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextFixed(x) => {
                    crate::types::TextFixed::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextUrl(x) => {
                    crate::types::TextUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextEmail(x) => {
                    crate::types::TextEmail::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextConcat(x) => {
                    crate::types::TextConcat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextSubscript(x) => {
                    crate::types::TextSubscript::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextSuperscript(x) => {
                    crate::types::TextSuperscript::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextMarked(x) => {
                    crate::types::TextMarked::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextPhone(x) => {
                    crate::types::TextPhone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextImage(x) => {
                    crate::types::TextImage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TextAnchor(x) => {
                    crate::types::TextAnchor::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for RichText {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TextEmpty::CONSTRUCTOR_ID => Self::TextEmpty,
                crate::types::TextPlain::CONSTRUCTOR_ID => {
                    Self::TextPlain(crate::types::TextPlain::deserialize(buf)?)
                }
                crate::types::TextBold::CONSTRUCTOR_ID => {
                    Self::TextBold(Box::new(crate::types::TextBold::deserialize(buf)?))
                }
                crate::types::TextItalic::CONSTRUCTOR_ID => {
                    Self::TextItalic(Box::new(crate::types::TextItalic::deserialize(buf)?))
                }
                crate::types::TextUnderline::CONSTRUCTOR_ID => {
                    Self::TextUnderline(Box::new(crate::types::TextUnderline::deserialize(buf)?))
                }
                crate::types::TextStrike::CONSTRUCTOR_ID => {
                    Self::TextStrike(Box::new(crate::types::TextStrike::deserialize(buf)?))
                }
                crate::types::TextFixed::CONSTRUCTOR_ID => {
                    Self::TextFixed(Box::new(crate::types::TextFixed::deserialize(buf)?))
                }
                crate::types::TextUrl::CONSTRUCTOR_ID => {
                    Self::TextUrl(Box::new(crate::types::TextUrl::deserialize(buf)?))
                }
                crate::types::TextEmail::CONSTRUCTOR_ID => {
                    Self::TextEmail(Box::new(crate::types::TextEmail::deserialize(buf)?))
                }
                crate::types::TextConcat::CONSTRUCTOR_ID => {
                    Self::TextConcat(crate::types::TextConcat::deserialize(buf)?)
                }
                crate::types::TextSubscript::CONSTRUCTOR_ID => {
                    Self::TextSubscript(Box::new(crate::types::TextSubscript::deserialize(buf)?))
                }
                crate::types::TextSuperscript::CONSTRUCTOR_ID => Self::TextSuperscript(Box::new(
                    crate::types::TextSuperscript::deserialize(buf)?,
                )),
                crate::types::TextMarked::CONSTRUCTOR_ID => {
                    Self::TextMarked(Box::new(crate::types::TextMarked::deserialize(buf)?))
                }
                crate::types::TextPhone::CONSTRUCTOR_ID => {
                    Self::TextPhone(Box::new(crate::types::TextPhone::deserialize(buf)?))
                }
                crate::types::TextImage::CONSTRUCTOR_ID => {
                    Self::TextImage(crate::types::TextImage::deserialize(buf)?)
                }
                crate::types::TextAnchor::CONSTRUCTOR_ID => {
                    Self::TextAnchor(Box::new(crate::types::TextAnchor::deserialize(buf)?))
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TextEmpty> for RichText {
        fn from(_x: crate::types::TextEmpty) -> Self {
            RichText::TextEmpty
        }
    }
    impl From<crate::types::TextPlain> for RichText {
        fn from(x: crate::types::TextPlain) -> Self {
            RichText::TextPlain(x)
        }
    }
    impl From<crate::types::TextBold> for RichText {
        fn from(x: crate::types::TextBold) -> Self {
            RichText::TextBold(Box::new(x))
        }
    }
    impl From<crate::types::TextItalic> for RichText {
        fn from(x: crate::types::TextItalic) -> Self {
            RichText::TextItalic(Box::new(x))
        }
    }
    impl From<crate::types::TextUnderline> for RichText {
        fn from(x: crate::types::TextUnderline) -> Self {
            RichText::TextUnderline(Box::new(x))
        }
    }
    impl From<crate::types::TextStrike> for RichText {
        fn from(x: crate::types::TextStrike) -> Self {
            RichText::TextStrike(Box::new(x))
        }
    }
    impl From<crate::types::TextFixed> for RichText {
        fn from(x: crate::types::TextFixed) -> Self {
            RichText::TextFixed(Box::new(x))
        }
    }
    impl From<crate::types::TextUrl> for RichText {
        fn from(x: crate::types::TextUrl) -> Self {
            RichText::TextUrl(Box::new(x))
        }
    }
    impl From<crate::types::TextEmail> for RichText {
        fn from(x: crate::types::TextEmail) -> Self {
            RichText::TextEmail(Box::new(x))
        }
    }
    impl From<crate::types::TextConcat> for RichText {
        fn from(x: crate::types::TextConcat) -> Self {
            RichText::TextConcat(x)
        }
    }
    impl From<crate::types::TextSubscript> for RichText {
        fn from(x: crate::types::TextSubscript) -> Self {
            RichText::TextSubscript(Box::new(x))
        }
    }
    impl From<crate::types::TextSuperscript> for RichText {
        fn from(x: crate::types::TextSuperscript) -> Self {
            RichText::TextSuperscript(Box::new(x))
        }
    }
    impl From<crate::types::TextMarked> for RichText {
        fn from(x: crate::types::TextMarked) -> Self {
            RichText::TextMarked(Box::new(x))
        }
    }
    impl From<crate::types::TextPhone> for RichText {
        fn from(x: crate::types::TextPhone) -> Self {
            RichText::TextPhone(Box::new(x))
        }
    }
    impl From<crate::types::TextImage> for RichText {
        fn from(x: crate::types::TextImage) -> Self {
            RichText::TextImage(x)
        }
    }
    impl From<crate::types::TextAnchor> for RichText {
        fn from(x: crate::types::TextAnchor) -> Self {
            RichText::TextAnchor(Box::new(x))
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum RpcDropAnswer {
        RpcAnswerUnknown,
        RpcAnswerDroppedRunning,
        RpcAnswerDropped(crate::types::RpcAnswerDropped),
    }
    impl crate::Serializable for RpcDropAnswer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::RpcAnswerUnknown => {
                    crate::types::RpcAnswerUnknown::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::RpcAnswerDroppedRunning => {
                    crate::types::RpcAnswerDroppedRunning::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::RpcAnswerDropped(x) => {
                    crate::types::RpcAnswerDropped::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for RpcDropAnswer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::RpcAnswerUnknown::CONSTRUCTOR_ID => Self::RpcAnswerUnknown,
                crate::types::RpcAnswerDroppedRunning::CONSTRUCTOR_ID => {
                    Self::RpcAnswerDroppedRunning
                }
                crate::types::RpcAnswerDropped::CONSTRUCTOR_ID => {
                    Self::RpcAnswerDropped(crate::types::RpcAnswerDropped::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::RpcAnswerUnknown> for RpcDropAnswer {
        fn from(_x: crate::types::RpcAnswerUnknown) -> Self {
            RpcDropAnswer::RpcAnswerUnknown
        }
    }
    impl From<crate::types::RpcAnswerDroppedRunning> for RpcDropAnswer {
        fn from(_x: crate::types::RpcAnswerDroppedRunning) -> Self {
            RpcDropAnswer::RpcAnswerDroppedRunning
        }
    }
    impl From<crate::types::RpcAnswerDropped> for RpcDropAnswer {
        fn from(x: crate::types::RpcAnswerDropped) -> Self {
            RpcDropAnswer::RpcAnswerDropped(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum RpcError {
        Error(crate::types::RpcError),
    }
    impl crate::Serializable for RpcError {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Error(x) => {
                    crate::types::RpcError::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for RpcError {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::RpcError::CONSTRUCTOR_ID => {
                    Self::Error(crate::types::RpcError::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::RpcError> for RpcError {
        fn from(x: crate::types::RpcError) -> Self {
            RpcError::Error(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SavedContact {
        SavedPhoneContact(crate::types::SavedPhoneContact),
    }
    impl crate::Serializable for SavedContact {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::SavedPhoneContact(x) => {
                    crate::types::SavedPhoneContact::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SavedContact {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SavedPhoneContact::CONSTRUCTOR_ID => {
                    Self::SavedPhoneContact(crate::types::SavedPhoneContact::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SavedPhoneContact> for SavedContact {
        fn from(x: crate::types::SavedPhoneContact) -> Self {
            SavedContact::SavedPhoneContact(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SearchResultsCalendarPeriod {
        Period(crate::types::SearchResultsCalendarPeriod),
    }
    impl crate::Serializable for SearchResultsCalendarPeriod {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Period(x) => {
                    crate::types::SearchResultsCalendarPeriod::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SearchResultsCalendarPeriod {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SearchResultsCalendarPeriod::CONSTRUCTOR_ID => {
                    Self::Period(crate::types::SearchResultsCalendarPeriod::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SearchResultsCalendarPeriod> for SearchResultsCalendarPeriod {
        fn from(x: crate::types::SearchResultsCalendarPeriod) -> Self {
            SearchResultsCalendarPeriod::Period(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SearchResultsPosition {
        SearchResultPosition(crate::types::SearchResultPosition),
    }
    impl crate::Serializable for SearchResultsPosition {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::SearchResultPosition(x) => {
                    crate::types::SearchResultPosition::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SearchResultsPosition {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SearchResultPosition::CONSTRUCTOR_ID => Self::SearchResultPosition(
                    crate::types::SearchResultPosition::deserialize(buf)?,
                ),
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SearchResultPosition> for SearchResultsPosition {
        fn from(x: crate::types::SearchResultPosition) -> Self {
            SearchResultsPosition::SearchResultPosition(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureCredentialsEncrypted {
        Encrypted(crate::types::SecureCredentialsEncrypted),
    }
    impl crate::Serializable for SecureCredentialsEncrypted {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Encrypted(x) => {
                    crate::types::SecureCredentialsEncrypted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureCredentialsEncrypted {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureCredentialsEncrypted::CONSTRUCTOR_ID => {
                    Self::Encrypted(crate::types::SecureCredentialsEncrypted::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureCredentialsEncrypted> for SecureCredentialsEncrypted {
        fn from(x: crate::types::SecureCredentialsEncrypted) -> Self {
            SecureCredentialsEncrypted::Encrypted(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureData {
        Data(crate::types::SecureData),
    }
    impl crate::Serializable for SecureData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Data(x) => {
                    crate::types::SecureData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureData::CONSTRUCTOR_ID => {
                    Self::Data(crate::types::SecureData::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureData> for SecureData {
        fn from(x: crate::types::SecureData) -> Self {
            SecureData::Data(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureFile {
        Empty,
        File(crate::types::SecureFile),
    }
    impl crate::Serializable for SecureFile {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::SecureFileEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::File(x) => {
                    crate::types::SecureFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureFile {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureFileEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::SecureFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::SecureFile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureFileEmpty> for SecureFile {
        fn from(_x: crate::types::SecureFileEmpty) -> Self {
            SecureFile::Empty
        }
    }
    impl From<crate::types::SecureFile> for SecureFile {
        fn from(x: crate::types::SecureFile) -> Self {
            SecureFile::File(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecurePasswordKdfAlgo {
        Unknown,
        Pbkdf2Hmacsha512iter100000(crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000),
        Sha512(crate::types::SecurePasswordKdfAlgoSha512),
    }
    impl crate::Serializable for SecurePasswordKdfAlgo {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Unknown => {
                    crate::types::SecurePasswordKdfAlgoUnknown::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Pbkdf2Hmacsha512iter100000(x) => {
                    crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000::CONSTRUCTOR_ID
                        .serialize(buf);
                    x.serialize(buf)
                }
                Self::Sha512(x) => {
                    crate::types::SecurePasswordKdfAlgoSha512::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecurePasswordKdfAlgo {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecurePasswordKdfAlgoUnknown::CONSTRUCTOR_ID => Self::Unknown,
                crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000::CONSTRUCTOR_ID => {
                    Self::Pbkdf2Hmacsha512iter100000(
                        crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000::deserialize(
                            buf,
                        )?,
                    )
                }
                crate::types::SecurePasswordKdfAlgoSha512::CONSTRUCTOR_ID => {
                    Self::Sha512(crate::types::SecurePasswordKdfAlgoSha512::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecurePasswordKdfAlgoUnknown> for SecurePasswordKdfAlgo {
        fn from(_x: crate::types::SecurePasswordKdfAlgoUnknown) -> Self {
            SecurePasswordKdfAlgo::Unknown
        }
    }
    impl From<crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000> for SecurePasswordKdfAlgo {
        fn from(x: crate::types::SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000) -> Self {
            SecurePasswordKdfAlgo::Pbkdf2Hmacsha512iter100000(x)
        }
    }
    impl From<crate::types::SecurePasswordKdfAlgoSha512> for SecurePasswordKdfAlgo {
        fn from(x: crate::types::SecurePasswordKdfAlgoSha512) -> Self {
            SecurePasswordKdfAlgo::Sha512(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecurePlainData {
        SecurePlainPhone(crate::types::SecurePlainPhone),
        SecurePlainEmail(crate::types::SecurePlainEmail),
    }
    impl crate::Serializable for SecurePlainData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::SecurePlainPhone(x) => {
                    crate::types::SecurePlainPhone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SecurePlainEmail(x) => {
                    crate::types::SecurePlainEmail::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecurePlainData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecurePlainPhone::CONSTRUCTOR_ID => {
                    Self::SecurePlainPhone(crate::types::SecurePlainPhone::deserialize(buf)?)
                }
                crate::types::SecurePlainEmail::CONSTRUCTOR_ID => {
                    Self::SecurePlainEmail(crate::types::SecurePlainEmail::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecurePlainPhone> for SecurePlainData {
        fn from(x: crate::types::SecurePlainPhone) -> Self {
            SecurePlainData::SecurePlainPhone(x)
        }
    }
    impl From<crate::types::SecurePlainEmail> for SecurePlainData {
        fn from(x: crate::types::SecurePlainEmail) -> Self {
            SecurePlainData::SecurePlainEmail(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureRequiredType {
        Type(crate::types::SecureRequiredType),
        OneOf(crate::types::SecureRequiredTypeOneOf),
    }
    impl crate::Serializable for SecureRequiredType {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Type(x) => {
                    crate::types::SecureRequiredType::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::OneOf(x) => {
                    crate::types::SecureRequiredTypeOneOf::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureRequiredType {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureRequiredType::CONSTRUCTOR_ID => {
                    Self::Type(crate::types::SecureRequiredType::deserialize(buf)?)
                }
                crate::types::SecureRequiredTypeOneOf::CONSTRUCTOR_ID => {
                    Self::OneOf(crate::types::SecureRequiredTypeOneOf::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureRequiredType> for SecureRequiredType {
        fn from(x: crate::types::SecureRequiredType) -> Self {
            SecureRequiredType::Type(x)
        }
    }
    impl From<crate::types::SecureRequiredTypeOneOf> for SecureRequiredType {
        fn from(x: crate::types::SecureRequiredTypeOneOf) -> Self {
            SecureRequiredType::OneOf(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureSecretSettings {
        Settings(crate::types::SecureSecretSettings),
    }
    impl crate::Serializable for SecureSecretSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::SecureSecretSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureSecretSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureSecretSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::SecureSecretSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureSecretSettings> for SecureSecretSettings {
        fn from(x: crate::types::SecureSecretSettings) -> Self {
            SecureSecretSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureValue {
        Value(crate::types::SecureValue),
    }
    impl crate::Serializable for SecureValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Value(x) => {
                    crate::types::SecureValue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureValue::CONSTRUCTOR_ID => {
                    Self::Value(crate::types::SecureValue::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureValue> for SecureValue {
        fn from(x: crate::types::SecureValue) -> Self {
            SecureValue::Value(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureValueError {
        Data(crate::types::SecureValueErrorData),
        FrontSide(crate::types::SecureValueErrorFrontSide),
        ReverseSide(crate::types::SecureValueErrorReverseSide),
        Selfie(crate::types::SecureValueErrorSelfie),
        File(crate::types::SecureValueErrorFile),
        Files(crate::types::SecureValueErrorFiles),
        Error(crate::types::SecureValueError),
        TranslationFile(crate::types::SecureValueErrorTranslationFile),
        TranslationFiles(crate::types::SecureValueErrorTranslationFiles),
    }
    impl SecureValueError {
        pub fn text(&self) -> String {
            match self {
                Self::Data(i) => i.text.clone(),
                Self::FrontSide(i) => i.text.clone(),
                Self::ReverseSide(i) => i.text.clone(),
                Self::Selfie(i) => i.text.clone(),
                Self::File(i) => i.text.clone(),
                Self::Files(i) => i.text.clone(),
                Self::Error(i) => i.text.clone(),
                Self::TranslationFile(i) => i.text.clone(),
                Self::TranslationFiles(i) => i.text.clone(),
            }
        }
        pub fn r#type(&self) -> crate::enums::SecureValueType {
            match self {
                Self::Data(i) => i.r#type.clone(),
                Self::FrontSide(i) => i.r#type.clone(),
                Self::ReverseSide(i) => i.r#type.clone(),
                Self::Selfie(i) => i.r#type.clone(),
                Self::File(i) => i.r#type.clone(),
                Self::Files(i) => i.r#type.clone(),
                Self::Error(i) => i.r#type.clone(),
                Self::TranslationFile(i) => i.r#type.clone(),
                Self::TranslationFiles(i) => i.r#type.clone(),
            }
        }
    }
    impl crate::Serializable for SecureValueError {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Data(x) => {
                    crate::types::SecureValueErrorData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::FrontSide(x) => {
                    crate::types::SecureValueErrorFrontSide::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReverseSide(x) => {
                    crate::types::SecureValueErrorReverseSide::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Selfie(x) => {
                    crate::types::SecureValueErrorSelfie::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::File(x) => {
                    crate::types::SecureValueErrorFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Files(x) => {
                    crate::types::SecureValueErrorFiles::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Error(x) => {
                    crate::types::SecureValueError::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TranslationFile(x) => {
                    crate::types::SecureValueErrorTranslationFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::TranslationFiles(x) => {
                    crate::types::SecureValueErrorTranslationFiles::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureValueError {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureValueErrorData::CONSTRUCTOR_ID => {
                    Self::Data(crate::types::SecureValueErrorData::deserialize(buf)?)
                }
                crate::types::SecureValueErrorFrontSide::CONSTRUCTOR_ID => {
                    Self::FrontSide(crate::types::SecureValueErrorFrontSide::deserialize(buf)?)
                }
                crate::types::SecureValueErrorReverseSide::CONSTRUCTOR_ID => {
                    Self::ReverseSide(crate::types::SecureValueErrorReverseSide::deserialize(buf)?)
                }
                crate::types::SecureValueErrorSelfie::CONSTRUCTOR_ID => {
                    Self::Selfie(crate::types::SecureValueErrorSelfie::deserialize(buf)?)
                }
                crate::types::SecureValueErrorFile::CONSTRUCTOR_ID => {
                    Self::File(crate::types::SecureValueErrorFile::deserialize(buf)?)
                }
                crate::types::SecureValueErrorFiles::CONSTRUCTOR_ID => {
                    Self::Files(crate::types::SecureValueErrorFiles::deserialize(buf)?)
                }
                crate::types::SecureValueError::CONSTRUCTOR_ID => {
                    Self::Error(crate::types::SecureValueError::deserialize(buf)?)
                }
                crate::types::SecureValueErrorTranslationFile::CONSTRUCTOR_ID => {
                    Self::TranslationFile(
                        crate::types::SecureValueErrorTranslationFile::deserialize(buf)?,
                    )
                }
                crate::types::SecureValueErrorTranslationFiles::CONSTRUCTOR_ID => {
                    Self::TranslationFiles(
                        crate::types::SecureValueErrorTranslationFiles::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureValueErrorData> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorData) -> Self {
            SecureValueError::Data(x)
        }
    }
    impl From<crate::types::SecureValueErrorFrontSide> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorFrontSide) -> Self {
            SecureValueError::FrontSide(x)
        }
    }
    impl From<crate::types::SecureValueErrorReverseSide> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorReverseSide) -> Self {
            SecureValueError::ReverseSide(x)
        }
    }
    impl From<crate::types::SecureValueErrorSelfie> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorSelfie) -> Self {
            SecureValueError::Selfie(x)
        }
    }
    impl From<crate::types::SecureValueErrorFile> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorFile) -> Self {
            SecureValueError::File(x)
        }
    }
    impl From<crate::types::SecureValueErrorFiles> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorFiles) -> Self {
            SecureValueError::Files(x)
        }
    }
    impl From<crate::types::SecureValueError> for SecureValueError {
        fn from(x: crate::types::SecureValueError) -> Self {
            SecureValueError::Error(x)
        }
    }
    impl From<crate::types::SecureValueErrorTranslationFile> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorTranslationFile) -> Self {
            SecureValueError::TranslationFile(x)
        }
    }
    impl From<crate::types::SecureValueErrorTranslationFiles> for SecureValueError {
        fn from(x: crate::types::SecureValueErrorTranslationFiles) -> Self {
            SecureValueError::TranslationFiles(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureValueHash {
        Hash(crate::types::SecureValueHash),
    }
    impl crate::Serializable for SecureValueHash {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Hash(x) => {
                    crate::types::SecureValueHash::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SecureValueHash {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureValueHash::CONSTRUCTOR_ID => {
                    Self::Hash(crate::types::SecureValueHash::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureValueHash> for SecureValueHash {
        fn from(x: crate::types::SecureValueHash) -> Self {
            SecureValueHash::Hash(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SecureValueType {
        PersonalDetails,
        Passport,
        DriverLicense,
        IdentityCard,
        InternalPassport,
        Address,
        UtilityBill,
        BankStatement,
        RentalAgreement,
        PassportRegistration,
        TemporaryRegistration,
        Phone,
        Email,
    }
    impl crate::Serializable for SecureValueType {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::PersonalDetails => {
                    crate::types::SecureValueTypePersonalDetails::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Passport => {
                    crate::types::SecureValueTypePassport::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::DriverLicense => {
                    crate::types::SecureValueTypeDriverLicense::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::IdentityCard => {
                    crate::types::SecureValueTypeIdentityCard::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::InternalPassport => {
                    crate::types::SecureValueTypeInternalPassport::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Address => {
                    crate::types::SecureValueTypeAddress::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::UtilityBill => {
                    crate::types::SecureValueTypeUtilityBill::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::BankStatement => {
                    crate::types::SecureValueTypeBankStatement::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::RentalAgreement => {
                    crate::types::SecureValueTypeRentalAgreement::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PassportRegistration => {
                    crate::types::SecureValueTypePassportRegistration::CONSTRUCTOR_ID
                        .serialize(buf);
                }
                Self::TemporaryRegistration => {
                    crate::types::SecureValueTypeTemporaryRegistration::CONSTRUCTOR_ID
                        .serialize(buf);
                }
                Self::Phone => {
                    crate::types::SecureValueTypePhone::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Email => {
                    crate::types::SecureValueTypeEmail::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for SecureValueType {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SecureValueTypePersonalDetails::CONSTRUCTOR_ID => {
                    Self::PersonalDetails
                }
                crate::types::SecureValueTypePassport::CONSTRUCTOR_ID => Self::Passport,
                crate::types::SecureValueTypeDriverLicense::CONSTRUCTOR_ID => Self::DriverLicense,
                crate::types::SecureValueTypeIdentityCard::CONSTRUCTOR_ID => Self::IdentityCard,
                crate::types::SecureValueTypeInternalPassport::CONSTRUCTOR_ID => {
                    Self::InternalPassport
                }
                crate::types::SecureValueTypeAddress::CONSTRUCTOR_ID => Self::Address,
                crate::types::SecureValueTypeUtilityBill::CONSTRUCTOR_ID => Self::UtilityBill,
                crate::types::SecureValueTypeBankStatement::CONSTRUCTOR_ID => Self::BankStatement,
                crate::types::SecureValueTypeRentalAgreement::CONSTRUCTOR_ID => {
                    Self::RentalAgreement
                }
                crate::types::SecureValueTypePassportRegistration::CONSTRUCTOR_ID => {
                    Self::PassportRegistration
                }
                crate::types::SecureValueTypeTemporaryRegistration::CONSTRUCTOR_ID => {
                    Self::TemporaryRegistration
                }
                crate::types::SecureValueTypePhone::CONSTRUCTOR_ID => Self::Phone,
                crate::types::SecureValueTypeEmail::CONSTRUCTOR_ID => Self::Email,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SecureValueTypePersonalDetails> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypePersonalDetails) -> Self {
            SecureValueType::PersonalDetails
        }
    }
    impl From<crate::types::SecureValueTypePassport> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypePassport) -> Self {
            SecureValueType::Passport
        }
    }
    impl From<crate::types::SecureValueTypeDriverLicense> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeDriverLicense) -> Self {
            SecureValueType::DriverLicense
        }
    }
    impl From<crate::types::SecureValueTypeIdentityCard> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeIdentityCard) -> Self {
            SecureValueType::IdentityCard
        }
    }
    impl From<crate::types::SecureValueTypeInternalPassport> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeInternalPassport) -> Self {
            SecureValueType::InternalPassport
        }
    }
    impl From<crate::types::SecureValueTypeAddress> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeAddress) -> Self {
            SecureValueType::Address
        }
    }
    impl From<crate::types::SecureValueTypeUtilityBill> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeUtilityBill) -> Self {
            SecureValueType::UtilityBill
        }
    }
    impl From<crate::types::SecureValueTypeBankStatement> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeBankStatement) -> Self {
            SecureValueType::BankStatement
        }
    }
    impl From<crate::types::SecureValueTypeRentalAgreement> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeRentalAgreement) -> Self {
            SecureValueType::RentalAgreement
        }
    }
    impl From<crate::types::SecureValueTypePassportRegistration> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypePassportRegistration) -> Self {
            SecureValueType::PassportRegistration
        }
    }
    impl From<crate::types::SecureValueTypeTemporaryRegistration> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeTemporaryRegistration) -> Self {
            SecureValueType::TemporaryRegistration
        }
    }
    impl From<crate::types::SecureValueTypePhone> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypePhone) -> Self {
            SecureValueType::Phone
        }
    }
    impl From<crate::types::SecureValueTypeEmail> for SecureValueType {
        fn from(_x: crate::types::SecureValueTypeEmail) -> Self {
            SecureValueType::Email
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SendMessageAction {
        SendMessageTypingAction,
        SendMessageCancelAction,
        SendMessageRecordVideoAction,
        SendMessageUploadVideoAction(crate::types::SendMessageUploadVideoAction),
        SendMessageRecordAudioAction,
        SendMessageUploadAudioAction(crate::types::SendMessageUploadAudioAction),
        SendMessageUploadPhotoAction(crate::types::SendMessageUploadPhotoAction),
        SendMessageUploadDocumentAction(crate::types::SendMessageUploadDocumentAction),
        SendMessageGeoLocationAction,
        SendMessageChooseContactAction,
        SendMessageGamePlayAction,
        SendMessageRecordRoundAction,
        SendMessageUploadRoundAction(crate::types::SendMessageUploadRoundAction),
        SpeakingInGroupCallAction,
        SendMessageHistoryImportAction(crate::types::SendMessageHistoryImportAction),
        SendMessageChooseStickerAction,
        SendMessageEmojiInteraction(crate::types::SendMessageEmojiInteraction),
        SendMessageEmojiInteractionSeen(crate::types::SendMessageEmojiInteractionSeen),
    }
    impl crate::Serializable for SendMessageAction {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::SendMessageTypingAction => {
                    crate::types::SendMessageTypingAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageCancelAction => {
                    crate::types::SendMessageCancelAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageRecordVideoAction => {
                    crate::types::SendMessageRecordVideoAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageUploadVideoAction(x) => {
                    crate::types::SendMessageUploadVideoAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageRecordAudioAction => {
                    crate::types::SendMessageRecordAudioAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageUploadAudioAction(x) => {
                    crate::types::SendMessageUploadAudioAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageUploadPhotoAction(x) => {
                    crate::types::SendMessageUploadPhotoAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageUploadDocumentAction(x) => {
                    crate::types::SendMessageUploadDocumentAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageGeoLocationAction => {
                    crate::types::SendMessageGeoLocationAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageChooseContactAction => {
                    crate::types::SendMessageChooseContactAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageGamePlayAction => {
                    crate::types::SendMessageGamePlayAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageRecordRoundAction => {
                    crate::types::SendMessageRecordRoundAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageUploadRoundAction(x) => {
                    crate::types::SendMessageUploadRoundAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SpeakingInGroupCallAction => {
                    crate::types::SpeakingInGroupCallAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageHistoryImportAction(x) => {
                    crate::types::SendMessageHistoryImportAction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageChooseStickerAction => {
                    crate::types::SendMessageChooseStickerAction::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SendMessageEmojiInteraction(x) => {
                    crate::types::SendMessageEmojiInteraction::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::SendMessageEmojiInteractionSeen(x) => {
                    crate::types::SendMessageEmojiInteractionSeen::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SendMessageAction {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SendMessageTypingAction::CONSTRUCTOR_ID => {
                    Self::SendMessageTypingAction
                }
                crate::types::SendMessageCancelAction::CONSTRUCTOR_ID => {
                    Self::SendMessageCancelAction
                }
                crate::types::SendMessageRecordVideoAction::CONSTRUCTOR_ID => {
                    Self::SendMessageRecordVideoAction
                }
                crate::types::SendMessageUploadVideoAction::CONSTRUCTOR_ID => {
                    Self::SendMessageUploadVideoAction(
                        crate::types::SendMessageUploadVideoAction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageRecordAudioAction::CONSTRUCTOR_ID => {
                    Self::SendMessageRecordAudioAction
                }
                crate::types::SendMessageUploadAudioAction::CONSTRUCTOR_ID => {
                    Self::SendMessageUploadAudioAction(
                        crate::types::SendMessageUploadAudioAction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageUploadPhotoAction::CONSTRUCTOR_ID => {
                    Self::SendMessageUploadPhotoAction(
                        crate::types::SendMessageUploadPhotoAction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageUploadDocumentAction::CONSTRUCTOR_ID => {
                    Self::SendMessageUploadDocumentAction(
                        crate::types::SendMessageUploadDocumentAction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageGeoLocationAction::CONSTRUCTOR_ID => {
                    Self::SendMessageGeoLocationAction
                }
                crate::types::SendMessageChooseContactAction::CONSTRUCTOR_ID => {
                    Self::SendMessageChooseContactAction
                }
                crate::types::SendMessageGamePlayAction::CONSTRUCTOR_ID => {
                    Self::SendMessageGamePlayAction
                }
                crate::types::SendMessageRecordRoundAction::CONSTRUCTOR_ID => {
                    Self::SendMessageRecordRoundAction
                }
                crate::types::SendMessageUploadRoundAction::CONSTRUCTOR_ID => {
                    Self::SendMessageUploadRoundAction(
                        crate::types::SendMessageUploadRoundAction::deserialize(buf)?,
                    )
                }
                crate::types::SpeakingInGroupCallAction::CONSTRUCTOR_ID => {
                    Self::SpeakingInGroupCallAction
                }
                crate::types::SendMessageHistoryImportAction::CONSTRUCTOR_ID => {
                    Self::SendMessageHistoryImportAction(
                        crate::types::SendMessageHistoryImportAction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageChooseStickerAction::CONSTRUCTOR_ID => {
                    Self::SendMessageChooseStickerAction
                }
                crate::types::SendMessageEmojiInteraction::CONSTRUCTOR_ID => {
                    Self::SendMessageEmojiInteraction(
                        crate::types::SendMessageEmojiInteraction::deserialize(buf)?,
                    )
                }
                crate::types::SendMessageEmojiInteractionSeen::CONSTRUCTOR_ID => {
                    Self::SendMessageEmojiInteractionSeen(
                        crate::types::SendMessageEmojiInteractionSeen::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SendMessageTypingAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageTypingAction) -> Self {
            SendMessageAction::SendMessageTypingAction
        }
    }
    impl From<crate::types::SendMessageCancelAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageCancelAction) -> Self {
            SendMessageAction::SendMessageCancelAction
        }
    }
    impl From<crate::types::SendMessageRecordVideoAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageRecordVideoAction) -> Self {
            SendMessageAction::SendMessageRecordVideoAction
        }
    }
    impl From<crate::types::SendMessageUploadVideoAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageUploadVideoAction) -> Self {
            SendMessageAction::SendMessageUploadVideoAction(x)
        }
    }
    impl From<crate::types::SendMessageRecordAudioAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageRecordAudioAction) -> Self {
            SendMessageAction::SendMessageRecordAudioAction
        }
    }
    impl From<crate::types::SendMessageUploadAudioAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageUploadAudioAction) -> Self {
            SendMessageAction::SendMessageUploadAudioAction(x)
        }
    }
    impl From<crate::types::SendMessageUploadPhotoAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageUploadPhotoAction) -> Self {
            SendMessageAction::SendMessageUploadPhotoAction(x)
        }
    }
    impl From<crate::types::SendMessageUploadDocumentAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageUploadDocumentAction) -> Self {
            SendMessageAction::SendMessageUploadDocumentAction(x)
        }
    }
    impl From<crate::types::SendMessageGeoLocationAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageGeoLocationAction) -> Self {
            SendMessageAction::SendMessageGeoLocationAction
        }
    }
    impl From<crate::types::SendMessageChooseContactAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageChooseContactAction) -> Self {
            SendMessageAction::SendMessageChooseContactAction
        }
    }
    impl From<crate::types::SendMessageGamePlayAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageGamePlayAction) -> Self {
            SendMessageAction::SendMessageGamePlayAction
        }
    }
    impl From<crate::types::SendMessageRecordRoundAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageRecordRoundAction) -> Self {
            SendMessageAction::SendMessageRecordRoundAction
        }
    }
    impl From<crate::types::SendMessageUploadRoundAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageUploadRoundAction) -> Self {
            SendMessageAction::SendMessageUploadRoundAction(x)
        }
    }
    impl From<crate::types::SpeakingInGroupCallAction> for SendMessageAction {
        fn from(_x: crate::types::SpeakingInGroupCallAction) -> Self {
            SendMessageAction::SpeakingInGroupCallAction
        }
    }
    impl From<crate::types::SendMessageHistoryImportAction> for SendMessageAction {
        fn from(x: crate::types::SendMessageHistoryImportAction) -> Self {
            SendMessageAction::SendMessageHistoryImportAction(x)
        }
    }
    impl From<crate::types::SendMessageChooseStickerAction> for SendMessageAction {
        fn from(_x: crate::types::SendMessageChooseStickerAction) -> Self {
            SendMessageAction::SendMessageChooseStickerAction
        }
    }
    impl From<crate::types::SendMessageEmojiInteraction> for SendMessageAction {
        fn from(x: crate::types::SendMessageEmojiInteraction) -> Self {
            SendMessageAction::SendMessageEmojiInteraction(x)
        }
    }
    impl From<crate::types::SendMessageEmojiInteractionSeen> for SendMessageAction {
        fn from(x: crate::types::SendMessageEmojiInteractionSeen) -> Self {
            SendMessageAction::SendMessageEmojiInteractionSeen(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ServerDhParams {
        Fail(crate::types::ServerDhParamsFail),
        Ok(crate::types::ServerDhParamsOk),
    }
    impl ServerDhParams {
        pub fn nonce(&self) -> [u8; 16] {
            match self {
                Self::Fail(i) => i.nonce.clone(),
                Self::Ok(i) => i.nonce.clone(),
            }
        }
        pub fn server_nonce(&self) -> [u8; 16] {
            match self {
                Self::Fail(i) => i.server_nonce.clone(),
                Self::Ok(i) => i.server_nonce.clone(),
            }
        }
    }
    impl crate::Serializable for ServerDhParams {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Fail(x) => {
                    crate::types::ServerDhParamsFail::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Ok(x) => {
                    crate::types::ServerDhParamsOk::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ServerDhParams {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ServerDhParamsFail::CONSTRUCTOR_ID => {
                    Self::Fail(crate::types::ServerDhParamsFail::deserialize(buf)?)
                }
                crate::types::ServerDhParamsOk::CONSTRUCTOR_ID => {
                    Self::Ok(crate::types::ServerDhParamsOk::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ServerDhParamsFail> for ServerDhParams {
        fn from(x: crate::types::ServerDhParamsFail) -> Self {
            ServerDhParams::Fail(x)
        }
    }
    impl From<crate::types::ServerDhParamsOk> for ServerDhParams {
        fn from(x: crate::types::ServerDhParamsOk) -> Self {
            ServerDhParams::Ok(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ServerDhInnerData {
        Data(crate::types::ServerDhInnerData),
    }
    impl crate::Serializable for ServerDhInnerData {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Data(x) => {
                    crate::types::ServerDhInnerData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ServerDhInnerData {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ServerDhInnerData::CONSTRUCTOR_ID => {
                    Self::Data(crate::types::ServerDhInnerData::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ServerDhInnerData> for ServerDhInnerData {
        fn from(x: crate::types::ServerDhInnerData) -> Self {
            ServerDhInnerData::Data(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SetClientDhParamsAnswer {
        DhGenOk(crate::types::DhGenOk),
        DhGenRetry(crate::types::DhGenRetry),
        DhGenFail(crate::types::DhGenFail),
    }
    impl SetClientDhParamsAnswer {
        pub fn server_nonce(&self) -> [u8; 16] {
            match self {
                Self::DhGenOk(i) => i.server_nonce.clone(),
                Self::DhGenRetry(i) => i.server_nonce.clone(),
                Self::DhGenFail(i) => i.server_nonce.clone(),
            }
        }
        pub fn nonce(&self) -> [u8; 16] {
            match self {
                Self::DhGenOk(i) => i.nonce.clone(),
                Self::DhGenRetry(i) => i.nonce.clone(),
                Self::DhGenFail(i) => i.nonce.clone(),
            }
        }
    }
    impl crate::Serializable for SetClientDhParamsAnswer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::DhGenOk(x) => {
                    crate::types::DhGenOk::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DhGenRetry(x) => {
                    crate::types::DhGenRetry::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DhGenFail(x) => {
                    crate::types::DhGenFail::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SetClientDhParamsAnswer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::DhGenOk::CONSTRUCTOR_ID => {
                    Self::DhGenOk(crate::types::DhGenOk::deserialize(buf)?)
                }
                crate::types::DhGenRetry::CONSTRUCTOR_ID => {
                    Self::DhGenRetry(crate::types::DhGenRetry::deserialize(buf)?)
                }
                crate::types::DhGenFail::CONSTRUCTOR_ID => {
                    Self::DhGenFail(crate::types::DhGenFail::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::DhGenOk> for SetClientDhParamsAnswer {
        fn from(x: crate::types::DhGenOk) -> Self {
            SetClientDhParamsAnswer::DhGenOk(x)
        }
    }
    impl From<crate::types::DhGenRetry> for SetClientDhParamsAnswer {
        fn from(x: crate::types::DhGenRetry) -> Self {
            SetClientDhParamsAnswer::DhGenRetry(x)
        }
    }
    impl From<crate::types::DhGenFail> for SetClientDhParamsAnswer {
        fn from(x: crate::types::DhGenFail) -> Self {
            SetClientDhParamsAnswer::DhGenFail(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ShippingOption {
        Option(crate::types::ShippingOption),
    }
    impl crate::Serializable for ShippingOption {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Option(x) => {
                    crate::types::ShippingOption::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ShippingOption {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ShippingOption::CONSTRUCTOR_ID => {
                    Self::Option(crate::types::ShippingOption::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ShippingOption> for ShippingOption {
        fn from(x: crate::types::ShippingOption) -> Self {
            ShippingOption::Option(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum SponsoredMessage {
        Message(crate::types::SponsoredMessage),
    }
    impl crate::Serializable for SponsoredMessage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Message(x) => {
                    crate::types::SponsoredMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for SponsoredMessage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::SponsoredMessage::CONSTRUCTOR_ID => {
                    Self::Message(crate::types::SponsoredMessage::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::SponsoredMessage> for SponsoredMessage {
        fn from(x: crate::types::SponsoredMessage) -> Self {
            SponsoredMessage::Message(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsAbsValueAndPrev {
        Prev(crate::types::StatsAbsValueAndPrev),
    }
    impl crate::Serializable for StatsAbsValueAndPrev {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Prev(x) => {
                    crate::types::StatsAbsValueAndPrev::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsAbsValueAndPrev {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsAbsValueAndPrev::CONSTRUCTOR_ID => {
                    Self::Prev(crate::types::StatsAbsValueAndPrev::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsAbsValueAndPrev> for StatsAbsValueAndPrev {
        fn from(x: crate::types::StatsAbsValueAndPrev) -> Self {
            StatsAbsValueAndPrev::Prev(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsDateRangeDays {
        Days(crate::types::StatsDateRangeDays),
    }
    impl crate::Serializable for StatsDateRangeDays {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Days(x) => {
                    crate::types::StatsDateRangeDays::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsDateRangeDays {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsDateRangeDays::CONSTRUCTOR_ID => {
                    Self::Days(crate::types::StatsDateRangeDays::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsDateRangeDays> for StatsDateRangeDays {
        fn from(x: crate::types::StatsDateRangeDays) -> Self {
            StatsDateRangeDays::Days(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsGraph {
        Async(crate::types::StatsGraphAsync),
        Error(crate::types::StatsGraphError),
        Graph(crate::types::StatsGraph),
    }
    impl crate::Serializable for StatsGraph {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Async(x) => {
                    crate::types::StatsGraphAsync::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Error(x) => {
                    crate::types::StatsGraphError::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Graph(x) => {
                    crate::types::StatsGraph::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsGraph {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsGraphAsync::CONSTRUCTOR_ID => {
                    Self::Async(crate::types::StatsGraphAsync::deserialize(buf)?)
                }
                crate::types::StatsGraphError::CONSTRUCTOR_ID => {
                    Self::Error(crate::types::StatsGraphError::deserialize(buf)?)
                }
                crate::types::StatsGraph::CONSTRUCTOR_ID => {
                    Self::Graph(crate::types::StatsGraph::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsGraphAsync> for StatsGraph {
        fn from(x: crate::types::StatsGraphAsync) -> Self {
            StatsGraph::Async(x)
        }
    }
    impl From<crate::types::StatsGraphError> for StatsGraph {
        fn from(x: crate::types::StatsGraphError) -> Self {
            StatsGraph::Error(x)
        }
    }
    impl From<crate::types::StatsGraph> for StatsGraph {
        fn from(x: crate::types::StatsGraph) -> Self {
            StatsGraph::Graph(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsGroupTopAdmin {
        Admin(crate::types::StatsGroupTopAdmin),
    }
    impl crate::Serializable for StatsGroupTopAdmin {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Admin(x) => {
                    crate::types::StatsGroupTopAdmin::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsGroupTopAdmin {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsGroupTopAdmin::CONSTRUCTOR_ID => {
                    Self::Admin(crate::types::StatsGroupTopAdmin::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsGroupTopAdmin> for StatsGroupTopAdmin {
        fn from(x: crate::types::StatsGroupTopAdmin) -> Self {
            StatsGroupTopAdmin::Admin(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsGroupTopInviter {
        Inviter(crate::types::StatsGroupTopInviter),
    }
    impl crate::Serializable for StatsGroupTopInviter {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Inviter(x) => {
                    crate::types::StatsGroupTopInviter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsGroupTopInviter {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsGroupTopInviter::CONSTRUCTOR_ID => {
                    Self::Inviter(crate::types::StatsGroupTopInviter::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsGroupTopInviter> for StatsGroupTopInviter {
        fn from(x: crate::types::StatsGroupTopInviter) -> Self {
            StatsGroupTopInviter::Inviter(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsGroupTopPoster {
        Poster(crate::types::StatsGroupTopPoster),
    }
    impl crate::Serializable for StatsGroupTopPoster {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Poster(x) => {
                    crate::types::StatsGroupTopPoster::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsGroupTopPoster {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsGroupTopPoster::CONSTRUCTOR_ID => {
                    Self::Poster(crate::types::StatsGroupTopPoster::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsGroupTopPoster> for StatsGroupTopPoster {
        fn from(x: crate::types::StatsGroupTopPoster) -> Self {
            StatsGroupTopPoster::Poster(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsPercentValue {
        Value(crate::types::StatsPercentValue),
    }
    impl crate::Serializable for StatsPercentValue {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Value(x) => {
                    crate::types::StatsPercentValue::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsPercentValue {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsPercentValue::CONSTRUCTOR_ID => {
                    Self::Value(crate::types::StatsPercentValue::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsPercentValue> for StatsPercentValue {
        fn from(x: crate::types::StatsPercentValue) -> Self {
            StatsPercentValue::Value(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StatsUrl {
        Url(crate::types::StatsUrl),
    }
    impl crate::Serializable for StatsUrl {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Url(x) => {
                    crate::types::StatsUrl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StatsUrl {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StatsUrl::CONSTRUCTOR_ID => {
                    Self::Url(crate::types::StatsUrl::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StatsUrl> for StatsUrl {
        fn from(x: crate::types::StatsUrl) -> Self {
            StatsUrl::Url(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StickerPack {
        Pack(crate::types::StickerPack),
    }
    impl crate::Serializable for StickerPack {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Pack(x) => {
                    crate::types::StickerPack::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StickerPack {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StickerPack::CONSTRUCTOR_ID => {
                    Self::Pack(crate::types::StickerPack::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StickerPack> for StickerPack {
        fn from(x: crate::types::StickerPack) -> Self {
            StickerPack::Pack(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StickerSet {
        Set(crate::types::StickerSet),
    }
    impl crate::Serializable for StickerSet {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Set(x) => {
                    crate::types::StickerSet::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StickerSet {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StickerSet::CONSTRUCTOR_ID => {
                    Self::Set(crate::types::StickerSet::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StickerSet> for StickerSet {
        fn from(x: crate::types::StickerSet) -> Self {
            StickerSet::Set(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum StickerSetCovered {
        Covered(crate::types::StickerSetCovered),
        StickerSetMultiCovered(crate::types::StickerSetMultiCovered),
    }
    impl StickerSetCovered {
        pub fn set(&self) -> crate::enums::StickerSet {
            match self {
                Self::Covered(i) => i.set.clone(),
                Self::StickerSetMultiCovered(i) => i.set.clone(),
            }
        }
    }
    impl crate::Serializable for StickerSetCovered {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Covered(x) => {
                    crate::types::StickerSetCovered::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::StickerSetMultiCovered(x) => {
                    crate::types::StickerSetMultiCovered::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for StickerSetCovered {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::StickerSetCovered::CONSTRUCTOR_ID => {
                    Self::Covered(crate::types::StickerSetCovered::deserialize(buf)?)
                }
                crate::types::StickerSetMultiCovered::CONSTRUCTOR_ID => {
                    Self::StickerSetMultiCovered(crate::types::StickerSetMultiCovered::deserialize(
                        buf,
                    )?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::StickerSetCovered> for StickerSetCovered {
        fn from(x: crate::types::StickerSetCovered) -> Self {
            StickerSetCovered::Covered(x)
        }
    }
    impl From<crate::types::StickerSetMultiCovered> for StickerSetCovered {
        fn from(x: crate::types::StickerSetMultiCovered) -> Self {
            StickerSetCovered::StickerSetMultiCovered(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Theme {
        Theme(crate::types::Theme),
    }
    impl crate::Serializable for Theme {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Theme(x) => {
                    crate::types::Theme::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Theme {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::Theme::CONSTRUCTOR_ID => {
                    Self::Theme(crate::types::Theme::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::Theme> for Theme {
        fn from(x: crate::types::Theme) -> Self {
            Theme::Theme(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum ThemeSettings {
        Settings(crate::types::ThemeSettings),
    }
    impl crate::Serializable for ThemeSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::ThemeSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for ThemeSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::ThemeSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::ThemeSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::ThemeSettings> for ThemeSettings {
        fn from(x: crate::types::ThemeSettings) -> Self {
            ThemeSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum TlsBlock {
        String(crate::types::TlsBlockString),
        Random(crate::types::TlsBlockRandom),
        Zero(crate::types::TlsBlockZero),
        Domain,
        Grease(crate::types::TlsBlockGrease),
        PublicKey,
        Scope(crate::types::TlsBlockScope),
    }
    impl crate::Serializable for TlsBlock {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::String(x) => {
                    crate::types::TlsBlockString::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Random(x) => {
                    crate::types::TlsBlockRandom::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Zero(x) => {
                    crate::types::TlsBlockZero::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Domain => {
                    crate::types::TlsBlockDomain::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Grease(x) => {
                    crate::types::TlsBlockGrease::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PublicKey => {
                    crate::types::TlsBlockPublicKey::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Scope(x) => {
                    crate::types::TlsBlockScope::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for TlsBlock {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TlsBlockString::CONSTRUCTOR_ID => {
                    Self::String(crate::types::TlsBlockString::deserialize(buf)?)
                }
                crate::types::TlsBlockRandom::CONSTRUCTOR_ID => {
                    Self::Random(crate::types::TlsBlockRandom::deserialize(buf)?)
                }
                crate::types::TlsBlockZero::CONSTRUCTOR_ID => {
                    Self::Zero(crate::types::TlsBlockZero::deserialize(buf)?)
                }
                crate::types::TlsBlockDomain::CONSTRUCTOR_ID => Self::Domain,
                crate::types::TlsBlockGrease::CONSTRUCTOR_ID => {
                    Self::Grease(crate::types::TlsBlockGrease::deserialize(buf)?)
                }
                crate::types::TlsBlockPublicKey::CONSTRUCTOR_ID => Self::PublicKey,
                crate::types::TlsBlockScope::CONSTRUCTOR_ID => {
                    Self::Scope(crate::types::TlsBlockScope::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TlsBlockString> for TlsBlock {
        fn from(x: crate::types::TlsBlockString) -> Self {
            TlsBlock::String(x)
        }
    }
    impl From<crate::types::TlsBlockRandom> for TlsBlock {
        fn from(x: crate::types::TlsBlockRandom) -> Self {
            TlsBlock::Random(x)
        }
    }
    impl From<crate::types::TlsBlockZero> for TlsBlock {
        fn from(x: crate::types::TlsBlockZero) -> Self {
            TlsBlock::Zero(x)
        }
    }
    impl From<crate::types::TlsBlockDomain> for TlsBlock {
        fn from(_x: crate::types::TlsBlockDomain) -> Self {
            TlsBlock::Domain
        }
    }
    impl From<crate::types::TlsBlockGrease> for TlsBlock {
        fn from(x: crate::types::TlsBlockGrease) -> Self {
            TlsBlock::Grease(x)
        }
    }
    impl From<crate::types::TlsBlockPublicKey> for TlsBlock {
        fn from(_x: crate::types::TlsBlockPublicKey) -> Self {
            TlsBlock::PublicKey
        }
    }
    impl From<crate::types::TlsBlockScope> for TlsBlock {
        fn from(x: crate::types::TlsBlockScope) -> Self {
            TlsBlock::Scope(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum TlsClientHello {
        Hello(crate::types::TlsClientHello),
    }
    impl crate::Serializable for TlsClientHello {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Hello(x) => {
                    crate::types::TlsClientHello::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for TlsClientHello {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TlsClientHello::CONSTRUCTOR_ID => {
                    Self::Hello(crate::types::TlsClientHello::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TlsClientHello> for TlsClientHello {
        fn from(x: crate::types::TlsClientHello) -> Self {
            TlsClientHello::Hello(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum TopPeer {
        Peer(crate::types::TopPeer),
    }
    impl crate::Serializable for TopPeer {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peer(x) => {
                    crate::types::TopPeer::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for TopPeer {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TopPeer::CONSTRUCTOR_ID => {
                    Self::Peer(crate::types::TopPeer::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TopPeer> for TopPeer {
        fn from(x: crate::types::TopPeer) -> Self {
            TopPeer::Peer(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum TopPeerCategory {
        BotsPm,
        BotsInline,
        Correspondents,
        Groups,
        Channels,
        PhoneCalls,
        ForwardUsers,
        ForwardChats,
    }
    impl crate::Serializable for TopPeerCategory {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::BotsPm => {
                    crate::types::TopPeerCategoryBotsPm::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::BotsInline => {
                    crate::types::TopPeerCategoryBotsInline::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Correspondents => {
                    crate::types::TopPeerCategoryCorrespondents::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Groups => {
                    crate::types::TopPeerCategoryGroups::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Channels => {
                    crate::types::TopPeerCategoryChannels::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneCalls => {
                    crate::types::TopPeerCategoryPhoneCalls::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ForwardUsers => {
                    crate::types::TopPeerCategoryForwardUsers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ForwardChats => {
                    crate::types::TopPeerCategoryForwardChats::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for TopPeerCategory {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TopPeerCategoryBotsPm::CONSTRUCTOR_ID => Self::BotsPm,
                crate::types::TopPeerCategoryBotsInline::CONSTRUCTOR_ID => Self::BotsInline,
                crate::types::TopPeerCategoryCorrespondents::CONSTRUCTOR_ID => Self::Correspondents,
                crate::types::TopPeerCategoryGroups::CONSTRUCTOR_ID => Self::Groups,
                crate::types::TopPeerCategoryChannels::CONSTRUCTOR_ID => Self::Channels,
                crate::types::TopPeerCategoryPhoneCalls::CONSTRUCTOR_ID => Self::PhoneCalls,
                crate::types::TopPeerCategoryForwardUsers::CONSTRUCTOR_ID => Self::ForwardUsers,
                crate::types::TopPeerCategoryForwardChats::CONSTRUCTOR_ID => Self::ForwardChats,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TopPeerCategoryBotsPm> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryBotsPm) -> Self {
            TopPeerCategory::BotsPm
        }
    }
    impl From<crate::types::TopPeerCategoryBotsInline> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryBotsInline) -> Self {
            TopPeerCategory::BotsInline
        }
    }
    impl From<crate::types::TopPeerCategoryCorrespondents> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryCorrespondents) -> Self {
            TopPeerCategory::Correspondents
        }
    }
    impl From<crate::types::TopPeerCategoryGroups> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryGroups) -> Self {
            TopPeerCategory::Groups
        }
    }
    impl From<crate::types::TopPeerCategoryChannels> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryChannels) -> Self {
            TopPeerCategory::Channels
        }
    }
    impl From<crate::types::TopPeerCategoryPhoneCalls> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryPhoneCalls) -> Self {
            TopPeerCategory::PhoneCalls
        }
    }
    impl From<crate::types::TopPeerCategoryForwardUsers> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryForwardUsers) -> Self {
            TopPeerCategory::ForwardUsers
        }
    }
    impl From<crate::types::TopPeerCategoryForwardChats> for TopPeerCategory {
        fn from(_x: crate::types::TopPeerCategoryForwardChats) -> Self {
            TopPeerCategory::ForwardChats
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum TopPeerCategoryPeers {
        Peers(crate::types::TopPeerCategoryPeers),
    }
    impl crate::Serializable for TopPeerCategoryPeers {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Peers(x) => {
                    crate::types::TopPeerCategoryPeers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for TopPeerCategoryPeers {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::TopPeerCategoryPeers::CONSTRUCTOR_ID => {
                    Self::Peers(crate::types::TopPeerCategoryPeers::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::TopPeerCategoryPeers> for TopPeerCategoryPeers {
        fn from(x: crate::types::TopPeerCategoryPeers) -> Self {
            TopPeerCategoryPeers::Peers(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum True {
        True,
    }
    impl crate::Serializable for True {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::True => {
                    crate::types::True::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for True {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::True::CONSTRUCTOR_ID => Self::True,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::True> for True {
        fn from(_x: crate::types::True) -> Self {
            True::True
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Update {
        NewMessage(crate::types::UpdateNewMessage),
        MessageId(crate::types::UpdateMessageId),
        DeleteMessages(crate::types::UpdateDeleteMessages),
        UserTyping(crate::types::UpdateUserTyping),
        ChatUserTyping(crate::types::UpdateChatUserTyping),
        ChatParticipants(crate::types::UpdateChatParticipants),
        UserStatus(crate::types::UpdateUserStatus),
        UserName(crate::types::UpdateUserName),
        UserPhoto(crate::types::UpdateUserPhoto),
        NewEncryptedMessage(crate::types::UpdateNewEncryptedMessage),
        EncryptedChatTyping(crate::types::UpdateEncryptedChatTyping),
        Encryption(crate::types::UpdateEncryption),
        EncryptedMessagesRead(crate::types::UpdateEncryptedMessagesRead),
        ChatParticipantAdd(crate::types::UpdateChatParticipantAdd),
        ChatParticipantDelete(crate::types::UpdateChatParticipantDelete),
        DcOptions(crate::types::UpdateDcOptions),
        NotifySettings(crate::types::UpdateNotifySettings),
        ServiceNotification(crate::types::UpdateServiceNotification),
        Privacy(crate::types::UpdatePrivacy),
        UserPhone(crate::types::UpdateUserPhone),
        ReadHistoryInbox(crate::types::UpdateReadHistoryInbox),
        ReadHistoryOutbox(crate::types::UpdateReadHistoryOutbox),
        WebPage(crate::types::UpdateWebPage),
        ReadMessagesContents(crate::types::UpdateReadMessagesContents),
        ChannelTooLong(crate::types::UpdateChannelTooLong),
        Channel(crate::types::UpdateChannel),
        NewChannelMessage(crate::types::UpdateNewChannelMessage),
        ReadChannelInbox(crate::types::UpdateReadChannelInbox),
        DeleteChannelMessages(crate::types::UpdateDeleteChannelMessages),
        ChannelMessageViews(crate::types::UpdateChannelMessageViews),
        ChatParticipantAdmin(crate::types::UpdateChatParticipantAdmin),
        NewStickerSet(crate::types::UpdateNewStickerSet),
        StickerSetsOrder(crate::types::UpdateStickerSetsOrder),
        StickerSets,
        SavedGifs,
        BotInlineQuery(crate::types::UpdateBotInlineQuery),
        BotInlineSend(crate::types::UpdateBotInlineSend),
        EditChannelMessage(crate::types::UpdateEditChannelMessage),
        BotCallbackQuery(crate::types::UpdateBotCallbackQuery),
        EditMessage(crate::types::UpdateEditMessage),
        InlineBotCallbackQuery(crate::types::UpdateInlineBotCallbackQuery),
        ReadChannelOutbox(crate::types::UpdateReadChannelOutbox),
        DraftMessage(crate::types::UpdateDraftMessage),
        ReadFeaturedStickers,
        RecentStickers,
        Config,
        PtsChanged,
        ChannelWebPage(crate::types::UpdateChannelWebPage),
        DialogPinned(crate::types::UpdateDialogPinned),
        PinnedDialogs(crate::types::UpdatePinnedDialogs),
        BotWebhookJson(crate::types::UpdateBotWebhookJson),
        BotWebhookJsonquery(crate::types::UpdateBotWebhookJsonquery),
        BotShippingQuery(crate::types::UpdateBotShippingQuery),
        BotPrecheckoutQuery(crate::types::UpdateBotPrecheckoutQuery),
        PhoneCall(crate::types::UpdatePhoneCall),
        LangPackTooLong(crate::types::UpdateLangPackTooLong),
        LangPack(crate::types::UpdateLangPack),
        FavedStickers,
        ChannelReadMessagesContents(crate::types::UpdateChannelReadMessagesContents),
        ContactsReset,
        ChannelAvailableMessages(crate::types::UpdateChannelAvailableMessages),
        DialogUnreadMark(crate::types::UpdateDialogUnreadMark),
        MessagePoll(crate::types::UpdateMessagePoll),
        ChatDefaultBannedRights(crate::types::UpdateChatDefaultBannedRights),
        FolderPeers(crate::types::UpdateFolderPeers),
        PeerSettings(crate::types::UpdatePeerSettings),
        PeerLocated(crate::types::UpdatePeerLocated),
        NewScheduledMessage(crate::types::UpdateNewScheduledMessage),
        DeleteScheduledMessages(crate::types::UpdateDeleteScheduledMessages),
        Theme(crate::types::UpdateTheme),
        GeoLiveViewed(crate::types::UpdateGeoLiveViewed),
        LoginToken,
        MessagePollVote(crate::types::UpdateMessagePollVote),
        DialogFilter(crate::types::UpdateDialogFilter),
        DialogFilterOrder(crate::types::UpdateDialogFilterOrder),
        DialogFilters,
        PhoneCallSignalingData(crate::types::UpdatePhoneCallSignalingData),
        ChannelMessageForwards(crate::types::UpdateChannelMessageForwards),
        ReadChannelDiscussionInbox(crate::types::UpdateReadChannelDiscussionInbox),
        ReadChannelDiscussionOutbox(crate::types::UpdateReadChannelDiscussionOutbox),
        PeerBlocked(crate::types::UpdatePeerBlocked),
        ChannelUserTyping(crate::types::UpdateChannelUserTyping),
        PinnedMessages(crate::types::UpdatePinnedMessages),
        PinnedChannelMessages(crate::types::UpdatePinnedChannelMessages),
        Chat(crate::types::UpdateChat),
        GroupCallParticipants(crate::types::UpdateGroupCallParticipants),
        GroupCall(crate::types::UpdateGroupCall),
        PeerHistoryTtl(crate::types::UpdatePeerHistoryTtl),
        ChatParticipant(crate::types::UpdateChatParticipant),
        ChannelParticipant(crate::types::UpdateChannelParticipant),
        BotStopped(crate::types::UpdateBotStopped),
        GroupCallConnection(crate::types::UpdateGroupCallConnection),
        BotCommands(crate::types::UpdateBotCommands),
        PendingJoinRequests(crate::types::UpdatePendingJoinRequests),
        BotChatInviteRequester(crate::types::UpdateBotChatInviteRequester),
    }
    impl crate::Serializable for Update {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::NewMessage(x) => {
                    crate::types::UpdateNewMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MessageId(x) => {
                    crate::types::UpdateMessageId::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DeleteMessages(x) => {
                    crate::types::UpdateDeleteMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserTyping(x) => {
                    crate::types::UpdateUserTyping::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatUserTyping(x) => {
                    crate::types::UpdateChatUserTyping::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatParticipants(x) => {
                    crate::types::UpdateChatParticipants::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserStatus(x) => {
                    crate::types::UpdateUserStatus::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserName(x) => {
                    crate::types::UpdateUserName::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserPhoto(x) => {
                    crate::types::UpdateUserPhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NewEncryptedMessage(x) => {
                    crate::types::UpdateNewEncryptedMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::EncryptedChatTyping(x) => {
                    crate::types::UpdateEncryptedChatTyping::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Encryption(x) => {
                    crate::types::UpdateEncryption::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::EncryptedMessagesRead(x) => {
                    crate::types::UpdateEncryptedMessagesRead::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatParticipantAdd(x) => {
                    crate::types::UpdateChatParticipantAdd::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatParticipantDelete(x) => {
                    crate::types::UpdateChatParticipantDelete::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DcOptions(x) => {
                    crate::types::UpdateDcOptions::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NotifySettings(x) => {
                    crate::types::UpdateNotifySettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ServiceNotification(x) => {
                    crate::types::UpdateServiceNotification::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Privacy(x) => {
                    crate::types::UpdatePrivacy::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UserPhone(x) => {
                    crate::types::UpdateUserPhone::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadHistoryInbox(x) => {
                    crate::types::UpdateReadHistoryInbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadHistoryOutbox(x) => {
                    crate::types::UpdateReadHistoryOutbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::WebPage(x) => {
                    crate::types::UpdateWebPage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadMessagesContents(x) => {
                    crate::types::UpdateReadMessagesContents::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelTooLong(x) => {
                    crate::types::UpdateChannelTooLong::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Channel(x) => {
                    crate::types::UpdateChannel::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NewChannelMessage(x) => {
                    crate::types::UpdateNewChannelMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadChannelInbox(x) => {
                    crate::types::UpdateReadChannelInbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DeleteChannelMessages(x) => {
                    crate::types::UpdateDeleteChannelMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelMessageViews(x) => {
                    crate::types::UpdateChannelMessageViews::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatParticipantAdmin(x) => {
                    crate::types::UpdateChatParticipantAdmin::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NewStickerSet(x) => {
                    crate::types::UpdateNewStickerSet::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::StickerSetsOrder(x) => {
                    crate::types::UpdateStickerSetsOrder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::StickerSets => {
                    crate::types::UpdateStickerSets::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::SavedGifs => {
                    crate::types::UpdateSavedGifs::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::BotInlineQuery(x) => {
                    crate::types::UpdateBotInlineQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotInlineSend(x) => {
                    crate::types::UpdateBotInlineSend::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::EditChannelMessage(x) => {
                    crate::types::UpdateEditChannelMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotCallbackQuery(x) => {
                    crate::types::UpdateBotCallbackQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::EditMessage(x) => {
                    crate::types::UpdateEditMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::InlineBotCallbackQuery(x) => {
                    crate::types::UpdateInlineBotCallbackQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadChannelOutbox(x) => {
                    crate::types::UpdateReadChannelOutbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DraftMessage(x) => {
                    crate::types::UpdateDraftMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadFeaturedStickers => {
                    crate::types::UpdateReadFeaturedStickers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::RecentStickers => {
                    crate::types::UpdateRecentStickers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Config => {
                    crate::types::UpdateConfig::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PtsChanged => {
                    crate::types::UpdatePtsChanged::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelWebPage(x) => {
                    crate::types::UpdateChannelWebPage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DialogPinned(x) => {
                    crate::types::UpdateDialogPinned::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PinnedDialogs(x) => {
                    crate::types::UpdatePinnedDialogs::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotWebhookJson(x) => {
                    crate::types::UpdateBotWebhookJson::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotWebhookJsonquery(x) => {
                    crate::types::UpdateBotWebhookJsonquery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotShippingQuery(x) => {
                    crate::types::UpdateBotShippingQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotPrecheckoutQuery(x) => {
                    crate::types::UpdateBotPrecheckoutQuery::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PhoneCall(x) => {
                    crate::types::UpdatePhoneCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::LangPackTooLong(x) => {
                    crate::types::UpdateLangPackTooLong::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::LangPack(x) => {
                    crate::types::UpdateLangPack::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::FavedStickers => {
                    crate::types::UpdateFavedStickers::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelReadMessagesContents(x) => {
                    crate::types::UpdateChannelReadMessagesContents::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ContactsReset => {
                    crate::types::UpdateContactsReset::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::ChannelAvailableMessages(x) => {
                    crate::types::UpdateChannelAvailableMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DialogUnreadMark(x) => {
                    crate::types::UpdateDialogUnreadMark::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::MessagePoll(x) => {
                    crate::types::UpdateMessagePoll::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatDefaultBannedRights(x) => {
                    crate::types::UpdateChatDefaultBannedRights::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::FolderPeers(x) => {
                    crate::types::UpdateFolderPeers::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerSettings(x) => {
                    crate::types::UpdatePeerSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerLocated(x) => {
                    crate::types::UpdatePeerLocated::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NewScheduledMessage(x) => {
                    crate::types::UpdateNewScheduledMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DeleteScheduledMessages(x) => {
                    crate::types::UpdateDeleteScheduledMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Theme(x) => {
                    crate::types::UpdateTheme::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GeoLiveViewed(x) => {
                    crate::types::UpdateGeoLiveViewed::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::LoginToken => {
                    crate::types::UpdateLoginToken::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::MessagePollVote(x) => {
                    crate::types::UpdateMessagePollVote::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DialogFilter(x) => {
                    crate::types::UpdateDialogFilter::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DialogFilterOrder(x) => {
                    crate::types::UpdateDialogFilterOrder::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::DialogFilters => {
                    crate::types::UpdateDialogFilters::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::PhoneCallSignalingData(x) => {
                    crate::types::UpdatePhoneCallSignalingData::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelMessageForwards(x) => {
                    crate::types::UpdateChannelMessageForwards::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadChannelDiscussionInbox(x) => {
                    crate::types::UpdateReadChannelDiscussionInbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ReadChannelDiscussionOutbox(x) => {
                    crate::types::UpdateReadChannelDiscussionOutbox::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerBlocked(x) => {
                    crate::types::UpdatePeerBlocked::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelUserTyping(x) => {
                    crate::types::UpdateChannelUserTyping::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PinnedMessages(x) => {
                    crate::types::UpdatePinnedMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PinnedChannelMessages(x) => {
                    crate::types::UpdatePinnedChannelMessages::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Chat(x) => {
                    crate::types::UpdateChat::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GroupCallParticipants(x) => {
                    crate::types::UpdateGroupCallParticipants::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GroupCall(x) => {
                    crate::types::UpdateGroupCall::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PeerHistoryTtl(x) => {
                    crate::types::UpdatePeerHistoryTtl::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChatParticipant(x) => {
                    crate::types::UpdateChatParticipant::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::ChannelParticipant(x) => {
                    crate::types::UpdateChannelParticipant::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotStopped(x) => {
                    crate::types::UpdateBotStopped::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::GroupCallConnection(x) => {
                    crate::types::UpdateGroupCallConnection::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotCommands(x) => {
                    crate::types::UpdateBotCommands::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::PendingJoinRequests(x) => {
                    crate::types::UpdatePendingJoinRequests::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::BotChatInviteRequester(x) => {
                    crate::types::UpdateBotChatInviteRequester::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Update {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UpdateNewMessage::CONSTRUCTOR_ID => {
                    Self::NewMessage(crate::types::UpdateNewMessage::deserialize(buf)?)
                }
                crate::types::UpdateMessageId::CONSTRUCTOR_ID => {
                    Self::MessageId(crate::types::UpdateMessageId::deserialize(buf)?)
                }
                crate::types::UpdateDeleteMessages::CONSTRUCTOR_ID => {
                    Self::DeleteMessages(crate::types::UpdateDeleteMessages::deserialize(buf)?)
                }
                crate::types::UpdateUserTyping::CONSTRUCTOR_ID => {
                    Self::UserTyping(crate::types::UpdateUserTyping::deserialize(buf)?)
                }
                crate::types::UpdateChatUserTyping::CONSTRUCTOR_ID => {
                    Self::ChatUserTyping(crate::types::UpdateChatUserTyping::deserialize(buf)?)
                }
                crate::types::UpdateChatParticipants::CONSTRUCTOR_ID => {
                    Self::ChatParticipants(crate::types::UpdateChatParticipants::deserialize(buf)?)
                }
                crate::types::UpdateUserStatus::CONSTRUCTOR_ID => {
                    Self::UserStatus(crate::types::UpdateUserStatus::deserialize(buf)?)
                }
                crate::types::UpdateUserName::CONSTRUCTOR_ID => {
                    Self::UserName(crate::types::UpdateUserName::deserialize(buf)?)
                }
                crate::types::UpdateUserPhoto::CONSTRUCTOR_ID => {
                    Self::UserPhoto(crate::types::UpdateUserPhoto::deserialize(buf)?)
                }
                crate::types::UpdateNewEncryptedMessage::CONSTRUCTOR_ID => {
                    Self::NewEncryptedMessage(crate::types::UpdateNewEncryptedMessage::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateEncryptedChatTyping::CONSTRUCTOR_ID => {
                    Self::EncryptedChatTyping(crate::types::UpdateEncryptedChatTyping::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateEncryption::CONSTRUCTOR_ID => {
                    Self::Encryption(crate::types::UpdateEncryption::deserialize(buf)?)
                }
                crate::types::UpdateEncryptedMessagesRead::CONSTRUCTOR_ID => {
                    Self::EncryptedMessagesRead(
                        crate::types::UpdateEncryptedMessagesRead::deserialize(buf)?,
                    )
                }
                crate::types::UpdateChatParticipantAdd::CONSTRUCTOR_ID => Self::ChatParticipantAdd(
                    crate::types::UpdateChatParticipantAdd::deserialize(buf)?,
                ),
                crate::types::UpdateChatParticipantDelete::CONSTRUCTOR_ID => {
                    Self::ChatParticipantDelete(
                        crate::types::UpdateChatParticipantDelete::deserialize(buf)?,
                    )
                }
                crate::types::UpdateDcOptions::CONSTRUCTOR_ID => {
                    Self::DcOptions(crate::types::UpdateDcOptions::deserialize(buf)?)
                }
                crate::types::UpdateNotifySettings::CONSTRUCTOR_ID => {
                    Self::NotifySettings(crate::types::UpdateNotifySettings::deserialize(buf)?)
                }
                crate::types::UpdateServiceNotification::CONSTRUCTOR_ID => {
                    Self::ServiceNotification(crate::types::UpdateServiceNotification::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdatePrivacy::CONSTRUCTOR_ID => {
                    Self::Privacy(crate::types::UpdatePrivacy::deserialize(buf)?)
                }
                crate::types::UpdateUserPhone::CONSTRUCTOR_ID => {
                    Self::UserPhone(crate::types::UpdateUserPhone::deserialize(buf)?)
                }
                crate::types::UpdateReadHistoryInbox::CONSTRUCTOR_ID => {
                    Self::ReadHistoryInbox(crate::types::UpdateReadHistoryInbox::deserialize(buf)?)
                }
                crate::types::UpdateReadHistoryOutbox::CONSTRUCTOR_ID => Self::ReadHistoryOutbox(
                    crate::types::UpdateReadHistoryOutbox::deserialize(buf)?,
                ),
                crate::types::UpdateWebPage::CONSTRUCTOR_ID => {
                    Self::WebPage(crate::types::UpdateWebPage::deserialize(buf)?)
                }
                crate::types::UpdateReadMessagesContents::CONSTRUCTOR_ID => {
                    Self::ReadMessagesContents(
                        crate::types::UpdateReadMessagesContents::deserialize(buf)?,
                    )
                }
                crate::types::UpdateChannelTooLong::CONSTRUCTOR_ID => {
                    Self::ChannelTooLong(crate::types::UpdateChannelTooLong::deserialize(buf)?)
                }
                crate::types::UpdateChannel::CONSTRUCTOR_ID => {
                    Self::Channel(crate::types::UpdateChannel::deserialize(buf)?)
                }
                crate::types::UpdateNewChannelMessage::CONSTRUCTOR_ID => Self::NewChannelMessage(
                    crate::types::UpdateNewChannelMessage::deserialize(buf)?,
                ),
                crate::types::UpdateReadChannelInbox::CONSTRUCTOR_ID => {
                    Self::ReadChannelInbox(crate::types::UpdateReadChannelInbox::deserialize(buf)?)
                }
                crate::types::UpdateDeleteChannelMessages::CONSTRUCTOR_ID => {
                    Self::DeleteChannelMessages(
                        crate::types::UpdateDeleteChannelMessages::deserialize(buf)?,
                    )
                }
                crate::types::UpdateChannelMessageViews::CONSTRUCTOR_ID => {
                    Self::ChannelMessageViews(crate::types::UpdateChannelMessageViews::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateChatParticipantAdmin::CONSTRUCTOR_ID => {
                    Self::ChatParticipantAdmin(
                        crate::types::UpdateChatParticipantAdmin::deserialize(buf)?,
                    )
                }
                crate::types::UpdateNewStickerSet::CONSTRUCTOR_ID => {
                    Self::NewStickerSet(crate::types::UpdateNewStickerSet::deserialize(buf)?)
                }
                crate::types::UpdateStickerSetsOrder::CONSTRUCTOR_ID => {
                    Self::StickerSetsOrder(crate::types::UpdateStickerSetsOrder::deserialize(buf)?)
                }
                crate::types::UpdateStickerSets::CONSTRUCTOR_ID => Self::StickerSets,
                crate::types::UpdateSavedGifs::CONSTRUCTOR_ID => Self::SavedGifs,
                crate::types::UpdateBotInlineQuery::CONSTRUCTOR_ID => {
                    Self::BotInlineQuery(crate::types::UpdateBotInlineQuery::deserialize(buf)?)
                }
                crate::types::UpdateBotInlineSend::CONSTRUCTOR_ID => {
                    Self::BotInlineSend(crate::types::UpdateBotInlineSend::deserialize(buf)?)
                }
                crate::types::UpdateEditChannelMessage::CONSTRUCTOR_ID => Self::EditChannelMessage(
                    crate::types::UpdateEditChannelMessage::deserialize(buf)?,
                ),
                crate::types::UpdateBotCallbackQuery::CONSTRUCTOR_ID => {
                    Self::BotCallbackQuery(crate::types::UpdateBotCallbackQuery::deserialize(buf)?)
                }
                crate::types::UpdateEditMessage::CONSTRUCTOR_ID => {
                    Self::EditMessage(crate::types::UpdateEditMessage::deserialize(buf)?)
                }
                crate::types::UpdateInlineBotCallbackQuery::CONSTRUCTOR_ID => {
                    Self::InlineBotCallbackQuery(
                        crate::types::UpdateInlineBotCallbackQuery::deserialize(buf)?,
                    )
                }
                crate::types::UpdateReadChannelOutbox::CONSTRUCTOR_ID => Self::ReadChannelOutbox(
                    crate::types::UpdateReadChannelOutbox::deserialize(buf)?,
                ),
                crate::types::UpdateDraftMessage::CONSTRUCTOR_ID => {
                    Self::DraftMessage(crate::types::UpdateDraftMessage::deserialize(buf)?)
                }
                crate::types::UpdateReadFeaturedStickers::CONSTRUCTOR_ID => {
                    Self::ReadFeaturedStickers
                }
                crate::types::UpdateRecentStickers::CONSTRUCTOR_ID => Self::RecentStickers,
                crate::types::UpdateConfig::CONSTRUCTOR_ID => Self::Config,
                crate::types::UpdatePtsChanged::CONSTRUCTOR_ID => Self::PtsChanged,
                crate::types::UpdateChannelWebPage::CONSTRUCTOR_ID => {
                    Self::ChannelWebPage(crate::types::UpdateChannelWebPage::deserialize(buf)?)
                }
                crate::types::UpdateDialogPinned::CONSTRUCTOR_ID => {
                    Self::DialogPinned(crate::types::UpdateDialogPinned::deserialize(buf)?)
                }
                crate::types::UpdatePinnedDialogs::CONSTRUCTOR_ID => {
                    Self::PinnedDialogs(crate::types::UpdatePinnedDialogs::deserialize(buf)?)
                }
                crate::types::UpdateBotWebhookJson::CONSTRUCTOR_ID => {
                    Self::BotWebhookJson(crate::types::UpdateBotWebhookJson::deserialize(buf)?)
                }
                crate::types::UpdateBotWebhookJsonquery::CONSTRUCTOR_ID => {
                    Self::BotWebhookJsonquery(crate::types::UpdateBotWebhookJsonquery::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateBotShippingQuery::CONSTRUCTOR_ID => {
                    Self::BotShippingQuery(crate::types::UpdateBotShippingQuery::deserialize(buf)?)
                }
                crate::types::UpdateBotPrecheckoutQuery::CONSTRUCTOR_ID => {
                    Self::BotPrecheckoutQuery(crate::types::UpdateBotPrecheckoutQuery::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdatePhoneCall::CONSTRUCTOR_ID => {
                    Self::PhoneCall(crate::types::UpdatePhoneCall::deserialize(buf)?)
                }
                crate::types::UpdateLangPackTooLong::CONSTRUCTOR_ID => {
                    Self::LangPackTooLong(crate::types::UpdateLangPackTooLong::deserialize(buf)?)
                }
                crate::types::UpdateLangPack::CONSTRUCTOR_ID => {
                    Self::LangPack(crate::types::UpdateLangPack::deserialize(buf)?)
                }
                crate::types::UpdateFavedStickers::CONSTRUCTOR_ID => Self::FavedStickers,
                crate::types::UpdateChannelReadMessagesContents::CONSTRUCTOR_ID => {
                    Self::ChannelReadMessagesContents(
                        crate::types::UpdateChannelReadMessagesContents::deserialize(buf)?,
                    )
                }
                crate::types::UpdateContactsReset::CONSTRUCTOR_ID => Self::ContactsReset,
                crate::types::UpdateChannelAvailableMessages::CONSTRUCTOR_ID => {
                    Self::ChannelAvailableMessages(
                        crate::types::UpdateChannelAvailableMessages::deserialize(buf)?,
                    )
                }
                crate::types::UpdateDialogUnreadMark::CONSTRUCTOR_ID => {
                    Self::DialogUnreadMark(crate::types::UpdateDialogUnreadMark::deserialize(buf)?)
                }
                crate::types::UpdateMessagePoll::CONSTRUCTOR_ID => {
                    Self::MessagePoll(crate::types::UpdateMessagePoll::deserialize(buf)?)
                }
                crate::types::UpdateChatDefaultBannedRights::CONSTRUCTOR_ID => {
                    Self::ChatDefaultBannedRights(
                        crate::types::UpdateChatDefaultBannedRights::deserialize(buf)?,
                    )
                }
                crate::types::UpdateFolderPeers::CONSTRUCTOR_ID => {
                    Self::FolderPeers(crate::types::UpdateFolderPeers::deserialize(buf)?)
                }
                crate::types::UpdatePeerSettings::CONSTRUCTOR_ID => {
                    Self::PeerSettings(crate::types::UpdatePeerSettings::deserialize(buf)?)
                }
                crate::types::UpdatePeerLocated::CONSTRUCTOR_ID => {
                    Self::PeerLocated(crate::types::UpdatePeerLocated::deserialize(buf)?)
                }
                crate::types::UpdateNewScheduledMessage::CONSTRUCTOR_ID => {
                    Self::NewScheduledMessage(crate::types::UpdateNewScheduledMessage::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateDeleteScheduledMessages::CONSTRUCTOR_ID => {
                    Self::DeleteScheduledMessages(
                        crate::types::UpdateDeleteScheduledMessages::deserialize(buf)?,
                    )
                }
                crate::types::UpdateTheme::CONSTRUCTOR_ID => {
                    Self::Theme(crate::types::UpdateTheme::deserialize(buf)?)
                }
                crate::types::UpdateGeoLiveViewed::CONSTRUCTOR_ID => {
                    Self::GeoLiveViewed(crate::types::UpdateGeoLiveViewed::deserialize(buf)?)
                }
                crate::types::UpdateLoginToken::CONSTRUCTOR_ID => Self::LoginToken,
                crate::types::UpdateMessagePollVote::CONSTRUCTOR_ID => {
                    Self::MessagePollVote(crate::types::UpdateMessagePollVote::deserialize(buf)?)
                }
                crate::types::UpdateDialogFilter::CONSTRUCTOR_ID => {
                    Self::DialogFilter(crate::types::UpdateDialogFilter::deserialize(buf)?)
                }
                crate::types::UpdateDialogFilterOrder::CONSTRUCTOR_ID => Self::DialogFilterOrder(
                    crate::types::UpdateDialogFilterOrder::deserialize(buf)?,
                ),
                crate::types::UpdateDialogFilters::CONSTRUCTOR_ID => Self::DialogFilters,
                crate::types::UpdatePhoneCallSignalingData::CONSTRUCTOR_ID => {
                    Self::PhoneCallSignalingData(
                        crate::types::UpdatePhoneCallSignalingData::deserialize(buf)?,
                    )
                }
                crate::types::UpdateChannelMessageForwards::CONSTRUCTOR_ID => {
                    Self::ChannelMessageForwards(
                        crate::types::UpdateChannelMessageForwards::deserialize(buf)?,
                    )
                }
                crate::types::UpdateReadChannelDiscussionInbox::CONSTRUCTOR_ID => {
                    Self::ReadChannelDiscussionInbox(
                        crate::types::UpdateReadChannelDiscussionInbox::deserialize(buf)?,
                    )
                }
                crate::types::UpdateReadChannelDiscussionOutbox::CONSTRUCTOR_ID => {
                    Self::ReadChannelDiscussionOutbox(
                        crate::types::UpdateReadChannelDiscussionOutbox::deserialize(buf)?,
                    )
                }
                crate::types::UpdatePeerBlocked::CONSTRUCTOR_ID => {
                    Self::PeerBlocked(crate::types::UpdatePeerBlocked::deserialize(buf)?)
                }
                crate::types::UpdateChannelUserTyping::CONSTRUCTOR_ID => Self::ChannelUserTyping(
                    crate::types::UpdateChannelUserTyping::deserialize(buf)?,
                ),
                crate::types::UpdatePinnedMessages::CONSTRUCTOR_ID => {
                    Self::PinnedMessages(crate::types::UpdatePinnedMessages::deserialize(buf)?)
                }
                crate::types::UpdatePinnedChannelMessages::CONSTRUCTOR_ID => {
                    Self::PinnedChannelMessages(
                        crate::types::UpdatePinnedChannelMessages::deserialize(buf)?,
                    )
                }
                crate::types::UpdateChat::CONSTRUCTOR_ID => {
                    Self::Chat(crate::types::UpdateChat::deserialize(buf)?)
                }
                crate::types::UpdateGroupCallParticipants::CONSTRUCTOR_ID => {
                    Self::GroupCallParticipants(
                        crate::types::UpdateGroupCallParticipants::deserialize(buf)?,
                    )
                }
                crate::types::UpdateGroupCall::CONSTRUCTOR_ID => {
                    Self::GroupCall(crate::types::UpdateGroupCall::deserialize(buf)?)
                }
                crate::types::UpdatePeerHistoryTtl::CONSTRUCTOR_ID => {
                    Self::PeerHistoryTtl(crate::types::UpdatePeerHistoryTtl::deserialize(buf)?)
                }
                crate::types::UpdateChatParticipant::CONSTRUCTOR_ID => {
                    Self::ChatParticipant(crate::types::UpdateChatParticipant::deserialize(buf)?)
                }
                crate::types::UpdateChannelParticipant::CONSTRUCTOR_ID => Self::ChannelParticipant(
                    crate::types::UpdateChannelParticipant::deserialize(buf)?,
                ),
                crate::types::UpdateBotStopped::CONSTRUCTOR_ID => {
                    Self::BotStopped(crate::types::UpdateBotStopped::deserialize(buf)?)
                }
                crate::types::UpdateGroupCallConnection::CONSTRUCTOR_ID => {
                    Self::GroupCallConnection(crate::types::UpdateGroupCallConnection::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateBotCommands::CONSTRUCTOR_ID => {
                    Self::BotCommands(crate::types::UpdateBotCommands::deserialize(buf)?)
                }
                crate::types::UpdatePendingJoinRequests::CONSTRUCTOR_ID => {
                    Self::PendingJoinRequests(crate::types::UpdatePendingJoinRequests::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateBotChatInviteRequester::CONSTRUCTOR_ID => {
                    Self::BotChatInviteRequester(
                        crate::types::UpdateBotChatInviteRequester::deserialize(buf)?,
                    )
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UpdateNewMessage> for Update {
        fn from(x: crate::types::UpdateNewMessage) -> Self {
            Update::NewMessage(x)
        }
    }
    impl From<crate::types::UpdateMessageId> for Update {
        fn from(x: crate::types::UpdateMessageId) -> Self {
            Update::MessageId(x)
        }
    }
    impl From<crate::types::UpdateDeleteMessages> for Update {
        fn from(x: crate::types::UpdateDeleteMessages) -> Self {
            Update::DeleteMessages(x)
        }
    }
    impl From<crate::types::UpdateUserTyping> for Update {
        fn from(x: crate::types::UpdateUserTyping) -> Self {
            Update::UserTyping(x)
        }
    }
    impl From<crate::types::UpdateChatUserTyping> for Update {
        fn from(x: crate::types::UpdateChatUserTyping) -> Self {
            Update::ChatUserTyping(x)
        }
    }
    impl From<crate::types::UpdateChatParticipants> for Update {
        fn from(x: crate::types::UpdateChatParticipants) -> Self {
            Update::ChatParticipants(x)
        }
    }
    impl From<crate::types::UpdateUserStatus> for Update {
        fn from(x: crate::types::UpdateUserStatus) -> Self {
            Update::UserStatus(x)
        }
    }
    impl From<crate::types::UpdateUserName> for Update {
        fn from(x: crate::types::UpdateUserName) -> Self {
            Update::UserName(x)
        }
    }
    impl From<crate::types::UpdateUserPhoto> for Update {
        fn from(x: crate::types::UpdateUserPhoto) -> Self {
            Update::UserPhoto(x)
        }
    }
    impl From<crate::types::UpdateNewEncryptedMessage> for Update {
        fn from(x: crate::types::UpdateNewEncryptedMessage) -> Self {
            Update::NewEncryptedMessage(x)
        }
    }
    impl From<crate::types::UpdateEncryptedChatTyping> for Update {
        fn from(x: crate::types::UpdateEncryptedChatTyping) -> Self {
            Update::EncryptedChatTyping(x)
        }
    }
    impl From<crate::types::UpdateEncryption> for Update {
        fn from(x: crate::types::UpdateEncryption) -> Self {
            Update::Encryption(x)
        }
    }
    impl From<crate::types::UpdateEncryptedMessagesRead> for Update {
        fn from(x: crate::types::UpdateEncryptedMessagesRead) -> Self {
            Update::EncryptedMessagesRead(x)
        }
    }
    impl From<crate::types::UpdateChatParticipantAdd> for Update {
        fn from(x: crate::types::UpdateChatParticipantAdd) -> Self {
            Update::ChatParticipantAdd(x)
        }
    }
    impl From<crate::types::UpdateChatParticipantDelete> for Update {
        fn from(x: crate::types::UpdateChatParticipantDelete) -> Self {
            Update::ChatParticipantDelete(x)
        }
    }
    impl From<crate::types::UpdateDcOptions> for Update {
        fn from(x: crate::types::UpdateDcOptions) -> Self {
            Update::DcOptions(x)
        }
    }
    impl From<crate::types::UpdateNotifySettings> for Update {
        fn from(x: crate::types::UpdateNotifySettings) -> Self {
            Update::NotifySettings(x)
        }
    }
    impl From<crate::types::UpdateServiceNotification> for Update {
        fn from(x: crate::types::UpdateServiceNotification) -> Self {
            Update::ServiceNotification(x)
        }
    }
    impl From<crate::types::UpdatePrivacy> for Update {
        fn from(x: crate::types::UpdatePrivacy) -> Self {
            Update::Privacy(x)
        }
    }
    impl From<crate::types::UpdateUserPhone> for Update {
        fn from(x: crate::types::UpdateUserPhone) -> Self {
            Update::UserPhone(x)
        }
    }
    impl From<crate::types::UpdateReadHistoryInbox> for Update {
        fn from(x: crate::types::UpdateReadHistoryInbox) -> Self {
            Update::ReadHistoryInbox(x)
        }
    }
    impl From<crate::types::UpdateReadHistoryOutbox> for Update {
        fn from(x: crate::types::UpdateReadHistoryOutbox) -> Self {
            Update::ReadHistoryOutbox(x)
        }
    }
    impl From<crate::types::UpdateWebPage> for Update {
        fn from(x: crate::types::UpdateWebPage) -> Self {
            Update::WebPage(x)
        }
    }
    impl From<crate::types::UpdateReadMessagesContents> for Update {
        fn from(x: crate::types::UpdateReadMessagesContents) -> Self {
            Update::ReadMessagesContents(x)
        }
    }
    impl From<crate::types::UpdateChannelTooLong> for Update {
        fn from(x: crate::types::UpdateChannelTooLong) -> Self {
            Update::ChannelTooLong(x)
        }
    }
    impl From<crate::types::UpdateChannel> for Update {
        fn from(x: crate::types::UpdateChannel) -> Self {
            Update::Channel(x)
        }
    }
    impl From<crate::types::UpdateNewChannelMessage> for Update {
        fn from(x: crate::types::UpdateNewChannelMessage) -> Self {
            Update::NewChannelMessage(x)
        }
    }
    impl From<crate::types::UpdateReadChannelInbox> for Update {
        fn from(x: crate::types::UpdateReadChannelInbox) -> Self {
            Update::ReadChannelInbox(x)
        }
    }
    impl From<crate::types::UpdateDeleteChannelMessages> for Update {
        fn from(x: crate::types::UpdateDeleteChannelMessages) -> Self {
            Update::DeleteChannelMessages(x)
        }
    }
    impl From<crate::types::UpdateChannelMessageViews> for Update {
        fn from(x: crate::types::UpdateChannelMessageViews) -> Self {
            Update::ChannelMessageViews(x)
        }
    }
    impl From<crate::types::UpdateChatParticipantAdmin> for Update {
        fn from(x: crate::types::UpdateChatParticipantAdmin) -> Self {
            Update::ChatParticipantAdmin(x)
        }
    }
    impl From<crate::types::UpdateNewStickerSet> for Update {
        fn from(x: crate::types::UpdateNewStickerSet) -> Self {
            Update::NewStickerSet(x)
        }
    }
    impl From<crate::types::UpdateStickerSetsOrder> for Update {
        fn from(x: crate::types::UpdateStickerSetsOrder) -> Self {
            Update::StickerSetsOrder(x)
        }
    }
    impl From<crate::types::UpdateStickerSets> for Update {
        fn from(_x: crate::types::UpdateStickerSets) -> Self {
            Update::StickerSets
        }
    }
    impl From<crate::types::UpdateSavedGifs> for Update {
        fn from(_x: crate::types::UpdateSavedGifs) -> Self {
            Update::SavedGifs
        }
    }
    impl From<crate::types::UpdateBotInlineQuery> for Update {
        fn from(x: crate::types::UpdateBotInlineQuery) -> Self {
            Update::BotInlineQuery(x)
        }
    }
    impl From<crate::types::UpdateBotInlineSend> for Update {
        fn from(x: crate::types::UpdateBotInlineSend) -> Self {
            Update::BotInlineSend(x)
        }
    }
    impl From<crate::types::UpdateEditChannelMessage> for Update {
        fn from(x: crate::types::UpdateEditChannelMessage) -> Self {
            Update::EditChannelMessage(x)
        }
    }
    impl From<crate::types::UpdateBotCallbackQuery> for Update {
        fn from(x: crate::types::UpdateBotCallbackQuery) -> Self {
            Update::BotCallbackQuery(x)
        }
    }
    impl From<crate::types::UpdateEditMessage> for Update {
        fn from(x: crate::types::UpdateEditMessage) -> Self {
            Update::EditMessage(x)
        }
    }
    impl From<crate::types::UpdateInlineBotCallbackQuery> for Update {
        fn from(x: crate::types::UpdateInlineBotCallbackQuery) -> Self {
            Update::InlineBotCallbackQuery(x)
        }
    }
    impl From<crate::types::UpdateReadChannelOutbox> for Update {
        fn from(x: crate::types::UpdateReadChannelOutbox) -> Self {
            Update::ReadChannelOutbox(x)
        }
    }
    impl From<crate::types::UpdateDraftMessage> for Update {
        fn from(x: crate::types::UpdateDraftMessage) -> Self {
            Update::DraftMessage(x)
        }
    }
    impl From<crate::types::UpdateReadFeaturedStickers> for Update {
        fn from(_x: crate::types::UpdateReadFeaturedStickers) -> Self {
            Update::ReadFeaturedStickers
        }
    }
    impl From<crate::types::UpdateRecentStickers> for Update {
        fn from(_x: crate::types::UpdateRecentStickers) -> Self {
            Update::RecentStickers
        }
    }
    impl From<crate::types::UpdateConfig> for Update {
        fn from(_x: crate::types::UpdateConfig) -> Self {
            Update::Config
        }
    }
    impl From<crate::types::UpdatePtsChanged> for Update {
        fn from(_x: crate::types::UpdatePtsChanged) -> Self {
            Update::PtsChanged
        }
    }
    impl From<crate::types::UpdateChannelWebPage> for Update {
        fn from(x: crate::types::UpdateChannelWebPage) -> Self {
            Update::ChannelWebPage(x)
        }
    }
    impl From<crate::types::UpdateDialogPinned> for Update {
        fn from(x: crate::types::UpdateDialogPinned) -> Self {
            Update::DialogPinned(x)
        }
    }
    impl From<crate::types::UpdatePinnedDialogs> for Update {
        fn from(x: crate::types::UpdatePinnedDialogs) -> Self {
            Update::PinnedDialogs(x)
        }
    }
    impl From<crate::types::UpdateBotWebhookJson> for Update {
        fn from(x: crate::types::UpdateBotWebhookJson) -> Self {
            Update::BotWebhookJson(x)
        }
    }
    impl From<crate::types::UpdateBotWebhookJsonquery> for Update {
        fn from(x: crate::types::UpdateBotWebhookJsonquery) -> Self {
            Update::BotWebhookJsonquery(x)
        }
    }
    impl From<crate::types::UpdateBotShippingQuery> for Update {
        fn from(x: crate::types::UpdateBotShippingQuery) -> Self {
            Update::BotShippingQuery(x)
        }
    }
    impl From<crate::types::UpdateBotPrecheckoutQuery> for Update {
        fn from(x: crate::types::UpdateBotPrecheckoutQuery) -> Self {
            Update::BotPrecheckoutQuery(x)
        }
    }
    impl From<crate::types::UpdatePhoneCall> for Update {
        fn from(x: crate::types::UpdatePhoneCall) -> Self {
            Update::PhoneCall(x)
        }
    }
    impl From<crate::types::UpdateLangPackTooLong> for Update {
        fn from(x: crate::types::UpdateLangPackTooLong) -> Self {
            Update::LangPackTooLong(x)
        }
    }
    impl From<crate::types::UpdateLangPack> for Update {
        fn from(x: crate::types::UpdateLangPack) -> Self {
            Update::LangPack(x)
        }
    }
    impl From<crate::types::UpdateFavedStickers> for Update {
        fn from(_x: crate::types::UpdateFavedStickers) -> Self {
            Update::FavedStickers
        }
    }
    impl From<crate::types::UpdateChannelReadMessagesContents> for Update {
        fn from(x: crate::types::UpdateChannelReadMessagesContents) -> Self {
            Update::ChannelReadMessagesContents(x)
        }
    }
    impl From<crate::types::UpdateContactsReset> for Update {
        fn from(_x: crate::types::UpdateContactsReset) -> Self {
            Update::ContactsReset
        }
    }
    impl From<crate::types::UpdateChannelAvailableMessages> for Update {
        fn from(x: crate::types::UpdateChannelAvailableMessages) -> Self {
            Update::ChannelAvailableMessages(x)
        }
    }
    impl From<crate::types::UpdateDialogUnreadMark> for Update {
        fn from(x: crate::types::UpdateDialogUnreadMark) -> Self {
            Update::DialogUnreadMark(x)
        }
    }
    impl From<crate::types::UpdateMessagePoll> for Update {
        fn from(x: crate::types::UpdateMessagePoll) -> Self {
            Update::MessagePoll(x)
        }
    }
    impl From<crate::types::UpdateChatDefaultBannedRights> for Update {
        fn from(x: crate::types::UpdateChatDefaultBannedRights) -> Self {
            Update::ChatDefaultBannedRights(x)
        }
    }
    impl From<crate::types::UpdateFolderPeers> for Update {
        fn from(x: crate::types::UpdateFolderPeers) -> Self {
            Update::FolderPeers(x)
        }
    }
    impl From<crate::types::UpdatePeerSettings> for Update {
        fn from(x: crate::types::UpdatePeerSettings) -> Self {
            Update::PeerSettings(x)
        }
    }
    impl From<crate::types::UpdatePeerLocated> for Update {
        fn from(x: crate::types::UpdatePeerLocated) -> Self {
            Update::PeerLocated(x)
        }
    }
    impl From<crate::types::UpdateNewScheduledMessage> for Update {
        fn from(x: crate::types::UpdateNewScheduledMessage) -> Self {
            Update::NewScheduledMessage(x)
        }
    }
    impl From<crate::types::UpdateDeleteScheduledMessages> for Update {
        fn from(x: crate::types::UpdateDeleteScheduledMessages) -> Self {
            Update::DeleteScheduledMessages(x)
        }
    }
    impl From<crate::types::UpdateTheme> for Update {
        fn from(x: crate::types::UpdateTheme) -> Self {
            Update::Theme(x)
        }
    }
    impl From<crate::types::UpdateGeoLiveViewed> for Update {
        fn from(x: crate::types::UpdateGeoLiveViewed) -> Self {
            Update::GeoLiveViewed(x)
        }
    }
    impl From<crate::types::UpdateLoginToken> for Update {
        fn from(_x: crate::types::UpdateLoginToken) -> Self {
            Update::LoginToken
        }
    }
    impl From<crate::types::UpdateMessagePollVote> for Update {
        fn from(x: crate::types::UpdateMessagePollVote) -> Self {
            Update::MessagePollVote(x)
        }
    }
    impl From<crate::types::UpdateDialogFilter> for Update {
        fn from(x: crate::types::UpdateDialogFilter) -> Self {
            Update::DialogFilter(x)
        }
    }
    impl From<crate::types::UpdateDialogFilterOrder> for Update {
        fn from(x: crate::types::UpdateDialogFilterOrder) -> Self {
            Update::DialogFilterOrder(x)
        }
    }
    impl From<crate::types::UpdateDialogFilters> for Update {
        fn from(_x: crate::types::UpdateDialogFilters) -> Self {
            Update::DialogFilters
        }
    }
    impl From<crate::types::UpdatePhoneCallSignalingData> for Update {
        fn from(x: crate::types::UpdatePhoneCallSignalingData) -> Self {
            Update::PhoneCallSignalingData(x)
        }
    }
    impl From<crate::types::UpdateChannelMessageForwards> for Update {
        fn from(x: crate::types::UpdateChannelMessageForwards) -> Self {
            Update::ChannelMessageForwards(x)
        }
    }
    impl From<crate::types::UpdateReadChannelDiscussionInbox> for Update {
        fn from(x: crate::types::UpdateReadChannelDiscussionInbox) -> Self {
            Update::ReadChannelDiscussionInbox(x)
        }
    }
    impl From<crate::types::UpdateReadChannelDiscussionOutbox> for Update {
        fn from(x: crate::types::UpdateReadChannelDiscussionOutbox) -> Self {
            Update::ReadChannelDiscussionOutbox(x)
        }
    }
    impl From<crate::types::UpdatePeerBlocked> for Update {
        fn from(x: crate::types::UpdatePeerBlocked) -> Self {
            Update::PeerBlocked(x)
        }
    }
    impl From<crate::types::UpdateChannelUserTyping> for Update {
        fn from(x: crate::types::UpdateChannelUserTyping) -> Self {
            Update::ChannelUserTyping(x)
        }
    }
    impl From<crate::types::UpdatePinnedMessages> for Update {
        fn from(x: crate::types::UpdatePinnedMessages) -> Self {
            Update::PinnedMessages(x)
        }
    }
    impl From<crate::types::UpdatePinnedChannelMessages> for Update {
        fn from(x: crate::types::UpdatePinnedChannelMessages) -> Self {
            Update::PinnedChannelMessages(x)
        }
    }
    impl From<crate::types::UpdateChat> for Update {
        fn from(x: crate::types::UpdateChat) -> Self {
            Update::Chat(x)
        }
    }
    impl From<crate::types::UpdateGroupCallParticipants> for Update {
        fn from(x: crate::types::UpdateGroupCallParticipants) -> Self {
            Update::GroupCallParticipants(x)
        }
    }
    impl From<crate::types::UpdateGroupCall> for Update {
        fn from(x: crate::types::UpdateGroupCall) -> Self {
            Update::GroupCall(x)
        }
    }
    impl From<crate::types::UpdatePeerHistoryTtl> for Update {
        fn from(x: crate::types::UpdatePeerHistoryTtl) -> Self {
            Update::PeerHistoryTtl(x)
        }
    }
    impl From<crate::types::UpdateChatParticipant> for Update {
        fn from(x: crate::types::UpdateChatParticipant) -> Self {
            Update::ChatParticipant(x)
        }
    }
    impl From<crate::types::UpdateChannelParticipant> for Update {
        fn from(x: crate::types::UpdateChannelParticipant) -> Self {
            Update::ChannelParticipant(x)
        }
    }
    impl From<crate::types::UpdateBotStopped> for Update {
        fn from(x: crate::types::UpdateBotStopped) -> Self {
            Update::BotStopped(x)
        }
    }
    impl From<crate::types::UpdateGroupCallConnection> for Update {
        fn from(x: crate::types::UpdateGroupCallConnection) -> Self {
            Update::GroupCallConnection(x)
        }
    }
    impl From<crate::types::UpdateBotCommands> for Update {
        fn from(x: crate::types::UpdateBotCommands) -> Self {
            Update::BotCommands(x)
        }
    }
    impl From<crate::types::UpdatePendingJoinRequests> for Update {
        fn from(x: crate::types::UpdatePendingJoinRequests) -> Self {
            Update::PendingJoinRequests(x)
        }
    }
    impl From<crate::types::UpdateBotChatInviteRequester> for Update {
        fn from(x: crate::types::UpdateBotChatInviteRequester) -> Self {
            Update::BotChatInviteRequester(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum Updates {
        TooLong,
        UpdateShortMessage(crate::types::UpdateShortMessage),
        UpdateShortChatMessage(crate::types::UpdateShortChatMessage),
        UpdateShort(crate::types::UpdateShort),
        Combined(crate::types::UpdatesCombined),
        Updates(crate::types::Updates),
        UpdateShortSentMessage(crate::types::UpdateShortSentMessage),
    }
    impl crate::Serializable for Updates {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::TooLong => {
                    crate::types::UpdatesTooLong::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::UpdateShortMessage(x) => {
                    crate::types::UpdateShortMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UpdateShortChatMessage(x) => {
                    crate::types::UpdateShortChatMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UpdateShort(x) => {
                    crate::types::UpdateShort::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Combined(x) => {
                    crate::types::UpdatesCombined::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Updates(x) => {
                    crate::types::Updates::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::UpdateShortSentMessage(x) => {
                    crate::types::UpdateShortSentMessage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for Updates {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UpdatesTooLong::CONSTRUCTOR_ID => Self::TooLong,
                crate::types::UpdateShortMessage::CONSTRUCTOR_ID => {
                    Self::UpdateShortMessage(crate::types::UpdateShortMessage::deserialize(buf)?)
                }
                crate::types::UpdateShortChatMessage::CONSTRUCTOR_ID => {
                    Self::UpdateShortChatMessage(crate::types::UpdateShortChatMessage::deserialize(
                        buf,
                    )?)
                }
                crate::types::UpdateShort::CONSTRUCTOR_ID => {
                    Self::UpdateShort(crate::types::UpdateShort::deserialize(buf)?)
                }
                crate::types::UpdatesCombined::CONSTRUCTOR_ID => {
                    Self::Combined(crate::types::UpdatesCombined::deserialize(buf)?)
                }
                crate::types::Updates::CONSTRUCTOR_ID => {
                    Self::Updates(crate::types::Updates::deserialize(buf)?)
                }
                crate::types::UpdateShortSentMessage::CONSTRUCTOR_ID => {
                    Self::UpdateShortSentMessage(crate::types::UpdateShortSentMessage::deserialize(
                        buf,
                    )?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UpdatesTooLong> for Updates {
        fn from(_x: crate::types::UpdatesTooLong) -> Self {
            Updates::TooLong
        }
    }
    impl From<crate::types::UpdateShortMessage> for Updates {
        fn from(x: crate::types::UpdateShortMessage) -> Self {
            Updates::UpdateShortMessage(x)
        }
    }
    impl From<crate::types::UpdateShortChatMessage> for Updates {
        fn from(x: crate::types::UpdateShortChatMessage) -> Self {
            Updates::UpdateShortChatMessage(x)
        }
    }
    impl From<crate::types::UpdateShort> for Updates {
        fn from(x: crate::types::UpdateShort) -> Self {
            Updates::UpdateShort(x)
        }
    }
    impl From<crate::types::UpdatesCombined> for Updates {
        fn from(x: crate::types::UpdatesCombined) -> Self {
            Updates::Combined(x)
        }
    }
    impl From<crate::types::Updates> for Updates {
        fn from(x: crate::types::Updates) -> Self {
            Updates::Updates(x)
        }
    }
    impl From<crate::types::UpdateShortSentMessage> for Updates {
        fn from(x: crate::types::UpdateShortSentMessage) -> Self {
            Updates::UpdateShortSentMessage(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum UrlAuthResult {
        Request(crate::types::UrlAuthResultRequest),
        Accepted(crate::types::UrlAuthResultAccepted),
        Default,
    }
    impl crate::Serializable for UrlAuthResult {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Request(x) => {
                    crate::types::UrlAuthResultRequest::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Accepted(x) => {
                    crate::types::UrlAuthResultAccepted::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Default => {
                    crate::types::UrlAuthResultDefault::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for UrlAuthResult {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UrlAuthResultRequest::CONSTRUCTOR_ID => {
                    Self::Request(crate::types::UrlAuthResultRequest::deserialize(buf)?)
                }
                crate::types::UrlAuthResultAccepted::CONSTRUCTOR_ID => {
                    Self::Accepted(crate::types::UrlAuthResultAccepted::deserialize(buf)?)
                }
                crate::types::UrlAuthResultDefault::CONSTRUCTOR_ID => Self::Default,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UrlAuthResultRequest> for UrlAuthResult {
        fn from(x: crate::types::UrlAuthResultRequest) -> Self {
            UrlAuthResult::Request(x)
        }
    }
    impl From<crate::types::UrlAuthResultAccepted> for UrlAuthResult {
        fn from(x: crate::types::UrlAuthResultAccepted) -> Self {
            UrlAuthResult::Accepted(x)
        }
    }
    impl From<crate::types::UrlAuthResultDefault> for UrlAuthResult {
        fn from(_x: crate::types::UrlAuthResultDefault) -> Self {
            UrlAuthResult::Default
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum User {
        Empty(crate::types::UserEmpty),
        User(crate::types::User),
    }
    impl User {
        pub fn id(&self) -> i64 {
            match self {
                Self::Empty(i) => i.id,
                Self::User(i) => i.id,
            }
        }
    }
    impl crate::Serializable for User {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::UserEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::User(x) => {
                    crate::types::User::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for User {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UserEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::UserEmpty::deserialize(buf)?)
                }
                crate::types::User::CONSTRUCTOR_ID => {
                    Self::User(crate::types::User::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UserEmpty> for User {
        fn from(x: crate::types::UserEmpty) -> Self {
            User::Empty(x)
        }
    }
    impl From<crate::types::User> for User {
        fn from(x: crate::types::User) -> Self {
            User::User(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum UserFull {
        Full(crate::types::UserFull),
    }
    impl crate::Serializable for UserFull {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Full(x) => {
                    crate::types::UserFull::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for UserFull {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UserFull::CONSTRUCTOR_ID => {
                    Self::Full(crate::types::UserFull::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UserFull> for UserFull {
        fn from(x: crate::types::UserFull) -> Self {
            UserFull::Full(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum UserProfilePhoto {
        Empty,
        Photo(crate::types::UserProfilePhoto),
    }
    impl crate::Serializable for UserProfilePhoto {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::UserProfilePhotoEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Photo(x) => {
                    crate::types::UserProfilePhoto::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for UserProfilePhoto {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UserProfilePhotoEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::UserProfilePhoto::CONSTRUCTOR_ID => {
                    Self::Photo(crate::types::UserProfilePhoto::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UserProfilePhotoEmpty> for UserProfilePhoto {
        fn from(_x: crate::types::UserProfilePhotoEmpty) -> Self {
            UserProfilePhoto::Empty
        }
    }
    impl From<crate::types::UserProfilePhoto> for UserProfilePhoto {
        fn from(x: crate::types::UserProfilePhoto) -> Self {
            UserProfilePhoto::Photo(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum UserStatus {
        Empty,
        Online(crate::types::UserStatusOnline),
        Offline(crate::types::UserStatusOffline),
        Recently,
        LastWeek,
        LastMonth,
    }
    impl crate::Serializable for UserStatus {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty => {
                    crate::types::UserStatusEmpty::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::Online(x) => {
                    crate::types::UserStatusOnline::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Offline(x) => {
                    crate::types::UserStatusOffline::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Recently => {
                    crate::types::UserStatusRecently::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::LastWeek => {
                    crate::types::UserStatusLastWeek::CONSTRUCTOR_ID.serialize(buf);
                }
                Self::LastMonth => {
                    crate::types::UserStatusLastMonth::CONSTRUCTOR_ID.serialize(buf);
                }
            }
        }
    }
    impl crate::Deserializable for UserStatus {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::UserStatusEmpty::CONSTRUCTOR_ID => Self::Empty,
                crate::types::UserStatusOnline::CONSTRUCTOR_ID => {
                    Self::Online(crate::types::UserStatusOnline::deserialize(buf)?)
                }
                crate::types::UserStatusOffline::CONSTRUCTOR_ID => {
                    Self::Offline(crate::types::UserStatusOffline::deserialize(buf)?)
                }
                crate::types::UserStatusRecently::CONSTRUCTOR_ID => Self::Recently,
                crate::types::UserStatusLastWeek::CONSTRUCTOR_ID => Self::LastWeek,
                crate::types::UserStatusLastMonth::CONSTRUCTOR_ID => Self::LastMonth,
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::UserStatusEmpty> for UserStatus {
        fn from(_x: crate::types::UserStatusEmpty) -> Self {
            UserStatus::Empty
        }
    }
    impl From<crate::types::UserStatusOnline> for UserStatus {
        fn from(x: crate::types::UserStatusOnline) -> Self {
            UserStatus::Online(x)
        }
    }
    impl From<crate::types::UserStatusOffline> for UserStatus {
        fn from(x: crate::types::UserStatusOffline) -> Self {
            UserStatus::Offline(x)
        }
    }
    impl From<crate::types::UserStatusRecently> for UserStatus {
        fn from(_x: crate::types::UserStatusRecently) -> Self {
            UserStatus::Recently
        }
    }
    impl From<crate::types::UserStatusLastWeek> for UserStatus {
        fn from(_x: crate::types::UserStatusLastWeek) -> Self {
            UserStatus::LastWeek
        }
    }
    impl From<crate::types::UserStatusLastMonth> for UserStatus {
        fn from(_x: crate::types::UserStatusLastMonth) -> Self {
            UserStatus::LastMonth
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum VideoSize {
        Size(crate::types::VideoSize),
    }
    impl crate::Serializable for VideoSize {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Size(x) => {
                    crate::types::VideoSize::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for VideoSize {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::VideoSize::CONSTRUCTOR_ID => {
                    Self::Size(crate::types::VideoSize::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::VideoSize> for VideoSize {
        fn from(x: crate::types::VideoSize) -> Self {
            VideoSize::Size(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WallPaper {
        Paper(crate::types::WallPaper),
        NoFile(crate::types::WallPaperNoFile),
    }
    impl WallPaper {
        pub fn default(&self) -> bool {
            match self {
                Self::Paper(i) => i.default,
                Self::NoFile(i) => i.default,
            }
        }
        pub fn dark(&self) -> bool {
            match self {
                Self::Paper(i) => i.dark,
                Self::NoFile(i) => i.dark,
            }
        }
        pub fn id(&self) -> i64 {
            match self {
                Self::Paper(i) => i.id,
                Self::NoFile(i) => i.id,
            }
        }
    }
    impl crate::Serializable for WallPaper {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Paper(x) => {
                    crate::types::WallPaper::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NoFile(x) => {
                    crate::types::WallPaperNoFile::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WallPaper {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WallPaper::CONSTRUCTOR_ID => {
                    Self::Paper(crate::types::WallPaper::deserialize(buf)?)
                }
                crate::types::WallPaperNoFile::CONSTRUCTOR_ID => {
                    Self::NoFile(crate::types::WallPaperNoFile::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WallPaper> for WallPaper {
        fn from(x: crate::types::WallPaper) -> Self {
            WallPaper::Paper(x)
        }
    }
    impl From<crate::types::WallPaperNoFile> for WallPaper {
        fn from(x: crate::types::WallPaperNoFile) -> Self {
            WallPaper::NoFile(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WallPaperSettings {
        Settings(crate::types::WallPaperSettings),
    }
    impl crate::Serializable for WallPaperSettings {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Settings(x) => {
                    crate::types::WallPaperSettings::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WallPaperSettings {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WallPaperSettings::CONSTRUCTOR_ID => {
                    Self::Settings(crate::types::WallPaperSettings::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WallPaperSettings> for WallPaperSettings {
        fn from(x: crate::types::WallPaperSettings) -> Self {
            WallPaperSettings::Settings(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WebAuthorization {
        Authorization(crate::types::WebAuthorization),
    }
    impl crate::Serializable for WebAuthorization {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Authorization(x) => {
                    crate::types::WebAuthorization::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WebAuthorization {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WebAuthorization::CONSTRUCTOR_ID => {
                    Self::Authorization(crate::types::WebAuthorization::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WebAuthorization> for WebAuthorization {
        fn from(x: crate::types::WebAuthorization) -> Self {
            WebAuthorization::Authorization(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WebDocument {
        Document(crate::types::WebDocument),
        NoProxy(crate::types::WebDocumentNoProxy),
    }
    impl WebDocument {
        pub fn attributes(&self) -> Vec<crate::enums::DocumentAttribute> {
            match self {
                Self::Document(i) => i.attributes.clone(),
                Self::NoProxy(i) => i.attributes.clone(),
            }
        }
        pub fn size(&self) -> i32 {
            match self {
                Self::Document(i) => i.size,
                Self::NoProxy(i) => i.size,
            }
        }
        pub fn mime_type(&self) -> String {
            match self {
                Self::Document(i) => i.mime_type.clone(),
                Self::NoProxy(i) => i.mime_type.clone(),
            }
        }
        pub fn url(&self) -> String {
            match self {
                Self::Document(i) => i.url.clone(),
                Self::NoProxy(i) => i.url.clone(),
            }
        }
    }
    impl crate::Serializable for WebDocument {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Document(x) => {
                    crate::types::WebDocument::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NoProxy(x) => {
                    crate::types::WebDocumentNoProxy::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WebDocument {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WebDocument::CONSTRUCTOR_ID => {
                    Self::Document(crate::types::WebDocument::deserialize(buf)?)
                }
                crate::types::WebDocumentNoProxy::CONSTRUCTOR_ID => {
                    Self::NoProxy(crate::types::WebDocumentNoProxy::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WebDocument> for WebDocument {
        fn from(x: crate::types::WebDocument) -> Self {
            WebDocument::Document(x)
        }
    }
    impl From<crate::types::WebDocumentNoProxy> for WebDocument {
        fn from(x: crate::types::WebDocumentNoProxy) -> Self {
            WebDocument::NoProxy(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WebPage {
        Empty(crate::types::WebPageEmpty),
        Pending(crate::types::WebPagePending),
        Page(crate::types::WebPage),
        NotModified(crate::types::WebPageNotModified),
    }
    impl crate::Serializable for WebPage {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Empty(x) => {
                    crate::types::WebPageEmpty::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Pending(x) => {
                    crate::types::WebPagePending::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::Page(x) => {
                    crate::types::WebPage::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
                Self::NotModified(x) => {
                    crate::types::WebPageNotModified::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WebPage {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WebPageEmpty::CONSTRUCTOR_ID => {
                    Self::Empty(crate::types::WebPageEmpty::deserialize(buf)?)
                }
                crate::types::WebPagePending::CONSTRUCTOR_ID => {
                    Self::Pending(crate::types::WebPagePending::deserialize(buf)?)
                }
                crate::types::WebPage::CONSTRUCTOR_ID => {
                    Self::Page(crate::types::WebPage::deserialize(buf)?)
                }
                crate::types::WebPageNotModified::CONSTRUCTOR_ID => {
                    Self::NotModified(crate::types::WebPageNotModified::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WebPageEmpty> for WebPage {
        fn from(x: crate::types::WebPageEmpty) -> Self {
            WebPage::Empty(x)
        }
    }
    impl From<crate::types::WebPagePending> for WebPage {
        fn from(x: crate::types::WebPagePending) -> Self {
            WebPage::Pending(x)
        }
    }
    impl From<crate::types::WebPage> for WebPage {
        fn from(x: crate::types::WebPage) -> Self {
            WebPage::Page(x)
        }
    }
    impl From<crate::types::WebPageNotModified> for WebPage {
        fn from(x: crate::types::WebPageNotModified) -> Self {
            WebPage::NotModified(x)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum WebPageAttribute {
        Theme(crate::types::WebPageAttributeTheme),
    }
    impl crate::Serializable for WebPageAttribute {
        fn serialize(&self, buf: crate::serialize::Buffer) {
            use crate::Identifiable;
            match self {
                Self::Theme(x) => {
                    crate::types::WebPageAttributeTheme::CONSTRUCTOR_ID.serialize(buf);
                    x.serialize(buf)
                }
            }
        }
    }
    impl crate::Deserializable for WebPageAttribute {
        fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
            use crate::Identifiable;
            let id = u32::deserialize(buf)?;
            Ok(match id {
                crate::types::WebPageAttributeTheme::CONSTRUCTOR_ID => {
                    Self::Theme(crate::types::WebPageAttributeTheme::deserialize(buf)?)
                }
                _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
            })
        }
    }
    impl From<crate::types::WebPageAttributeTheme> for WebPageAttribute {
        fn from(x: crate::types::WebPageAttributeTheme) -> Self {
            WebPageAttribute::Theme(x)
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod account {
        #[derive(Debug, Clone, PartialEq)]
        pub enum AuthorizationForm {
            Form(crate::types::account::AuthorizationForm),
        }
        impl crate::Serializable for AuthorizationForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Form(x) => {
                        crate::types::account::AuthorizationForm::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AuthorizationForm {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::AuthorizationForm::CONSTRUCTOR_ID => {
                        Self::Form(crate::types::account::AuthorizationForm::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::AuthorizationForm> for AuthorizationForm {
            fn from(x: crate::types::account::AuthorizationForm) -> Self {
                AuthorizationForm::Form(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Authorizations {
            Authorizations(crate::types::account::Authorizations),
        }
        impl crate::Serializable for Authorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Authorizations(x) => {
                        crate::types::account::Authorizations::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Authorizations {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::Authorizations::CONSTRUCTOR_ID => Self::Authorizations(
                        crate::types::account::Authorizations::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::Authorizations> for Authorizations {
            fn from(x: crate::types::account::Authorizations) -> Self {
                Authorizations::Authorizations(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum AutoDownloadSettings {
            Settings(crate::types::account::AutoDownloadSettings),
        }
        impl crate::Serializable for AutoDownloadSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Settings(x) => {
                        crate::types::account::AutoDownloadSettings::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AutoDownloadSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::AutoDownloadSettings::CONSTRUCTOR_ID => Self::Settings(
                        crate::types::account::AutoDownloadSettings::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::AutoDownloadSettings> for AutoDownloadSettings {
            fn from(x: crate::types::account::AutoDownloadSettings) -> Self {
                AutoDownloadSettings::Settings(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ContentSettings {
            Settings(crate::types::account::ContentSettings),
        }
        impl crate::Serializable for ContentSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Settings(x) => {
                        crate::types::account::ContentSettings::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ContentSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::ContentSettings::CONSTRUCTOR_ID => {
                        Self::Settings(crate::types::account::ContentSettings::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::ContentSettings> for ContentSettings {
            fn from(x: crate::types::account::ContentSettings) -> Self {
                ContentSettings::Settings(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Password {
            Password(crate::types::account::Password),
        }
        impl crate::Serializable for Password {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Password(x) => {
                        crate::types::account::Password::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Password {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::Password::CONSTRUCTOR_ID => {
                        Self::Password(crate::types::account::Password::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::Password> for Password {
            fn from(x: crate::types::account::Password) -> Self {
                Password::Password(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PasswordInputSettings {
            Settings(crate::types::account::PasswordInputSettings),
        }
        impl crate::Serializable for PasswordInputSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Settings(x) => {
                        crate::types::account::PasswordInputSettings::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PasswordInputSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::PasswordInputSettings::CONSTRUCTOR_ID => Self::Settings(
                        crate::types::account::PasswordInputSettings::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::PasswordInputSettings> for PasswordInputSettings {
            fn from(x: crate::types::account::PasswordInputSettings) -> Self {
                PasswordInputSettings::Settings(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PasswordSettings {
            Settings(crate::types::account::PasswordSettings),
        }
        impl crate::Serializable for PasswordSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Settings(x) => {
                        crate::types::account::PasswordSettings::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PasswordSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::PasswordSettings::CONSTRUCTOR_ID => {
                        Self::Settings(crate::types::account::PasswordSettings::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::PasswordSettings> for PasswordSettings {
            fn from(x: crate::types::account::PasswordSettings) -> Self {
                PasswordSettings::Settings(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PrivacyRules {
            Rules(crate::types::account::PrivacyRules),
        }
        impl crate::Serializable for PrivacyRules {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Rules(x) => {
                        crate::types::account::PrivacyRules::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PrivacyRules {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::PrivacyRules::CONSTRUCTOR_ID => {
                        Self::Rules(crate::types::account::PrivacyRules::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::PrivacyRules> for PrivacyRules {
            fn from(x: crate::types::account::PrivacyRules) -> Self {
                PrivacyRules::Rules(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ResetPasswordResult {
            ResetPasswordFailedWait(crate::types::account::ResetPasswordFailedWait),
            ResetPasswordRequestedWait(crate::types::account::ResetPasswordRequestedWait),
            ResetPasswordOk,
        }
        impl crate::Serializable for ResetPasswordResult {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::ResetPasswordFailedWait(x) => {
                        crate::types::account::ResetPasswordFailedWait::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::ResetPasswordRequestedWait(x) => {
                        crate::types::account::ResetPasswordRequestedWait::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::ResetPasswordOk => {
                        crate::types::account::ResetPasswordOk::CONSTRUCTOR_ID.serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for ResetPasswordResult {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::ResetPasswordFailedWait::CONSTRUCTOR_ID => {
                        Self::ResetPasswordFailedWait(
                            crate::types::account::ResetPasswordFailedWait::deserialize(buf)?,
                        )
                    }
                    crate::types::account::ResetPasswordRequestedWait::CONSTRUCTOR_ID => {
                        Self::ResetPasswordRequestedWait(
                            crate::types::account::ResetPasswordRequestedWait::deserialize(buf)?,
                        )
                    }
                    crate::types::account::ResetPasswordOk::CONSTRUCTOR_ID => Self::ResetPasswordOk,
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::ResetPasswordFailedWait> for ResetPasswordResult {
            fn from(x: crate::types::account::ResetPasswordFailedWait) -> Self {
                ResetPasswordResult::ResetPasswordFailedWait(x)
            }
        }
        impl From<crate::types::account::ResetPasswordRequestedWait> for ResetPasswordResult {
            fn from(x: crate::types::account::ResetPasswordRequestedWait) -> Self {
                ResetPasswordResult::ResetPasswordRequestedWait(x)
            }
        }
        impl From<crate::types::account::ResetPasswordOk> for ResetPasswordResult {
            fn from(_x: crate::types::account::ResetPasswordOk) -> Self {
                ResetPasswordResult::ResetPasswordOk
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SentEmailCode {
            Code(crate::types::account::SentEmailCode),
        }
        impl crate::Serializable for SentEmailCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Code(x) => {
                        crate::types::account::SentEmailCode::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SentEmailCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::SentEmailCode::CONSTRUCTOR_ID => {
                        Self::Code(crate::types::account::SentEmailCode::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::SentEmailCode> for SentEmailCode {
            fn from(x: crate::types::account::SentEmailCode) -> Self {
                SentEmailCode::Code(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Takeout {
            Takeout(crate::types::account::Takeout),
        }
        impl crate::Serializable for Takeout {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Takeout(x) => {
                        crate::types::account::Takeout::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Takeout {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::Takeout::CONSTRUCTOR_ID => {
                        Self::Takeout(crate::types::account::Takeout::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::Takeout> for Takeout {
            fn from(x: crate::types::account::Takeout) -> Self {
                Takeout::Takeout(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Themes {
            NotModified,
            Themes(crate::types::account::Themes),
        }
        impl crate::Serializable for Themes {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::account::ThemesNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Themes(x) => {
                        crate::types::account::Themes::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Themes {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::ThemesNotModified::CONSTRUCTOR_ID => Self::NotModified,
                    crate::types::account::Themes::CONSTRUCTOR_ID => {
                        Self::Themes(crate::types::account::Themes::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::ThemesNotModified> for Themes {
            fn from(_x: crate::types::account::ThemesNotModified) -> Self {
                Themes::NotModified
            }
        }
        impl From<crate::types::account::Themes> for Themes {
            fn from(x: crate::types::account::Themes) -> Self {
                Themes::Themes(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum TmpPassword {
            Password(crate::types::account::TmpPassword),
        }
        impl crate::Serializable for TmpPassword {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Password(x) => {
                        crate::types::account::TmpPassword::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for TmpPassword {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::TmpPassword::CONSTRUCTOR_ID => {
                        Self::Password(crate::types::account::TmpPassword::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::TmpPassword> for TmpPassword {
            fn from(x: crate::types::account::TmpPassword) -> Self {
                TmpPassword::Password(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum WallPapers {
            NotModified,
            Papers(crate::types::account::WallPapers),
        }
        impl crate::Serializable for WallPapers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::account::WallPapersNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Papers(x) => {
                        crate::types::account::WallPapers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for WallPapers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::WallPapersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::account::WallPapers::CONSTRUCTOR_ID => {
                        Self::Papers(crate::types::account::WallPapers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::WallPapersNotModified> for WallPapers {
            fn from(_x: crate::types::account::WallPapersNotModified) -> Self {
                WallPapers::NotModified
            }
        }
        impl From<crate::types::account::WallPapers> for WallPapers {
            fn from(x: crate::types::account::WallPapers) -> Self {
                WallPapers::Papers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum WebAuthorizations {
            Authorizations(crate::types::account::WebAuthorizations),
        }
        impl crate::Serializable for WebAuthorizations {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Authorizations(x) => {
                        crate::types::account::WebAuthorizations::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for WebAuthorizations {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::account::WebAuthorizations::CONSTRUCTOR_ID => {
                        Self::Authorizations(crate::types::account::WebAuthorizations::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::account::WebAuthorizations> for WebAuthorizations {
            fn from(x: crate::types::account::WebAuthorizations) -> Self {
                WebAuthorizations::Authorizations(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod auth {
        #[derive(Debug, Clone, PartialEq)]
        pub enum Authorization {
            Authorization(crate::types::auth::Authorization),
            SignUpRequired(crate::types::auth::AuthorizationSignUpRequired),
        }
        impl crate::Serializable for Authorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Authorization(x) => {
                        crate::types::auth::Authorization::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::SignUpRequired(x) => {
                        crate::types::auth::AuthorizationSignUpRequired::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Authorization {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::Authorization::CONSTRUCTOR_ID => {
                        Self::Authorization(crate::types::auth::Authorization::deserialize(buf)?)
                    }
                    crate::types::auth::AuthorizationSignUpRequired::CONSTRUCTOR_ID => {
                        Self::SignUpRequired(
                            crate::types::auth::AuthorizationSignUpRequired::deserialize(buf)?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::Authorization> for Authorization {
            fn from(x: crate::types::auth::Authorization) -> Self {
                Authorization::Authorization(x)
            }
        }
        impl From<crate::types::auth::AuthorizationSignUpRequired> for Authorization {
            fn from(x: crate::types::auth::AuthorizationSignUpRequired) -> Self {
                Authorization::SignUpRequired(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum CodeType {
            Sms,
            Call,
            FlashCall,
            MissedCall,
        }
        impl crate::Serializable for CodeType {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Sms => {
                        crate::types::auth::CodeTypeSms::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Call => {
                        crate::types::auth::CodeTypeCall::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FlashCall => {
                        crate::types::auth::CodeTypeFlashCall::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::MissedCall => {
                        crate::types::auth::CodeTypeMissedCall::CONSTRUCTOR_ID.serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for CodeType {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::CodeTypeSms::CONSTRUCTOR_ID => Self::Sms,
                    crate::types::auth::CodeTypeCall::CONSTRUCTOR_ID => Self::Call,
                    crate::types::auth::CodeTypeFlashCall::CONSTRUCTOR_ID => Self::FlashCall,
                    crate::types::auth::CodeTypeMissedCall::CONSTRUCTOR_ID => Self::MissedCall,
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::CodeTypeSms> for CodeType {
            fn from(_x: crate::types::auth::CodeTypeSms) -> Self {
                CodeType::Sms
            }
        }
        impl From<crate::types::auth::CodeTypeCall> for CodeType {
            fn from(_x: crate::types::auth::CodeTypeCall) -> Self {
                CodeType::Call
            }
        }
        impl From<crate::types::auth::CodeTypeFlashCall> for CodeType {
            fn from(_x: crate::types::auth::CodeTypeFlashCall) -> Self {
                CodeType::FlashCall
            }
        }
        impl From<crate::types::auth::CodeTypeMissedCall> for CodeType {
            fn from(_x: crate::types::auth::CodeTypeMissedCall) -> Self {
                CodeType::MissedCall
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ExportedAuthorization {
            Authorization(crate::types::auth::ExportedAuthorization),
        }
        impl crate::Serializable for ExportedAuthorization {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Authorization(x) => {
                        crate::types::auth::ExportedAuthorization::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ExportedAuthorization {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::ExportedAuthorization::CONSTRUCTOR_ID => {
                        Self::Authorization(crate::types::auth::ExportedAuthorization::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::ExportedAuthorization> for ExportedAuthorization {
            fn from(x: crate::types::auth::ExportedAuthorization) -> Self {
                ExportedAuthorization::Authorization(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum LoggedOut {
            Out(crate::types::auth::LoggedOut),
        }
        impl crate::Serializable for LoggedOut {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Out(x) => {
                        crate::types::auth::LoggedOut::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for LoggedOut {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::LoggedOut::CONSTRUCTOR_ID => {
                        Self::Out(crate::types::auth::LoggedOut::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::LoggedOut> for LoggedOut {
            fn from(x: crate::types::auth::LoggedOut) -> Self {
                LoggedOut::Out(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum LoginToken {
            Token(crate::types::auth::LoginToken),
            MigrateTo(crate::types::auth::LoginTokenMigrateTo),
            Success(crate::types::auth::LoginTokenSuccess),
        }
        impl crate::Serializable for LoginToken {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Token(x) => {
                        crate::types::auth::LoginToken::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::MigrateTo(x) => {
                        crate::types::auth::LoginTokenMigrateTo::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Success(x) => {
                        crate::types::auth::LoginTokenSuccess::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for LoginToken {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::LoginToken::CONSTRUCTOR_ID => {
                        Self::Token(crate::types::auth::LoginToken::deserialize(buf)?)
                    }
                    crate::types::auth::LoginTokenMigrateTo::CONSTRUCTOR_ID => {
                        Self::MigrateTo(crate::types::auth::LoginTokenMigrateTo::deserialize(buf)?)
                    }
                    crate::types::auth::LoginTokenSuccess::CONSTRUCTOR_ID => {
                        Self::Success(crate::types::auth::LoginTokenSuccess::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::LoginToken> for LoginToken {
            fn from(x: crate::types::auth::LoginToken) -> Self {
                LoginToken::Token(x)
            }
        }
        impl From<crate::types::auth::LoginTokenMigrateTo> for LoginToken {
            fn from(x: crate::types::auth::LoginTokenMigrateTo) -> Self {
                LoginToken::MigrateTo(x)
            }
        }
        impl From<crate::types::auth::LoginTokenSuccess> for LoginToken {
            fn from(x: crate::types::auth::LoginTokenSuccess) -> Self {
                LoginToken::Success(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PasswordRecovery {
            Recovery(crate::types::auth::PasswordRecovery),
        }
        impl crate::Serializable for PasswordRecovery {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Recovery(x) => {
                        crate::types::auth::PasswordRecovery::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PasswordRecovery {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::PasswordRecovery::CONSTRUCTOR_ID => {
                        Self::Recovery(crate::types::auth::PasswordRecovery::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::PasswordRecovery> for PasswordRecovery {
            fn from(x: crate::types::auth::PasswordRecovery) -> Self {
                PasswordRecovery::Recovery(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SentCode {
            Code(crate::types::auth::SentCode),
        }
        impl crate::Serializable for SentCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Code(x) => {
                        crate::types::auth::SentCode::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SentCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::SentCode::CONSTRUCTOR_ID => {
                        Self::Code(crate::types::auth::SentCode::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::SentCode> for SentCode {
            fn from(x: crate::types::auth::SentCode) -> Self {
                SentCode::Code(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SentCodeType {
            App(crate::types::auth::SentCodeTypeApp),
            Sms(crate::types::auth::SentCodeTypeSms),
            Call(crate::types::auth::SentCodeTypeCall),
            FlashCall(crate::types::auth::SentCodeTypeFlashCall),
            MissedCall(crate::types::auth::SentCodeTypeMissedCall),
        }
        impl crate::Serializable for SentCodeType {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::App(x) => {
                        crate::types::auth::SentCodeTypeApp::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Sms(x) => {
                        crate::types::auth::SentCodeTypeSms::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Call(x) => {
                        crate::types::auth::SentCodeTypeCall::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::FlashCall(x) => {
                        crate::types::auth::SentCodeTypeFlashCall::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::MissedCall(x) => {
                        crate::types::auth::SentCodeTypeMissedCall::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SentCodeType {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::auth::SentCodeTypeApp::CONSTRUCTOR_ID => {
                        Self::App(crate::types::auth::SentCodeTypeApp::deserialize(buf)?)
                    }
                    crate::types::auth::SentCodeTypeSms::CONSTRUCTOR_ID => {
                        Self::Sms(crate::types::auth::SentCodeTypeSms::deserialize(buf)?)
                    }
                    crate::types::auth::SentCodeTypeCall::CONSTRUCTOR_ID => {
                        Self::Call(crate::types::auth::SentCodeTypeCall::deserialize(buf)?)
                    }
                    crate::types::auth::SentCodeTypeFlashCall::CONSTRUCTOR_ID => Self::FlashCall(
                        crate::types::auth::SentCodeTypeFlashCall::deserialize(buf)?,
                    ),
                    crate::types::auth::SentCodeTypeMissedCall::CONSTRUCTOR_ID => Self::MissedCall(
                        crate::types::auth::SentCodeTypeMissedCall::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::auth::SentCodeTypeApp> for SentCodeType {
            fn from(x: crate::types::auth::SentCodeTypeApp) -> Self {
                SentCodeType::App(x)
            }
        }
        impl From<crate::types::auth::SentCodeTypeSms> for SentCodeType {
            fn from(x: crate::types::auth::SentCodeTypeSms) -> Self {
                SentCodeType::Sms(x)
            }
        }
        impl From<crate::types::auth::SentCodeTypeCall> for SentCodeType {
            fn from(x: crate::types::auth::SentCodeTypeCall) -> Self {
                SentCodeType::Call(x)
            }
        }
        impl From<crate::types::auth::SentCodeTypeFlashCall> for SentCodeType {
            fn from(x: crate::types::auth::SentCodeTypeFlashCall) -> Self {
                SentCodeType::FlashCall(x)
            }
        }
        impl From<crate::types::auth::SentCodeTypeMissedCall> for SentCodeType {
            fn from(x: crate::types::auth::SentCodeTypeMissedCall) -> Self {
                SentCodeType::MissedCall(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod channels {
        #[derive(Debug, Clone, PartialEq)]
        pub enum AdminLogResults {
            Results(crate::types::channels::AdminLogResults),
        }
        impl crate::Serializable for AdminLogResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Results(x) => {
                        crate::types::channels::AdminLogResults::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AdminLogResults {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::channels::AdminLogResults::CONSTRUCTOR_ID => {
                        Self::Results(crate::types::channels::AdminLogResults::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::channels::AdminLogResults> for AdminLogResults {
            fn from(x: crate::types::channels::AdminLogResults) -> Self {
                AdminLogResults::Results(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChannelParticipant {
            Participant(crate::types::channels::ChannelParticipant),
        }
        impl crate::Serializable for ChannelParticipant {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Participant(x) => {
                        crate::types::channels::ChannelParticipant::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ChannelParticipant {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::channels::ChannelParticipant::CONSTRUCTOR_ID => {
                        Self::Participant(crate::types::channels::ChannelParticipant::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::channels::ChannelParticipant> for ChannelParticipant {
            fn from(x: crate::types::channels::ChannelParticipant) -> Self {
                ChannelParticipant::Participant(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChannelParticipants {
            Participants(crate::types::channels::ChannelParticipants),
            NotModified,
        }
        impl crate::Serializable for ChannelParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Participants(x) => {
                        crate::types::channels::ChannelParticipants::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::NotModified => {
                        crate::types::channels::ChannelParticipantsNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for ChannelParticipants {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::channels::ChannelParticipants::CONSTRUCTOR_ID => {
                        Self::Participants(
                            crate::types::channels::ChannelParticipants::deserialize(buf)?,
                        )
                    }
                    crate::types::channels::ChannelParticipantsNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::channels::ChannelParticipants> for ChannelParticipants {
            fn from(x: crate::types::channels::ChannelParticipants) -> Self {
                ChannelParticipants::Participants(x)
            }
        }
        impl From<crate::types::channels::ChannelParticipantsNotModified> for ChannelParticipants {
            fn from(_x: crate::types::channels::ChannelParticipantsNotModified) -> Self {
                ChannelParticipants::NotModified
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SendAsPeers {
            Peers(crate::types::channels::SendAsPeers),
        }
        impl crate::Serializable for SendAsPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Peers(x) => {
                        crate::types::channels::SendAsPeers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SendAsPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::channels::SendAsPeers::CONSTRUCTOR_ID => {
                        Self::Peers(crate::types::channels::SendAsPeers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::channels::SendAsPeers> for SendAsPeers {
            fn from(x: crate::types::channels::SendAsPeers) -> Self {
                SendAsPeers::Peers(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod contacts {
        #[derive(Debug, Clone, PartialEq)]
        pub enum Blocked {
            Blocked(crate::types::contacts::Blocked),
            Slice(crate::types::contacts::BlockedSlice),
        }
        impl Blocked {
            pub fn chats(&self) -> Vec<crate::enums::Chat> {
                match self {
                    Self::Blocked(i) => i.chats.clone(),
                    Self::Slice(i) => i.chats.clone(),
                }
            }
            pub fn users(&self) -> Vec<crate::enums::User> {
                match self {
                    Self::Blocked(i) => i.users.clone(),
                    Self::Slice(i) => i.users.clone(),
                }
            }
            pub fn blocked(&self) -> Vec<crate::enums::PeerBlocked> {
                match self {
                    Self::Blocked(i) => i.blocked.clone(),
                    Self::Slice(i) => i.blocked.clone(),
                }
            }
        }
        impl crate::Serializable for Blocked {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Blocked(x) => {
                        crate::types::contacts::Blocked::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::contacts::BlockedSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Blocked {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::Blocked::CONSTRUCTOR_ID => {
                        Self::Blocked(crate::types::contacts::Blocked::deserialize(buf)?)
                    }
                    crate::types::contacts::BlockedSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::contacts::BlockedSlice::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::Blocked> for Blocked {
            fn from(x: crate::types::contacts::Blocked) -> Self {
                Blocked::Blocked(x)
            }
        }
        impl From<crate::types::contacts::BlockedSlice> for Blocked {
            fn from(x: crate::types::contacts::BlockedSlice) -> Self {
                Blocked::Slice(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Contacts {
            NotModified,
            Contacts(crate::types::contacts::Contacts),
        }
        impl crate::Serializable for Contacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::contacts::ContactsNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Contacts(x) => {
                        crate::types::contacts::Contacts::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Contacts {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::ContactsNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::contacts::Contacts::CONSTRUCTOR_ID => {
                        Self::Contacts(crate::types::contacts::Contacts::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::ContactsNotModified> for Contacts {
            fn from(_x: crate::types::contacts::ContactsNotModified) -> Self {
                Contacts::NotModified
            }
        }
        impl From<crate::types::contacts::Contacts> for Contacts {
            fn from(x: crate::types::contacts::Contacts) -> Self {
                Contacts::Contacts(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Found {
            Found(crate::types::contacts::Found),
        }
        impl crate::Serializable for Found {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Found(x) => {
                        crate::types::contacts::Found::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Found {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::Found::CONSTRUCTOR_ID => {
                        Self::Found(crate::types::contacts::Found::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::Found> for Found {
            fn from(x: crate::types::contacts::Found) -> Self {
                Found::Found(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ImportedContacts {
            Contacts(crate::types::contacts::ImportedContacts),
        }
        impl crate::Serializable for ImportedContacts {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Contacts(x) => {
                        crate::types::contacts::ImportedContacts::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ImportedContacts {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::ImportedContacts::CONSTRUCTOR_ID => {
                        Self::Contacts(crate::types::contacts::ImportedContacts::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::ImportedContacts> for ImportedContacts {
            fn from(x: crate::types::contacts::ImportedContacts) -> Self {
                ImportedContacts::Contacts(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ResolvedPeer {
            Peer(crate::types::contacts::ResolvedPeer),
        }
        impl crate::Serializable for ResolvedPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Peer(x) => {
                        crate::types::contacts::ResolvedPeer::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ResolvedPeer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::ResolvedPeer::CONSTRUCTOR_ID => {
                        Self::Peer(crate::types::contacts::ResolvedPeer::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::ResolvedPeer> for ResolvedPeer {
            fn from(x: crate::types::contacts::ResolvedPeer) -> Self {
                ResolvedPeer::Peer(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum TopPeers {
            NotModified,
            Peers(crate::types::contacts::TopPeers),
            Disabled,
        }
        impl crate::Serializable for TopPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::contacts::TopPeersNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Peers(x) => {
                        crate::types::contacts::TopPeers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Disabled => {
                        crate::types::contacts::TopPeersDisabled::CONSTRUCTOR_ID.serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for TopPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::contacts::TopPeersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::contacts::TopPeers::CONSTRUCTOR_ID => {
                        Self::Peers(crate::types::contacts::TopPeers::deserialize(buf)?)
                    }
                    crate::types::contacts::TopPeersDisabled::CONSTRUCTOR_ID => Self::Disabled,
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::contacts::TopPeersNotModified> for TopPeers {
            fn from(_x: crate::types::contacts::TopPeersNotModified) -> Self {
                TopPeers::NotModified
            }
        }
        impl From<crate::types::contacts::TopPeers> for TopPeers {
            fn from(x: crate::types::contacts::TopPeers) -> Self {
                TopPeers::Peers(x)
            }
        }
        impl From<crate::types::contacts::TopPeersDisabled> for TopPeers {
            fn from(_x: crate::types::contacts::TopPeersDisabled) -> Self {
                TopPeers::Disabled
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod help {
        #[derive(Debug, Clone, PartialEq)]
        pub enum AppUpdate {
            Update(crate::types::help::AppUpdate),
            NoAppUpdate,
        }
        impl crate::Serializable for AppUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Update(x) => {
                        crate::types::help::AppUpdate::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::NoAppUpdate => {
                        crate::types::help::NoAppUpdate::CONSTRUCTOR_ID.serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for AppUpdate {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::AppUpdate::CONSTRUCTOR_ID => {
                        Self::Update(crate::types::help::AppUpdate::deserialize(buf)?)
                    }
                    crate::types::help::NoAppUpdate::CONSTRUCTOR_ID => Self::NoAppUpdate,
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::AppUpdate> for AppUpdate {
            fn from(x: crate::types::help::AppUpdate) -> Self {
                AppUpdate::Update(x)
            }
        }
        impl From<crate::types::help::NoAppUpdate> for AppUpdate {
            fn from(_x: crate::types::help::NoAppUpdate) -> Self {
                AppUpdate::NoAppUpdate
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ConfigSimple {
            Simple(crate::types::help::ConfigSimple),
        }
        impl crate::Serializable for ConfigSimple {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Simple(x) => {
                        crate::types::help::ConfigSimple::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ConfigSimple {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::ConfigSimple::CONSTRUCTOR_ID => {
                        Self::Simple(crate::types::help::ConfigSimple::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::ConfigSimple> for ConfigSimple {
            fn from(x: crate::types::help::ConfigSimple) -> Self {
                ConfigSimple::Simple(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum CountriesList {
            NotModified,
            List(crate::types::help::CountriesList),
        }
        impl crate::Serializable for CountriesList {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::help::CountriesListNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::List(x) => {
                        crate::types::help::CountriesList::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for CountriesList {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::CountriesListNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::help::CountriesList::CONSTRUCTOR_ID => {
                        Self::List(crate::types::help::CountriesList::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::CountriesListNotModified> for CountriesList {
            fn from(_x: crate::types::help::CountriesListNotModified) -> Self {
                CountriesList::NotModified
            }
        }
        impl From<crate::types::help::CountriesList> for CountriesList {
            fn from(x: crate::types::help::CountriesList) -> Self {
                CountriesList::List(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Country {
            Country(crate::types::help::Country),
        }
        impl crate::Serializable for Country {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Country(x) => {
                        crate::types::help::Country::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Country {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::Country::CONSTRUCTOR_ID => {
                        Self::Country(crate::types::help::Country::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::Country> for Country {
            fn from(x: crate::types::help::Country) -> Self {
                Country::Country(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum CountryCode {
            Code(crate::types::help::CountryCode),
        }
        impl crate::Serializable for CountryCode {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Code(x) => {
                        crate::types::help::CountryCode::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for CountryCode {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::CountryCode::CONSTRUCTOR_ID => {
                        Self::Code(crate::types::help::CountryCode::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::CountryCode> for CountryCode {
            fn from(x: crate::types::help::CountryCode) -> Self {
                CountryCode::Code(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum DeepLinkInfo {
            Empty,
            Info(crate::types::help::DeepLinkInfo),
        }
        impl crate::Serializable for DeepLinkInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty => {
                        crate::types::help::DeepLinkInfoEmpty::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Info(x) => {
                        crate::types::help::DeepLinkInfo::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for DeepLinkInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::DeepLinkInfoEmpty::CONSTRUCTOR_ID => Self::Empty,
                    crate::types::help::DeepLinkInfo::CONSTRUCTOR_ID => {
                        Self::Info(crate::types::help::DeepLinkInfo::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::DeepLinkInfoEmpty> for DeepLinkInfo {
            fn from(_x: crate::types::help::DeepLinkInfoEmpty) -> Self {
                DeepLinkInfo::Empty
            }
        }
        impl From<crate::types::help::DeepLinkInfo> for DeepLinkInfo {
            fn from(x: crate::types::help::DeepLinkInfo) -> Self {
                DeepLinkInfo::Info(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum InviteText {
            Text(crate::types::help::InviteText),
        }
        impl crate::Serializable for InviteText {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Text(x) => {
                        crate::types::help::InviteText::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for InviteText {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::InviteText::CONSTRUCTOR_ID => {
                        Self::Text(crate::types::help::InviteText::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::InviteText> for InviteText {
            fn from(x: crate::types::help::InviteText) -> Self {
                InviteText::Text(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PassportConfig {
            NotModified,
            Config(crate::types::help::PassportConfig),
        }
        impl crate::Serializable for PassportConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::help::PassportConfigNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Config(x) => {
                        crate::types::help::PassportConfig::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PassportConfig {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::PassportConfigNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::help::PassportConfig::CONSTRUCTOR_ID => {
                        Self::Config(crate::types::help::PassportConfig::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::PassportConfigNotModified> for PassportConfig {
            fn from(_x: crate::types::help::PassportConfigNotModified) -> Self {
                PassportConfig::NotModified
            }
        }
        impl From<crate::types::help::PassportConfig> for PassportConfig {
            fn from(x: crate::types::help::PassportConfig) -> Self {
                PassportConfig::Config(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PromoData {
            Empty(crate::types::help::PromoDataEmpty),
            Data(crate::types::help::PromoData),
        }
        impl PromoData {
            pub fn expires(&self) -> i32 {
                match self {
                    Self::Empty(i) => i.expires,
                    Self::Data(i) => i.expires,
                }
            }
        }
        impl crate::Serializable for PromoData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty(x) => {
                        crate::types::help::PromoDataEmpty::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Data(x) => {
                        crate::types::help::PromoData::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PromoData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::PromoDataEmpty::CONSTRUCTOR_ID => {
                        Self::Empty(crate::types::help::PromoDataEmpty::deserialize(buf)?)
                    }
                    crate::types::help::PromoData::CONSTRUCTOR_ID => {
                        Self::Data(crate::types::help::PromoData::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::PromoDataEmpty> for PromoData {
            fn from(x: crate::types::help::PromoDataEmpty) -> Self {
                PromoData::Empty(x)
            }
        }
        impl From<crate::types::help::PromoData> for PromoData {
            fn from(x: crate::types::help::PromoData) -> Self {
                PromoData::Data(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum RecentMeUrls {
            Urls(crate::types::help::RecentMeUrls),
        }
        impl crate::Serializable for RecentMeUrls {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Urls(x) => {
                        crate::types::help::RecentMeUrls::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for RecentMeUrls {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::RecentMeUrls::CONSTRUCTOR_ID => {
                        Self::Urls(crate::types::help::RecentMeUrls::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::RecentMeUrls> for RecentMeUrls {
            fn from(x: crate::types::help::RecentMeUrls) -> Self {
                RecentMeUrls::Urls(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Support {
            Support(crate::types::help::Support),
        }
        impl crate::Serializable for Support {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Support(x) => {
                        crate::types::help::Support::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Support {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::Support::CONSTRUCTOR_ID => {
                        Self::Support(crate::types::help::Support::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::Support> for Support {
            fn from(x: crate::types::help::Support) -> Self {
                Support::Support(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SupportName {
            Name(crate::types::help::SupportName),
        }
        impl crate::Serializable for SupportName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Name(x) => {
                        crate::types::help::SupportName::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SupportName {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::SupportName::CONSTRUCTOR_ID => {
                        Self::Name(crate::types::help::SupportName::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::SupportName> for SupportName {
            fn from(x: crate::types::help::SupportName) -> Self {
                SupportName::Name(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum TermsOfService {
            Service(crate::types::help::TermsOfService),
        }
        impl crate::Serializable for TermsOfService {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Service(x) => {
                        crate::types::help::TermsOfService::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for TermsOfService {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::TermsOfService::CONSTRUCTOR_ID => {
                        Self::Service(crate::types::help::TermsOfService::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::TermsOfService> for TermsOfService {
            fn from(x: crate::types::help::TermsOfService) -> Self {
                TermsOfService::Service(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum TermsOfServiceUpdate {
            Empty(crate::types::help::TermsOfServiceUpdateEmpty),
            Update(crate::types::help::TermsOfServiceUpdate),
        }
        impl TermsOfServiceUpdate {
            pub fn expires(&self) -> i32 {
                match self {
                    Self::Empty(i) => i.expires,
                    Self::Update(i) => i.expires,
                }
            }
        }
        impl crate::Serializable for TermsOfServiceUpdate {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty(x) => {
                        crate::types::help::TermsOfServiceUpdateEmpty::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Update(x) => {
                        crate::types::help::TermsOfServiceUpdate::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for TermsOfServiceUpdate {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::TermsOfServiceUpdateEmpty::CONSTRUCTOR_ID => Self::Empty(
                        crate::types::help::TermsOfServiceUpdateEmpty::deserialize(buf)?,
                    ),
                    crate::types::help::TermsOfServiceUpdate::CONSTRUCTOR_ID => {
                        Self::Update(crate::types::help::TermsOfServiceUpdate::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::TermsOfServiceUpdateEmpty> for TermsOfServiceUpdate {
            fn from(x: crate::types::help::TermsOfServiceUpdateEmpty) -> Self {
                TermsOfServiceUpdate::Empty(x)
            }
        }
        impl From<crate::types::help::TermsOfServiceUpdate> for TermsOfServiceUpdate {
            fn from(x: crate::types::help::TermsOfServiceUpdate) -> Self {
                TermsOfServiceUpdate::Update(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum UserInfo {
            Empty,
            Info(crate::types::help::UserInfo),
        }
        impl crate::Serializable for UserInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty => {
                        crate::types::help::UserInfoEmpty::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Info(x) => {
                        crate::types::help::UserInfo::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for UserInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::help::UserInfoEmpty::CONSTRUCTOR_ID => Self::Empty,
                    crate::types::help::UserInfo::CONSTRUCTOR_ID => {
                        Self::Info(crate::types::help::UserInfo::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::help::UserInfoEmpty> for UserInfo {
            fn from(_x: crate::types::help::UserInfoEmpty) -> Self {
                UserInfo::Empty
            }
        }
        impl From<crate::types::help::UserInfo> for UserInfo {
            fn from(x: crate::types::help::UserInfo) -> Self {
                UserInfo::Info(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod messages {
        #[derive(Debug, Clone, PartialEq)]
        pub enum AffectedFoundMessages {
            Messages(crate::types::messages::AffectedFoundMessages),
        }
        impl crate::Serializable for AffectedFoundMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Messages(x) => {
                        crate::types::messages::AffectedFoundMessages::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AffectedFoundMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::AffectedFoundMessages::CONSTRUCTOR_ID => {
                        Self::Messages(crate::types::messages::AffectedFoundMessages::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::AffectedFoundMessages> for AffectedFoundMessages {
            fn from(x: crate::types::messages::AffectedFoundMessages) -> Self {
                AffectedFoundMessages::Messages(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum AffectedHistory {
            History(crate::types::messages::AffectedHistory),
        }
        impl crate::Serializable for AffectedHistory {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::History(x) => {
                        crate::types::messages::AffectedHistory::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AffectedHistory {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::AffectedHistory::CONSTRUCTOR_ID => {
                        Self::History(crate::types::messages::AffectedHistory::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::AffectedHistory> for AffectedHistory {
            fn from(x: crate::types::messages::AffectedHistory) -> Self {
                AffectedHistory::History(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum AffectedMessages {
            Messages(crate::types::messages::AffectedMessages),
        }
        impl crate::Serializable for AffectedMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Messages(x) => {
                        crate::types::messages::AffectedMessages::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AffectedMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::AffectedMessages::CONSTRUCTOR_ID => {
                        Self::Messages(crate::types::messages::AffectedMessages::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::AffectedMessages> for AffectedMessages {
            fn from(x: crate::types::messages::AffectedMessages) -> Self {
                AffectedMessages::Messages(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum AllStickers {
            NotModified,
            Stickers(crate::types::messages::AllStickers),
        }
        impl crate::Serializable for AllStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::AllStickersNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Stickers(x) => {
                        crate::types::messages::AllStickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for AllStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::AllStickersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::AllStickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::AllStickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::AllStickersNotModified> for AllStickers {
            fn from(_x: crate::types::messages::AllStickersNotModified) -> Self {
                AllStickers::NotModified
            }
        }
        impl From<crate::types::messages::AllStickers> for AllStickers {
            fn from(x: crate::types::messages::AllStickers) -> Self {
                AllStickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ArchivedStickers {
            Stickers(crate::types::messages::ArchivedStickers),
        }
        impl crate::Serializable for ArchivedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Stickers(x) => {
                        crate::types::messages::ArchivedStickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ArchivedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ArchivedStickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::ArchivedStickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ArchivedStickers> for ArchivedStickers {
            fn from(x: crate::types::messages::ArchivedStickers) -> Self {
                ArchivedStickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum BotCallbackAnswer {
            Answer(crate::types::messages::BotCallbackAnswer),
        }
        impl crate::Serializable for BotCallbackAnswer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Answer(x) => {
                        crate::types::messages::BotCallbackAnswer::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for BotCallbackAnswer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::BotCallbackAnswer::CONSTRUCTOR_ID => {
                        Self::Answer(crate::types::messages::BotCallbackAnswer::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::BotCallbackAnswer> for BotCallbackAnswer {
            fn from(x: crate::types::messages::BotCallbackAnswer) -> Self {
                BotCallbackAnswer::Answer(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum BotResults {
            Results(crate::types::messages::BotResults),
        }
        impl crate::Serializable for BotResults {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Results(x) => {
                        crate::types::messages::BotResults::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for BotResults {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::BotResults::CONSTRUCTOR_ID => {
                        Self::Results(crate::types::messages::BotResults::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::BotResults> for BotResults {
            fn from(x: crate::types::messages::BotResults) -> Self {
                BotResults::Results(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChatAdminsWithInvites {
            Invites(crate::types::messages::ChatAdminsWithInvites),
        }
        impl crate::Serializable for ChatAdminsWithInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Invites(x) => {
                        crate::types::messages::ChatAdminsWithInvites::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ChatAdminsWithInvites {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ChatAdminsWithInvites::CONSTRUCTOR_ID => Self::Invites(
                        crate::types::messages::ChatAdminsWithInvites::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ChatAdminsWithInvites> for ChatAdminsWithInvites {
            fn from(x: crate::types::messages::ChatAdminsWithInvites) -> Self {
                ChatAdminsWithInvites::Invites(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChatFull {
            Full(crate::types::messages::ChatFull),
        }
        impl crate::Serializable for ChatFull {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Full(x) => {
                        crate::types::messages::ChatFull::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ChatFull {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ChatFull::CONSTRUCTOR_ID => {
                        Self::Full(crate::types::messages::ChatFull::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ChatFull> for ChatFull {
            fn from(x: crate::types::messages::ChatFull) -> Self {
                ChatFull::Full(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChatInviteImporters {
            Importers(crate::types::messages::ChatInviteImporters),
        }
        impl crate::Serializable for ChatInviteImporters {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Importers(x) => {
                        crate::types::messages::ChatInviteImporters::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ChatInviteImporters {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ChatInviteImporters::CONSTRUCTOR_ID => Self::Importers(
                        crate::types::messages::ChatInviteImporters::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ChatInviteImporters> for ChatInviteImporters {
            fn from(x: crate::types::messages::ChatInviteImporters) -> Self {
                ChatInviteImporters::Importers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Chats {
            Chats(crate::types::messages::Chats),
            Slice(crate::types::messages::ChatsSlice),
        }
        impl Chats {
            pub fn chats(&self) -> Vec<crate::enums::Chat> {
                match self {
                    Self::Chats(i) => i.chats.clone(),
                    Self::Slice(i) => i.chats.clone(),
                }
            }
        }
        impl crate::Serializable for Chats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Chats(x) => {
                        crate::types::messages::Chats::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::messages::ChatsSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Chats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::Chats::CONSTRUCTOR_ID => {
                        Self::Chats(crate::types::messages::Chats::deserialize(buf)?)
                    }
                    crate::types::messages::ChatsSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::messages::ChatsSlice::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::Chats> for Chats {
            fn from(x: crate::types::messages::Chats) -> Self {
                Chats::Chats(x)
            }
        }
        impl From<crate::types::messages::ChatsSlice> for Chats {
            fn from(x: crate::types::messages::ChatsSlice) -> Self {
                Chats::Slice(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum CheckedHistoryImportPeer {
            Peer(crate::types::messages::CheckedHistoryImportPeer),
        }
        impl crate::Serializable for CheckedHistoryImportPeer {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Peer(x) => {
                        crate::types::messages::CheckedHistoryImportPeer::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for CheckedHistoryImportPeer {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::CheckedHistoryImportPeer::CONSTRUCTOR_ID => Self::Peer(
                        crate::types::messages::CheckedHistoryImportPeer::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::CheckedHistoryImportPeer> for CheckedHistoryImportPeer {
            fn from(x: crate::types::messages::CheckedHistoryImportPeer) -> Self {
                CheckedHistoryImportPeer::Peer(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum DhConfig {
            NotModified(crate::types::messages::DhConfigNotModified),
            Config(crate::types::messages::DhConfig),
        }
        impl DhConfig {
            pub fn random(&self) -> Vec<u8> {
                match self {
                    Self::NotModified(i) => i.random.clone(),
                    Self::Config(i) => i.random.clone(),
                }
            }
        }
        impl crate::Serializable for DhConfig {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified(x) => {
                        crate::types::messages::DhConfigNotModified::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Config(x) => {
                        crate::types::messages::DhConfig::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for DhConfig {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::DhConfigNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified(crate::types::messages::DhConfigNotModified::deserialize(
                            buf,
                        )?)
                    }
                    crate::types::messages::DhConfig::CONSTRUCTOR_ID => {
                        Self::Config(crate::types::messages::DhConfig::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::DhConfigNotModified> for DhConfig {
            fn from(x: crate::types::messages::DhConfigNotModified) -> Self {
                DhConfig::NotModified(x)
            }
        }
        impl From<crate::types::messages::DhConfig> for DhConfig {
            fn from(x: crate::types::messages::DhConfig) -> Self {
                DhConfig::Config(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Dialogs {
            Dialogs(crate::types::messages::Dialogs),
            Slice(crate::types::messages::DialogsSlice),
            NotModified(crate::types::messages::DialogsNotModified),
        }
        impl crate::Serializable for Dialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Dialogs(x) => {
                        crate::types::messages::Dialogs::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::messages::DialogsSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::NotModified(x) => {
                        crate::types::messages::DialogsNotModified::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Dialogs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::Dialogs::CONSTRUCTOR_ID => {
                        Self::Dialogs(crate::types::messages::Dialogs::deserialize(buf)?)
                    }
                    crate::types::messages::DialogsSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::messages::DialogsSlice::deserialize(buf)?)
                    }
                    crate::types::messages::DialogsNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified(crate::types::messages::DialogsNotModified::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::Dialogs> for Dialogs {
            fn from(x: crate::types::messages::Dialogs) -> Self {
                Dialogs::Dialogs(x)
            }
        }
        impl From<crate::types::messages::DialogsSlice> for Dialogs {
            fn from(x: crate::types::messages::DialogsSlice) -> Self {
                Dialogs::Slice(x)
            }
        }
        impl From<crate::types::messages::DialogsNotModified> for Dialogs {
            fn from(x: crate::types::messages::DialogsNotModified) -> Self {
                Dialogs::NotModified(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum DiscussionMessage {
            Message(crate::types::messages::DiscussionMessage),
        }
        impl crate::Serializable for DiscussionMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Message(x) => {
                        crate::types::messages::DiscussionMessage::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for DiscussionMessage {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::DiscussionMessage::CONSTRUCTOR_ID => {
                        Self::Message(crate::types::messages::DiscussionMessage::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::DiscussionMessage> for DiscussionMessage {
            fn from(x: crate::types::messages::DiscussionMessage) -> Self {
                DiscussionMessage::Message(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ExportedChatInvite {
            Invite(crate::types::messages::ExportedChatInvite),
            Replaced(crate::types::messages::ExportedChatInviteReplaced),
        }
        impl ExportedChatInvite {
            pub fn users(&self) -> Vec<crate::enums::User> {
                match self {
                    Self::Invite(i) => i.users.clone(),
                    Self::Replaced(i) => i.users.clone(),
                }
            }
            pub fn invite(&self) -> crate::enums::ExportedChatInvite {
                match self {
                    Self::Invite(i) => i.invite.clone(),
                    Self::Replaced(i) => i.invite.clone(),
                }
            }
        }
        impl crate::Serializable for ExportedChatInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Invite(x) => {
                        crate::types::messages::ExportedChatInvite::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Replaced(x) => {
                        crate::types::messages::ExportedChatInviteReplaced::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ExportedChatInvite {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ExportedChatInvite::CONSTRUCTOR_ID => Self::Invite(
                        crate::types::messages::ExportedChatInvite::deserialize(buf)?,
                    ),
                    crate::types::messages::ExportedChatInviteReplaced::CONSTRUCTOR_ID => {
                        Self::Replaced(
                            crate::types::messages::ExportedChatInviteReplaced::deserialize(buf)?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ExportedChatInvite> for ExportedChatInvite {
            fn from(x: crate::types::messages::ExportedChatInvite) -> Self {
                ExportedChatInvite::Invite(x)
            }
        }
        impl From<crate::types::messages::ExportedChatInviteReplaced> for ExportedChatInvite {
            fn from(x: crate::types::messages::ExportedChatInviteReplaced) -> Self {
                ExportedChatInvite::Replaced(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ExportedChatInvites {
            Invites(crate::types::messages::ExportedChatInvites),
        }
        impl crate::Serializable for ExportedChatInvites {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Invites(x) => {
                        crate::types::messages::ExportedChatInvites::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ExportedChatInvites {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::ExportedChatInvites::CONSTRUCTOR_ID => Self::Invites(
                        crate::types::messages::ExportedChatInvites::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::ExportedChatInvites> for ExportedChatInvites {
            fn from(x: crate::types::messages::ExportedChatInvites) -> Self {
                ExportedChatInvites::Invites(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum FavedStickers {
            NotModified,
            Stickers(crate::types::messages::FavedStickers),
        }
        impl crate::Serializable for FavedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::FavedStickersNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Stickers(x) => {
                        crate::types::messages::FavedStickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for FavedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::FavedStickersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::FavedStickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::FavedStickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::FavedStickersNotModified> for FavedStickers {
            fn from(_x: crate::types::messages::FavedStickersNotModified) -> Self {
                FavedStickers::NotModified
            }
        }
        impl From<crate::types::messages::FavedStickers> for FavedStickers {
            fn from(x: crate::types::messages::FavedStickers) -> Self {
                FavedStickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum FeaturedStickers {
            NotModified(crate::types::messages::FeaturedStickersNotModified),
            Stickers(crate::types::messages::FeaturedStickers),
        }
        impl FeaturedStickers {
            pub fn count(&self) -> i32 {
                match self {
                    Self::NotModified(i) => i.count,
                    Self::Stickers(i) => i.count,
                }
            }
        }
        impl crate::Serializable for FeaturedStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified(x) => {
                        crate::types::messages::FeaturedStickersNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Stickers(x) => {
                        crate::types::messages::FeaturedStickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for FeaturedStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::FeaturedStickersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified(
                            crate::types::messages::FeaturedStickersNotModified::deserialize(buf)?,
                        )
                    }
                    crate::types::messages::FeaturedStickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::FeaturedStickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::FeaturedStickersNotModified> for FeaturedStickers {
            fn from(x: crate::types::messages::FeaturedStickersNotModified) -> Self {
                FeaturedStickers::NotModified(x)
            }
        }
        impl From<crate::types::messages::FeaturedStickers> for FeaturedStickers {
            fn from(x: crate::types::messages::FeaturedStickers) -> Self {
                FeaturedStickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum FoundStickerSets {
            NotModified,
            Sets(crate::types::messages::FoundStickerSets),
        }
        impl crate::Serializable for FoundStickerSets {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::FoundStickerSetsNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Sets(x) => {
                        crate::types::messages::FoundStickerSets::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for FoundStickerSets {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::FoundStickerSetsNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::FoundStickerSets::CONSTRUCTOR_ID => {
                        Self::Sets(crate::types::messages::FoundStickerSets::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::FoundStickerSetsNotModified> for FoundStickerSets {
            fn from(_x: crate::types::messages::FoundStickerSetsNotModified) -> Self {
                FoundStickerSets::NotModified
            }
        }
        impl From<crate::types::messages::FoundStickerSets> for FoundStickerSets {
            fn from(x: crate::types::messages::FoundStickerSets) -> Self {
                FoundStickerSets::Sets(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum HighScores {
            Scores(crate::types::messages::HighScores),
        }
        impl crate::Serializable for HighScores {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Scores(x) => {
                        crate::types::messages::HighScores::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for HighScores {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::HighScores::CONSTRUCTOR_ID => {
                        Self::Scores(crate::types::messages::HighScores::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::HighScores> for HighScores {
            fn from(x: crate::types::messages::HighScores) -> Self {
                HighScores::Scores(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum HistoryImport {
            Import(crate::types::messages::HistoryImport),
        }
        impl crate::Serializable for HistoryImport {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Import(x) => {
                        crate::types::messages::HistoryImport::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for HistoryImport {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::HistoryImport::CONSTRUCTOR_ID => {
                        Self::Import(crate::types::messages::HistoryImport::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::HistoryImport> for HistoryImport {
            fn from(x: crate::types::messages::HistoryImport) -> Self {
                HistoryImport::Import(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum HistoryImportParsed {
            Parsed(crate::types::messages::HistoryImportParsed),
        }
        impl crate::Serializable for HistoryImportParsed {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Parsed(x) => {
                        crate::types::messages::HistoryImportParsed::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for HistoryImportParsed {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::HistoryImportParsed::CONSTRUCTOR_ID => Self::Parsed(
                        crate::types::messages::HistoryImportParsed::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::HistoryImportParsed> for HistoryImportParsed {
            fn from(x: crate::types::messages::HistoryImportParsed) -> Self {
                HistoryImportParsed::Parsed(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum InactiveChats {
            Chats(crate::types::messages::InactiveChats),
        }
        impl crate::Serializable for InactiveChats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Chats(x) => {
                        crate::types::messages::InactiveChats::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for InactiveChats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::InactiveChats::CONSTRUCTOR_ID => {
                        Self::Chats(crate::types::messages::InactiveChats::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::InactiveChats> for InactiveChats {
            fn from(x: crate::types::messages::InactiveChats) -> Self {
                InactiveChats::Chats(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum MessageEditData {
            Data(crate::types::messages::MessageEditData),
        }
        impl crate::Serializable for MessageEditData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Data(x) => {
                        crate::types::messages::MessageEditData::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for MessageEditData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::MessageEditData::CONSTRUCTOR_ID => {
                        Self::Data(crate::types::messages::MessageEditData::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::MessageEditData> for MessageEditData {
            fn from(x: crate::types::messages::MessageEditData) -> Self {
                MessageEditData::Data(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum MessageViews {
            Views(crate::types::messages::MessageViews),
        }
        impl crate::Serializable for MessageViews {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Views(x) => {
                        crate::types::messages::MessageViews::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for MessageViews {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::MessageViews::CONSTRUCTOR_ID => {
                        Self::Views(crate::types::messages::MessageViews::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::MessageViews> for MessageViews {
            fn from(x: crate::types::messages::MessageViews) -> Self {
                MessageViews::Views(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Messages {
            Messages(crate::types::messages::Messages),
            Slice(crate::types::messages::MessagesSlice),
            ChannelMessages(crate::types::messages::ChannelMessages),
            NotModified(crate::types::messages::MessagesNotModified),
        }
        impl crate::Serializable for Messages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Messages(x) => {
                        crate::types::messages::Messages::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::messages::MessagesSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::ChannelMessages(x) => {
                        crate::types::messages::ChannelMessages::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::NotModified(x) => {
                        crate::types::messages::MessagesNotModified::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Messages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::Messages::CONSTRUCTOR_ID => {
                        Self::Messages(crate::types::messages::Messages::deserialize(buf)?)
                    }
                    crate::types::messages::MessagesSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::messages::MessagesSlice::deserialize(buf)?)
                    }
                    crate::types::messages::ChannelMessages::CONSTRUCTOR_ID => {
                        Self::ChannelMessages(crate::types::messages::ChannelMessages::deserialize(
                            buf,
                        )?)
                    }
                    crate::types::messages::MessagesNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified(crate::types::messages::MessagesNotModified::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::Messages> for Messages {
            fn from(x: crate::types::messages::Messages) -> Self {
                Messages::Messages(x)
            }
        }
        impl From<crate::types::messages::MessagesSlice> for Messages {
            fn from(x: crate::types::messages::MessagesSlice) -> Self {
                Messages::Slice(x)
            }
        }
        impl From<crate::types::messages::ChannelMessages> for Messages {
            fn from(x: crate::types::messages::ChannelMessages) -> Self {
                Messages::ChannelMessages(x)
            }
        }
        impl From<crate::types::messages::MessagesNotModified> for Messages {
            fn from(x: crate::types::messages::MessagesNotModified) -> Self {
                Messages::NotModified(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PeerDialogs {
            Dialogs(crate::types::messages::PeerDialogs),
        }
        impl crate::Serializable for PeerDialogs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Dialogs(x) => {
                        crate::types::messages::PeerDialogs::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PeerDialogs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::PeerDialogs::CONSTRUCTOR_ID => {
                        Self::Dialogs(crate::types::messages::PeerDialogs::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::PeerDialogs> for PeerDialogs {
            fn from(x: crate::types::messages::PeerDialogs) -> Self {
                PeerDialogs::Dialogs(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PeerSettings {
            Settings(crate::types::messages::PeerSettings),
        }
        impl crate::Serializable for PeerSettings {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Settings(x) => {
                        crate::types::messages::PeerSettings::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PeerSettings {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::PeerSettings::CONSTRUCTOR_ID => {
                        Self::Settings(crate::types::messages::PeerSettings::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::PeerSettings> for PeerSettings {
            fn from(x: crate::types::messages::PeerSettings) -> Self {
                PeerSettings::Settings(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum RecentStickers {
            NotModified,
            Stickers(crate::types::messages::RecentStickers),
        }
        impl crate::Serializable for RecentStickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::RecentStickersNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Stickers(x) => {
                        crate::types::messages::RecentStickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for RecentStickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::RecentStickersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::RecentStickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::RecentStickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::RecentStickersNotModified> for RecentStickers {
            fn from(_x: crate::types::messages::RecentStickersNotModified) -> Self {
                RecentStickers::NotModified
            }
        }
        impl From<crate::types::messages::RecentStickers> for RecentStickers {
            fn from(x: crate::types::messages::RecentStickers) -> Self {
                RecentStickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SavedGifs {
            NotModified,
            Gifs(crate::types::messages::SavedGifs),
        }
        impl crate::Serializable for SavedGifs {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::SavedGifsNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Gifs(x) => {
                        crate::types::messages::SavedGifs::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SavedGifs {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SavedGifsNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::SavedGifs::CONSTRUCTOR_ID => {
                        Self::Gifs(crate::types::messages::SavedGifs::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SavedGifsNotModified> for SavedGifs {
            fn from(_x: crate::types::messages::SavedGifsNotModified) -> Self {
                SavedGifs::NotModified
            }
        }
        impl From<crate::types::messages::SavedGifs> for SavedGifs {
            fn from(x: crate::types::messages::SavedGifs) -> Self {
                SavedGifs::Gifs(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SearchCounter {
            Counter(crate::types::messages::SearchCounter),
        }
        impl crate::Serializable for SearchCounter {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Counter(x) => {
                        crate::types::messages::SearchCounter::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SearchCounter {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SearchCounter::CONSTRUCTOR_ID => {
                        Self::Counter(crate::types::messages::SearchCounter::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SearchCounter> for SearchCounter {
            fn from(x: crate::types::messages::SearchCounter) -> Self {
                SearchCounter::Counter(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SearchResultsCalendar {
            Calendar(crate::types::messages::SearchResultsCalendar),
        }
        impl crate::Serializable for SearchResultsCalendar {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Calendar(x) => {
                        crate::types::messages::SearchResultsCalendar::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SearchResultsCalendar {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SearchResultsCalendar::CONSTRUCTOR_ID => {
                        Self::Calendar(crate::types::messages::SearchResultsCalendar::deserialize(
                            buf,
                        )?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SearchResultsCalendar> for SearchResultsCalendar {
            fn from(x: crate::types::messages::SearchResultsCalendar) -> Self {
                SearchResultsCalendar::Calendar(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SearchResultsPositions {
            Positions(crate::types::messages::SearchResultsPositions),
        }
        impl crate::Serializable for SearchResultsPositions {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Positions(x) => {
                        crate::types::messages::SearchResultsPositions::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SearchResultsPositions {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SearchResultsPositions::CONSTRUCTOR_ID => {
                        Self::Positions(
                            crate::types::messages::SearchResultsPositions::deserialize(buf)?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SearchResultsPositions> for SearchResultsPositions {
            fn from(x: crate::types::messages::SearchResultsPositions) -> Self {
                SearchResultsPositions::Positions(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SentEncryptedMessage {
            Message(crate::types::messages::SentEncryptedMessage),
            SentEncryptedFile(crate::types::messages::SentEncryptedFile),
        }
        impl SentEncryptedMessage {
            pub fn date(&self) -> i32 {
                match self {
                    Self::Message(i) => i.date,
                    Self::SentEncryptedFile(i) => i.date,
                }
            }
        }
        impl crate::Serializable for SentEncryptedMessage {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Message(x) => {
                        crate::types::messages::SentEncryptedMessage::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::SentEncryptedFile(x) => {
                        crate::types::messages::SentEncryptedFile::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SentEncryptedMessage {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SentEncryptedMessage::CONSTRUCTOR_ID => Self::Message(
                        crate::types::messages::SentEncryptedMessage::deserialize(buf)?,
                    ),
                    crate::types::messages::SentEncryptedFile::CONSTRUCTOR_ID => {
                        Self::SentEncryptedFile(
                            crate::types::messages::SentEncryptedFile::deserialize(buf)?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SentEncryptedMessage> for SentEncryptedMessage {
            fn from(x: crate::types::messages::SentEncryptedMessage) -> Self {
                SentEncryptedMessage::Message(x)
            }
        }
        impl From<crate::types::messages::SentEncryptedFile> for SentEncryptedMessage {
            fn from(x: crate::types::messages::SentEncryptedFile) -> Self {
                SentEncryptedMessage::SentEncryptedFile(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SponsoredMessages {
            Messages(crate::types::messages::SponsoredMessages),
        }
        impl crate::Serializable for SponsoredMessages {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Messages(x) => {
                        crate::types::messages::SponsoredMessages::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SponsoredMessages {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::SponsoredMessages::CONSTRUCTOR_ID => {
                        Self::Messages(crate::types::messages::SponsoredMessages::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::SponsoredMessages> for SponsoredMessages {
            fn from(x: crate::types::messages::SponsoredMessages) -> Self {
                SponsoredMessages::Messages(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum StickerSet {
            Set(crate::types::messages::StickerSet),
            NotModified,
        }
        impl crate::Serializable for StickerSet {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Set(x) => {
                        crate::types::messages::StickerSet::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::NotModified => {
                        crate::types::messages::StickerSetNotModified::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for StickerSet {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::StickerSet::CONSTRUCTOR_ID => {
                        Self::Set(crate::types::messages::StickerSet::deserialize(buf)?)
                    }
                    crate::types::messages::StickerSetNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::StickerSet> for StickerSet {
            fn from(x: crate::types::messages::StickerSet) -> Self {
                StickerSet::Set(x)
            }
        }
        impl From<crate::types::messages::StickerSetNotModified> for StickerSet {
            fn from(_x: crate::types::messages::StickerSetNotModified) -> Self {
                StickerSet::NotModified
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum StickerSetInstallResult {
            Success,
            Archive(crate::types::messages::StickerSetInstallResultArchive),
        }
        impl crate::Serializable for StickerSetInstallResult {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Success => {
                        crate::types::messages::StickerSetInstallResultSuccess::CONSTRUCTOR_ID
                            .serialize(buf);
                    }
                    Self::Archive(x) => {
                        crate::types::messages::StickerSetInstallResultArchive::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for StickerSetInstallResult {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::StickerSetInstallResultSuccess::CONSTRUCTOR_ID => {
                        Self::Success
                    }
                    crate::types::messages::StickerSetInstallResultArchive::CONSTRUCTOR_ID => {
                        Self::Archive(
                            crate::types::messages::StickerSetInstallResultArchive::deserialize(
                                buf,
                            )?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::StickerSetInstallResultSuccess> for StickerSetInstallResult {
            fn from(_x: crate::types::messages::StickerSetInstallResultSuccess) -> Self {
                StickerSetInstallResult::Success
            }
        }
        impl From<crate::types::messages::StickerSetInstallResultArchive> for StickerSetInstallResult {
            fn from(x: crate::types::messages::StickerSetInstallResultArchive) -> Self {
                StickerSetInstallResult::Archive(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Stickers {
            NotModified,
            Stickers(crate::types::messages::Stickers),
        }
        impl crate::Serializable for Stickers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::NotModified => {
                        crate::types::messages::StickersNotModified::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::Stickers(x) => {
                        crate::types::messages::Stickers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Stickers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::StickersNotModified::CONSTRUCTOR_ID => {
                        Self::NotModified
                    }
                    crate::types::messages::Stickers::CONSTRUCTOR_ID => {
                        Self::Stickers(crate::types::messages::Stickers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::StickersNotModified> for Stickers {
            fn from(_x: crate::types::messages::StickersNotModified) -> Self {
                Stickers::NotModified
            }
        }
        impl From<crate::types::messages::Stickers> for Stickers {
            fn from(x: crate::types::messages::Stickers) -> Self {
                Stickers::Stickers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum VotesList {
            List(crate::types::messages::VotesList),
        }
        impl crate::Serializable for VotesList {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::List(x) => {
                        crate::types::messages::VotesList::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for VotesList {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::messages::VotesList::CONSTRUCTOR_ID => {
                        Self::List(crate::types::messages::VotesList::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::messages::VotesList> for VotesList {
            fn from(x: crate::types::messages::VotesList) -> Self {
                VotesList::List(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod payments {
        #[derive(Debug, Clone, PartialEq)]
        pub enum BankCardData {
            Data(crate::types::payments::BankCardData),
        }
        impl crate::Serializable for BankCardData {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Data(x) => {
                        crate::types::payments::BankCardData::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for BankCardData {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::BankCardData::CONSTRUCTOR_ID => {
                        Self::Data(crate::types::payments::BankCardData::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::BankCardData> for BankCardData {
            fn from(x: crate::types::payments::BankCardData) -> Self {
                BankCardData::Data(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PaymentForm {
            Form(crate::types::payments::PaymentForm),
        }
        impl crate::Serializable for PaymentForm {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Form(x) => {
                        crate::types::payments::PaymentForm::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PaymentForm {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::PaymentForm::CONSTRUCTOR_ID => {
                        Self::Form(crate::types::payments::PaymentForm::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::PaymentForm> for PaymentForm {
            fn from(x: crate::types::payments::PaymentForm) -> Self {
                PaymentForm::Form(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PaymentReceipt {
            Receipt(crate::types::payments::PaymentReceipt),
        }
        impl crate::Serializable for PaymentReceipt {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Receipt(x) => {
                        crate::types::payments::PaymentReceipt::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PaymentReceipt {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::PaymentReceipt::CONSTRUCTOR_ID => {
                        Self::Receipt(crate::types::payments::PaymentReceipt::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::PaymentReceipt> for PaymentReceipt {
            fn from(x: crate::types::payments::PaymentReceipt) -> Self {
                PaymentReceipt::Receipt(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PaymentResult {
            Result(crate::types::payments::PaymentResult),
            PaymentVerificationNeeded(crate::types::payments::PaymentVerificationNeeded),
        }
        impl crate::Serializable for PaymentResult {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Result(x) => {
                        crate::types::payments::PaymentResult::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::PaymentVerificationNeeded(x) => {
                        crate::types::payments::PaymentVerificationNeeded::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PaymentResult {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::PaymentResult::CONSTRUCTOR_ID => {
                        Self::Result(crate::types::payments::PaymentResult::deserialize(buf)?)
                    }
                    crate::types::payments::PaymentVerificationNeeded::CONSTRUCTOR_ID => {
                        Self::PaymentVerificationNeeded(
                            crate::types::payments::PaymentVerificationNeeded::deserialize(buf)?,
                        )
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::PaymentResult> for PaymentResult {
            fn from(x: crate::types::payments::PaymentResult) -> Self {
                PaymentResult::Result(x)
            }
        }
        impl From<crate::types::payments::PaymentVerificationNeeded> for PaymentResult {
            fn from(x: crate::types::payments::PaymentVerificationNeeded) -> Self {
                PaymentResult::PaymentVerificationNeeded(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum SavedInfo {
            Info(crate::types::payments::SavedInfo),
        }
        impl crate::Serializable for SavedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Info(x) => {
                        crate::types::payments::SavedInfo::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SavedInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::SavedInfo::CONSTRUCTOR_ID => {
                        Self::Info(crate::types::payments::SavedInfo::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::SavedInfo> for SavedInfo {
            fn from(x: crate::types::payments::SavedInfo) -> Self {
                SavedInfo::Info(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum ValidatedRequestedInfo {
            Info(crate::types::payments::ValidatedRequestedInfo),
        }
        impl crate::Serializable for ValidatedRequestedInfo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Info(x) => {
                        crate::types::payments::ValidatedRequestedInfo::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ValidatedRequestedInfo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::payments::ValidatedRequestedInfo::CONSTRUCTOR_ID => Self::Info(
                        crate::types::payments::ValidatedRequestedInfo::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::payments::ValidatedRequestedInfo> for ValidatedRequestedInfo {
            fn from(x: crate::types::payments::ValidatedRequestedInfo) -> Self {
                ValidatedRequestedInfo::Info(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod phone {
        #[derive(Debug, Clone, PartialEq)]
        pub enum ExportedGroupCallInvite {
            Invite(crate::types::phone::ExportedGroupCallInvite),
        }
        impl crate::Serializable for ExportedGroupCallInvite {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Invite(x) => {
                        crate::types::phone::ExportedGroupCallInvite::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ExportedGroupCallInvite {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::phone::ExportedGroupCallInvite::CONSTRUCTOR_ID => Self::Invite(
                        crate::types::phone::ExportedGroupCallInvite::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::phone::ExportedGroupCallInvite> for ExportedGroupCallInvite {
            fn from(x: crate::types::phone::ExportedGroupCallInvite) -> Self {
                ExportedGroupCallInvite::Invite(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum GroupCall {
            Call(crate::types::phone::GroupCall),
        }
        impl crate::Serializable for GroupCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Call(x) => {
                        crate::types::phone::GroupCall::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for GroupCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::phone::GroupCall::CONSTRUCTOR_ID => {
                        Self::Call(crate::types::phone::GroupCall::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::phone::GroupCall> for GroupCall {
            fn from(x: crate::types::phone::GroupCall) -> Self {
                GroupCall::Call(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum GroupParticipants {
            Participants(crate::types::phone::GroupParticipants),
        }
        impl crate::Serializable for GroupParticipants {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Participants(x) => {
                        crate::types::phone::GroupParticipants::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for GroupParticipants {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::phone::GroupParticipants::CONSTRUCTOR_ID => Self::Participants(
                        crate::types::phone::GroupParticipants::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::phone::GroupParticipants> for GroupParticipants {
            fn from(x: crate::types::phone::GroupParticipants) -> Self {
                GroupParticipants::Participants(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum JoinAsPeers {
            Peers(crate::types::phone::JoinAsPeers),
        }
        impl crate::Serializable for JoinAsPeers {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Peers(x) => {
                        crate::types::phone::JoinAsPeers::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for JoinAsPeers {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::phone::JoinAsPeers::CONSTRUCTOR_ID => {
                        Self::Peers(crate::types::phone::JoinAsPeers::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::phone::JoinAsPeers> for JoinAsPeers {
            fn from(x: crate::types::phone::JoinAsPeers) -> Self {
                JoinAsPeers::Peers(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum PhoneCall {
            Call(crate::types::phone::PhoneCall),
        }
        impl crate::Serializable for PhoneCall {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Call(x) => {
                        crate::types::phone::PhoneCall::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for PhoneCall {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::phone::PhoneCall::CONSTRUCTOR_ID => {
                        Self::Call(crate::types::phone::PhoneCall::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::phone::PhoneCall> for PhoneCall {
            fn from(x: crate::types::phone::PhoneCall) -> Self {
                PhoneCall::Call(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod photos {
        #[derive(Debug, Clone, PartialEq)]
        pub enum Photo {
            Photo(crate::types::photos::Photo),
        }
        impl crate::Serializable for Photo {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Photo(x) => {
                        crate::types::photos::Photo::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Photo {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::photos::Photo::CONSTRUCTOR_ID => {
                        Self::Photo(crate::types::photos::Photo::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::photos::Photo> for Photo {
            fn from(x: crate::types::photos::Photo) -> Self {
                Photo::Photo(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Photos {
            Photos(crate::types::photos::Photos),
            Slice(crate::types::photos::PhotosSlice),
        }
        impl Photos {
            pub fn photos(&self) -> Vec<crate::enums::Photo> {
                match self {
                    Self::Photos(i) => i.photos.clone(),
                    Self::Slice(i) => i.photos.clone(),
                }
            }
            pub fn users(&self) -> Vec<crate::enums::User> {
                match self {
                    Self::Photos(i) => i.users.clone(),
                    Self::Slice(i) => i.users.clone(),
                }
            }
        }
        impl crate::Serializable for Photos {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Photos(x) => {
                        crate::types::photos::Photos::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::photos::PhotosSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Photos {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::photos::Photos::CONSTRUCTOR_ID => {
                        Self::Photos(crate::types::photos::Photos::deserialize(buf)?)
                    }
                    crate::types::photos::PhotosSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::photos::PhotosSlice::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::photos::Photos> for Photos {
            fn from(x: crate::types::photos::Photos) -> Self {
                Photos::Photos(x)
            }
        }
        impl From<crate::types::photos::PhotosSlice> for Photos {
            fn from(x: crate::types::photos::PhotosSlice) -> Self {
                Photos::Slice(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod stats {
        #[derive(Debug, Clone, PartialEq)]
        pub enum BroadcastStats {
            Stats(crate::types::stats::BroadcastStats),
        }
        impl crate::Serializable for BroadcastStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Stats(x) => {
                        crate::types::stats::BroadcastStats::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for BroadcastStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::stats::BroadcastStats::CONSTRUCTOR_ID => {
                        Self::Stats(crate::types::stats::BroadcastStats::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::stats::BroadcastStats> for BroadcastStats {
            fn from(x: crate::types::stats::BroadcastStats) -> Self {
                BroadcastStats::Stats(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum MegagroupStats {
            Stats(crate::types::stats::MegagroupStats),
        }
        impl crate::Serializable for MegagroupStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Stats(x) => {
                        crate::types::stats::MegagroupStats::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for MegagroupStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::stats::MegagroupStats::CONSTRUCTOR_ID => {
                        Self::Stats(crate::types::stats::MegagroupStats::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::stats::MegagroupStats> for MegagroupStats {
            fn from(x: crate::types::stats::MegagroupStats) -> Self {
                MegagroupStats::Stats(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum MessageStats {
            Stats(crate::types::stats::MessageStats),
        }
        impl crate::Serializable for MessageStats {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Stats(x) => {
                        crate::types::stats::MessageStats::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for MessageStats {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::stats::MessageStats::CONSTRUCTOR_ID => {
                        Self::Stats(crate::types::stats::MessageStats::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::stats::MessageStats> for MessageStats {
            fn from(x: crate::types::stats::MessageStats) -> Self {
                MessageStats::Stats(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod stickers {
        #[derive(Debug, Clone, PartialEq)]
        pub enum SuggestedShortName {
            Name(crate::types::stickers::SuggestedShortName),
        }
        impl crate::Serializable for SuggestedShortName {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Name(x) => {
                        crate::types::stickers::SuggestedShortName::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for SuggestedShortName {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::stickers::SuggestedShortName::CONSTRUCTOR_ID => Self::Name(
                        crate::types::stickers::SuggestedShortName::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::stickers::SuggestedShortName> for SuggestedShortName {
            fn from(x: crate::types::stickers::SuggestedShortName) -> Self {
                SuggestedShortName::Name(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod storage {
        #[derive(Debug, Clone, PartialEq)]
        pub enum FileType {
            FileUnknown,
            FilePartial,
            FileJpeg,
            FileGif,
            FilePng,
            FilePdf,
            FileMp3,
            FileMov,
            FileMp4,
            FileWebp,
        }
        impl crate::Serializable for FileType {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::FileUnknown => {
                        crate::types::storage::FileUnknown::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FilePartial => {
                        crate::types::storage::FilePartial::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileJpeg => {
                        crate::types::storage::FileJpeg::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileGif => {
                        crate::types::storage::FileGif::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FilePng => {
                        crate::types::storage::FilePng::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FilePdf => {
                        crate::types::storage::FilePdf::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileMp3 => {
                        crate::types::storage::FileMp3::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileMov => {
                        crate::types::storage::FileMov::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileMp4 => {
                        crate::types::storage::FileMp4::CONSTRUCTOR_ID.serialize(buf);
                    }
                    Self::FileWebp => {
                        crate::types::storage::FileWebp::CONSTRUCTOR_ID.serialize(buf);
                    }
                }
            }
        }
        impl crate::Deserializable for FileType {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::storage::FileUnknown::CONSTRUCTOR_ID => Self::FileUnknown,
                    crate::types::storage::FilePartial::CONSTRUCTOR_ID => Self::FilePartial,
                    crate::types::storage::FileJpeg::CONSTRUCTOR_ID => Self::FileJpeg,
                    crate::types::storage::FileGif::CONSTRUCTOR_ID => Self::FileGif,
                    crate::types::storage::FilePng::CONSTRUCTOR_ID => Self::FilePng,
                    crate::types::storage::FilePdf::CONSTRUCTOR_ID => Self::FilePdf,
                    crate::types::storage::FileMp3::CONSTRUCTOR_ID => Self::FileMp3,
                    crate::types::storage::FileMov::CONSTRUCTOR_ID => Self::FileMov,
                    crate::types::storage::FileMp4::CONSTRUCTOR_ID => Self::FileMp4,
                    crate::types::storage::FileWebp::CONSTRUCTOR_ID => Self::FileWebp,
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::storage::FileUnknown> for FileType {
            fn from(_x: crate::types::storage::FileUnknown) -> Self {
                FileType::FileUnknown
            }
        }
        impl From<crate::types::storage::FilePartial> for FileType {
            fn from(_x: crate::types::storage::FilePartial) -> Self {
                FileType::FilePartial
            }
        }
        impl From<crate::types::storage::FileJpeg> for FileType {
            fn from(_x: crate::types::storage::FileJpeg) -> Self {
                FileType::FileJpeg
            }
        }
        impl From<crate::types::storage::FileGif> for FileType {
            fn from(_x: crate::types::storage::FileGif) -> Self {
                FileType::FileGif
            }
        }
        impl From<crate::types::storage::FilePng> for FileType {
            fn from(_x: crate::types::storage::FilePng) -> Self {
                FileType::FilePng
            }
        }
        impl From<crate::types::storage::FilePdf> for FileType {
            fn from(_x: crate::types::storage::FilePdf) -> Self {
                FileType::FilePdf
            }
        }
        impl From<crate::types::storage::FileMp3> for FileType {
            fn from(_x: crate::types::storage::FileMp3) -> Self {
                FileType::FileMp3
            }
        }
        impl From<crate::types::storage::FileMov> for FileType {
            fn from(_x: crate::types::storage::FileMov) -> Self {
                FileType::FileMov
            }
        }
        impl From<crate::types::storage::FileMp4> for FileType {
            fn from(_x: crate::types::storage::FileMp4) -> Self {
                FileType::FileMp4
            }
        }
        impl From<crate::types::storage::FileWebp> for FileType {
            fn from(_x: crate::types::storage::FileWebp) -> Self {
                FileType::FileWebp
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod updates {
        #[derive(Debug, Clone, PartialEq)]
        pub enum ChannelDifference {
            Empty(crate::types::updates::ChannelDifferenceEmpty),
            TooLong(crate::types::updates::ChannelDifferenceTooLong),
            Difference(crate::types::updates::ChannelDifference),
        }
        impl ChannelDifference {
            pub fn r#final(&self) -> bool {
                match self {
                    Self::Empty(i) => i.r#final,
                    Self::TooLong(i) => i.r#final,
                    Self::Difference(i) => i.r#final,
                }
            }
        }
        impl crate::Serializable for ChannelDifference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty(x) => {
                        crate::types::updates::ChannelDifferenceEmpty::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::TooLong(x) => {
                        crate::types::updates::ChannelDifferenceTooLong::CONSTRUCTOR_ID
                            .serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Difference(x) => {
                        crate::types::updates::ChannelDifference::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for ChannelDifference {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::updates::ChannelDifferenceEmpty::CONSTRUCTOR_ID => Self::Empty(
                        crate::types::updates::ChannelDifferenceEmpty::deserialize(buf)?,
                    ),
                    crate::types::updates::ChannelDifferenceTooLong::CONSTRUCTOR_ID => {
                        Self::TooLong(
                            crate::types::updates::ChannelDifferenceTooLong::deserialize(buf)?,
                        )
                    }
                    crate::types::updates::ChannelDifference::CONSTRUCTOR_ID => Self::Difference(
                        crate::types::updates::ChannelDifference::deserialize(buf)?,
                    ),
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::updates::ChannelDifferenceEmpty> for ChannelDifference {
            fn from(x: crate::types::updates::ChannelDifferenceEmpty) -> Self {
                ChannelDifference::Empty(x)
            }
        }
        impl From<crate::types::updates::ChannelDifferenceTooLong> for ChannelDifference {
            fn from(x: crate::types::updates::ChannelDifferenceTooLong) -> Self {
                ChannelDifference::TooLong(x)
            }
        }
        impl From<crate::types::updates::ChannelDifference> for ChannelDifference {
            fn from(x: crate::types::updates::ChannelDifference) -> Self {
                ChannelDifference::Difference(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum Difference {
            Empty(crate::types::updates::DifferenceEmpty),
            Difference(crate::types::updates::Difference),
            Slice(crate::types::updates::DifferenceSlice),
            TooLong(crate::types::updates::DifferenceTooLong),
        }
        impl crate::Serializable for Difference {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Empty(x) => {
                        crate::types::updates::DifferenceEmpty::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Difference(x) => {
                        crate::types::updates::Difference::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::Slice(x) => {
                        crate::types::updates::DifferenceSlice::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::TooLong(x) => {
                        crate::types::updates::DifferenceTooLong::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for Difference {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::updates::DifferenceEmpty::CONSTRUCTOR_ID => {
                        Self::Empty(crate::types::updates::DifferenceEmpty::deserialize(buf)?)
                    }
                    crate::types::updates::Difference::CONSTRUCTOR_ID => {
                        Self::Difference(crate::types::updates::Difference::deserialize(buf)?)
                    }
                    crate::types::updates::DifferenceSlice::CONSTRUCTOR_ID => {
                        Self::Slice(crate::types::updates::DifferenceSlice::deserialize(buf)?)
                    }
                    crate::types::updates::DifferenceTooLong::CONSTRUCTOR_ID => {
                        Self::TooLong(crate::types::updates::DifferenceTooLong::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::updates::DifferenceEmpty> for Difference {
            fn from(x: crate::types::updates::DifferenceEmpty) -> Self {
                Difference::Empty(x)
            }
        }
        impl From<crate::types::updates::Difference> for Difference {
            fn from(x: crate::types::updates::Difference) -> Self {
                Difference::Difference(x)
            }
        }
        impl From<crate::types::updates::DifferenceSlice> for Difference {
            fn from(x: crate::types::updates::DifferenceSlice) -> Self {
                Difference::Slice(x)
            }
        }
        impl From<crate::types::updates::DifferenceTooLong> for Difference {
            fn from(x: crate::types::updates::DifferenceTooLong) -> Self {
                Difference::TooLong(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum State {
            State(crate::types::updates::State),
        }
        impl crate::Serializable for State {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::State(x) => {
                        crate::types::updates::State::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for State {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::updates::State::CONSTRUCTOR_ID => {
                        Self::State(crate::types::updates::State::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::updates::State> for State {
            fn from(x: crate::types::updates::State) -> Self {
                State::State(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod upload {
        #[derive(Debug, Clone, PartialEq)]
        pub enum CdnFile {
            ReuploadNeeded(crate::types::upload::CdnFileReuploadNeeded),
            File(crate::types::upload::CdnFile),
        }
        impl crate::Serializable for CdnFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::ReuploadNeeded(x) => {
                        crate::types::upload::CdnFileReuploadNeeded::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::File(x) => {
                        crate::types::upload::CdnFile::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for CdnFile {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::upload::CdnFileReuploadNeeded::CONSTRUCTOR_ID => {
                        Self::ReuploadNeeded(
                            crate::types::upload::CdnFileReuploadNeeded::deserialize(buf)?,
                        )
                    }
                    crate::types::upload::CdnFile::CONSTRUCTOR_ID => {
                        Self::File(crate::types::upload::CdnFile::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::upload::CdnFileReuploadNeeded> for CdnFile {
            fn from(x: crate::types::upload::CdnFileReuploadNeeded) -> Self {
                CdnFile::ReuploadNeeded(x)
            }
        }
        impl From<crate::types::upload::CdnFile> for CdnFile {
            fn from(x: crate::types::upload::CdnFile) -> Self {
                CdnFile::File(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum File {
            File(crate::types::upload::File),
            CdnRedirect(crate::types::upload::FileCdnRedirect),
        }
        impl crate::Serializable for File {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::File(x) => {
                        crate::types::upload::File::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                    Self::CdnRedirect(x) => {
                        crate::types::upload::FileCdnRedirect::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for File {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::upload::File::CONSTRUCTOR_ID => {
                        Self::File(crate::types::upload::File::deserialize(buf)?)
                    }
                    crate::types::upload::FileCdnRedirect::CONSTRUCTOR_ID => {
                        Self::CdnRedirect(crate::types::upload::FileCdnRedirect::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::upload::File> for File {
            fn from(x: crate::types::upload::File) -> Self {
                File::File(x)
            }
        }
        impl From<crate::types::upload::FileCdnRedirect> for File {
            fn from(x: crate::types::upload::FileCdnRedirect) -> Self {
                File::CdnRedirect(x)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub enum WebFile {
            File(crate::types::upload::WebFile),
        }
        impl crate::Serializable for WebFile {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::File(x) => {
                        crate::types::upload::WebFile::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for WebFile {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::upload::WebFile::CONSTRUCTOR_ID => {
                        Self::File(crate::types::upload::WebFile::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::upload::WebFile> for WebFile {
            fn from(x: crate::types::upload::WebFile) -> Self {
                WebFile::File(x)
            }
        }
    }
    #[allow(clippy::large_enum_variant)]
    pub mod users {
        #[derive(Debug, Clone, PartialEq)]
        pub enum UserFull {
            Full(crate::types::users::UserFull),
        }
        impl crate::Serializable for UserFull {
            fn serialize(&self, buf: crate::serialize::Buffer) {
                use crate::Identifiable;
                match self {
                    Self::Full(x) => {
                        crate::types::users::UserFull::CONSTRUCTOR_ID.serialize(buf);
                        x.serialize(buf)
                    }
                }
            }
        }
        impl crate::Deserializable for UserFull {
            fn deserialize(buf: crate::deserialize::Buffer) -> crate::deserialize::Result<Self> {
                use crate::Identifiable;
                let id = u32::deserialize(buf)?;
                Ok(match id {
                    crate::types::users::UserFull::CONSTRUCTOR_ID => {
                        Self::Full(crate::types::users::UserFull::deserialize(buf)?)
                    }
                    _ => return Err(crate::deserialize::Error::UnexpectedConstructor { id }),
                })
            }
        }
        impl From<crate::types::users::UserFull> for UserFull {
            fn from(x: crate::types::users::UserFull) -> Self {
                UserFull::Full(x)
            }
        }
    }
}
